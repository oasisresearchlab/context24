a r X i v : 1809 . 09938v8 [ c s . L O ] 11 O c t 2023 LOGIC PROGRAM PROPORTIONS CHRISTIAN ANTI ´C christian . antic @ icloud . com Vienna , Austria A bstract . The purpose of this paper is to present a fresh idea on how symbolic learning might be re - alized via analogical reasoning . For this , we introduce directed analogical proportions between logic programs of the form “ P transforms into Q as R transforms into S ” as a mechanism for deriving similar programs by analogy - making . The idea is to instantiate a fragment of a recently introduced abstract algebraic framework of analogical proportions in the domain of logic programming . Technically , we deﬁne proportions in terms of modularity where we derive abstract forms of concrete programs from a “known” source domain which can then be instantiated in an “unknown” target domain to obtain analo - gous programs . To this end , we introduce algebraic operations for syntactic logic program composition and concatenation . Interestingly , our work suggests a close relationship between modularity , general - ization , and analogy which we believe should be explored further in the future . In a broader sense , this paper is a further step towards a mathematical theory of logic - based analogical reasoning and learn - ing with potential applications to open AI - problems like commonsense reasoning and computational learning and creativity . 1 . I ntroduction This paper is a ﬁrst step towards an answer to the following question : How can a computer “creatively” generate interesting logic programs from a collec - tion of given ones by using analogical reasoning ? For example , given a program for the addition of natural numbers , how can we systematically gen - erate from it a program for “adding” lists using analogy ? This question can be stated mathematically in the form of a proportional equation between programs as Nat : Plus : : List : X where Nat and List are programs for generating the natural numbers and lists , respectively , Plus is the arithmetical program for the addition of numbers , and X is a placeholder for a concrete program , the solution to the equation . That is , we are asking for a program X = PlusList which operates on lists and is analogous to the program Plus . A solution to this equation indeed yields a reasonable program for the “addition” of lists , namely the program for appending lists ( see Examples 9 and 22 ) . To this end , in this paper we introduce directed analogical proportions between logic programs of the form “ P transforms into Q as R transforms into S ” — in symbols , P → Q : · R → S — as an instance of Anti´c’s ( 2022 ) general framework of analogical proportions as a mechanism for constructing similar programs by analogy - making . The purpose of this paper is to present a fresh idea on how logic - based symbolic learning can be realized via analogical reasoning , not to give full - ﬂedged solutions to real - world problems — it is the ﬁrst paper in a promising direction , and hopefully not the last one . 1 2 LOGIC PROGRAM PROPORTIONS In the literature , computational learning usually means learning from ( a massive amount of ) data . For example , in “deep learning” artiﬁcial neural networks ( ANNs ) extract abstract features from data sets ( cf . Goodfellow , Bengio , & Courville , 2016 ; LeCun , Bengio , & Hinton , 2015 ) and , on the sym - bolic side , inductive logic programs ( ILPs ) are provided with positive and negative examples of the target concept to be learned ( cf . Muggleton , 1991 ) . Another characteristic feature of current machine learning systems is the focus on goal - oriented problem solving — a typical task of ANNs is the cat - egorization of the input data ( e . g . , ﬁnding cats in images ) and ILPs try to construct logic programs from given examples which partially encode the problem to be solved ( e . g . , adding numbers or sorting lists ) . The emphasis in this paper is di ﬀ erent as we believe that program generation is equally important to artiﬁcial intelligence — and may even be more important for artiﬁcial general intelligence than problem - solving — and deserves much more attention . This is Sir Michael Atiyah’s ( ﬁelds medalist ) answer to the question of how he selects a problem to study : I think that presupposes an answer . I don’t think that’s the way I work at all . Some people may sit back and say , ‘I want to solve this problem’ and they sit down and say , ‘How do I solve this problem ? ’ I don’t . I just move around in the mathematical waters , thinking about things , being curious , interested , talking to people , stirring up ideas ; things emerge and I follow them up . Or I see something which connects up with something else I know about , and I try to put them together and things develop . I have practically never started o ﬀ with any idea of what I’m going to be doing or where it’s going to go . I’m interested in mathematics ; I talk , I learn , I discuss and then interesting questions simply emerge . I have never started o ﬀ with a particular goal , except the goal of understanding mathematics . ( cf . Gowers , 2000 ) . The process Sir Michael Atiyah is describing is the generation of new knowledge by connecting existing knowledge in a novel way without any speciﬁc “goal” in mind and it is believed by many researchers that analogy - making is the core mechanism for doing so ( e . g . Hofstadter & Sander , 2013 ) . In the framework presented in this paper , “program generation” means the construction of novel logic programs in an “unknown” target domain via analogical transfer — realized by directed logic program proportions via generalization and instantiation — from a “known” source domain . This approach is similar to ILP in that novel programs are derived from experience represented as knowl - edge bases consisting of “known” programs . However , it di ﬀ ers signiﬁcantly from ILP on how novel programs are constructed from experience — while in ILP the construction is goal - oriented and thus guided by partial speciﬁcations in the form of given examples , in our setting programs are derived by analogy - making to similar programs ( without the need for concrete examples ) . For instance , we may ask — by analogy to arithmetic — what it means to “multiply” two arbitrary lists ( cf . Example 22 ) or to reverse “even” lists ( cf . Examples 10 and 23 ) . Here , contrary to ILP , we do not expect a supervisor to provide the system with examples explaining list “multiplication” or “evenness” of lists , but instead we assume that there are arithmetic programs operating on numbers ( i . e . numerals ) — programs deﬁning multiplication and evenness of numbers — which we can transfer to the list domain . Example 1 . Imagine two domains , one consisting of numbers ( or numerals ) and the other made up of lists . We know from basic arithmetic what it means to add two numerals . Now suppose we want to transfer the concept of addition to the list domain . We can then ask — by analogy — the following question : What does it mean to “add” two lists ? We can transform this question into the following LOGIC PROGRAM PROPORTIONS 3 directed analogical equation : Nat → Plus : · List → X . ( 1 ) In our framework , Nat , Plus , and List will be logic programs , and X will be a program variable standing for a program which is obtained from List as Plus is obtained from Nat . That is , solutions to ( 1 ) will be programs implementing ‘addition of lists’ . The idea is to derive an abstract form Plus ( Z ) as a generalization of the concrete program Plus such that Plus = Plus ( Nat ) . That is , we factor Plus into subprograms and generalize every instance of the subprogram Nat in Plus by a program variable Z . We can then instantiate the form Plus ( Z ) with List to obtain a plausible solution to ( 1 ) , that is , a program for ‘addition of lists’ : Nat → Plus ( Nat ) : · List → Plus ( List ) . It is important to emphasize that in order to be able to decompose the program Plus with respect to the above algebraic operations so that Nat occurs as a factor , we need to introduce novel algebraic operations on logic programs ( Section 3 ) . We will return to this example , in a more formal manner , in Examples 9 and 22 . In ( semi - ) automatic programming ( Czarnecki & Eisenecker , 2000 ) , 1 one usually wants to construct a program given some speciﬁcation . This is complicated by the fact that writing the complete spec - iﬁcation is as complex as writing the logic program itself ( cf . Kowalski , 1984 ) . In this paper , we therefore propose a di ﬀ ernt view on automatic programming motivated by Sir Atiyah’s approach to mathematical research quoted above : Instead of trying to satisfy a ( complete ) speciﬁcation , a teacher iteratively constructs a source program S in a “known” domain by constructing a sequence of pro - grams S 1 → S 2 → . . . → S n → S whose “limit” is S ; the student then tries to “copycat” 2 the same proceses in an “unknown” target domain by constructing the sequence P 1 → P 2 → . . . P n → P such that S 1 → S 2 : · P 1 → P 2 , S 2 → S 3 : · P 2 → P 3 , . . . S n → S : · P n → P . By construction , the program P is then “analogous” to the source program S . Interestingly , our work suggests a close relationship between modularity , generalization , and anal - ogy which we believe should be explored further in the future . In a broader sense , this paper is a ﬁrst step towards a mathematical theory of logic - based analogical reasoning and learning in knowledge representation and reasoning systems with potential applications to fundamental AI - problems like commonsense reasoning and computational learning and creativity . 2 . L ogic programs In this section , we recall the syntax and semantics of logic programming by mainly following the lines of Apt ( 1990 ) . 1 https : / / en . wikipedia . org / wiki / Automatic _ programming 2 Homage to Hofstadter and Mitchell ( 1995 ) . 4 LOGIC PROGRAM PROPORTIONS 2 . 1 . Syntax . An ( unranked ﬁrst - order ) language L consists of a set Ps L of predicate symbols , a set Fs L of function symbols , a set Cs L of constant symbols , and a denumerable set V = { z 1 , z 2 , . . . } of variables . Terms and atoms are deﬁned in the usual way . Substitutions and ( most general ) uniﬁers of terms and ( sets of ) atoms are deﬁned as usual . Let L be a language . A ( Horn logic ) program over L ( or L - program ) is a set of rules of the form A 0 ← A 1 , . . . , A k , k ≥ 0 , ( 2 ) where A 0 , . . . , A k are atoms over L . It will be convenient to deﬁne , for a rule r of the form ( 2 ) , head ( r ) : = { A 0 } and body ( r ) : = { A 1 , . . . , A k } , extended to programs by head ( P ) : = S r ∈ P head ( r ) and body ( P ) : = S r ∈ P body ( r ) . In this case , the size of r is k denoted by sz ( r ) . A fact is a rule with empty body and a proper rule is a rule which is not a fact . We denote the facts and proper rules in P by f acts ( P ) and proper ( P ) , respectively . We deﬁne the skeleton inductively as follows : ( i ) for an atom p ( ~ t ) , deﬁne sk ( p ( ~ t ) ) : = p ; ( ii ) for a rule r of the form ( 2 ) , deﬁne sk ( r ) : = sk ( A 0 ) ← sk ( A 1 ) , . . . , sk ( A k ) ; ﬁnally , ( iii ) deﬁne the skeleton of a program P rule - wise as sk ( P ) : = { sk ( r ) | r ∈ P } ( see ( 3 ) ) . A program P is ground if it contains no variables and we denote the grounding of P which contains all ground instances of the rules in P by gnd ( P ) . We call any bijective substitution a renaming . The set of all variants of P is deﬁned by variants ( P ) : = S θ renaming P [ θ ] . The main predicate of a program is given by the name of the program in lower case letters if not speciﬁed otherwise . We will sometimes write P h p i to make the main predicate p in P ex - plicit and we will occasionally write P ( ~ x ) to indicate that P contains variables among ~ x = x 1 , . . . , x n , n ≥ 1 . We denote the program constructed from P h p i by replacing every occurrence of the predicate symbol p with q by P [ p / q ] . Example 2 . Later , we will be interested in the basic data structures of numerals , lists , and ( binary ) trees . The programs for generating numerals and lists are given by Nat ( x ) : = ( nat ( 0 ) nat ( s ( x ) ) ← nat ( x ) . ) and List ( u , x ) : = ( list ( [ ] ) list ( [ u | x ] ) ← list ( x ) . ) . As is customary in logic programming , [ ] and [ u | x ] is syntactic sugar for nil and cons ( u , x ) , respectively . The program for generating ( binary ) trees is given by Tree ( u , x , y ) : =   tree ( void ) tree ( t ( u , x , y ) ) ← tree ( x ) , tree ( y ) .   . For instance , the tree consisting of a root a , and two leafs b and c is symbolically represented as tree ( t ( a , t ( b , void , void ) , t ( c , void , void ) ) ) . The skeleton of Tree is given by sk ( Tree ) = ( treetree ← tree ) . ( 3 ) We will frequently refer to the programs above in the rest of the paper . 2 . 2 . Semantics . An interpretation is any set of ground atoms . We deﬁne the entailment relation , for every interpretation I , inductively as follows : • For a ground atom A , I | = A if A ∈ I . • For a set of ground atoms B , I | = B if B ⊆ I . LOGIC PROGRAM PROPORTIONS 5 • For a ground rule r of the form ( 2 ) , I | = r if I | = body ( r ) implies I | = head ( r ) . • Finally , for a ground program P , I | = P if I | = r holds for each rule r ∈ P . In case I | = gnd ( P ) , we call I a model of P . The set of all models of P has a least element with respect to set inclusion called the least model of P and denoted by LM ( P ) . We call a ground atom A a ( logical ) consequence of P — in symbols P | = A — if A is contained in the least model of P and we say that P and R are ( logically ) equivalent if LM ( P ) = LM ( R ) . 3 . A lgebra of logic programs Our framework of analogical proportions between logic programs will be built on top of an algebra of logic programs which allows us to decompose programs into simpler modules 3 via algebraic opera - tions on programs . For this , it will be useful to introduce in this section two novel algebraic operations for logic program composition ( Section 3 . 1 ) and concatenation ( Section 3 . 2 ) . In the rest of the paper , P and R denote logic programs over some joint unranked ﬁrst - order lan - guage L . 3 . 1 . Composition . The rule - like structure of logic programs induces naturally a compositional struc - ture which allows us to decompose programs rule - wise . We deﬁne the ( sequential ) composition of P and R by 4 P ◦ R : =  head ( r ϑ ) ← body ( S ϑ ) (cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12) r ∈ P S ⊆ sz ( r ) variants ( R ) head ( S ϑ ) = body ( r ϑ ) ϑ = mgu ( body ( r ) , head ( S ) )  . Roughly , we obtain the composition of P and R by resolving all body atoms in P with the ‘match - ing’ rule heads of R . This is illustrated in the next example , where we construct the even from the natural numbers via composition . Example 3 . Reconsider the program Nat of Example 2 generating the natural numbers . By compos - ing the only proper rule in Nat with itself , we obtain { nat ( s ( x ) ) ← nat ( x ) } ◦ { nat ( s ( x ) ) ← nat ( x ) } = { nat ( s ( s ( x ) ) ) ← nat ( x ) } . Notice that this program , together with the single fact in Nat , generates the even numbers . Let us therefore deﬁne the program Even : = (cid:16) f acts ( Nat ) ∪ proper ( Nat ) 2 (cid:17) [ nat / even ] =  even ( 0 ) even ( s ( s ( x ) ) ) ← even ( x )  , ( 4 ) where proper ( Nat ) 2 = proper ( Nat ) ◦ proper ( Nat ) . We will come back to this program in Example 10 . The following example shows that , unfortunately , composition is not associative . 3 We use here the term “module” as a synonym for “ ( sub - ) program” . 4 We write X ⊆ k Y in case X is a subset of Y consisting of k elements . 6 LOGIC PROGRAM PROPORTIONS Example 4 . Consider the rule r : = a ← b , c and the programs P : = ( b ← b c ← b , c ) and R : =  b ← d b ← e c ← f  . Let us compute ( { r } P ) R . We ﬁrst compute { r } P by noting that the rule r has two body atoms and has therefore size 2 , which means that there is only a single choice of subprogram S of P with two rules , namely S = P ; this yields { r } P = { head ( r ) ← body ( P ) } = { a ← b , c } = { r } . Next we compute ( { r } P ) R = { r } R by noting that now there are two possible S 1 , S 2 ⊆ 2 R with head ( S 1 ) = head ( S 2 ) = body ( r ) , given by S 1 = ( b ← d c ← f ) and S 2 = ( b ← e c ← f ) . This yields { r } R = ( head ( r ) ← body ( S 1 ) head ( r ) ← body ( S 2 ) ) = ( a ← d , f a ← e , f ) . Let us now compute { r } ( PR ) . We ﬁrst compute PR . We have PR = { b ← b } R ∪ { c ← b , c } R . We easily obtain { b ← b } R = ( b ← d b ← e ) . Similar computations as above show { c ← b , c } R = ( c ← d , f c ← d , e ) . So in total we have PR =   b ← d b ← e c ← d , f c ← d , e   . To compute { r } ( PR ) , we therefore see that there are four two rule subprograms S 1 , S 2 , S 4 , S 4 ⊆ 2 PR with b or c in their heads given by S 1 = ( b ← d c ← d , f ) S 2 = ( b ← d c ← d , e ) S 3 = ( b ← e c ← d , f ) S 4 = ( b ← e c ← d , f ) . Hence , we have { r } PR =  head ( r ) ← body ( S 1 ) head ( r ) ← body ( S 2 ) head ( r ) ← body ( S 3 ) head ( r ) ← body ( S 4 )  =  a ← d , f a ← d , e a ← d , e , f  . LOGIC PROGRAM PROPORTIONS 7 We have thus shown { r } ( PR ) =  a ← d , f a ← e , f a ← d , e , f  , ( a ← d , f a ← e , f ) = ( { r } P ) R . Remark 5 . Notice that the least model of P ◦ R is , in general , not obtained from the least models of its factors P and R in an obvious way . For example , the least models of P : = { a ← b } and R : = ( b a ← b ) are ∅ and { a , b } , respectively , but the least model of P ◦ R = { a } is { a } . 3 . 2 . Concatenation . In many cases , a program is the ‘concatenation’ of two or more simpler pro - grams on an atomic level . A typical example is the program Length : =  length ( [ ] , 0 ) length ( [ u | x ] , s ( y ) ) ← length ( x , y )  , ( 5 ) which is , roughly , the ‘concatenation’ of List in the ﬁrst and Nat in the second argument modulo renaming of predicate symbols ( cf . Example 2 ) . This motivates the following deﬁnition . We deﬁne the concatenation of P and R inductively as follows : ( 1 ) For atoms p ( ~ s ) and p ( ~ t ) , we deﬁne p ( ~ s ) · p ( ~ t ) : = p ( ~ s , ~ t ) , extended to sets of atoms B and B ′ by B · B ′ : = (cid:8) A · A ′ | A ∈ B , A ′ ∈ B ′ : sk ( A ) = sk ( A ′ ) (cid:9) . ( 2 ) For rules r and r ′ with sk ( r ) = sk ( r ′ ) , we deﬁne r · r ′ : = ( head ( r ) · head ( r ′ ) ) ← ( body ( r ) · body ( r ′ ) ) . ( 3 ) Finally , we deﬁne the concatenation of P and R by P · R : = { r · r ′ | r ∈ P , r ′ ∈ R : sk ( r ) = sk ( r ′ ) } . We will often write PR instead of P · R in case the operation is understood from the context . We can now formally deconcatenate the list program from above as Length = ( length ( [ ] ) length ( [ u | x ] ) ← length ( x ) ) · ( length ( 0 ) length ( s ( y ) ) ← length ( y ) ) = ( list ( [ ] ) list ( [ u | x ] ) ← list ( x ) ) [ list / length ] · ( nat ( 0 ) nat ( s ( y ) ) ← nat ( y ) ) [ nat / length ] , which is equivalent to Length = List [ list / length ] · Nat [ nat / length ] . ( 6 ) We will return to deconcatenations of this form in Section 4 ( cf . Example 9 ) . Theorem 6 . Concatenation is associative . Proof . We know that the concatenation of words is associative . From this we deduce A · ( A ′ · A ′′ ) = ( A · A ′ ) · A ′′ , for any atoms A , A ′ , A ′′ with sk ( A ) = sk ( A ′ ) = sk ( A ′′ ) . ( 7 ) 8 LOGIC PROGRAM PROPORTIONS This implies B · ( B ′ · B ′′ ) = (cid:8) A · ( A ′ · A ′′ ) (cid:12)(cid:12)(cid:12) A ∈ B , A ′ ∈ B ′ , A ′′ ∈ B ′′ , sk ( A ) = sk ( A ′ ) = sk ( A ′′ ) (cid:9) ( 7 ) = (cid:8) ( A · A ′ ) · A ′′ (cid:12)(cid:12)(cid:12) A ∈ B , A ′ ∈ B ′ , A ′′ ∈ B ′′ , sk ( A ) = sk ( A ′ ) = sk ( A ′′ ) (cid:9) = ( B · B ′ ) · B ′′ , for any sets of atoms B , B ′ , B ′′ . From this , we deduce the associativity of rule concatenation : p · ( q · r ) = ( head ( p ) · ( head ( q ) · head ( r ) ) ) ← ( body ( p ) · ( body ( q ) · body ( r ) ) ) = ( ( head ( p ) · head ( q ) ) · head ( r ) ) ← ( body ( p ) · body ( q ) ) · body ( r ) ) = ( p · q ) · r . We have sk ( r ) = sk ( s ) ⇔ sk ( r · s ) = sk ( r ) = sk ( s ) , which ﬁnally implies the associativity of concatenation via P · ( Q · R ) = [ p ∈ P , q ∈ Q , r ∈ R sk ( p ) = sk ( q ) = sk ( r ) ( p · ( q · r ) ) = [ p ∈ P , q ∈ Q , r ∈ R sk ( p ) = sk ( q ) = sk ( r ) ( ( p · q ) · r ) = ( P · Q ) · R . (cid:3) Remark 7 . The least model of P · R is not obtained from the least models of P and R in an obvious way . For example , we have LM ( Nat · Nat ) = { nat ( s n ( 0 ) , s n ( 0 ) ) | n ≥ 0 } whereas LM ( Nat ) · LM ( Nat ) = { nat ( s m ( 0 ) , s n ( 0 ) ) | m , n ≥ 0 } . Deﬁnition 8 . The algebra of logic programs over L consists of all L - programs together with all unary and binary operations on programs introduced above , including composition , concatenation , union , and the least model operator . 4 . L ogic program forms Recall from Example 1 that we wish to derive abstract generalizations of concrete programs , which can then be instantiated to obtain similar programs . We formalize this idea via logic program forms as follows . In the rest of the paper , we assume that we are given program variables X , Y , Z , . . . as placeholders for concrete programs and an algebra of logic programs P over some ﬁxed language L ( cf . Deﬁnition 8 ) . A ( logic program ) form over P ( or P - form ) is any well - formed expression built up from L - programs , program variables , and all algebraic operations on programs from above including substitution . More precisely , P - forms are deﬁned by the grammar F : : = P | Z | F ∪ F | F ◦ F | F · F | F σ | LM ( F ) | head ( F ) | body ( F ) | f acts ( F ) | proper ( F ) , where P ∈ P is an L - program , Z is a program variable , and σ is a substitution . We will denote forms by boldface letters . Forms generalize logic programs and induce transformations on programs in the obvious way by replacing program variables with concrete programs . This means that we can interpret logic program forms as ‘meta - terms’ over the algebra of logic programs with programs as ‘constants’ , program LOGIC PROGRAM PROPORTIONS 9 variables as variables , and algebraic operations on programs as ‘function symbols’ . This is illustrated in the following examples . Example 9 . The program Plus of Example 1 for the addition of numerals is given by Plus : =  plus ( 0 , y , y ) plus ( s ( x ) , y , s ( z ) ) ← plus ( x , y , z )  . Recall from Example 1 that we wish to derive a form Plus from Plus which abstractly represents addition . Notice that Plus is , essentially , the concatenation of the program Nat ( Example 2 ) in the ﬁrst and last argument together with a middle part . Formally , we have Plus =  plus ( 0 ) plus ( s ( x ) ) ← plus ( x )  ·  plus ( y , y ) plus ( y ) ← plus ( y )  ·  plus ( ) plus ( s ( z ) ) ← plus ( z )  =  nat ( 0 ) nat ( s ( x ) ) ← nat ( x )  [ nat / plus ] ·  plus ( y , y ) plus ( y ) ← plus ( y )  ·  plus ( ) nat ( s ( z ) ) ← nat ( z )  [ nat / plus ] = Nat ( x ) [ nat / plus ] ·  plus ( y , y ) plus ( y ) ← plus ( y )  · ( plus ( ) proper ( Nat ( z ) ) [ nat / plus ] ) . We therefore deﬁne the form Plus ( Z h q i ( ~ x ) ) , where Z is a program variable , q stands for the main predicate symbol in Z , and ~ x is a sequence of variables , by Plus ( Z h q i ( ~ x ) ) : = Z [ q / plus ] ·  plus ( y , y ) plus ( y ) ← plus ( y )  · ( plus ( ) proper ( Z ) [ q / plus , ~ x / ~ z ] ) . Here ~ z is a sequence of fresh variables distinct from the variables in ~ x . We can think of Plus as a generalization of Plus where we have abstracted from the concrete data type Nat . In fact , Plus is an instance of Plus : Plus = Plus ( Nat ( x ) ) . Similarly , instantiating the form Plus with the program List ( u , x ) for constructing the data type of lists ( cf . Example 2 ) yields the program 5 plus ( [ ] , y , y ) plus ( [ u | x ] , y , [ u | z ] ) ← plus ( x , y , z ) , which is the program for appending lists . For example , we have Plus ( List ) | = plus ( [ a , b ] , [ c , d ] , [ a , b , c , d ] ) . As a further example , we want to deﬁne the ‘addition’ of ( binary ) trees by instantiating the form Plus with Tree . Note that we now have multiple choices : since Tree ( u , x , y ) contains two variables x 5 Here we have instantiated the sequence of variables ~ x with ~ z = ( u , z ) . 10 LOGIC PROGRAM PROPORTIONS and y occurring in the second rule’s body and head , we have two possibilities : we can either choose x = y or x , y . Let us ﬁrst consider the program Plus ( Tree ( u , x , x ) ) =  plus ( void , y , y ) plus ( t ( u , x , x ) , y , t ( u , z , z ) ) ← plus ( x , y , z ) .  . ( 8 ) This program ‘appends’ the tree in the second argument to each leaf of the symmetric tree in the ﬁrst argument . Notice that all of the above programs are syntactically almost identical , e . g . , we can transform Plus into Plus ( List ) via a simple rewriting of terms . The next program shows that we can derive programs from Plus which syntactically di ﬀ er more substantially from the above programs . Concretely , the program Plus ( Tree ( u , x 1 , x 2 ) ) =  plus ( void , y , y ) plus ( t ( u , x 1 , x 2 ) , y , t ( u , z 1 , z 2 ) ) ← plus ( x 1 , y , z 1 ) , plus ( x 2 , y , z 1 ) , plus ( x 1 , y , z 2 ) , plus ( x 2 , y , z 2 ) .  is logically equivalent to program ( 8 ) . However , in some situations this more complicated represen - tation is beneﬁcial . For example , we can now remove the second and third body atom to obtain the more compact program plus ( void , y , y ) plus ( t ( u , x 1 , x 2 ) , y , t ( u , z 1 , z 2 ) ) ← plus ( x 1 , y , z 1 ) , plus ( x 2 , y , z 2 ) . This program , in analogy to program ( 8 ) , ‘appends’ the tree in the second argument to each leaf of the not necessarily symmetric tree in the ﬁrst argument and thus generalizes ( 8 ) . Generally speaking , solutions to proportional equations my be inexact in nature needing further transformation in order to satisfy additional information and constraints . Example 10 . In Example 3 , we have constructed the program Even , representing the even numbers , from Nat by inheriting its fact and by iterating its proper rule once . By replacing Nat in ( 4 ) by a program variable Z , we arrive at the form Even ( Z ) : = f acts ( Z ) ∪ ( proper ( Z ) ◦ proper ( Z ) ) . ( 9 ) We can now instantiate this form with arbitrary programs to transfer the concept of “evenness” to other domains . For example , consider the program Reverse for reversing lists given by Reverse : = Reverse 0 ∪ Plus ( List ( u , x ) ) , where Reverse 0 : =  reverse ( [ ] , [ ] ) reverse ( [ u | x ] , y ) ← reverse ( x , z ) , plus ( z , [ u ] , y )  . LOGIC PROGRAM PROPORTIONS 11 By instantiating the form Even with Reverse , we obtain the program Even ( Reverse ) =  reverse ( [ ] , [ ] ) reverse ( [ u 1 , u 2 | x ] , [ u 3 | y ] ) ← reverse ( x , z ) , plus ( z , [ u 2 ] , [ u 3 | w ] ) , plus ( w , [ u 1 ] , y ) , plus ( [ ] , y , y ) plus ( [ u 1 , u 2 | x ] , y , [ u 1 , u 2 | z ] ) ← plus ( x , y , z ) .  . One can verify that this program reverses lists of even length . Similarly , if S ort is a program for sorting lists , then Even ( S ort ) is a program for sorting “even” lists and so on . Example 11 . The program for checking list membership is given by Member : =  member ( u , [ u | x ] ) member ( u , [ v | x ] ) ← member ( u , x )  . Notice the syntactic similarity between the program List of Example 2 and the second arguments in Member — in fact , we can deconcatenate Member as follows : Member =  member ( u ) member ( u ) ← member ( u )  ·  member ( [ u | x ] ) member ( [ v | x ] ) ← member ( x )  . The second factor can be expressed in terms of List via { member ( [ u | x ] ) } = ( proper ( List ( u , x ) ) ◦ body ( proper ( List ( u , x ) ) ) ) [ list / member ] and { member ( [ v | x ] ) ← member ( x ) } = proper ( List ( v , x ) ) [ list / member ] . This yields the form Member ( Z ( u , ~ x ) h q i ) , where ~ x is a ( possibly empty ) sequence of variables , given by  member ( u ) member ( u ) ← member ( u )  · ( proper ( Z ( u , x ) ) ◦ body ( proper ( Z ( u , x ) ) ) proper ( Z ( u , x ) ) [ u / v ] ) [ q / member ] . We can now ask — by analogy — what “membership” means in the numerical domain . For this , we compute Member ( Nat ( u ) ) =  member ( u , s ( u ) ) member ( u , s ( v ) ) ← member ( u , v )  . One can easily check that this program computes the “less than” relation between numerals . 12 LOGIC PROGRAM PROPORTIONS 5 . L ogic program proportions This is the main section of the paper . Recall from Example 1 that we want to formalize analogical reasoning and learning in the logic programming setting via directed analogical proportions between programs . For this , we instantiate here a fragment of Anti´c’s ( 2022 ) abstract algebraic framework of analogical proportions within the algebra of logic programs from above using logic program forms . Let us ﬁrst recall Anti´c’s ( 2022 ) framework , where we restrict ourselves to the directed fragment . In the rest of the paper , we may assume some “known” source domain P and some “unknown” target domain R , both algebras of logic programs over some languages L P and L R , respectively . We may think of the source domain P as our background knowledge — a repertoire of programs we are familiar with — whereas R stands for an unfamiliar domain which we want to explore via analogical transfer from P . For this we will consider directed analogical equations of the form ‘ P transforms into Q as R transforms into X ’ — in symbols , P → Q : · R → X — where P and Q are programs of P , R is a program of R , and X is a program variable . The task of learning logic programs by analogy is then to solve such equations and thus to expand our knowledge about the intimate relationships between ( seemingly unrelated ) programs , that is , solutions to directed analogical equations will be programs of R which are obtained from R in R as Q is obtained from P in P in a mathematically precise way ( Deﬁnition 12 ) . Speciﬁcally , we want to functionally relate programs via rewrite rules as follows . Recall from Example 1 that transforming Nat into Plus means transforming Id ( Nat ) into Plus ( Nat ) , where Id ( Z ) : = Z and Plus ( Z ) are forms . We can state this transformation more pictorially as the rewrite rule Id → Plus . Now transforming the program List ‘in the same way’ means to transform Id ( List ) into Plus ( List ) , which again is an instance of Id → Plus . Let us make this notation o ﬃ cial . We will always write F ( ~ Z ) → G ( ~ Z ) or F → G instead of ( F , G ) , for any pair of forms F and G containing program variables among ~ Z such that every program variable in G occurs in F . We call such expressions justiﬁcations . We denote the set of all justiﬁcations with variables among ~ Z by J ( ~ Z ) . We make the convention that → binds weaker than every other algebraic operation . The above explanation motivates the following deﬁnition . Deﬁne the set of justiﬁcations of two programs P and R in P by Jus P ( P → R ) : = (cid:26) F → G ∈ J ( ~ Z ) (cid:12)(cid:12)(cid:12)(cid:12) P → R = F ( ~ O ) → G ( ~ O ) , for some ~ O ∈ P | ~ Z | (cid:27) . For instance , Jus ( Nat → Plus ( Nat ) ) and Jus ( List → Plus ( List ) ) both contain the justiﬁcation Z → Plus ( Z ) . We are now ready to state the main deﬁnition of the paper as an instance of ( the directed fragment of ) Anti´c’s ( 2022 , Deﬁnition 5 ) . Deﬁnition 12 . A directed program equation in ( P , R ) is an expression of the form ‘ P transforms into Q as R transforms into X ’ — in symbols , P → Q : · R → X , ( 10 ) where P and Q are source programs from P , R is a target program from R , and X is a program variable . Given a target program S ∈ R , deﬁne the set of justiﬁcations of P → Q : · R → S in ( P , R ) by Jus ( P , R ) ( P → Q : · R → S ) : = Jus P ( P → Q ) ∩ Jus R ( R → S ) . We say that J is a trivial set of justiﬁcations in ( P , R ) i ﬀ every justiﬁcation in J justiﬁes every directed proportion P → Q : · R → S in ( P , R ) , that is , i ﬀ J ⊆ Jus ( P , R ) ( P → Q : · R → S ) for all P , Q ∈ P and R , S ∈ R . In this case , we call every justiﬁcation in J a trivial justiﬁcation in ( P , R ) . LOGIC PROGRAM PROPORTIONS 13 Now we call S a solution to ( 10 ) in ( P , R ) i ﬀ either Jus P ( P → Q ) ∪ Jus R ( R → S ) consists only of trivial justiﬁcations , in which case there is neither a non - trivial transformation of P into Q in P nor of R into S in R ; or Jus ( P , R ) ( P → Q : · R → S ) is maximal with respect to subset inclusion among the sets Jus ( P , R ) ( P → Q : · R → S ′ ) , S ′ ∈ R , containing at least one non - trivial justiﬁcation , that is , for any program S ′ ∈ R , Jus ( P , R ) ( P → Q : · R → S ) ⊆ Jus ( P , R ) ( P → Q : · R → S ′ ) implies Jus ( P , R ) ( P → Q : · R → S ′ ) ⊆ Jus ( P , R ) ( P → Q : · R → S ) . In this case , we say that P , Q , R , S are in directed logic program proportion in ( P , R ) written as ( P , R ) | = P → Q : · R → S . We denote the set of all solutions to ( 10 ) in ( P , R ) by S ol ( P , R ) ( P → Q : · R → X ) . Roughly , a program S in the target domain is a solution to a directed program equation of the form P → Q : · R → X i ﬀ there is no other target program S ′ whose transformation from R is more similar to the transformation of P into Q in the source domain expressed in terms of maximal sets of algebraic justiﬁcations . We will always write P instead of ( P , P ) . In what follows , we will usually omit trivial justiﬁcations from notation . So , for example , we will write Jus ( P , R ) ( P → Q : · R → S ) = ∅ instead of Jus ( P , R ) ( P → Q : · R → S ) = { trivial justiﬁcations } in case P → Q : · R → S has only trivial justiﬁcations in ( P , R ) , et cetera . The empty set is always a trivial set of justiﬁcations . Every justiﬁcation is meant to be non - trivial unless stated otherwise . The forms tr 1 ( X , Y ) : = ( X ∩ Y ) ∪ ( X − Y ) and tr 2 ( X , Y ) : = ( X ∩ Y ) ∪ ( Y − X ) justify any proportion P → Q : · R → S , which shows that tr 1 → tr 2 is a trivial justiﬁcation . This ex - ample shows that trivial justiﬁcations may contain useful information about the underlying structures — in this case , it encodes the trivial observation that any two programs P and Q are symmetrically related via P = ( P ∩ Q ) ∪ ( P − Q ) and Q = ( P ∩ Q ) ∪ ( Q − P ) . We call a form F ( ~ Z ) a P - generalization of a program P in P i ﬀ P = F ( ~ O ) , for some ~ O ∈ P | ~ Z | , and we denote the set of all P - generalizations of P in P by Gen P ( P ) . Moreover , we deﬁne for any programs P ∈ P and R ∈ R : Gen ( P , R ) ( P , R ) : = Gen P ( P ) ∩ Gen R ( R ) . Example 13 . Consider the directed equation of Example 1 given by Nat → Plus : · List → X . ( 11 ) This equation asks for a list program S which is obtained from List as the program Plus on numerals is obtained from Nat . In Example 22 , we will see that the program for concatenating lists is a solution to ( 11 ) . Example 14 . Consider the directed equation given by Nat → Even : · Reverse → X , ( 12 ) where Reverse is the program for reversing lists of Example 10 . In Example 23 , we will see that the program for reversing lists of even length is a solution to ( 12 ) . 14 LOGIC PROGRAM PROPORTIONS To guide the AI - practitioner , we shall now rewrite the above framework in a more algorithmic style ( cf . Anti´c , 2022 , Pseudocode 17 ) . Pseudocode 15 . Computing the solution set S to a directed logic program equation P → Q : · R → X consists of the following steps : ( 1 ) Compute S 0 : = S ol ( P , R ) ( P → Q : · R → X ) : ( a ) For each S ∈ R , if Jus P ( P , Q ) ∪ Jus R ( R , S ) consists only of trivial justiﬁcations , then add S to S 0 . ( b ) For each form F ( ~ Z ) ∈ Gen ( P , R ) ( P , R ) and all witnesses ~ O 1 ∈ P | ~ Z | , ~ O 2 ∈ R | ~ Z | satisfying P = F ( ~ O 1 ) and R = F ( ~ O 2 ) , and for each form G ( ~ Z ) ∈ Gen P ( Q ) containing only variables occurring in F ( ~ Z ) and satisfying Q = G ( ~ O 1 ) , add F → G to Jus ( P , R ) ( P → Q : · R → G ( ~ O 2 ) ) . ( c ) Identify those non - empty sets Jus ( P , R ) ( P → Q : · R → S ) which are subset maximal with respect to S and add those S ’s to S 0 . ( 2 ) For each S ∈ S 0 , check the following relations with the above procedure : ( a ) R ∈ S ol ( P , R ) ( Q → P : · S → X ) ? ( b ) Q ∈ S ol ( B , A ) ( R → S : · P → X ) ? ( c ) P ∈ S ol ( B , A ) ( S → R : · Q → X ) ? Add those S ∈ S 0 to S which pass all three tests . The set S now contains all solutions to P : Q : : R : X in ( P , R ) . 6 . P roperties of logic program proportions We summarize here Anti´c’s ( 2022 ) most important properties of analogical equations and propor - tions interpreted in the logic programming setting from above . 6 . 1 . Characteristic justiﬁcations . Computing all justiﬁcations of an analogical proportion is com - plicated in general , which fortunately can be omitted in many cases . We call a set J of justiﬁcations a characteristic set of justiﬁcations ( Anti´c , 2022 , Deﬁnition 20 ) of P → Q : · R → S in ( P , R ) i ﬀ J is a su ﬃ cient set of justiﬁcations of P → Q : · R → S in ( P , R ) , that is , i ﬀ ( 1 ) J ⊆ Jus ( P , R ) ( P → Q : · R → S ) , and ( 2 ) J ⊆ Jus ( P , R ) ( P → Q : · R → S ′ ) implies S ′ = S , for each S ′ ∈ P . In case J = { F → G } is a singleton , we call F → G a characteristic justiﬁcation of P → Q : · R → S in ( P , R ) . The following lemma is a useful characterization of characteristic justiﬁcations in terms of mild injectivity ( cf . Anti´c , 2022 , Uniqueness Lemma ) . Lemma 16 ( Uniqueness Lemma ) . For any justiﬁcation F ( ~ Z ) → G ( ~ Z ) of P → Q : · R → S in ( P , R ) , if there is a unique ~ O ∈ R | ~ Z | such that R = F ( ~ O ) , then F → G is a characteristic justiﬁcation of P → Q : · R → S in ( P , R ) . Proof . See the proof of Anti´c’s ( 2022 , Uniqueness Lemma ) . (cid:3) LOGIC PROGRAM PROPORTIONS 15 6 . 2 . Functional proportion theorem . In the rest of the paper , we will often use the following reason - ing pattern which roughly says that functional dependencies are preserved across ( di ﬀ erent ) domains ( cf . Anti´c , 2022 , Functional Proportion Theorem ) : Theorem 17 ( Functional Proportion Theorem ) . For any ( A ∩ B ) - form G ( Z ) , we have ( P , R ) | = P → G ( P ) : · R → G ( R ) , for all P ∈ P and R ∈ R . In this case , we call G ( R ) a functional solution of P → Q : · R → X in ( P , R ) characteristically justiﬁed by Z → G ( Z ) . Proof . See the proof of Anti´c’s ( 2022 , Functional Proportion Theorem ) . (cid:3) Functional solutions are plausible since transforming P into G ( P ) and R into G ( R ) is a direct im - plementation of “transforming P and R in the same way” , and it is therefore surprising that functional solutions can be nonetheless ‘unexpected’ and therefore ‘creative’ as will be demonstrated in Section 7 . Remark 18 . An interesting consequence of Theorem 17 is that in case Q ∈ P ∩ R is a constant program contained in both domains P and R , we have ( P , R ) | = P → Q : · R → Q , for all P ∈ P and R ∈ R , ( 13 ) characteristically justiﬁed by Theorem 17 via Z → Q . This can be intuitively interpreted as follows : every program in P ∩ R has a ‘name’ and can therefore be used to form logic program forms , which means that it is in a sense a “known” program . As the framework is designed to compute “novel” or “unknown” programs in the target domain via analogy - making , ( 13 ) means that “known” target programs can always be computed . The following result summarizes some useful consequences of Theorem 17 . Corollary 19 . For any source program P ∈ P , target program R ∈ R , and joint programs Q , S ∈ P ∩ R , the following proportions hold in ( P , R ) : P → P c : · R → R c P → P ∪ Q : · R → R ∪ Q P → ( Q ◦ P ) ◦ S : · R → ( Q ◦ R ) ◦ S P → Q · P · S : · R → Q · R · S P → f acts ( P ) : · R → f acts ( R ) P → head ( P ) : · R → head ( R ) P → body ( P ) : · R → body ( R ) P → LM ( P ) : · R → LM ( R ) . The following result is an instance of Anti´c ( 2022 , Theorem 28 ) . Corollary 20 . For any logic programs P , Q ∈ P and R ∈ R , we have ( P , R ) | = P → P : · R → R ( inner reﬂexivity ) , ( 14 ) P | = P → Q : · P → Q ( reﬂexivity ) . ( 15 ) 16 LOGIC PROGRAM PROPORTIONS 7 . E xamples In this section , we demonstrate the idea of learning logic programs by analogy via directed logic program proportions by giving some illustrative examples . Example 21 . Let A = { a , b } and B = { c , d } be propositional alphabets , and let P and R for the moment be the identical spaces of all propositional programs over A ∪ B . Consider the following directed equation : { a ← b } → ( b a ← b ) : · { c ← d } → X . ( 16 ) Here we have at least two candidates for the solution S . First , we can say that the second program in ( 16 ) is obtained from the ﬁrst by adding the fact b , in which case we expect — by analogy — that S = ( b c ← d ) ( 17 ) is a solution to ( 16 ) . Deﬁne the form G ( Z ) : = Z ∪ { b } . ( 18 ) Then the computations G ( { a ← b } ) = ( b a ← b ) and G ( { c ← d } ) = S ( 19 ) show that S is indeed a solution by Theorem 17 , that is , we have { a ← b } → G ( { a ← b } ) : · { c ← d } → G ( { c ← d } ) . ( 20 ) However , what if we separate the two domains by saying that P and R are the spaces of proposi - tional programs over the disjoint alphabets A and B , respectively ? In this case , Z → G ( Z ) is no longer a valid justiﬁcation of ( 20 ) as { b } in ( 18 ) is not contained in P ∩ R . This makes sense since , in this case , the “solution” S contains the fact b alien to the target domain R . Thus the question is whether we can redeﬁne G , without using the fact b , so that ( 19 ) holds . Observe that b is also the body of a ← b , which motivates the following deﬁnition : G ′ ( Z ) : = Z ∪ body ( Z ) . A simple computation shows that G ′ satisﬁes G ′ ( { a ← b } ) = ( b a ← b ) , which means that we can compute a solution S ′ of ( 16 ) via Theorem 17 as S ′ : = G ′ ( { c ← d } ) = ( d c ← d ) . Example 22 . Reconsider the situation in Example 9 , where we have derived the abstract form Plus generalizing addition . As a consequence of Theorem 17 , we have the following directed logic program proportion : 6 Nat → Plus ( Nat ) : · List → Plus ( List ) . ( 21 ) 6 For simplicity , we omit here the variables u and x from notation , that is , we write Nat and List instead of Nat ( x ) and List ( u , x ) , respectively . LOGIC PROGRAM PROPORTIONS 17 This proportion formalizes the intuition that “numbers are to addition what lists are to list concatena - tion . ” Similarly , we have Nat → Plus ( Nat ) : · Tree → Plus ( Tree ) . Without going into technical details , we want to mention that a similar procedure as in Example 9 applied to a program for multiplication yields a form Times ( Z h q i ( ~ x ) ) such that Times ( List ( u , x ) ) is a program for “multiplying” lists , e . g . , Times ( List ( u , x ) ) | = times ( [ a , a ] , [ b , b ] , [ b , b , b , b ] ) , where the result [ b , b , b , b ] is obtained from the input lists by concatenating the second list [ b , b ] k times with itself , where k is the length of the ﬁrst list ( in this case k = 2 ; the actual content of the ﬁrst list does not matter here ) . We then have the following directed logic program proportion as an instance of Theorem 17 : Nat → Times ( Nat ) : · List → Times ( List ) . In other words , addition is to multiplication what list concatenation is to list “multiplication . ” Example 23 . In Example 3 , we have constructed Even from Nat via composition and in Example 10 , we have then derived the abstract form Even generalizing “evenness . ” As a consequence of Theorem 17 , we have the following directed logic program proportion : Nat → Even ( Nat ) : · Reverse → Even ( Reverse ) . This shows that the ( seemingly unrelated ) program for reversing lists of even length shares the syn - tactic property of “evenness” with the program for constructing the even numbers . Example 24 . In Example 11 , we have derived the abstract form Member generalizing “membership” and we have asked the following question : What does “membership” mean in the numerical domain ? We can now state this question formally in the form of the following directed logic program equation : List → Member : · Nat → X . As a consequence of Theorem 17 , we have the following directed logic program proportion : List ( u , x ) → Member ( List ( u , x ) ) : · Nat ( u ) → Member ( Nat ( u ) ) , where Member ( Nat ( u ) ) is the program computing the numerical “less than” relation of Example 11 . 8 . R elated W ork Arguably , the most prominent ( symbolic ) model of analogical reasoning to date is Gentner’s ( 1983 ) Structure - Mapping Theory ( or SMT ) , ﬁrst implemented by Falkenhainer , Forbus , and Gentner ( 1989 ) . Our approach shares with Gentner’s SMT its symbolic nature . However , while in SMT mappings are constructed with respect to meta - logical considerations — for instance , Gentner’s systematicity principle prefers connected knowledge over independent facts — in our framework ‘mappings’ are realized via directed logic program proportions satisfying mathematically well - deﬁned properties . Formal models of analogical proportions started to appear only recently ( Lepage , 2001 ; Miclet & Prade , 2009 ; Stroppa & Yvon , 2006 ) . The functional - based view in Barbot , Miclet , and Prade ( 2019 ) is related to our Theorem 17 on the preservation of functional dependencies across di ﬀ erent domains ( Section 6 . 2 ) . Moreover , Anti´c ( 2022 , § 7 . 3 ) contains a brief discussion on the important di ﬀ erence between analogical proportions and categories as studied in abstract algebra . 18 LOGIC PROGRAM PROPORTIONS Heuristic - Driven Theory Projection ( HDTP ) ( Schmidt , Krumnack , Gust , & K¨uhnberger , 2014 ) has a similar focus on analogical proportions between logical theories . The critical di ﬀ erence to our ap - proach is that in our framework , we consider the set of all generalizations of a program , whereas in HDTP only minimally general generalizations ( mggs ) are considered , that is , there is no notion of “justiﬁcation” in HDTP and proportions are “’justiﬁed” by mggs only . Another di ﬀ erence is that HDTP is formulated within ﬁrst - order logic , whereas our framework is formulated within logic pro - gramming . The main beneﬁt of restricting the formalism to logic programs ( i . e . , sets of Horn clauses ) is that the rule - like syntactic form of logic programs allows an algebraization via composition and concatenation — this is not the case for ﬁrst - order logic . Moreover , the task of ﬁnding generaliza - tions is governed by heuristics in HDTP , which has no counterpart in our theory . In a sense , similar to HDTP , our framework can be interpreted as a generalization of classical anti - uniﬁcation ( Plotkin , 1970 ; Reynolds , 1970 ) . More precisely , while anti - uniﬁcation focuses on least general generalizations of terms , we are interested here in all generalizations of programs ( i . e . logical theories ) . Finally , we want to mention the recent work in Anti´c ( 2023b ) where a syntactic and algebraic notion of logic program similarity has been introduced via sequential compositions and decompositions as deﬁned in Section 3 . 1 . 9 . F uture W ork In this paper , we have demonstrated the utility of our framework of directed logic program propor - tions for learning logic programs by analogy with numerous examples . The main task for future research is to develop methods for the algorithmic computation of solu - tions to directed program equations as deﬁned in this paper ( see Pseudocode 15 ) . At its core , this requires algebraic methods for logic program decomposition ( Anti´c , 2023d , 2023c ) and deconcatena - tion , which are then used to compute forms generalizing a given program and ( characteristic ) justiﬁ - cations of a directed proportion . This task turns out to be highly non - trivial even for the propositional case . In fact , the only domains I fully understand at the moment is the 2 - valued boolean domain consisting only of two elements 0 and 1 — and already in that simple case a whole paper is needed to fully describe all solutions ( Anti´c , 2023a ) ! For example , in the arithmetical domain of natural numbers with multiplication , computing all solutions even to a single concrete analogical equation is non - trivial : computing all solutions to 20 : 4 : : 30 : x requires an 8 - page long computation ( cf . Anti´c , 2022 , pp . 42 , Example 66 ) . Since logic programs are more complicated than booleans or numbers , providing general algorithms for the computation of some or all solutions to analogical logic program equations is highly non - trivial even in the propositional case and far beyond the scope of the current paper . This does not mean that the framework is useless for learning — to the contrary , the paper shows , I hope , quite convincingly that learning of logic programs via solving analogical equations ( which appears to be a novel idea ) can in principle be done via solving ( directed ) logic program equations as proposed in the paper . It is therefore , in a sense , a “declarative” paper which shows what can be done with logic program proportions — in the future , more “procedural” papers will be needed to resolve the issue of how solutions to equations are to be computed in practice . Composition and concatenation are interesting operations on programs in their own right and a comparison to other operators for program modularity ( cf . Bugliesi , Lamma , & Mello , 1994 ; Brogi , Mancarella , Pedreschi , & Turini , 1999 ) remains as future work . A related question is whether these operations are su ﬃ cient for modeling all plausible analogies in logic programming or whether further operations are needed ( “completeness” ) . It is important to emphasize that in the latter case , adding novel operations to the framework does not a ﬀ ect the general formulations of the core deﬁnitions . References 19 In this paper , we have restricted ourselves to Horn programs . In the future we plan to adapt our framework to extended classes of programs as , for example , higher - order ( cf . Chen , Kifer , & War - ren , 1993 ; Miller & Nadathur , 2012 ) and non - monotonic logic programming under the stable model or answer set semantics ( Gelfond & Lifschitz , 1991 ) and extensions thereof ( cf . Brewka , Eiter , & Truszczynski , 2011 ) . For this , we will deﬁne the composition and concatenation of answer set pro - grams ( Anti´c , 2023c ) which is non - trivial due to negation as failure occurring in rule bodies ( and heads ) . Finally , a formal comparison of analogical reasoning and learning as deﬁned in this paper with other forms of reasoning and learning , most importantly inductive logic programming ( Muggleton , 1991 ) , is desirable as this line of research may lead to an interesting combination of di ﬀ erent learning methods . 10 . C onclusion This paper studied directed analogical proportions between logic programs for logic - based analog - ical reasoning and learning in the setting of logic programming . This enabled us to compare logic programs possibly across di ﬀ erent domains in a uniform way which is crucial for AI - systems . For this , we deﬁned the composition and concatenation of logic programs and showed , by giving some examples , that syntactically similar programs have similar decompositions . This observation led us to the notion of logic program forms which are proper generalizations of logic programs . We then used forms to formalize directed analogical proportions between logic programs — as an instance of the author’s model of analogical proportions — as a mechanism for deriving novel programs in an “unknown” target domain via analogical transfer — realized by generalization and instantiation — from a “known” source domain . A cknowledgments We would like to thank the reviewers for their thoughtful and constructive comments , and for their helpful suggestions to improve the presentation of the article . C onflict of interest The authors declare that they have no conﬂict of interest . D ata availability statement The manuscript has no data associated . R eferences Anti´c , C . ( 2022 ) . Analogical proportions . Annals of Mathematics and Artiﬁcial Intelligence , 90 ( 6 ) , 595 – 644 . Anti´c , C . ( 2023a ) . Boolean proportions . Logical Methods in Computer Science , under review , https : / / arxiv . org / pdf / 2109 . 00388 . pdf . Anti´c , C . ( 2023b ) . On syntactically similar logic programs and sequential decompositions . Informa - tion and Computation , under review , https : / / arxiv . org / pdf / 2109 . 05300 . pdf . Anti´c , C . ( 2023c ) . Sequential composition of answer set programs . , https : / / arxiv . org / pdf / 2104 . 12156v2 . pdf . Anti´c , C . ( 2023d ) . Sequential composition of propositional logic programs . Annals of Mathematics and Artiﬁcial Intelligence , under revision , https : / / arxiv . org / pdf / 2009 . 05774v4 . pdf . 20 References Apt , K . R . ( 1990 ) . Logic programming . In van Leeuwen , J . ( Ed . ) , Handbook of Theoretical Computer Science , Vol . B , pp . 493 – 574 . Elsevier , Amsterdam . Barbot , N . , Miclet , L . , & Prade , H . ( 2019 ) . Analogy between concepts . Artiﬁcial Intelligence , 275 , 487 – 539 . Brewka , G . , Eiter , T . , & Truszczynski , M . ( 2011 ) . Answer set programming at a glance . Communi - cations of the ACM , 54 ( 12 ) , 92 – 103 . Brogi , A . , Mancarella , P . , Pedreschi , D . , & Turini , F . ( 1999 ) . Modular logic programming . ACM Transactions on Programming Languages and Systems , 16 ( 4 ) , 1361 – 1398 . Bugliesi , M . , Lamma , E . , & Mello , P . ( 1994 ) . Modularity in logic programming . The Journal of Logic Programming , 19 - 20 ( 1 ) , 443 – 502 . Chen , W . , Kifer , M . , & Warren , D . S . ( 1993 ) . HiLog : A foundation for higher - order logic program - ming . The Journal of Logic Programming , 15 ( 3 ) , 187 – 230 . Czarnecki , K . , & Eisenecker , U . W . ( 2000 ) . Generative Programming : Methods , Tools , and Applica - tions . Addison - Wesley . Falkenhainer , B . , Forbus , K . D . , & Gentner , D . ( 1989 ) . The structure - mapping engine : algorithm and examples . Artiﬁcial Intelligence , 41 ( 1 ) , 1 – 63 . Gelfond , M . , & Lifschitz , V . ( 1991 ) . Classical negation in logic programs and disjunctive databases . New Generation Computing , 9 ( 3 - 4 ) , 365 – 385 . Gentner , D . ( 1983 ) . Structure - mapping : a theoretical framework for analogy . Cognitive Science , 7 ( 2 ) , 155 – 170 . Goodfellow , I . , Bengio , Y . , & Courville , A . ( 2016 ) . Deep Learning : Adaptive Computation and Ma - chine Learning . MIT Press , Cambridge USA . Gowers , T . ( 2000 ) . The two cultures of mathematics . In Arnold , W . I . , Atiyah , M . F . , Lax , P . , & Mazur , B . ( Eds . ) , Mathematics : Frontiers and Perspectives , pp . 65 – 78 . American Mathematical Society . Hofstadter , D . , & Mitchell , M . ( 1995 ) . The copycat project : a model of mental ﬂuidity and analogy - making . In Fluid Concepts and Creative Analogies . Computer Models of the Fundamental Mechanisms of Thought , chap . 5 , pp . 205 – 267 . Basic Books , New York . Hofstadter , D . , & Sander , E . ( 2013 ) . Surfaces and Essences . Analogy as the Fuel and Fire of Thinking . Basic Books , New York . Kowalski , R . ( 1984 ) . The relation between logic programming and logic speciﬁcation . Philosophical Transactions of the Royal Society of London , 312 ( 1522 ) , 345 – 361 . LeCun , Y . , Bengio , Y . , & Hinton , G . ( 2015 ) . Deep learning . Nature , 521 , 436 – 444 . Lepage , Y . ( 2001 ) . Analogy and formal languages . Electronic Notes in Theoretical Computer Science , 53 , 180 – 191 . Miclet , L . , & Prade , H . ( 2009 ) . Handling analogical proportions in classical logic and fuzzy logics settings . In Sossai , C . , & Chemello , G . ( Eds . ) , ECSQARU 2009 , LNAI 5590 , pp . 638 – 650 . Springer - Verlag , Berlin / Heidelberg . Miller , D . , & Nadathur , G . ( 2012 ) . Programming with Higher - Order Logic . Cambridge University Press . Muggleton , S . ( 1991 ) . Inductive logic programming . New Generation Computing , 8 ( 4 ) , 295 – 318 . Plotkin , G . D . ( 1970 ) . A note on inductive generalization . Machine Intelligence , 5 , 153 – 163 . Reynolds , J . C . ( 1970 ) . Transformational systems and the algebraic structure of atomic formulas . Machine Intelligence , 5 ( 1 ) , 135 – 151 . Schmidt , M . , Krumnack , U . , Gust , H . , & K¨uhnberger , K . - U . ( 2014 ) . Heuristic - driven theory projec - tion : an overview . In Prade , H . , & Richard , G . ( Eds . ) , Computational Approaches to Analogical Reasoning : Current Trends , Vol . 548 of Studies in Computational Intelligence , pp . 163 – 194 . References 21 Springer - Verlag , Berlin / Heidelberg . Stroppa , N . , & Yvon , F . ( 2006 ) . Formal models of analogical proportions . Technical Report D008 , Telecom ParisTech - ´Ecole Nationale Sup´erieure de T´el´ecommunications , T´el´ecom Paris .