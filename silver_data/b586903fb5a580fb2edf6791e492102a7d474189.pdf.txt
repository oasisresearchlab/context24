HAL Id : hal - 00467747 https : / / hal . archives - ouvertes . fr / hal - 00467747 Submitted on 26 Apr 2010 HAL is a multi - disciplinary open access archive for the deposit and dissemination of sci - entific research documents , whether they are pub - lished or not . The documents may come from teaching and research institutions in France or abroad , or from public or private research centers . L’archive ouverte pluridisciplinaire HAL , est destinée au dépôt et à la diffusion de documents scientifiques de niveau recherche , publiés ou non , émanant des établissements d’enseignement et de recherche français ou étrangers , des laboratoires publics ou privés . Discovering frequent closed itemsets for association rules Nicolas Pasquier , Yves Bastide , Rafik Taouil , Lotfi Lakhal To cite this version : Nicolas Pasquier , Yves Bastide , Rafik Taouil , Lotfi Lakhal . Discovering frequent closed itemsets for association rules . ICDT’1999 International Conference on Database Theory , Jan 1999 , Jerusalem , Israel . 1540 , pp . 398 - 416 , 1999 , Lecture Notes in Computer Science . < hal - 00467747 > Discovering Frequent Closed Itemsets for Association Rules Nicolas Pasquier , Yves Bastide , Ra(cid:12)k Taouil , and Lot(cid:12) Lakhal Laboratoire d ' Informatique ( LIMOS ) Universit(cid:19)e Blaise Pascal - Clermont - Ferrand II Complexe Scienti(cid:12)que des C(cid:19)ezeaux 24 , av . des Landais , 63177 Aubi(cid:18)ere Cedex France fpasquier , bastide , taouil , lakhalg @ libd1 . univ - bpclermont . fr Abstract . In this paper , we address the problem of (cid:12)nding frequent itemsets in a database . Using the closed itemset lattice framework , we show that this problem can be reduced to the problem of (cid:12)nding frequent closed itemsets . Based on this statement , we can construct e(cid:14)cient data mining algorithms by limiting the search space to the closed itemset lattice rather than the subset lattice . Moreover , we show that the set of all frequent closed itemsets su(cid:14)ces to determine a reduced set of association rules , thus addressing another important data mining problem : limiting the numberof rules producedwithout information loss . We propose a new algorithm , called A - Close , using a closure mechanism to (cid:12)nd frequent closed itemsets . We realized experiments to compare our approach to the commonly used frequent itemset search approach . Those experiments showed that our approach is very valuable for dense and / or correlated data that represent an important part of existing databases . 1 Introduction The discovery of association rules was (cid:12)rst introduced in [ 1 ] . This task con - sists in determining relationships between sets of items in very large databases . Agrawal ' sstatement of this problem is the following [ 1 , 2 ] . Let I = fi1 ; i2 ; : : : ; img be a set of m items . Let the database D = ft1 ; t2 ; : : : ; tng be a set of n trans - actions , each one identi(cid:12)ed by its unique TID . Each transaction t consists of a set of items I from I . If kIk = k , then I is called a k - itemset . An itemset I is contained in a transaction t 2 D if I (cid:18) t . The support of an itemset I is the percentage of transactions in D containing I . Association rules are of the form r : I1 c (cid:0) ! I2 , with I1 ; I2 (cid:26) I and I1 \ I2 = ; . Each association rule r has a support de(cid:12)ned as support ( r ) = support ( I1 [ I2 ) and a con(cid:12)dence c de(cid:12)ned as confidence ( r ) = support ( I1 [ I2 ) = support ( I1 ) . Given the user de(cid:12)ned minimum support minsup and minimum con(cid:12)dence minconf thresholds , the problem of mining association rules can be divided into two sub - problems [ 1 ] : 1 . Find all frequent itemsets in D , i . e . itemsets with support greater or equal to minsup . 2 . For each frequent itemset I1 found , generate all association rules I2 c (cid:0) ! I1(cid:0)I2 where I2 (cid:26) I1 , with con(cid:12)dence c greater or equal to minconf . Once all frequent itemsets and their support are known , the association rule generation is straightforward . Hence , the problem of mining association rules is reduced to the problem of determining frequent itemsets and their support . Recent works demonstrated that the frequent itemset discovery is also the key stage in the search for episodes from sequences and in (cid:12)nding keys or inclusion as well as functional dependencies from a relation [ 12 ] . All existing algorithms use one of the two following approach : a levelwise [ 12 ] bottom - up search [ 2 , 5 , 13 , 16 , 17 ] or a simultaneous bottom - up and top - down search [ 3 , 10 , 20 ] . Although they are dissimilar , all those algorithms explore the subset lattice ( itemset lattice ) for (cid:12)nding frequent itemsets : they all use the basic properties that all subsets of a frequent itemset are frequent and that all supersets of an infrequent itemset are infrequent in order to prune elements of the itemset lattice . In this paper , we propose a new e(cid:14)cient algorithm , called A - Close , for (cid:12)nd - ing frequent closed itemsets and their support in a database . Using a closure mechanism based on the Galois connection , we de(cid:12)ne the closed itemset lattice which is a sub - order of the itemset lattice , thus often much smaller . This lat - tice is closely related to the Galois lattice [ 4 , 7 ] also called concept lattice [ 19 ] . The closed itemset lattice can be used as a formal framework for discovering frequent itemsets given the basic properties that the support of an itemset I is equal to the support of its closure and that the set of maximal frequent itemsets is identical to the set of maximal frequent closed itemsets . Then , once A - Close has discovered all frequent closed itemsets and their support , we can directly determine the frequent itemsets and their support . Hence , we reduce the prob - lem of mining association rules to the problem of determining frequent closed itemsets and their support . Using the set of frequent closed itemsets , we can also directly generate a reduced set of association rules without having to determine all frequent item - sets , thus lowering the algorithm computation cost . Moreover , since there can be thousands of association rules holding in a database , reducing the number of rules produced without information loss is an important problem for the un - derstandability of the result [ 18 ] . Empirical evaluations comparing A - Close to an optimized version of Apriori showed that they give nearly always equivalent results for weakly correlated data ( such as synthetic data ) and that A - Close clearly outperforms Apriori for correlated data ( such as statistical or text data ) . The rest of the paper is organized as follows . In Section 2 , we present the closed itemset lattice . In Section 3 , we propose a new model for association rules based on the Galois connection and we characterize a reduced set of association rules . In Section 4 , we describe the A - Close algorithm . Section 5 gives experimen - tal results on synthetic data 1 and census data using the PUMS (cid:12)le for Kansas USA 2 and Section 6 concludes the paper . 1 http : / / www . almaden . ibm . com / cs / quest / syndata . html 2 ftp : / / ftp2 . cc . ukans . edu / pub / ippbr / census / pums / pums90ks . zip 2 Closed Itemset Lattices In this section , we de(cid:12)ne data mining context , Galois connection , Galois closure operators , closed itemsets and closed itemset lattice . Interested readers should read [ 4 , 7 , 19 ] for further details on order and lattice theory . De(cid:12)nition 1 ( Data mining context ) . A data mining context 3 is a triple D = ( O ; I ; R ) . O and I are (cid:12)nite sets of objects and items respectively . R (cid:18) O (cid:2) I is a binary relation between objects and items . Each couple ( o ; i ) 2 R denotes the fact that the object o 2 O is related to the item i 2 I . De(cid:12)nition 2 ( Galois connection ) . Let D = ( O ; I ; R ) be a data mining con - text . For O (cid:18) O and I (cid:18) I , we de(cid:12)ne : f ( O ) : 2 O ! 2 I g ( I ) : 2 I ! 2 O f ( O ) = fi 2 I j 8o 2 O ; ( o ; i ) 2 Rg g ( I ) = fo 2 O j 8i 2 I ; ( o ; i ) 2 Rg f ( O ) associates with O the items common to all objects o 2 O and g ( I ) associates with I the objects related to all items i 2 I . The couple of applications ( f ; g ) is a Galois connection between the power set of O ( i . e . 2 O ) and the power set of I ( i . e . 2 I ) . The following properties hold for all I ; I1 ; I2 (cid:18) I and O ; O1 ; O2 (cid:18) O : ( 1 ) I1 (cid:18) I2 ) g ( I1 ) (cid:19) g ( I2 ) ( 1 ' ) O1 (cid:18) O2 ) f ( O1 ) (cid:19) f ( O2 ) ( 2 ) O (cid:18) g ( I ) ( ) I (cid:18) f ( O ) De(cid:12)nition 3 ( Galois closure operators ) . The operators h = f(cid:14)g in 2 I and h 0 = g(cid:14)f in 2 O are Galois closure operators 4 . Given the Galois connection ( f ; g ) , the following properties hold for all I ; I1 ; I2 (cid:18) I and O ; O1 ; O2 (cid:18) O [ 4 , 7 , 19 ] : Extension : ( 3 ) I (cid:18) h ( I ) ( 3 ' ) O (cid:18) h 0 ( O ) Idempotency : ( 4 ) h ( h ( I ) ) = h ( I ) ( 4 ' ) h 0 ( h 0 ( O ) ) = h 0 ( O ) Monotonicity : ( 5 ) I1 (cid:18) I2 ) h ( I1 ) (cid:18) h ( I2 ) ( 5 ' ) O1 (cid:18) O2 ) h 0 ( O1 ) (cid:18) h 0 ( O2 ) De(cid:12)nition 4 ( Closed itemsets ) . An itemset C (cid:18) I from D is a closed itemset i(cid:11) h ( C ) = C . The smallest ( minimal ) closed itemset containing an itemset I is obtained by applying h to I . We call h ( I ) the closure of I . De(cid:12)nition 5 ( Closed itemset lattice ) . Let C be the set of closed itemsets derived from D using the Galois closure operator h . The pair LC = ( C ; (cid:20) ) is a complete lattice called closed itemset lattice . The lattice structure implies two properties : i ) There exists a partial order on the lattice elements such that , for every ele - ments C1 ; C2 2 LC , C1 (cid:20) C2 , i(cid:11) C1 (cid:18) C2 5 . ii ) All subsets of LC have one greatest lower bound , the Join element , and one lowest upper bound , the Meet element . 3 By extension , we call database a data mining context afterwards . 4 Here , we use the following notation : f(cid:14)g ( I ) = f ( g ( I ) ) and g(cid:14)f ( O ) = g ( f ( O ) ) . 5 C1 is a sub - closed itemset of C2 and C2 is a sup - closed itemset of C1 . Below , we give the de(cid:12)nitions of the Join and Meet elements extracted from the basic theorem on Galois ( concept ) lattices [ 4 , 7 , 19 ] . For all S (cid:18) LC : Join ( S ) = h ( [ C2S C ) ; Meet ( S ) = \ C2S C OID Items 1 A C D 2 B C E 3 A B C E 4 B E 5 A B C E ABCDE ABCE AC BE C ACD BCE Ø Fig . 1 . The data mining context D and its associated closed itemset lattice . 3 Association Rule Model In this section , we de(cid:12)ne frequent and maximal frequent itemsets and closed itemsets using the Galois connection . We then de(cid:12)ne association rules and valid association rules , and we characterise a reduced set of valid association rules in a data mining context D . 3 . 1 Frequent Itemsets De(cid:12)nition 6 ( Itemset support ) . Let I (cid:18) I be a set of items from D . The support count of the itemset I in D is : support ( I ) = kg ( I ) k kOk De(cid:12)nition 7 ( Frequent itemsets ) . The itemset I is said to be frequent if the support of I in D is at least minsup . The set L of frequent itemsets in D is : L = fI (cid:18) I j support ( I ) (cid:21) minsupg De(cid:12)nition 8 ( Maximal frequent itemsets ) . Let L be the set of frequent itemsets . We de(cid:12)ne the set M of maximal frequent itemsets in D as : M = fI 2 L j 69I 0 2 L ; I (cid:26) I 0 g Property 1 . All subsets of a frequent itemset are frequent ( intuitive in [ 2 ] ) . Proof . Let I ; I 0 (cid:18) I , I 2 L and I 0 (cid:18) I . According to Property ( 1 ) of the Galois connection : I 0 (cid:18) I = ) g ( I 0 ) (cid:19) g ( I ) = ) support ( I 0 ) (cid:21) support ( I ) (cid:21) minsup . So , we get : I 0 2 L . Property 2 . All supersets of an infrequent itemset are infrequent ( intuitive in [ 2 ] ) . Proof . Let I ; I 0 (cid:18) I , I 0 = 2 L and I 0 (cid:18) I . According to Property ( 1 ) of the Galois connection : I (cid:19) I 0 = ) g ( I ) (cid:18) g ( I 0 ) = ) support ( I ) (cid:20) support ( I 0 ) (cid:20) minsup . So , we get : I = 2 L . 3 . 2 Frequent Closed Itemsets De(cid:12)nition 9 ( Frequent closed itemsets ) . The closed itemset C is said to be frequent if the support of C in D is at least minsup . We de(cid:12)ne the set FC of frequent closed itemsets in D as : FC = fC (cid:18) I j C = h ( C ) ^ support ( C ) (cid:21) minsupg De(cid:12)nition 10 ( Maximal frequent closed itemsets ) . Let FC be the set of frequent closed itemsets . We de(cid:12)ne the set MC of maximal frequent closed item - sets in D as : MC = fC 2 FC j 69C 0 2 FC ; C (cid:26) C 0 g Property 3 . The support of an itemset I is equal to the support of its closure : support ( I ) = support ( h ( I ) ) . Proof . Let I (cid:18) I be an itemset . The support of I in D is : support ( I ) = kg ( I ) k kOk Now , we consider h ( I ) , the closure of I . Let ' s show that h 0 ( g ( I ) ) = g ( I ) . We have g ( I ) (cid:18) h ( g ( I ) ) ( extension property of the Galois closure ) and I (cid:18) h ( I ) ) g ( h ( I ) ) (cid:18) g ( I ) ( Property ( 1 ) of the Galois connection ) . We deduce that h 0 ( g ( I ) ) = g ( I ) , and therefore we have : support ( h ( I ) ) = kg ( h ( I ) ) k kOk = kh 0 ( g ( I ) ) k kOk = kg ( I ) k kOk = support ( I ) Property 4 . The set of maximal frequent itemsets M is identical to the set of maximal frequent closed itemsets MC . Proof . It su(cid:14)ces to demonstrate that 8I 2 M , I is closed , i . e . I = h ( I ) . Let I 2 M be a maximal frequent itemset . According to Property ( 3 ) of the Galois connection I (cid:18) h ( I ) and , since I is maximal and support ( h ( I ) ) = support ( I ) (cid:21) minsup , we conclude that I = h ( I ) . I is a maximal frequent closed itemset . Since all maximal frequent itemsets are also maximal frequent closed itemsets , we get : M = MC . 3 . 3 Association Rule Semantics De(cid:12)nition 11 ( Association rules ) . An association rule is an implication be - tween itemsets of the form I1 c (cid:0) ! I2 where I1 ; I2 (cid:26) I and I1 \ I2 = ; . Below , we de(cid:12)ne the support and con(cid:12)dence c of an association rule r : I1 c (cid:0) ! I2 using the Galois connection : support ( r ) = kg ( I1 [ I2 ) k kOk ; confidence ( r ) = support ( I1 [ I2 ) support ( I1 ) = kg ( I1 [ I2 ) k kg ( I1 ) k De(cid:12)nition 12 ( Valid association rules ) . A valid association rules is an as - sociation rules with support and con(cid:12)dence greater or equal to the minsup and minconf thresholds respectively . We de(cid:12)ne the set AR of valid association rules in D using the set MC of maximal frequent closed itemsets as : AR ( D ; minsup , minconf ) = fr : I2 c (cid:0) ! I1 (cid:0) I2 ; I2 (cid:26) I1 j I1 2 L = [ C2MC 2 C and confidence ( r ) (cid:21) minconfg 3 . 4 Reduced Set of Association Rules Let I1 ; I2 (cid:26) I and I1 \ I2 = ; . An association rule r : I1 c (cid:0) ! I2 is an exact association rule if c = 1 . Then , r is noted r : I1 ) I2 . An association rule r : I1 c (cid:0) ! I2 where c < 1 is called an approximate association rule . Let D be a data mining context . De(cid:12)nition 13 ( Pseudo - closed itemsets ) . An itemset I (cid:18) I from D is a pseudo - closed itemset i(cid:11) h ( I ) 6 = I and 8I 0 (cid:26) I such as I 0 is a pseudo - closed itemset , we have h ( I 0 ) (cid:18) I . Theorem 1 ( Exact association rules basis [ 8 ] ) . Let P be the set of pseudo - closed itemsets and R the set of exact association rules in D . The set E = fr : I1 ) h ( I1 ) (cid:0)I1 j I1 2 Pg is a basis for all exact association rules . 8r 0 2 R where con(cid:12)dence ( r 0 ) = 1 (cid:21) minconf we have E j = r 0 . Corollary 1 ( Exact valid association rules basis ) . Let FP be the set of fre - quent pseudo - closed itemsets in D . The set BE = fr : I1 ) h ( I1 ) (cid:0)I1 j I1 2 FPg is a basis for all exact valid association rules . 8r 0 2 AR where con(cid:12)dence ( r 0 ) = 1 we have BE j = r 0 . Theorem 2 ( Reduced set of approximate association rules [ 11 ] ) . Let C be the set of closed itemsets and R the set of approximate association rules in D . The set A = fr : I1 c (cid:0) ! I2 (cid:0) I1 j I2 (cid:26) I1 ^ I1 ; I2 2 Cg is a correct reduced set for all approximate association rules . 8r 0 2 R where minconf (cid:20) con(cid:12)dence ( r 0 ) < 1 we have A j = r 0 . Corollary 2 ( Reduced set of approximate valid association rules ) . Let FC be the set of frequent closed itemsets in D . The set BA = fr : I1 c (cid:0) ! I2 (cid:0) I1 j I2 (cid:26) I1 ^ I1 ; I2 2 FCg is a correct reduced set for all approximate valid assocition rules . 8r 0 2 AR where con(cid:12)dence ( r 0 ) (cid:20) 1 we have BA j = r 0 . 4 A - Close Algorithm In this section , we present our algorithm for (cid:12)nding frequent closed itemsets and their supports in a database . Section 4 . 1 describes its principle . In Section 4 . 2 to 4 . 5 , we give the pseudo - close of the algorithm and the sub - functions it uses . Section 4 . 6 provides an example and the proof of the algorithm correctness . 4 . 1 A - Close Principle A closed itemset is a maximal set of items common to a set of objects . For example , in the database D in Figure 1 , the itemset BCE is a closed itemset since it is the maximal set of items common to the objects f2 ; 3 ; 5g . BCE is called a frequent closed itemset for minsup = 2 as support ( BCE ) = kf2 ; 3 ; 5gk = 3 (cid:21) minsup . In a basket database , this means that 60 % of customers ( 3 customers on a total of 5 ) purchase at most the items B ; C and E . The itemset BC is not a closed itemset since it is not a maximal group of items common to some objects : all customers purchasing the items B and C also purchase the item E . The closed itemset lattice of a (cid:12)nite relation ( the database ) is dually isomorphic to the Galois lattice [ 4 , 7 ] , also called concept lattice [ 19 ] . Based on the closed itemset lattice properties ( Section 2 and 3 ) , using the result of A - Close we can generate all frequent itemsets from a database D through the two following phases : 1 . Discover all frequent closed itemsets in D , i . e . itemsets that are closed and have support greater or equal to minsup . 2 . Derive all frequent itemsets from the frequent closed itemsets found in phase 1 . That is generate all subsets of the maximal frequent closed itemsets and de - rive their support from the frequent closed itemset supports . A di(cid:11)erent algorithm for (cid:12)nding frequent closed itemsets and algorithms for deriving frequent itemsets and generating valid association rules are presented in [ 15 ] . Using the result of A - Close , we can directly generate the reduced set of valid association rules de(cid:12)ned in Section 3 . 4 instead of determining all frequent itemsets . The procedure is the following : 1 . Discover all frequent closed itemsets in D . 2 . Determine the exact valid association rule basis : determine the pseudo - closed itemsets in D and then generate all rules r : I1 ) I2 (cid:0) I1 j I1 (cid:26) I2 where I2 is a frequent closed itemset and I1 is a frequent pseudo - closed itemset . 3 . Construct the reduced set of approximate valid association rules : generate all rules of the form : r : I1 c (cid:0) ! I2 (cid:0) I1 j I1 (cid:26) I2 where I1 and I2 are frequent closed itemsets . In the two cases , the (cid:12)rst phase is the most computationally intensive part . After this phase , no more database pass is necessary and the later phases can be solved easily in a straightforward manner . Indeed , the (cid:12)rst phase has given us all information needed by the next ones . A - Close discovers the frequent closed itemsets as follows . Based on the closed itemset properties , it determines a set of generators that will give us all frequent closed itemsets by application of the Galois closure operator h . An itemset p is a generator of a closed itemset c if it is one of the smallest itemsets ( there can be more than one ) that will determine c using the Galois closure operator : h ( p ) = c . For instance , in the database D ( Figure 1 ) , BC and CE are generators of the closed itemset BCE . The itemsets B , C and E are not generators of BCE since h ( C ) = C and h ( B ) = h ( E ) = BE . The itemset BCE is not a generator of itself since it includes BC and CE : BCE is not one of the smallest itemsets for which closure is BCE . The algorithm constructs the set of generators in a levelwise manner : ( i + 1 ) - generators 6 are created using i - generators in Gi . Then , their support is counted and the useless generators are pruned . According to their supports and the sup - ports of their i - subsets in Gi , infrequent generators and generators that have the same closure as one of their subsets are deleted from Gi + 1 . In the previ - ous example , the support of the generator BCE is the same as the support of generators BC and CE since they have the same closure ( Property 3 ) . Once all frequent useful generators are found , their closures are determined , giving us the set of all frequent closed itemsets . For reducing the cost of the closure computation when possible , we introduce the following optimization . We determine the (cid:12)rst iteration of the algorithm for which a ( i + 1 ) - generator was pruned because it had the same closure as one of its i - subsets . In all iterations preceding the i th one , the generators created are closed and their closure com - putation is useless . Hence , we can limit the closure computation to generators of size greater or equal to i . For this purpose , the level variable indicates the (cid:12)rst iteration for which a generator was pruned by this pruning strategy . 4 . 2 Discovering Frequent Closed Itemsets As in the Apriori algorithm , items are sorted in lexicographic order . The pseudo - code for discovering frequent closed itemsets is given in Algorithm 1 . The nota - tion is given in Table 1 . In each of the iterations that construct the candidate generators , one pass over the database is necessary in order to count the support of the candidate generators . At the end of the algorithm , one more pass is needed for determining the closures of generators that are not closed . If all generators are closed , this pass is not made . First , the algorithm determines the set G1 of frequent 1 - generators and their support ( step 1 to 5 ) . Then , the level variable is set to 0 ( step 6 ) . In each of the following iterations ( step 7 to 9 ) , the AC - Generator function ( Section 4 . 4 ) is applied to the set of generators Gi , determining the candidate ( i + 1 ) - generators and their support in Gi + 1 ( step 8 ) . This process takes place until Gi is empty . Finally , closures of all generators produced are determined ( step 10 to 14 ) . Using the level variable , we construct two sets of generators . The set G which contains generators p for which size is less than level(cid:0)1 , and so that are closed ( p = h ( p ) ) . 6 A generator of size i is called an i - generator . Set Field Contains Gi generator A generator of size i . support Support count of the generator : support = count ( generator ) G ; G 0 generator A generator of size i . closure Closure of the generator : closure = h ( generator ) . support Support count of the generator and its closure : support = count ( closure ) = count ( generator ) ( Property 3 ) . FC closure Frequent closed itemset ( closed itemset with support (cid:21) minsup ) . support Support count of the frequent closed itemset . Table 1 . Notation The set G 0 which contains generators for which size is at least level (cid:0) 1 , among which some are not closed , and so for which closure computation is necessary . The closures of generators in G 0 are determined by applying the AC - Generator function ( Section 4 . 4 ) to G 0 ( step 15 ) . Then , all frequent closed itemsets have been produced and their support is known ( see Theorem 3 ) . Algorithm 1 A - Close algorithm 1 ) generators in G1 f1 - itemsetsg ; 2 ) G1 Support - Count ( G1 ) ; 3 ) forall generators p 2 G1 do begin 4 ) if ( support ( p ) < minsup ) then delete p from G1 ; / / Pruning infrequent 5 ) end 6 ) level 0 ; 7 ) for ( i 1 ; Gi . generator 6 = ; ; i + + ) do begin 8 ) Gi + 1 AC - Generator ( Gi ) ; / / Creates ( i + 1 ) - generators 9 ) end 10 ) if ( level > 2 ) then begin 11 ) G S fGj j j < level - 1g ; / / Those generators are all closed 12 ) forall generators p 2 G do begin 13 ) p . closure p . generator ; 14 ) end 15 ) end 16 ) if ( level 6 = 0 ) then begin 17 ) G 0 S fGj j j (cid:21) level - 1g ; / / Some of those generators are not closed 18 ) G 0 AC - Closure ( G 0 ) ; 19 ) end 20 ) Answer FC fc . closure , c . supportjc 2 G [ G 0 g ; 4 . 3 Support - Count Function The function takes the set Gi of frequent i - generators as argument . It returns the set Gi with , for each generator p 2 Gi , its support count : support ( p ) = kfo 2 O j p (cid:18) f ( fog ) k . The pseudo - code of the function is given in Algorithm 2 . Algorithm 2 Support - Count function 1 ) forall objects o 2 O do begin 2 ) Go Subset ( Gi . generator , f ( fog ) ) ; / / Generators that are subsets of f ( fog ) 3 ) forall generators p 2 Go do begin 4 ) p . support + + ; 5 ) end 6 ) end The Subset function quickly determines which generators are contained in an object 7 , i . e . generators that are subsets of f ( fog ) . For this purpose , generators are stored in a pre(cid:12)x - tree structure derived from the one proposed in [ 14 ] . 4 . 4 AC - Generator Function The function takes the set Gi of frequent i - generators as argument . Based on Lemma 1 and 2 , it returns the set Gi + 1 of frequent ( i + 1 ) - generators . The pseudo - code of the function is given in Algorithm 3 . Lemma 1 . Let I1 ; I2 be two itemsets . We have : h ( I1 [ I2 ) = h ( h ( I1 ) [ h ( I2 ) ) Proof . Let I1 and I2 be two itemsets . According to the extension property of the Galois closure operators : I1 (cid:18) h ( I1 ) and I2 (cid:18) h ( I2 ) = ) I1 [ I2 (cid:18) h ( I1 ) [ h ( I2 ) = ) h ( I1 [ I2 ) (cid:18) h ( h ( I1 ) [ h ( I2 ) ) ( 1 ) Obviously , I1 (cid:18) I1 [ I2 and I2 (cid:18) I1 [ I2 . So h ( I1 ) (cid:18) h ( I1 [ I2 ) and h ( I2 ) (cid:18) h ( I1 [ I2 ) . According to the idempotency property of the Galois closure operators : h ( h ( I1 ) [ h ( I2 ) ) (cid:18) h ( h ( I1 [ I2 ) ) = ) h ( h ( I1 ) [ h ( I2 ) ) (cid:18) h ( I1 [ I2 ) ( 2 ) From ( 1 ) and ( 2 ) , we conclude that h ( I1 [ I2 ) = h ( h ( I1 ) [ h ( I2 ) ) . Lemma 2 . Let I1 be an itemset and I2 a subset of I1 where support ( I1 ) = support ( I2 ) . Then we have h ( I1 ) = h ( I2 ) and 8I3 (cid:18) I , h ( I1 [ I3 ) = h ( I2 [ I3 ) . Proof . Let I1 ; I2 be two itemsets where I2 (cid:26) I1 and support ( I1 ) = support ( I2 ) . Then , we have that kg ( I1 ) k = kg ( I2 ) k and we deduce that g ( I1 ) = g ( I2 ) . From this , we conclude f ( g ( I1 ) ) = f ( g ( I2 ) ) = ) h ( I1 ) = h ( I2 ) . Let I3 (cid:18) I be an itemset . Then according to Lemma 1 : h ( I1 [ I3 ) = h ( h ( I1 ) [ h ( I3 ) ) = h ( h ( I2 ) [ h ( I3 ) ) = h ( I2 [ I3 ) 7 We say that an itemset I is contained in object o if o is related to all items i 2 I . Corollary 3 . Let I be an i - generator and S = fs1 ; s2 ; : : : ; sjg a set of ( i (cid:0) 1 ) - subsets of I where S s2S s = I . If 9s 2 S such as support ( s ) = support ( I ) , then h ( I ) = h ( s ) . Proof . Derived from Lemma 2 . The AC - Generator function works as follows . We (cid:12)rst apply the combinato - rial phase of Apriori - Gen [ 2 ] to the set of generators Gi in order to obtain a set of candidate ( i + 1 ) - generators : two generators of size i in Gi with the same (cid:12)rst i (cid:0) 1 items are joined , producing a new potential generator of size i + 1 ( step 1 to 4 ) . Then , the potential generators produced that will lead to useless com - putations ( infrequent closed itemsets ) or redundancies ( frequent closed itemsets already produced ) are pruned from Gi + 1 as follows . First , like in Apriori - Gen , Gi + 1 is pruned by removing every candidate ( i + 1 ) - generator c such that some i - subset of c is not in Gi ( step 8 and 9 ) . Using this strategy , we prune two kinds of itemsets : (cid:12)rst , all supersets of infrequent gener - ators ( that are also infrequent according to Property 2 ) ; second , all generators that have the same support as one of their subset and therefore have the same closure ( see Theorem 3 ) . Let ' s take an example . Suppose that the set of frequent closed itemsets G2 contains the generators AB ; AC . The AC - Generator function will create ABC = AB [ AC as a new potential generator in G3 and the (cid:12)rst pruning will remove ABC since BC = 2 G2 . Next , the supports of the remaining candidate generators in Gi + 1 are de - termined and , based on Property 2 , those with support less than minsup are deleted from Gi + 1 ( step 7 ) . The third pruning strategy works as follows . For each candidate generator c in Gi + 1 , we test if the support of one of its i - subsets s is equal to the sup - port of c . In that case , the closure of c will be equal to the closure of s ( see Corollary 3 ) , so we remove c from Gi + 1 ( step 10 to 13 ) . Let ' s give another example . Suppose that the (cid:12)nal set of generators G2 contains frequent gen - erators AB ; AC ; BC and their respective supports 3 ; 2 ; 3 . The AC - Generator function will create ABC = AB [ AC as a new potential generator in G3 and suppose it determines its support is 2 . The third prune step will remove ABC from G3 since support ( ABC ) = support ( AC ) . Indeed , we deduce that closure ( ABC ) = closure ( AC ) and the computation of the closure of ABC is use - less . For the optimization of the generator closure computation in Algorithm 1 , we determine the iteration at which the second prune suppressed a generator ( variable level ) . 4 . 5 AC - Closure Function The AC - Closure function takes the set of frequent generators G , for which clo - sures must be determined , as argument . It updates G with , for each generator p 2 G , the closed itemset p . closure obtained by applying the closure operator h to p . Algorithm 4 gives the pseudo - code of the function . The method used to compute closures is based on Proposition 1 . Algorithm 3 AC - Generator function 1 ) insert into Gi + 1 2 ) select p . item1 , p . item2 , : : : , p . itemi , q . itemi 3 ) from Gi p , Gi q 4 ) where p . item1 = q . item1 , : : : , p . itemi(cid:0)1 = q . itemi(cid:0)1 , p . itemi < q . itemi ; 5 ) forall candidate generators c 2 Gi + 1 do begin 6 ) forall i - subsets s of c do begin 7 ) if ( s = 2 Gi ) then delete c from Gi + 1 ; 8 ) end 9 ) end 10 ) Gi + 1 Support - Count ( Gi + 1 ) ; 11 ) forall candidate generators c 2 Gi + 1 do begin 12 ) if ( support ( c ) < minsup ) then delete c from Gi + 1 ; / / Pruning infrequent 13 ) else do begin 14 ) forall i - subsets s of c do begin 15 ) if ( support ( s ) = support ( c ) ) then begin 16 ) delete c from Gi + 1 ; 17 ) if ( level = 0 ) then level i ; / / Iteration number of the (cid:12)rst prune 18 ) endif 29 ) end 20 ) end 21 ) end 22 ) Answer S fc 2 Gi + 1g ; Proposition 1 . The closed itemset h ( I ) corresponding to the closure by h of the itemset I is the intersection of all objects in the database that contain I : h ( I ) = \ o2O ff ( fog ) j I (cid:18) f ( fog ) g Proof . We de(cid:12)ne H = T o2S f ( fog ) where S = fo 2 O j I (cid:18) f ( fog ) g . We have h ( I ) = f ( g ( I ) ) = T o2g ( I ) f ( fog ) = T o2S 0 f ( fog ) where S 0 = fo 2 O j o 2 g ( I ) g . Let ' s show that S 0 = S : I (cid:18) f ( fog ) ( ) o 2 g ( I ) o 2 g ( I ) ( ) I (cid:18) f ( g ( I ) ) (cid:18) f ( fog ) We conclude that S = S 0 , thus h ( I ) = H . Using Proposition 1 , only one database pass is necessary to compute the closures of the generators . The function works as follows . For each object o in D , the set Go is created ( step 2 ) . Go contains all generators in G that are subsets of the object itemset f ( fog ) . Then , for each generator p in Go , the associated closed itemset p . closure is updated ( step 3 to 6 ) . If the object o is the (cid:12)rst one containing the generator , p . closure is empty and the object itemset f ( fog ) is assigned to it ( step 4 ) . Otherwise , the intersection between p . closure and the object itemset gives the new p . closure ( step 5 ) . At the end , the function returns Algorithm 4 AC - Closure function 1 ) forall objects o 2 O do begin 2 ) Go Subset ( G . generator , f ( fog ) ) ; / / Generators that are subsets of f ( fog ) 3 ) forall generators p 2 Go do begin 4 ) if ( p . closure = ; ) then p . closure f ( fog ) ; 5 ) else p . closure p . closure \ f ( fog ) ; 6 ) end 7 ) end 8 ) Answer S fp 2 G j 69p 0 2 G ; closure ( p 0 ) = closure ( p ) g ; for each generator p in G , the closed itemset p . closure corresponding to the intersection of all objects containing p . 4 . 6 Example and Correctness Figure 2 gives the execution of A - Close for a minimum support of 2 ( 40 % ) on the data mining context D given in Figure 1 . First , the algorithm determines the set G1 of 1 - generators and their support ( step 1 and 2 ) , and the infrequent generator D is deleted form G1 ( step 3 to 5 ) . Then , generators in G2 are determined by applying the AC - Generator function to G1 ( step 8 ) : the 2 - generators are created by union of generators in G1 , their support is determined and the three pruning strategies are applied . Generators AC and BE are pruned since support ( AC ) = support ( A ) and support ( BE ) = support ( B ) , and the level variable is set to 2 . Calling AC - Generator with G2 produces 3 - generators in G3 . The only gen - erator created in G3 is ABE since only AB and AE have the same (cid:12)rst item . The three pruning strategies are applied and the second one removes ABE form G3 as BE = 2 G2 . Then , G3 is empty and the iterative construction of sets Gi terminates ( the loop in step 7 to 9 stops ) . The sets G and G 0 are constructed using the level variable ( step 10 and 11 ) : G is empty and G 0 contains generators from G1 and G2 . The closure function AC - Closure is applied to G 0 and the closures of all generators in G 0 are determined ( step 15 ) . Finally , duplicates closures are removed from G 0 by AC - Closure and the result is returned to the set FC which therefore contains AC , BE , C , ABCE and BCE , that are all frequent closed itemsets in D . Lemma 3 . For p (cid:18) I such as kpk > 1 , if p = 2 G kpk and support ( p ) (cid:21) minsup then 9s1 ; s2 (cid:18) I , s1 (cid:26) s2 (cid:18) p and ks1k = ks2k (cid:0) 1 such as h ( s1 ) = h ( s2 ) and s1 2 G ks1k . Proof . We show this using a recurrence . For kpk = 2 , we have p = s2 and 9s1 2 G1 j s1 (cid:26) s2 and support ( s1 ) = support ( s2 ) = ) h ( s1 ) = h ( s2 ) ( Lemma 3 is obvious ) . Then , supposing that Lemma 3 is true for kpk = i , let ' s show that it is true for kpk = i + 1 . Let p (cid:18) I j kpk = i + 1 and p = 2 G kpk . There are two possible cases : ( 1 ) 9p 0 (cid:26) p j kp 0 k = i and p 0 = 2 G kp 0 k ( 2 ) 9p 0 (cid:26) p j kp 0 k = i and p 0 2 G kp 0 k and support ( p ) = support ( p 0 ) = ) h ( p ) = Support - Count (cid:0) ! G1 Generator Support fAg 3 fBg 4 fCg 4 fDg 1 fEg 4 Pruning infrequent generators (cid:0) ! G1 Generator Support fAg 3 fBg 4 fCg 4 fEg 4 AC - Generator (cid:0) ! G2 Generator Support fABg 2 fACg 3 fAEg 2 fBCg 3 fBEg 4 fCEg 3 Pruning (cid:0) ! G2 Generator Support fABg 2 fAEg 2 fBCg 3 fCEg 3 AC - Closure (cid:0) ! G 0 Generator Closure Support fAg fACg 3 fBg fBEg 4 fCg fCg 4 fEg fBEg 4 fABg fABCEg 2 fAEg fABCEg 2 fBCg fBCEg 3 fCEg fBCEg 3 Pruning (cid:0) ! Answer : FC Closure Support fACg 3 fBEg 4 fCg 4 fABCEg 2 fBCEg 3 Fig . 2 . A - Close frequent closed itemset discovery for minsup = 2 ( 40 % ) h ( p 0 ) ( Lemma 2 ) If ( 1 ) then according to the recurrence hypothesis , 9s1 (cid:26) s2 (cid:18) p 0 (cid:26) p such as h ( s1 ) = h ( s2 ) and s1 2 G ks1k . If ( 2 ) then we identify s1 to p 0 and s2 to p . Theorem 3 . The A - Close algorithm generates all frequent closed itemsets . Proof . Using a recurrence , we show that 8p (cid:18) I j support ( p ) (cid:21) minsup we have h ( p ) 2 FC . We (cid:12)rst demonstrate the property for the 1 - itemsets : 8p (cid:18) I where kpk = 1 , if support ( p ) (cid:21) minsup then p 2 G1 ) h ( p ) 2 FC . Let ' s suppose that 8p (cid:18) I such as kpk = i we have h ( p ) 2 FC . We then demonstrate that 8p (cid:18) I where kpk = i + 1 we have h ( p ) 2 FC . If p 2 G kpk then h ( p ) 2 FC . Else , if p = 2 G kpk and according to Lemma 3 , we have : 9s1 (cid:26) s2 (cid:18) p j s1 2 G ks1k and h ( s1 ) = h ( s2 ) . Now h ( p ) = h ( s2 [ p (cid:0) s2 ) = h ( s1 [ p (cid:0) s2 ) and ks1 [ p (cid:0) s2k = i , therefore in conformity with the recurrence hypothesis we conclude that h ( s1 [ p (cid:0) s2 ) 2 FC and so h ( p ) 2 FC . 5 Experimental Results We implemented the Apriori and A - Close algorithms in C + + , both using the same pre(cid:12)x - tree structure that improves Apriori e(cid:14)ciency . Experiments were realized on a 43P240 bi - processor IBM Power - PC running AIX 4 . 1 . 5 with a CPU clock rate of 166 MHz , 1GB of main memory and a 9GB disk . Each execution uses only one processor ( the application was single - threaded ) and was allowed a maximum of 128MB . Test Data We used two kinds of datasets : synthetic data , that simulate market basket data , and census data , that are typical statistical data . The synthetic datasets were generated using the program described in [ 2 ] . The census data were extracted from the Kansas 1990 PUMS (cid:12)le ( Public Use Microdata Samples ) , in the same way as [ 5 ] for the PUMS (cid:12)le of Washington ( unavailable through Internet at the time of the experiments ) . Unlike in [ 5 ] though , we did not put an upper bound on the support , as this distorts each algorithm results in di(cid:11)erent ways . We therefore took smaller datasets containing the (cid:12)rst 10 , 000 persons . Parameter T10I4D100K T20I6D100K C20D10K C73D10K Average size of the objects 10 20 20 73 Total number of items 1000 1000 386 2178 Number of objects 100K 100K 10K 10K Average size of the maximal poten - 4 6 - - - tially frequent itemsets Table 2 . Notation Results on Synthetic Data Figure 3 shows the execution times of Apriori and A - Close on the datasets T10I4D100K and T20I6D100K . We can observe that both algorithms always give similar results except for executions with min - sup = 0 . 5 % and 0 . 33 % on T20I6D100 . This similitude comes from the fact that data are weakly correlated and sparse in such datasets . Hence , the sets of gener - ators in A - Close and frequent itemsets in Apriori are identical , and the closure mechanism does not help in jumping iterations . In the two cases where Apriori outperforms A - Close , there was in the 4 th iteration a generator that has been pruned because it had the same support as one of its subsets . As a consequence , A - Close determined closures of all generators with size greater or equal than 3 . Results on Census Data Experiments were conducted on the two census datasets using di(cid:11)erent minsup ranges to get meaningful response times and to accommodate with the memory space limit . Results for the C20D10K and C73D10K datasets are plotted on Figure 4 and 5 respectively . A - Close always sig - ni(cid:12)cantly outperforms Apriori , for execution times as well as number of database passes . Here , contrarily to the experiments on synthetic data , the di(cid:11)erences be - tween execution times can be measured in minutes for C20D10K and in hours for 0 5 10 15 20 25 30 35 40 2 % 1 . 5 % 1 % 0 . 75 % 0 . 5 % 0 . 33 % T i m e ( s e c ond s ) Minimum support A - CloseApriori Execution times on T10I4D100K 0 100 200 300 400 500 600 700 800 0 . 33 % 0 . 5 % 0 . 75 % 1 % 1 . 5 % 2 % T i m e ( s e c ond s ) Minimum support A - CloseApriori Execution times on T20I6D100K Fig . 3 . Performance of Apriori and A - Close on synthetic data C73D10K . It should furthermore be noted that Apriori could not be run for min - sup lower than 3 % on C20D10K and lower than 70 % on C73D10K as it exceeds the memory limit . Census datasets are typical of statistical databases : highly correlated and dense data . Many items being extremely popular , this leads to a huge number of frequent itemsets from which few are closed . Scale up Properties on Census Data We (cid:12)nally examined how Apriori and A - Close behave as the object size is increased in census data . The number of objects was (cid:12)xed to 10 , 000 and the minsup level was set to 10 % . The object size varied from 10 ( 281 total items ) up to 24 ( 408 total items ) . Apriori could not be run for higher object sizes . Results are shown in Figure 6 . We can see here that , the scale up properties of A - Close are far better than those of Apriori . 6 Conclusion We presented a new algorithm , called A - Close , for discovering frequent closed itemsets in large databases . This algorithm is based on the pruning of the closed itemset lattice instead of the itemset lattice , which is the commonly used ap - proach . This lattice being a sub - order of the itemset lattice , for many datasets , the number of itemsets considered will be signi(cid:12)cantly reduced . Given the set of frequent closed itemsets and their support , we showed that we can either de - duce all frequent itemsets , or construct a reduced set of valid association rules needless the search for frequent itemsets . We realized experiments in order to compare our approach to the itemset lattice exploration approach . We implemented A - Close and an optimized ver - sion of Apriori using pre(cid:12)x - trees . The choice of Apriori leads form the fact that , in practice , it remains one of the most general and powerful algorithms . Those experiments showed that A - Close is very e(cid:14)cient for mining dense and / or cor - related data ( such as statistical data ) : on such datasets , the number of itemsets considered and the number of database passes made are signi(cid:12)cantly reduced 0 500 1000 1500 2000 2500 3000 20 % 15 % 10 % 7 . 5 % 5 % 4 % 3 % T i m e ( s e c ond s ) Minimum support A - CloseApriori Execution times 10 11 12 13 14 15 16 3 % 4 % 5 % 7 . 5 % 10 % 15 % 20 % N u m be r o f pa ss e s Minimum support A - CloseApriori Number of database passes Fig . 4 . Performance of Apriori and A - Close on census data C20D10K 0 10000 20000 30000 40000 50000 60000 70 % 75 % 80 % 85 % 90 % T i m e ( s e c ond s ) Minimum support A - CloseApriori Execution times 10 12 14 16 18 70 % 75 % 80 % 85 % 90 % N u m be r o f pa ss e s Minimum support A - Close Apriori Number of database passes Fig . 5 . Performance of Apriori and A - Close on census data C73D10K 0 500 1000 1500 2000 2500 3000 3500 4000 10 12 14 16 18 20 22 24 T i m e ( s e c ond s ) Number of items per transaction A - CloseApriori Fig . 6 . Scale - up properties of Apriori and A - Close on census data compared to those Apriori needs . They also showed that A - Close leads to equiv - alent performances of the two algorithms for weakly correlated data ( such as synthetic data ) in which many generators are closed . This leads from the adap - tive characteristic of A - Close that consists in determining the (cid:12)rst iteration for which it is necessary to compute closures of generators . Such a way , we avoid A - Close many useless closure computations . We think these results are very interesting since dense and / or correlated data represent an important part of all existing data , and since mining such data is considered as very di(cid:14)cult . Statistical , text , biological and medical data are examples of such correlated data . Supermarket data are weakly correlated and quite sparse , but experimental results showed that mining such data is consider - ably less di(cid:14)cult than mining correlated data . In the (cid:12)rst case , executions take some minutes at most whereas in the second case , executions sometimes take several hours . Moreover , A - Close gives an e(cid:14)cient unsupervised classi(cid:12)cation technic : the closed itemset lattice of an order is dually isomorphic to the Dedekind - MacNeille completion of an order [ 7 ] , which is the smallest lattice associated with an order . The closest work is Ganter ' s algorithm [ 9 ] which works only in main memory . This feature is very interesting since unsupervised classi(cid:12)cation is another im - portant problem in data mining [ 6 ] and in machine learning . References 1 . R . Agrawal , T . Imielinski , and A . Swami . Mining association rules between sets of items in large databases . Proceedings of the ACM SIGMOD Int ' l Conference on Management of Data , pages 207 { 216 , May 1993 . 2 . R . Agrawal and R . Srikant . Fast algorithms for mining association rules . Proceed - ings of the 20th Int ' l Conference on Very Large Data Bases , pages 478 { 499 , June 1994 . Expanded version in IBM Research Report RJ9839 . 3 . R . J . Bayardo . E(cid:14)ciently mining long patterns from databases . Proceedings of the ACM SIGMOD Int ' l Conference on Management of Data , pages 85 { 93 , June 1998 . 4 . G . Birkho(cid:11) . Lattices theory . In Coll . Pub . XXV , volume 25 . American Mathemat - ical Society , 1967 . Third edition . 5 . S . Brin , R . Motwani , J . D . Ullman , and S . Tsur . Dynamic itemset counting and implication rules for market basket data . Proceedings of the ACM SIGMOD Int ' l Conference on Management of Data , pages 255 { 264 , May 1997 . 6 . M . - S . Chen , J . Han , and P . S . Yu . Data mining : An overview from a database perspective . IEEE Transactions on Knowledge and Data Engineering , 8 ( 6 ) : 866 { 883 , December 1996 . 7 . B . A . Davey and H . A . Priestley . Introduction to Lattices and Order . Cambridge University Press , 1994 . Fourth edition . 8 . V . Duquenne and L . - L . Guigues . Famille minimale d ' implication informatives r(cid:19)esultant d ' un tableau de donn(cid:19)ees binaires . Math . Sci . Hum . , 24 ( 95 ) : 5 { 18 , 1986 . 9 . B . Ganter and K . Reuter . Finding all closed sets : A general approach . In Order , pages 283 { 290 . Kluwer Academic Publishers , 1991 . 10 . D . Lin and Z . M . Kedem . Pincer - search : A new algorithm for discovering the max - imum frequent set . Proceedings of the 6th Int ' l Conference on Extending Database Technology , pages 105 { 119 , March 1998 . 11 . M . Luxenburger . Implications partielles dans un contexte . Math . Inf . Sci . Hum . , 29 ( 113 ) : 35 { 55 , 1991 . 12 . H . Mannila and H . Toivonen . Levelwise search and borders of theories in knowledge discovery . Data Mining and Knowledge Discovery , 1 ( 3 ) : 241 { 258 , 1997 . 13 . H . Mannila , H . Toivonen , and A . I . Verkamo . E(cid:14)cient algorithms for discovering association rules . Proceedings of the AAAI Workshop on Knowledge Discovery in Databases , pages 181 { 192 , July 1994 . 14 . A . M . Mueller . Fast sequential and parallel algorithms for association rules mining : A comparison . Technical report , Faculty of the Graduate School of The University of Maryland , 1995 . 15 . N . Pasquier , Y . Bastide , R . Taouil , and L . Lakhal . Pruning closed itemset lattices for association rules . Proceedings of the BDA French Conference on Advanced Databases , October 1998 . To appear . 16 . A . Savasere , E . Omiecinski , and S . Navathe . An e(cid:14)cient algorithm for mining association rules in larges databases . Proceedings of the 21th Int ' l Conference on Very Large Data Bases , pages 432 { 444 , September 1995 . 17 . H . Toivonen . Sampling large databases for association rules . Proceedings of the 22nd Int ' l Conference on Very Large Data Bases , pages 134 { 145 , September 1996 . 18 . H . Toivonen , M . Klemettinen , P . Ronkainen , K . Hatonen , and H . Mannila . Pruning and grouping discovered association rules . ECML - 95 Workshop on Statistics , Ma - chine Learning , and Knowledge Discovery in Databases , pages 47 { 52 , April 1995 . 19 . R . Wille . Concept lattices and conceptual knowledge systems . Computers and Mathematics with Applications , 23 : 493 { 515 , 1992 . 20 . M . J . Zaki , S . Parthasarathy , M . Ogihara , and W . Li . New algorithms for fast discovery of association rules . Proceedings of the 3rd Int ' l Conference on Knowledge Discovery in Databases , pages 283 { 286 , August 1997 .