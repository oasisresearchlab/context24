Intermedia : The ConceDt and the Construction of a Seamless Information Environment Nicole Yankelovich , Bernard J . Haan , Norman K . Meyrowitz , and Steven M . Drucker Brown University ntermedia , a tool designed to support both teaching and research in a uni - versity environment , contains multi - ple applications and mechanisms to link the contents of documents created with those applications . The system was devel - oped at Brown University’s Institute for Research in Information and Scholarship ( IRIS ) . A hypermedia system expressly devel - oped for use in a university setting , Intermedia provides a framework for object - oriented , direct manipulation edi - tors and applications . With it , instructors can construct exploratory environments for their students as well as use applica - tions for day - to - day work , research , and writing . Intermedia is also an environment in which programmers can develop consis - tent applications , using object - oriented programming techniques and reusable building blocks . Hypertext and hypermedia . Although only recently popularized by products like Apple’s Hypercard and Owl’s Guide , hypertext and hypermedia have been the subject of research , writing , and experimentation for more than 20 years . ( Examples of early hypertext systems and existing hypermedia systems may be found January 1988 This multi - application hypermedia system provides linking capabilities integrated into a desktop user environment . To promote consistency , the applications were built with an object - oriented framework . in Conklin’ and Yankelovich . ’ ) Interme - dia is a direct descendent of ideas devel - oped by such prominent researchers as Theodor Nelson , Douglas Engelbart , and Andries van Dam . Nelson coined the term hypertext in the early 1960s to describe the idea of “non - sequential writing . ” He 00l8 - 9162 / 8S / Ol00 - 0081 $ 01 . oO 01988 IEEE expanded on that theme in a book he wrote entitled Literary Machines . In essence , a hypertext system allows authors or groups of authors to link infor - mation together , create paths through a body of related material , annotate existing texts , and create notes that direct readers to either bibliographic data or the body of the referenced text . Using a computer - based hypertext system , students and researchers can quickly follow trails of footnotes and related materials without losing their original context ; thus , they are not obliged to search through library stacks to look up referenced books and articles . Explicit connections - links - allow readers to travel from one document to another , effectively automating the process of following references in an ency - clopedia . In addition , hypertext systems that support multiple users allow researchers , professors , and students to communicate and collaborate with one another within the context of a body of scholarly material . Hypermedia is simply an extension of hypertext that incorporates other media in addition to text . With a hypermedia sys - tem , authors can create a linked body of material that includes text , static graphics , animated graphics , video , and sound . 81 Intermedia : the concepts according to user - defined styles . Like a charting package , the display of the data is determined by a modifiable set of ent parameters for all types of data in the system . Related to the use of styles is the fre - parameters . Figure 1 illustrates an example of materials from a linked Intermedia corpus ( collection of documents ) called Context 32 : A Web of Englkh Literature , designed by Brown University English professor George Landow . Intermedia is both an author’s tool and a reader’s tool . The system , in fact , makes no distinction between types of users , provided they have appropriate access rights to the material they wish to edit , explore , or annotate . Creating new materials and making and following links are all integrated into a single seamless , multiuser environment . User interface . Several user - interface Applications . The system , which runs on a network of Unix - based workstations , currently contains five integrated applica - tions : a text editor ( InterText ) , agraphia editor ( InterDraw ) , a scanned image viewer ( Interpix ) , a three - dimensional object viewer ( InterSpect ) , and a timeline editor ( Interval ) . These applications con - form to Macintosh / Microsoft Windows interface standards . Any number of docu - ments of different types , along with the folders containing these documents , may be open on the desktop at one time . The InterText word processing applica - tion resembles Apple’s Macwrite , with the addition of style sheets for formatting rather than MacWrite style rulers . Using style sheets , the user can define a set of styles for a particular document ( such as paragraph , title , subtitle , indented quote , and numbered point ) and apply those styles to an entity - the text contained between two carriage returns . When the user edits the definition of a style , all the entities to which that style are applied reformat accordingly . With InterDraw , a structured graphics editor similar to Apple’s MacDraw , users can create two - dimensional illustrations by selecting tools from a palette attached to each InterDraw window . InterPix displays bit - map images entered into the system using a digitizing scanner . These images can be cropped , copied , and pasted into InterDraw documents . The InterSpect viewer converts files containing three - dimensional data points into three - dimensional representations of that data . Users can manipulate three - dimensional images of cells , for example , by rotating them , zooming in or out , or hiding parts of the model . The fifth application , Interval , pro - vides interactive editing features for creat - ing chronological timelines . As the user enters pairs of dates and labels , the appli - cation formats them on a vertical timeline concepts stressed throughout Intermedia enable users to learn new applications quickly and predict the behavior of fea - tures they have never used before . In a sys - tem that encourages rapid transitions between applications , it is essential to limit the amount a browser must learn in order to successfully use the system and capital - ize on those conventions with which he or she may be already familiar . Like the copy and paste operations in Macintosh and Smalltalk programs , some operations in the Intermedia system behave identically across all applications . The linking func - tionality described below is a prime example . All applications also provide direct manipulation interfaces . To change the displayed information , the user first selects one or more of the displayed objects and then issues a command through a key - board or menu interface . Likewise , other system features , while not exactly identi - cal to one another , are conceptually simi - lar . Most applications , for instance , allow users to control the format or the display characteristics of data . We designed the interface techniques for conceptually simi - lar operations to capitalize on the like - nesses . The style paradigm3 is one example . Styles are sets of properties or characteris - tics that govern the appearance of data within a document . Users can define or modify a style by editing a form called a style sheet ( sometimes referred to as a property sheet ) . Both the InterText appli - cation and the Interval application con - tain style sheets to specify different text formats such as paragraphs , indented quotes , lists , and titles , or different time - line formats such as the position of dates relative to tick marks and the position of labels relative to dates . In the graphics edi - tor , different styles may be applied to shapes such as line width , pen style , or fill style . By storing all presentation parameters in style sheets , you can substi - tute styles with the same name but differ - quent use of palettes - sets of controls attached as a pane to a document window . Along with style sheet dialogs , palettes provide a means for defining and applying styles . In InterText , for example , all the styles defined for a particular document are viewed in a style palette ( see Figure I ) . Two mouse clicks will change the style of an existing text entity or change the style from one style to another before beginning a new entity . With a large screen and the capacity for 30 or 40 open windows at one time , it is essential that all the tools needed for common operations be close at hand rather than in the pull - down menus . When not needed , all palettes can be hidden from view to unclutter the screen and improve the way material is presented to a person browsing through the system . The use of “infinite” undo and redo commands - made possible in a worksta - tion environment with virtual memory capabilities - provides another example of a standard user - interface concept that permeates the system . Instead of retract - ing only the last action performed , the user can incrementally undo the effects of all actions performed since the last time a document was saved . Any single action or set of actions the user has undone can then be incrementally redone . This capability fosters a sense of security in users and ena - bles them to experiment freely with their documents . Hypermedia functionality . In Interme - dia , the hypermedia functionality is inte - grated into each application so that the actions of creating and traversing links can be interspersed with the actions of creat - ing and editing documents . ( The screens in the “Sample session” illustrate the oper - ation of Intermedia , highlighting the hypermedia functionality . ) In an effort to fit the link - making pro - cess into a conceptual model already fa - miliar to users , the act of making links between Intermedia documents was modeled as closely as possible on the Smalltalk / Macintosh copy / paste para - digm4 If links are to be made frequently , they must be a seamless part of the user interface . In any document , users can specify a selection region and choose the Start Link command from the menu . In any other document , regardless of type , users can define another selection region and choose one of the Complete Link commands . 82 COMPUTER history ea ALEXANDER POPE 16as1m uellglon I - I Figure 1 . Two InterText documents ( top right ) , two Interval documents ( bottom left ) , and two InterDraw documents ( top left and bottom right ) open on the screen . Both InterDraw documents contain scanned images cropped , copied , and pasted from InterPix documents . Likewise , to follow a link , a user explor - ing a linked set of documents can select a marker icon in any type of document and choose the Follow command from a menu . As a short cut , a user can double - click on a marker icon to initiate the fol - low , just as he or she might double - click on an icon in a folder to open a document . Since following a link usually entails open - ing a document , we anticipated that users would expect to be able to follow a link by double - clicking on the marker icon . Unlike some other hypertext or hypermedia systems that only allow links to entire documents , ’ Intermedia allows users to create bidirectional links from a specific location in one document to a spe - cific location in another document . These “anchor points” in the documents are called blocks . One of our design goals , in designing the Intermedia linking function - ality , was to allow the user to designate any selection region as a block that might stand alone or serve as an anchor for one or more links . The size of a block , therefore , may range from an entire document to an inser - tion point , depending on the selection region a user identifies as the block’s extent . For example , in an InterText document , a block might consist of an insertion point , a single character , a word , or two para - graphs . Small marker icons placed near the source and destination blocks indicate the existence of a link . As a user edits a docu - ment , the blocks “stick” to the selection they are associated with , preserving the context of the concection . If a document containing links is deleted , the links to that document are also deleted ; however , the block markers at the other ends of the links remain intact , reminding users of the loca - tion of link anchors . To help manage a large corpus of linked documents , links and blocks are assigned descriptive properties . Some of these , like user I . D . and creation time , are assigned automatically , while other properties are user - defined . Users access and edit link and block property information through property sheet dialog boxes . These dialog boxes allow users to enter a one - line “explainer , ” similar to the subject field in an electronic mail message . Link explainers are particularly important from a reader’s perspective . If more than one link emanates from a single block , users choose the path they wish to follow from ( Continued on p . 90 ) January 1988 83 Sample session To illustrate Intermedia ' s user - interface features and linking function a I i t y , this si de bar w i I I take you on a system walkthrough designed to simulate the interac - tion that takes place during a hands - on lntermedia session . The screen illustrations should help you visualize the system , while the text should supply the action . The example is taken from Bio 106 : Cell Biology in Context , designed by Brown University biology professor Peter Heywood . Students in Heywood ' s plant cell biology course use Intermedia ' s editors , utilities , and linking func - tionality to write term papers and explore materials about the cell and its processes . The scenario will take you through a sample session from the perspective of the biology professor in the midst of creating course materials . Screen 1 . As you can see , the lntermedia desktop includes a window manager , a graphical folder system , a menu bar , and a mouse interface . The contents of the folders reflect the underlying hierarchical structure of the file system . dia does not store application icons in the same folders with documents . Instead , application icons are stored with several other special - purpose tools in an application , or New , window that you can see in the upper right cor - ner of the screen . The reason for this is twofold . First , users do not have to search through folders to find the applications . Even if the New window is hidden from view by overlapping windows , selecting the New command from the File menu will reveal it . Second , in a networked environment , it is best to have a single set of applica - tions in an agreed - upon place that can be maintained and updated by a system administrator . Unlike the Macintosh , Interme - Screen 1 Screen 2 84 _ _ Screen 3 Screen 4 1 P” Before we browse through the documents contained in the folders , follow links , or create them , we must first define a con - text by opening an existing web or by creating a new one . If a web is not open , we can still open and edit the documents even though no link and block information will be visible . Rather than beginning a new web , we select the icon titled “Bio 106” and choose the Open command ( not pictured ) from the File menu . Screen 2 . After opening the web , indicated by an empty local tracking map window ( described below ) , we open a folder con - tained in the “Bio” folder called “Simple Cell . ” The icons in this cell folder represent a folder plus a number of different types of documents ( one InterSpect , nine InterPix , two Interval , five InterDraw , and three InterText ) . Any of these document icons can be selected , opened , and edited . We select and double - click on the InterSpect document called “Micromonas 3D” to open it . Screen 3 . When the InterSpect document opens , the application displays the entire Micromonas cell in a three - dimensional view ( above left ) and a single section of the cell in a two - dimensional view ( below left ) . Students can use the tools in the palette to rotate the 3D reconstruction , to highlight the location of the 2D section cur - rently displayed in the bottom view , and to scroll through all the 2D sections associated with the cell . Menu commands allow you to selectively hide and display different components of the cell and / or the labels . The local tracking niap , empty in the previous screen , now shows the currently active document and the links that emanate from it . Local maps are analogous to detailed street maps . They show you your current location and what location you can travel to the immediate vicinity . As you January 1988 85 change locations , you require a new local map as a guide . In Intermedia , when the user acti - vates a different document , either by following a link or by opening one from a folder , the local map updates or tracks the user ' s prog - ress to display the new current document and its direct predeces - sor and successor links . Screen 4 . When we last worked on the Micromonas 3D document , we created a number of links con - necting the plasma membrane to five different InterDraw docu - ments , each containing a scanned photograph of one of the sections of the Micromonas cell used as data for the 3D reconstruction . Before we connect the plasma membrane to the remaining pho - tographs , we decide to connect the nucleus to general informa - tion about nuclei . The first step in creating a link involves defining a block to serve as the anchor for the link . We select the label " Nucleus " as the source block of the new link ( the selection is indi - cated by a rectangular box ) and choose the Start Link command from the menu . While a link is pending , we can perform any number of other actions unrelated to link - making . Like the Copy operation common to all Macintosh - like applications , the Start Link operation is completely modeless . Screen 5 . Before completing the pending link , we browse through the folders and locate and open an already existing InterText document called " Nucleus Outline . " Once the text is displayed , we select the word " nucleus " in the first sentence of the document to serve as the des - tination block of the link and choose Complete Relation from the menu . You will notice two different complete commands in the menu . These are similar in function , but each creates a different type of link . The Com - plete Relation command that we Screen 5 Screen 6 The Nudsus mrmbnnr htcnn * fth the pcrlpherd ImIna7 ConilLrthrc dlmcnilmd < . . - - / - - sb The b k u s b compared ol the % ear Malm ( W ) VIc ~ x ~ clcar Rvclopc ( NE ) . DNA , RNA , nucleolus Screen 7 ( The illustration of the nucleus was originally published in Molecular Biology of the Cell by Bruce Alberts et al . and is reprinted with the permission of Garland Publishing , Inc . ) . . . - . . " - - I - Screen 8 chose indicates a primary path , whereas the Complete Reference command signifies a secondary path , in much the same way as a footnote or a " see also . . . " refer - ence . Notice that the local track - ing map has been updated to show the links that emanate from " Nucleus Outline , " since it is the currently active document . Screen 6 . Once the link is established , both ends are indi - cated with markers ( arrows enclosed in rectangular boxes ) and the new link is added to the local tracking map . To find other relevant material to connect to the nucleus in the InterSpect docu - ment , we enlarge the lnteirext win - dow and read through the text . Since pores are important when studying simple cells such as the Micromonas cell , we select the link marker above the words " nuclear pores " and choose the Follow command from the menu to traverse the link . Screen 7 . Following the link causes an InterDraw document containing a diagram of the nucleus to open . Notice that when a link is traversed , Interme - dia automatically highlights the extent of the block at the other end of the link , indicating a partic - ular scope of information to the reader . In this case , our attention is drawn to the label " Nuclear pore " and its associated label line . The illustration on the screen was entered into the system using a scanner . The bit map was then displayed by the Interpix applica - tion , cropped , and pasted into this InterDraw document , and the text and lines were added to complete the diagram . Before we continue making new links , we decide to change the default " viewing specification " for link creation to " verbose " ( not pictured ) . With the verbose option , lntermedia automatically presents a property sheet for each new link as it is created . January 1988 87 Screen 8 . We activate the Inter - Spect document by clicking once in the window and select the nucleus . This time we decide to select the component itself rather than the label . When students fol - low the link from the InterDraw diagram to the three - dimensional representation , their attention will be drawn to the nucleus ( the source block ) in both the 2D and 3D views . As in Screen 4 , we select the Start Link command to initiate a new link . Screen 9 . Next , we reactivate the " Nucleus Diagram , " select the title of the diagram and the scanned illustration as the desti - nation block for the link , and choose Complete Relation from the menu ( not pictured ) . After we issue the complete command , a link property dialog box appears , allowing us to fill in descriptive information about the link . We replace the default text , " Link 35 , " with the more meaningful explainer shown in Screen 9 . Screen 10 . Now we will skip ahead a few steps . After creating the link from the nucleus in " Micromonas 3D " to the InterDraw diagram , we reactivated the Inter - Spect document and used the bottom tool in the palette to scroll to the next two - dimensional sec - tion . Since the label " Plasma Membrane " has already been defined as a block for another link , we decided to select the existing marker as the source point for our new link . Before we are ready to com - plete the link , we have to create a new document . We return to the " Simple Cell " folder , open an Interpix document ( bottom left ) containing a photograph that cor - responds to the section currently displayed in the InterSpect docu - ment window , and crop and copy a portion of the photograph into Screen 9 Screen 10 ( The electronmicrograph of Micromonas was originally published in The Journal of Phycology and is reprinted with the permission of the editor . ) Screen 11 u s u s n q B O n e e n n e e n n m B O Screen 12 the clipboard . We paste this image into a new InterDraw docu . ment , created by double - clicking on the draw icon in the New win - dow . Finally we add some text to accompany the photograph ( bot - tom right ) . Screen 11 . Here , we have com - pleted editing the new InterDraw document and have hidden the palettes to unclutter the screen . We have also completed the pend - ing link , using the text " Micromonas Electronmicrograph Section 6 " as the destination block of the link . After the link was established , we double - clicked on the marker associated with " Plasma Mem - brane " in the InterSpect docu - ment to traverse the new link . Since more than one link is associated with the selected block , lntermedia presents a dia - log box containing the explainers for each link . We select the link we just created and click on " OK . " Since the document at the other end of the link is already open on the screen , following the link will simply activate the docu - ment and highlight the extent of the destination block ( not pictured ) . Screen 12 . Before ending our session , we save and close the new InterDraw document , select its icon , and choose the Access Rights command from the menu . The dialog that appears allows us to add or subtract access rights for different groups of users . For this document , we decide to add Annotate rights for all users of the system . This means that any user may create links to or from the document but may not edit its content . Before exiting the sys - tem , we save and close the open InterSpect document and the Bio 106 web . January 1988 - 89 ( Continued from p . 83 ) a list of link explainers presented in a dia - log box . Property sheets also allow users to add keywords . Although still under develop - ment , these keywords , along with the default information assigned to links and blocks , will provide users with a mecha - nism for searching the document corpus . A keyword search will yield a list of explainers associated with all the blocks or links meeting the search criteria . Each item in the resultant list will be automatically linked to its corresponding block or , in the case of links , to the corresponding source block of each link . For example , a student could search for all links containing the keywords “Pope” and “Heroic Couplet” that were created by the professor after a certain date . Link and block properties help manage complexity within the Intermedia environ - ment , but the notion of context is even more crucial . In some systems , links are global - all links are available at all times to all users . In such systems , links become an integral part of the documents . In Intermedia , block and link information is not stored within individual documents but is superimposed on them . Webs main - tain the block and link information , allow - ing one or more users to work within their own context undistracted by blocks and links created by others sharing the same computing resources . Most importantly , users do not see hypermedia as an alterna - tive to their desktop environment ; rather , they see it as an integral technique tying together documents in that environment . Currently , opening a web imposes a par - ticular set of blocks and links on a set of documents while that web is open . Thus , webs allow different users to impose their own links on the same document set . Although only one context can be viewed at a time , users can easily switch contexts by closing one web and opening another . In the future , webs will also serve as the focus for keyword searching operations . Intermedia differs from most other hypermedia systems in that it allows mul - tiple users to both follow and create links concurrently in the same web . Intermedia incorporates a system of user access rights that helps manage multiple users sharing large bodies of connected material . Due to the hypermedia functionality of Interme - dia , the access rights scheme builds on the protection mechanisms offered in most file systems where users either have “read” permission or “write” permission to files and directories . Intermedia adds “anno - tation” permission to the other two forms of access rights . This allows users to add links to a document that they are not allowed to edit . Intermedia : the construction Intermedia not only provides a rich environment for authors and browsers but also for developers , furnishing a set of tools that facilitate the creation of new applications adhering to the Intermedia paradigms . In designing the Intermedia system , we believed that consistency among applica - tions was crucial , since the system encourages quick transitions from one application to another . User - interface consistency is not always easy to achieve , however . s In part , this may result from carelessness . But , more often , interface inconsistencies result from not quite iden - tical implementations of features already implemented elsewhere in a system . The Apple Macintosh represents a prime exam - ple . The system has clearly defined user - interface paradigms , and new programs almost always use a number of the same functions that exist in hundreds of other Macintosh programs . Even so , software developers must reimplement most of the “standards” ( selection , resizing , dragging , etc . ) from scratch because the Macintosh Toolbox provides the mechanisms for building them but not the implementa - tions . Often these programmers miss an important feature or user - interface detail that users immediately notice . To build Intermedia , we needed a devel - opment environment that would help programmers create a multiuser system with consistent , direct - manipulation appli - cations , plus the ability to link together the contents of documents created with those applications . Faced with the task of developing a relatively large , interactive system in an ambitiously short timeframe , we needed a set of development tools that would help us remove the burden of user - interface consistency from the application pro - grammer adopt an existing user - interface standard allow small groups of programmers to work on different parts of the sys - tem in parallel facilitate the integration of modules developed by different groups avoid as much duplication of effort as 90 possible , and create a system that would be exten - sible and suitable for prototyping new applications . We created such an environment by building some of the pieces ourselves and adapting and integrating tools developed by others . This resulted in a layered set of tools that allows programmers to develop applications conforming to the user - interface standards . In particular , we started with CadMac , Cadmus Computer’s implementation of the Macintosh toolbox under the 4 . 2 BSD Unix operating system ; supplemented it with an object - oriented programming lan - guage called Inheritance C ( developed at Bolt Beranek and Newman ) ; and added a C version of Apple’s MacApp - a set of classes for creating “generic” Macintosh - like applications . On this , we superim - posed several crucial building blocks from which any number of end - user applica - tions and utilities can be constructed . The Proceedings of the I986 Conference on Object - Oriented Programming Systems , Languages , and Applications ( OOPSLA ) 6 provides a detailed technical description of the architecture of the development envi - ronment that we summarize below . Object - oriented programming . The technique of object - oriented program - ming has gained a great deal of recognition as a superior approach to programming tasks . Studies have shown significant reductions in both development time and size of source code when such techniques were used , ’ with a significant increase in the amount of reusable code . One criticism of programs written using object - oriented programming techniques is that they tend to be slower than comparable conven - tional programs . First , much of this view relates to historical speed problems in early versions of Smalltalk where object - oriented code was interpreted rather than compiled . With the advent of object - oriented compilers and optimization tech - niques , speed is no longer an insurmount - able problem . Second , if you use an appropriate object - oriented system , ’ you can carefully write and optimize reusable chunks of code . We selected an object - oriented pro - gramming language for the Intermedia project partly because of the reduction in development time it promised , but mostly for the benefits it affords to a group - development effort . A team of developers can agree on a shared set of parent classes and their corresponding abstract methods . COMPUTER The use of abstract methods - or templates - clarifies the behaviors an application programmer must implement . Then , working individually , the developers can create appropriate subclasses - defining one class of objects in terms of other classes - that will respond to a single set of messages and that can be easily integrated into one program . When a programming task is divided , one mem - ber of the team can implement the code that will coordinate the sending of mes - sages to objects while the other members of the team work on defining and refining the object classes . The applications framework . While an object - oriented programming language provides a number of features that facili - tate team efforts , supplementing those fea - tures with a set of classes that define common behaviors - an applications framework - insures a greater degree of user - interface consistency in the system under development . Our choice , Apple’s MacApp , represents such a companion to an object - oriented programming language and pro - vides a framework for constructing Macintosh application ^ . ' . ' ^ MacApp defines classes with a combination of abstract and nonabstract methods that encapsulate the behavior of the Macintosh user interface . A tiny program ( on the order of 10 to 20 lines ) bound with MacApp suffices to create a skeletal Macintosh - like application with menus ; blank windows that can bemoved , resized , and scrolled ; data that can be stored and Review of object - oriented programming principles Not surprisingly , the fundamental notion in object - oriented programming is that of objects . An object - oriented program is a system of interacting objects . Objects encapsulate data and the algorithms that specify the behavior of that data . Opera tions on an object can take place only through a well - defined interface to the object’s behavior ; the actual implementation of the behavior is hidden from everyone but the designer . The data structure components of an object are known as its fields or slots . The routines that can act upon an object of a particular type are called methods . These methods are the primary means through which the fields within an object may be manipulated or modified . Other objects invoke an object’s method by sending a message to the object . Then , the object interprets the message and the appropriate method is per - formed . Classes ( also known as object types ) are templates defined by programmers that describe the properties and behaviors of a set of common objects . An object is actually an instance of a class template , typically created as a program is running . Each object is a copy of the class template . Thus , each object has the same number and types of fields , and only differs from other objects in the class in the data in those fields . All objects in a class share the same methods , typically by point - ing to a common method table or dictionary . While class tem - plates provide a basis for modularity , subclassing - the ability to define one class of objects in terms of other classes - is one of the object - oriented programming concepts from which much leverage is gained . tor classes . An object in a subclass contains all the same field types and methods as an object in the parent class . In defining a subclass , a programmer can add fields and methods or redefine methods that one of its superclasses originally implemented . A redefined method can implement a behavior completely different from the original method , or it can merely slightly modify or extend the behavior of its parent . Refining , or overriding , a method of a class makes it possi - ble to considerably reduce the amount of code that an appli - cation programmer needs to write ; the only code necessary is that which explains how a method differs from the parent method . The programmer is guaranteed that the methods he or she did not override will respond properly to any messages sent to the object . This process of redefining and extending a class of objects in terms of another class is important Subclasses inherit the characteristics of higher - level ances - because it enables programmers to use and modify existing parts of a system without having to understand the details of their implementation . objects that are instances of this class will have two Point fields ( the topleft and the bottom - right corners of the rectan - gle ) . The class will have methods for calculating area and drawing the rectangle . If we wish to draw a rectangle on the screen , we first create a Rectangle object and then send a message to invoke the Draw method . To create a more special - ized object that draws a rectangle and prints text inside the rectangle , we would define a subclass of Rectangle , called TextRect . No existing code has to be rewritten . Instead , in the definition of the TextRect class we can add a character string field , override the Draw method inherited from the parent class , refine its behavior to do what its parent did , and draw the text . Like Rectangle objects , TextRect objects will respond to FindArea messages , even though we did not add any code for calculating area in the TextRect class . In the above example , the Rectangle class served as a tem - plate for the subclass TextRect . However , it often helps to define less specific templates than the Rectangle class . For instance , a parent class of Rectangle called Shape might have been created with two abstract methods , Draw and FindArea . An abstract method contains no code ; it exists only for the purpose of being overridden . To create a new shape , a pro - grammer would subclass Shape , add appropriate fields , and override the Draw and FindArea methods . Likewise , a program that displays many different shapes on the screen might contain a list defined to point to objects of class Shape or any subclass of Shape . Each object in the list inherits the Draw method from the Shape superclass , but has overridden it with code appropriate for drawing the specific object . Since all shapes are guaranteed to understand the same message protocol , we can display a whole screenful of shapes by merely sending the same draw message to each object in the list without knowing exactly what type of shape objects are in the list . Objects descending from the same parent class are essen - tially “plug compatible ; ” each understands the same mes - sages as the others , yet each performs the task in its own way . This modularity allows the transparent creation and insertion of new subclasses into the program . For example , say we define a class called Rectangle . All the January 1988 91 retrieved ; and views that can be automat - ically laser printed . This default program , however , has a blank view . To write an application with views that render some - thing in the windows , the programmer must subclass several base classes provided by MacApp . The most important of these classes are The Object class , which manages the freeing of memory and the cloning of new objects . It is the parent of all other classes . The Application class , which contains methods for launching an applica - tion , displaying the menu bar , managing the main event loop , and creating and initializing appropriate document objects . The Document class , which main - tains the data model for the program . Document objects contain all the basic information for saving and restoring the data and managing several other objects - such as Win - dow objects , Frame objects , and View objects - involved in viewing the information contained in the document . The Window class , which manages all the operations pertaining to windows , including opening , closing , resizing , moving , activating , and redrawing . The View class , which manages the rendering of the data contained in the document and passes on mouse events to the appropriate objects within the view . The Command class , which is the template from which command objects are generated to respond to outside actions from the menu , the mouse , or the keyboard . Since com - mand objects can be maintained on a stack , multilevel undo and redo are easily implemented . By subclassing these and other MacApp classes , a programmer builds a model for the data in an application , creates the win - dows and frames in which the information will be viewed , and describes how the user can interact with that information . The Application class has perhaps the greatest impact on the developer . This class contains the methods necessary for an application’s most basic behavior . For example , it includes methods for launch - ing an application , running the main event loop , dispatching events to the appropri - ate event handler , and creating , closing , and deleting documents . In the case of a user selecting a command from a menu , IItvo building blocks were initially implemented . Later , it was discovered a third building block was needed . the Application object interprets the mouse press and sends a message to the currently selected object’s DoMenuCom - mand method . A programmer does not have to consider flow - of - control issues since an Application object handles all user - initiated events , such as mouse presses , keystrokes , and menu selections , and dispatches those events to the appro - priate target object . As an applications framework , MacApp promotes consistency in a multi - application environment by eliminating the need for programmers to reimplement any of the user - interface features required for the shell of a Macintosh - like applica - tion . The framework insures that each application will have windows , menus , dialog boxes , and other basic components that look and behave the same way as all others in the system . Building blocks . While object - oriented programming provides the structure and methodology for cooperative develop - ment , and MacApp provides a set of base classes from which to build an application , these two components alone are not enough to create a fully functional devel - opment environment for a group of cooperative developers . Still missing is a component that helps developers render and manipulate the data for their particular application . To this end , we have implemented several build - ing blocks - sets of reusable classes that implement basic functions common to multiple applications . The philosophy behind the building blocks is that they should encapsulate important end - user functionality - both input and output components - and pro - vide both a user interface and a program - mer interface . Instances of these building blocks can be incorporated directly into an application ; the application programmer can use part or all of a building block’s functionality as it exists or modify the functionality to suit a specific application . To support the development of applica - tions within Intermedia , we initially imple - mented two building blocks - a Text Building Block and a Graphics Building Block - and later found the need f Jr a third - a Table Building Block . The Text Building Block permits the inclusion of text anywhere within an appli - cation . It makes it possible to provide exactly the same interface for displaying , editing , and formatting multifont text throughout the system . An entire applica - tion , such as a text editor , or some part of an application , such as the input field of a palette , can be based on the Text Build - ing Block . Just as the Text Building Block allows the inclusion of text anywhere within an application , the Table Building Block facilitates the incorporation of tabular data . A programmer can use the Table Building Block as the backbone of a spreadsheet program or a database inter - face , or to integrate one or more tables into any other type of application . For exam - ple , Release 3 . 0 of Intermedia will include a videodisc application with tables for storing data such as frame numbers , sequence names , and playing times of video images . The Graphics Building Block ( GBB ) lets programmers incorporate graphics , such as lines , rectangles , circles , icons , and polygons , into their applications . This building block defines a number of shape classes with methods for drawing , high - lighting , selecting , resizing , and moving . The GBB also subclasses MacApp’s View class so that the subclassed graphics GView contains a list of all objects to be rendered on the screen . To illustrate how building blocks are used in general , we will focus on the GBB . Programmers can take advantage of a building block such as the GBB in one of four ways . First , a programmer can use the building block functionality in its entirety . For example , to create a structured graphics editor similar to Apple’s Mac - Draw in which users can draw a variety of different shapes on the screen , rearrange them , group them , and perform various other editing operations , a programmer could use most of the GBB’s shape classes , subclassing where necessary , and then add application - specific user - interface features such as alignment , tool palettes , and style palettes . In the second case , a programmer can eliminate functions inherited from a build - 92 COMPUTER ing block . For example , one method associated with polygon objects in the GBB allows users to move polygons by clicking on them and dragging . In Inter - Spect , data files - not users - govern the placement of each polygon relative to other polygons in a three - dimensional object , so the developers override GPoly - gon’s Move method to eliminate the drag - ging functionality . In all other respects , polygons behave in InterSpect as defined in the GBB . Third , you can override methods to add increased functionality to building block classes . The use of icons in Intermedia’s desktop application illustrates the addition of functionality to a building block’s method . The desktop application sub - classes GBB icons - simple bit maps - and overrides the Draw method so that a text string , representing a document’s name , always appears below the icon ( see Screen 1 in the sidebar , “Sample session” ) . In the fourth case , a programmer can override methods to change the behavior of building block classes . An example in InterSpect clearly illustrates this . To indi - cate that an object has been selected , the GBB uses “handles” to indicate highlight - ing . In InterSpect , however , the GBB’s GSelection method is overridden to substi - tute bold outlines as a highlighting method . With these four options available , appli - cation developers have enough flexibility to create innovative interfaces , but are not burdened with the implementation of functions that should behave identically across applications . The building blocks complement MacApp by providing a means of achieving internal as well as external consistency among applications . Adding shared functionality . By using the tools described above - an object - oriented programming language , MacApp , and building blocks - a pro - grammer could create applications that adhere to the Macintosh - style user - interface paradigms . In our requirements for Intermedia , however , we identified the need to run multiple applications on the desktop as well as the need to link the con - tents of documents together . These two requirements made it necessary for us to extend , and in some cases alter , the exist - ing Macintosh user - interface paradigms . To this end , we kept MacApp as the first layer of our system and then subclassed most of the MacApp classes to create an Intermedia layer . The way the Intermedia layer extends the functionality of MacApp Running multiple desktop applications and linking document contents were identified as requirements . illustrates the ease with which features shared by many applications can be imple - mented using our object - oriented develop - ment base . Briefly , the type of additional function - ality the Intermedia layer supports includes the creation of links between a selection in a source document and a selec - tion in a destination document . To attain the desired consistency , the Intermedia layer subclasses MacApp’s Document , View , and Application classes . In MacApp , the Document class manages the reading and writing of an application’s data model while the View class manages the rendering of that model . IntDoc and IntView , the Intermedia layer’s document and view classes , extend the MacApp func - tionality to include the reading and writ - ing of link information to a relational database and the rendering of the links . The Intermedia layer’s application class , IntAppl , adds the functionality necessary to interface with Intermedia’s folder system . Like MacApp , the Intermedia applica - tion framework “calls” the applications through the use of abstract methods . By defining an abstract method , the frame - work indicates to the application developers that it is the responsibility of a building block or an application to provide a concrete implementation of that method . For example , IntView provides abstract methods for displaying block markers concretely implemented by the various building blocks . The linking functionality is imple - mented largely in the Block class that exists at the Intermedia layer and inherits from MacApp’s Object class . Since there must be a block at either end of a link , blocks are created each time a link is made , unless the user attaches one end of the link to an already existing block . A Block object keeps track of all links that emanate from it by pointing to a Link Array object that , in turn , points to the appropriate Link objects . Therefore , users can access a link through a block to follow the link or view its properties . The methods of the Blocks include ones for starting links , completing links , fol - lowing links , viewing properties , and several others . Certain appropriate menu items become available when a BlockMar - ker is selected . The menu items for show - ing the extent of the block , starting a link , deleting the block , and viewing the block properties are enabled if the block to which the Block object points has no links . If that Block has at least one link , all of the previ - ously mentioned options are available , along with following , viewing of link properties , and deleting the link . All of these actions are done using Block methods that themselves may use fields as well as methods of the associated Link objects . This portion of the linking functional - ity is shared in its entirety by all Interme - dia applications , leaving only a few details for the developer to implement in order to integrate linking into a new application . With a non - object - oriented development base , each application programmer would have been forced to identify and call proce - dures from appropriate subroutine librar - ies for saving , restoring , creating , deleting , and viewing links , and to do all this in the appropriate order with the correct parameters . Using the Intermedia layer augmenting MacApp , the applications framework essentially alerts the program - mer , who must implement only those methods that are specific to his or her application . All other functionality is shared as standard fare by all developers . Larry Rosenstein of Apple Computer has whimsically labelled this a “don’t call us , we’ll call you” programming meth - odology . Building an application . While the Block methods in the Intermedia layer handle the core of the linking functional - ity , the methods of the individual applica - tion’s View objects handle the way blocks are displayed in different applications . The display methods include the creation and display of marker icons , scrolling to a block after a follow , and highlighting the extent of a block . In the GBB , these methods , defined at the Intermedia layer as abstract methods of IntView , are imple - mented in the subclass GView . An appli - cation that , in turn , subclasses GView inherits a whole hierarchy of functional - ity , part of which includes the display of January 1988 93 P i - I - - Gnphlcm Bulldlnv Block Lmyu Figure 2 . Inheritance hierarchy for the InterSpect unit . blocks ( see Figure 2 ) . The application developer then subclasses GView and the associated GObject , and uses the Dialog , Control , List , and other classes to create a customized application . Every application added to the Interme - dia environment has a number of features , like zooming and rotation in InterSpect , that differ from functions implemented at the MacApp , Intermedia , or building block layers . In this case , the programmer creates new objects that are simply sub - classes of MacApp’s generic Command or Object classes . While the development tools do not directly simplify the imple - mentation of these features , general object - oriented techniques help structure the thinking of programmers about their applicati Jn - specific problems . Developing in parallel . When building applications such as InterSpect in parallel with other applications that run in the same environment , we initially consider each application as a separate entity . Programmers build and debug their pro - grams as independent applications , each taking advantage of the inheritance hier - archy provided by the development tools . The extreme modularity of the object - oriented environment makes it possible to take applications developed separately and , without requiring recompilation , integrate them into a single system . For application integration , the Intermedia system contains a Framework application . When programmers develop an application , they compile the code for each application object separately from the code for all other objects . The com - piled code minus the application object is called a unit . For example , InterSpect has an application object , called SpectAppl , that is a subclass of the Intermedia layer’s application object , IntAppl . The Spect - Appl object contains a method called DoMakeDocument exclusively for creat - ing InterSpect document objects . To test InterSpect , the programmer binds the InterSpect unit to the SpectAppl object . When ready to integrate InterSpect into 94 COMPUTER the Intermedia system , the programmer instead relies on the framework’s applica - tion object ( FrameworkAppl , also a sub - class of IntAppl ) , which contains a DoMakeDocument method for creating not just InterSpect documents , but many different document types . When integrat - ing InterSpect into the Intermedia system , the programmer adds InterSpect to the list of document types specified in Framework - Appl’s DoMakeDocument method and then binds InterSpect and all other appli - cation units with the FrameworkAppl object rather than the SpectAppl object , without ever having to recompile the Inter - Spect unit . The capability to reuse the same units without recompilation for independent testing and for creating an integrated sys - tem was instrumental in the success of our parallel development effort . Developers could work on their portions of the proj - ect independently , knowing that the effort of integration would be minimal as long as they worked within the structure provided by the building block and the Intermedia application framework . In particular , developers could count on inheriting all the linking functionality as soon as their application was bound and run with the FrameworkAppl object . Measuring success The concept . To assess the power and utility of hypermedia , IRIS is conducting a series of experiments at Brown that intro - duce Intermedia into existing courses and work settings . To date , Intermedia - based materials and applications have been used in a plant cell biology course and an Eng - lish literature course involving about eight users who might be classified as authors and 80 students who primarily used the system as browsers ( although many experimented with creating their own documents ) . As evidence that users appreciated the multiple applications provided by the Intermedia framework , two substantial linked bodies of material ( approximately 850 English - related documents and 200 biology - related documents ) were created that included documents of all available types . Authors and browsers alike learned to use the system with almost no training . Even though experienced Macintosh users learned more quickly than others , no user required more than a week or two to feel comfortable using Intermedia and all its available applications . The approximately 3 , 000 links created by the eight authors seems to indicate that link - making as well as link - following posed little or no diffi - culty to the users . Although there is no empirical evidence to show that con - sistency among applications is related to ease of use , we believe it is a strong factor . In fact , we believe the consistent applica - tion framework with seamless inclusion of linking allows users to ponder new appli - cations , taking for granted that linking will be incorporated into those applications as a standard feature . An examination of the course materials created by the instructors in this study indi - cated that each used Intermedia success - fully ( measured by a substantial increase in the critical thinking skills of the students” ) , despite the fact that each instructor used the system in a fundamen - tally different way . We believe this study points to the potential value of multiuser hypermedia systems across a wide range of academic disciplines . The construction . With the generic MacApp layer , the Intermedia layer , and three crucial building blocks in place , we can now build and integrate new applica - tions into the Intermedia environment in a matter of weeks . By systematically implementing abstract methods and over - riding other methods found in layers above the application layer , developers can cre - ate applications guaranteed to have com - mon functionality consistent with all other applications . While it is , of course , possi - ble to institute inconsistencies , it takes more effort to be inconsistent than con - sistent . We can directly attribute the successful and rapid development of the Intermedia environment to object - oriented program - ming techniques . These techniques , in combination with other factors , enabled us to attain each of our goals for the proj - ect . We were able to remove the burden of user - interface consistency from the appli - cation developer , adopt an existing user - interface definition , allow groups of programmers to work in parallel , integrate separate modules without recompilation , avoid considerable duplication of effort , and create anextensible system suitable for the rapid development of new applica - tions . The Proceedings of OOPSLA 866 provides a more detailed description of the specific measures we used as a basis for these conclusions . Despite the substantial benefits of our development base , as with every system , we encountered problems and drawbacks . Our most serious problem stemmed from working in an extremely layered environ - ment . Although inheritance certainly saves programmers an enormous amount of work , it can prove quite time - consuming in an environment that does not support incremental compilation . When working with a Unix system using the C program - ming language and an object - oriented preprocessor , changes in one layer are not automatically propagated to other lower - level layers . In our case , when we changed fields and methods in a parent class such as IntView , we had to recompile all layers inheriting from that class . These often required 45 minutes or longer . Although we attempted to minimize the number of recompilations , they were often unavoid - able during the period we worked on all layers of the system simultaneously . We did manage to structure the working envi - ronment so the recompilations would not prevent other people from working , but this scheme added the expense of keeping duplicate copies of the source code and producing new releases of the system every week . Even though we used a source code control system to facilitate release track - ing , we still had to be extremely careful to include the most up - to - date versions of every layer in each release . hrough the use of abstract methods , object - oriented pro - T gramming provided us with a concrete structure that could be shared by each of the applications in the system . With object - oriented programming and MacApp , we could structure the whole system in such a way that each part could be worked on independently with the guar - antee that integration would be easily accomplished and common functions would behave identically in each of the applications . As we look toward the future , we plan to expand Intermedia , both from a user’s and a programmer’s point of view . Devel - opment of new applications and system features are under way to provide links to and from video and audio , more complex filtering and information retrieval , better visualizations of connections between documents , and support for capturing and replaying paths through a web . On the development side , we plan to implement building blocks for handling controls such as sliders and scrollbars , for abstracting menus , for providing MIDI music record - ing and replay , and for providing more sophisticated text - editing features . More January 1988 95 ‘importantly , we hope to persuade the soft - ware development community that ( 1 ) application development will be most fruitful when that community at large embraces object - oriented building blocks and frameworks and ( 2 ) hypermedia will only be readily accessible when a common linking protocol is adhered to by all third - party software creators . 0 Acknowledgments Intermedia is the culmination of two years of intense effort by a large team of developers led by Norman Meyrowitz . We would like to thank Tim Catlin , Helen DeAndrade , Page Elmore , Charlie Evett , Matt Evett , Nan Garrett , Allan Gold , Ed Grossman , Karen Smith , Tom Stam - baugh , Ken Utting , Dave Bundy , Dan Stone , Steve Williams , Bill Shipp , Marty Michel , and Andy van Dam for their tireless contributions to developing the system . We would also like to thank Peter Heywood , Scott Buchanon , and Chris Scott for the many hours they spent con - structing the biology materials , and George Landow , David Cody , Glenn Everett , Rob Sul - livan , Katherine Stockton , and Suzanne Keen Morley for producing the enormous corpus , Context 32 : A Web of English Literature . The work described in this paper was spon - sored in part by a joint study contract with IBM , a grant from the Annenberg / CPB Project , and a research agreement with Apple Computer . VICE PRESIDENT FOR 1 Adelphi University a Vice President for Information vsystemsandehnology ; establishment of policy and guidance of operations for educa - t i l technology and computing . High pr ! ority will be given to acadermcneedswithemphaslson enhancement d faculty and stu - dent utiliition . References 1 . J . Conklin , “Hypertext : An Introduction and Survey , ” Computer , Sept . 1987 , pp . 17 - 41 . 2 . N . Yankelovich , M . Meyrowitz , and A . van Dam , “Reading and Writing the Electronic Book , ” Computer , Oct . 1985 , pp . 15 - 30 . 3 . D . C . Smith et al . , “Designing the Star User Interface , ” Byte , Byte Publications Inc . , Apr . 1982 , pp . 243 - 281 . 4 . A . Goldberg , Smalltalk - 80 : The Interactive Programming Environment , Addison - Wesley Publishing Co . Inc . , Reading , Mass . , 1984 . 5 . B . Shneiderman , Designing the User Inter - face : Strategies for Effective Human - Computer Interaction , Addison - Wesley Publishing Co . , Inc . , Reading , Mass . , 1987 . 6 . N . Meyrowitz , “Intermedia : The Architec - ture and Construction of an Object - Oriented Hypermedia System and Applica - tions Framework , ” Proc . OOPSLA 86 , Sept . , 1986 , pp . 186 - 201 . 7 . B . Cox , “Message / Object Programming : An Evolutionary Change in Programming Technology , ’ ’ IEEE So f f ware , Jan . 1984 , pp . 50 - 61 . 8 . B . Stroustrup , The C + + Programming Language , Addison - Wesley Publishing Co . , Inc . , Reading , Mass . , 1986 . 9 . K . Schmucker , Objeet - OrientedProgram - ming for thekfacintosh , Hayden Book Co . , Hasbrouck Heights , N . J . , 1986 . 10 . L . Tesler , “An Introduction to MacApp 0 . 1 , ” Apple Computer , Inc . , Cupertino , Calif . , Feb . 14 , 1985 . 11 . W . O . Beeman et al . , Intermedia : A Case Study of Innovation in Higher Education , assessment report prepared for the Annen - berg / Corp . for Public Broadcasting Proj - ect , Oct . 1987 . Nicole Yankelovich , a founding member of Brown University’s Institute for Research in Information and Scholarship ( IRIS ) , is project coordinator at the Institute . She is responsible for overseeing a number of projects , including experiments to introduce Intermedia into Brown University courses . She has participated in the design and development of Intermedia from its inception , contributing most heavily to the user - interface specifications . Yankelovich holds the BA degree from Brown University in political science and is a member of the Computer Society of the IEEE , the ACM , and a number of educational com - puting organizations . Readers may write to the authors at IRIS , PO Box 1946 , Brown University , Providence , RI 02912 . Bernard J . Haan , a research software engineer at the Institute for Research in Information and Scholarship at Brown University , is one of the original members of the Intermedia project team . As project leader of the programming team developing Intermedia’s linking capabil - ities , he has been involved in all phases of the program’s development , from design to imple - mentation . Haan is agraduate of Brown University , with degrees in computer science and French litera - ture . He is a member of the ACM . Norman K . Meyrowitz , associate director of the Institute for Research in Information and Scholarship at Brown University , has directed the Institute’s hypertext and multimedia research program since he helped found IRIS in 1983 . Most recently , Meyrowitz has managed and has been the principal architect of the Intermedia project . His major research interests are in the areas of multimedia documents , text processing , user - interface design , and object - oriented programming . Meyrowitz graduated from Brown University in 1981 with a degree in computer science . He is a member of the Computer Society of the IEEE , the ACM , and Sigma Xi . Steven M . Drucker is a PhD candidate in the Brain and Cognitive Sciences Dept . at the Mas - sachussetts Institute of Technology , studying robotics , tactile sensing , and machine learning as a Poitras fellow at MIT’s Whitaker College . Previously , he spent two years at the Institute for Research in Information and Scholarship at Brown University , working first on an Interme - dia prototype and later on the framework for the current version of Intermedia . Drucker received the ScB in neurosciences , summa cum laude , from Brown University . COMPUTER