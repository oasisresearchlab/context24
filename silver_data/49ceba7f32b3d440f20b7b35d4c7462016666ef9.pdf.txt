So Who Won ? Dynamic Max Discovery with the Crowd Stephen Guo Stanford University Stanford , CA , USA sdguo @ cs . stanford . edu Aditya Parameswaran Stanford University Stanford , CA , USA adityagp @ cs . stanford . edu Hector Garcia - Molina Stanford University Stanford , CA , USA hector @ cs . stanford . edu ABSTRACT We consider a crowdsourcing database system that may cleanse , populate , or ﬁlter its data by using human workers . Just like a con - ventional DB system , such a crowdsourcing DB system requires data manipulation functions such as select , aggregate , maximum , average , and so on , except that now it must rely on human oper - ators ( that for example compare two objects ) with very different latency , cost and accuracy characteristics . In this paper , we focus on one such function , maximum , that ﬁnds the highest ranked object or tuple in a set . In particularm we study two problems : given a set of votes ( pairwise comparisons among objects ) , how do we select the maximum ? And how do we improve our estimate by requesting additional votes ? We show that in a crowdsourcing DB system , the optimal solution to both problems is NP - Hard . We then provide heuristic functions to select the maximum given evidence , and to select additional votes . We experimentally evaluate our functions to highlight their strengths and weaknesses . Categories and Subject Descriptors : H . 3 . 3 [ Information Storage and Retrieval ] : Information Search and Retrieval – Information Fil - tering Keywords : Crowdsourcing , Human Computation , Max , Voting , Aggregation . 1 . INTRODUCTION A crowdsourcing database system uses people to perform data cleansing , collection or ﬁltering tasks that are difﬁcult for comput - ers to perform . For example , suppose that a large collection of maps is being loaded into the database , and we would like to add data ﬁelds to identify “features” of interest such as washed out roads , dangerous curves , intersections with dirt roads or tracks not on the maps , accidents , possible shelter , and so on . Such features are very hard for image analysis software to identify , but could be identiﬁed relatively easily by people who live in the area , who visited the area recently , or who are shown satellite images of the area . A crowd - sourcing database system issues tasks to people ( e . g . , tag features on this map , compare the quality of one map as compared to an - other ) , collects the answers , and veriﬁes the answers ( e . g . , by ask - ing other people to check identiﬁed features ) . We focus on crowd - Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for proﬁt or commercial advantage and that copies bear this notice and the full citation on the ﬁrst page . To copy otherwise , to republish , to post on servers or to redistribute to lists , requires prior speciﬁc permission and / or a fee . SIGMOD ’12 , May 20 – 24 , 2012 , Scottsdale , Arizona , USA . Copyright 2012 ACM 978 - 1 - 4503 - 1247 - 9 / 12 / 05 . . . $ 10 . 00 . sourcing systems where people are paid for their work , although in others they volunteer their work ( e . g . , in the Christmas Bird Count , http : / / birds . audubon . org / christmas - bird - count , volunteers identify birds across the US ) , while in other systems the tasks are pre - sented as games that people do for fun ( e . g . , gwap . com ) . Ama - zon’s Mechanical Turk ( mturk . com ) can be used by the database system to ﬁnd human workers and perform the tasks , although there are many other companies now offering services in this space ( CrowdFlower crowdﬂower . com , uTest utest . com , Microtask mi - crotask . com , Tagasauris tagasauris . com ) . Just like a conventional database system , a crowdsourcing database system will need to perform data processing functions like selects and aggregates , except that now these functions may involve inter - acting with humans . For example , to add a ﬁeld “average movie rat - ing” to movie tuples involves an aggregate over the user inputs . Se - lecting “horror movies” may involve asking humans what movies are “horror movies . ” The underlying operations ( e . g . , ask a human if a given movie is a “horror movie” or ask a human which of two cameras is best ) have very different latency , cost and accuracy char - acteristics than in a traditional database system . Thus , we need to develop effective strategies for performing such fundamental data processing functions . In particular , in this paper we focus on the Max ( Maximum ) func - tion : The database has a set of objects ( e . g . , maps , photographs , Facebook proﬁles ) , where conceptually each object has an intrinsic “quality” measure ( e . g . , how useful is a map for a speciﬁc human - itarian mission , how well does a photo describe a given restaurant , how likely is it that a given Facebook proﬁle is the actual proﬁle of Lady Gaga ) . Of the set of objects , we want to ﬁnd the one with the largest quality measure . While there are many possible underlying types of human operators , in this paper we focus on a pairwise op - erator : a human is asked to compare two objects and returns the one object he thinks is of higher quality . We call this type of pairwise comparison a vote . If we ask two humans to compare the same pair of objects they may give us different answers , either because they makes mistakes or because their notion of quality is subjective . Either way , the crowdsourcing algorithm may need to submit the same vote to mul - tiple humans to increase the likelihood that its ﬁnal answer is cor - rect ( i . e . that the reported max is indeed the object with the highest quality measure ) . Of course , executing more votes increases the cost of the algorithm , either in running time and / or in monetary compensation given to the humans for their work . There are two types of algorithms for the Max Problem : struc - tured and unstructured . With a structured approach , a regular pat - tern of votes is set up in advance , as in a tournament . For example , if we have 8 objects to consider , we can ﬁrst compare 1 to 2 , 3 to 4 , 5 to 6 and 7 to 8 . After we get all results , we compare the 1 - 2 winner to the 3 - 4 winner and the 5 - 6 winner to the 7 - 8 winner . In 385 the third stage , we compare the two winners to obtain the overall winner , which is declared the max . If we are concerned about vot - ing errors , we can repeat each vote an odd number of times and use the consensus result . For instance , three humans can be asked to do the 1 - 2 comparison , and the winner of this comparison is the object that wins in 2 or 3 of the individual votes . While structured approaches are very effective in predictable en - vironments ( such as in a sports tournament ) , they are much harder to implement in a crowdsourcing database system , where humans may simply not respond to a vote , or may take an unacceptably long time to respond . In our 8 - object example , for instance , after asking for the ﬁrst 4 votes , and waiting for 10 minutes , we may have only the answers to the 1 - 2 and 5 - 6 comparisons . We could then re - issue the 3 - 4 and 7 - 8 comparisons and just wait , but perhaps we should also try comparing the winner of 1 - 2 with the winner of 5 - 6 ( which was not in our original plan ) . The point is that even if we start with a structured plan in mind , because of incomplete votes we will likely be faced with an un - structured scenario : some subset of the possible votes have com - pleted ( some with varying numbers of repetitions ) , and we have to answer one or both of the following questions : • Judgment Problem : what is our current best estimate for the overall max winner ? • Next Votes Problem : if we want to invoke more votes , which are the most effective ones to invoke , given the current stand - ing of results ? In this paper we focus precisely on these two problems , in an un - structured setting that is much more likely to occur in a crowdsourc - ing database system . Both of these problems are quite challenging because there may be many objects in the database , and because there are many possible votes to invoke . An additional challenge is contradictory evidence . For instance , say we have three objects , and one vote told us 1 was better than 2 , another vote told us that 2 was better than 3 , and a third one told us that 3 was better and 1 . What is the most likely max in a scenario like this one where evi - dence is in conﬂict ? Should we just ignore “conﬂicting” evidence , but how exactly do we do this ? Yet another challenge is the lack of evidence for some objects . For example , say our evidence is that 1 is better than objects 2 , 3 and 4 . However , there are two addi - tional objects , 5 and 6 , for which there is no data . If we can invoke one more vote , should we compare the current favorite , object 1 , against another object to verify that it is the max , or should we at least try comparing 5 and 6 , for which we have no information ? The Judgment Problem draws its roots from the historical paired comparisons problem , wherein the goal is to ﬁnd the best rank - ing of objects when noisy evidence is provided [ 20 , 29 , 11 ] . The problem is also related to the Winner Determination problem in the economic and social choice literature [ 6 ] , wherein the goal is to ﬁnd the best object via a voting rule : either by ﬁnding a “good” rank - ing of objects and then returning the best object ( s ) in that ranking , or by scoring each object and returning the best scoring object ( s ) . As we will see in Section 2 , our solution to the Judgment Problem differs from both of these approaches . As far as we know , no coun - terpart of the Next Votes problem exists in the literature . We survey related work in more detail in Section 4 . In summary , our contributions are as follows : • We formalize the Max Problem for a crowdsourcing database system , with its two subproblems , the Judgment and the Next Votes problems . • We propose a Maximum Likelihood ( ML ) formulation of the Judgment Problem , which ﬁnds the object that is prob - abilistically the most likely to be the maximum . We show that computing the Maximum Likelihood object is NP - Hard , while computation of the probabilities involved is # P - Hard . To the best of our knowledge , our ML formulation is the ﬁrst formal deﬁnition and analysis of the Judgment Problem . • We propose and evaluate four different heuristics for the Judg - ment Problem , some of which are adapted from solutions for sorting with noisy comparisons . For small problem settings , we compare the heuristic solutions to those provided by ML . When there is only a small number of votes available , we show that one of our methods , a novel algorithm based on PageRank , is the best heuristic . • We provide the ﬁrst formal deﬁnition of the Next Votes Prob - lem , and again , propose a formulation based on ML . We show that selecting optimal additional votes is NP - Hard , while computation of the probabilities involved is # P - Hard . • We propose four novel heuristics for the Next Votes Prob - lem . We experimentally evaluate the heuristics , and when feasible , compare them to the ML formulation . 2 . JUDGMENT PROBLEM 2 . 1 Problem Setup Objects and Permutations : We are given a set O of n objects { o 1 , . . . , o n } , where each object o i is associated with a latent quality c i , with no two c ’s being the same . If c i > c j , we say that o i is greater than o j . Let π denote a permutation function , e . g . , a bijection from N to N , where N = { 1 , . . . , n } . We use π ( i ) to denote the rank , or index , of object o i in permutation π , and π − 1 ( i ) to denote the object index of the i th position in permutation π . If π ( i ) < π ( j ) , we say that o i is ranked higher than o j in permutation π . Since no two objects have the same quality , there exists a true permutation π ∗ such that for any pair ( i , j ) , if π ∗ ( i ) < π ∗ ( j ) , then c π ∗ ( i ) > c π ∗ ( j ) . Note that throughout this paper , we use the terms permutation and ranking interchangeably . Voting : We wish to develop an algorithm to ﬁnd the maximum ( greatest ) object in set O , i . e . , to ﬁnd π ∗− 1 ( 1 ) . The only type of op - eration or information available to an algorithm is a pairwise vote : in a vote , a human worker is shown two objects o i and o j , and is asked to indicate the greater object . We assume that all work - ers vote correctly with probability p ( 0 . 5 < p ≤ 1 ) , where p is a quantity indicating average worker accuracy . We also assume p is unaffected by worker identities , object values , or worker be - havior . In other words , each vote can be viewed as a independent Bernoulli trial with success probability p . In general , the value p is not available to the algorithm , but may be used for algorithm eval - uation . However , for reference we do study two algorithms where p is known . Goals : No matter how the algorithm decides to issue vote requests to workers , at the end it must select what it thinks is the maximum object based on the evidence , i . e . , based on the votes completed so far . We start by focusing on this Judgment Problem , which we deﬁne as follows : P ROBLEM 1 ( J UDGMENT ) . Given W , predict the maxi - mum object in O , π ∗− 1 ( 1 ) . In Section 3 , we then address the other important problem , i . e . , how to request additional votes ( in case the algorithm decides it is not done yet ) . In general , a solution to the Judgment Problem is based upon a scoring function s . The scoring function ﬁrst com - putes a score s ( i ) for each object o i , with the score s ( i ) represent - ing the “conﬁdence” that object o i is the true maximum . As we will see , for some strategies scores are actual probabilities , for oth - ers they are heuristic estimates . Then , the strategy selects the object with the largest score as its answer . Representation : We represent the evidence obtained as an n × n vote matrix W , with w ij being the number of votes for o j being 386 W = 0 B @ 0 2 0 0 0 0 2 3 0 1 0 1 0 0 1 0 1 CA Figure 1 : How should these objects be ranked ? Vote matrix ( left ) and equivalent graph representation ( right ) . Arc weights indicate number of votes . greater than o i . Note that w ii = 0 for all i . No other assumptions are made about the structure of matrix W . The evidence can also be viewed as a directed weighted graph G v = ( V , A ) , with the vertices being the objects and the arcs representing the vote out - comes . For each pair ( i , j ) , if w ij > 0 , arc ( i , j ) with weight w ij is present in A . For example , Figure 1 displays a sample vote matrix and equivalent graph representation . In this example , ob - ject 1 is called A , object 2 is B , and so on . For instance , there is an arc from vertex ( object ) B to vertex C with weight 2 because w 2 , 3 = 2 , and there is a reverse arc from C to B with weight 1 because w 3 , 2 = 1 . If there are no votes ( w ij = 0 , as from B to A ) , we can either say that there is no arc , or that the arc has weight 0 . 2 . 2 Maximum Likelihood Preliminaries : We ﬁrst present a Maximum Likelihood ( ML ) for - mulation of the Judgment Problem . We directly compute the object that has the highest probability of being the maximum object in O , given vote matrix W . Assuming that average worker accuracy p is known , the ML formulation we present is the optimal feasible solution to the Judgment Problem . Let π be a random variable over the set of all n ! possible permu - tations , where we assume a - priori that each permutation is equally likely to be observed . We denote the probability of a given permu - tation π d given the vote matrix W as P ( π = π d | W ) . For the ease of exposition , we adopt the shorthand P ( π d | W ) instead of writing P ( π = π d | W ) . To derive the formula for P ( π d | W ) , we ﬁrst apply Bayes’ theorem , P ( π d | W ) = P ( W | π d ) P ( π d ) P ( W ) = P ( W | π d ) P ( π d ) X j P ( W | π j ) P ( π j ) ( 1 ) From our assumption that the prior probabilities of all permutations are equal , P ( π d ) = 1 n ! . Now consider P ( W | π d ) . Given a permutation π d , for each un - ordered pair { i , j } , the probability f π d ( i , j ) of observing w ij and w ji is the binomial distribution probability mass function ( p . m . f . ) : f π d ( i , j ) = ( ` w ij + w ji w ij ´ p w ji ( 1 − p ) w ij if π d ( i ) < π d ( j ) ` w ij + w ji w ji ´ p w ij ( 1 − p ) w ji if π d ( j ) < π d ( i ) Note that if both w ij and w ji are equal to 0 , then f π d ( i , j ) = 1 . Now , given a permutation π d , observing the votes involving an unordered pair { i , j } is conditionally independent of observ - ing the votes involving any other unordered pair . Using this fact , P ( W | π d ) , the probability of observing all votes given a permuta - tion π d is simply : P ( W | π d ) = Y i , j : i < j f π d ( i , j ) ( 2 ) Since we know the values of both p and W , we can derive a for - mula for P ( π d | W ) in Equation 1 . In particular , the most likely permutation ( s ) , is simply : arg max d P ( π d | W ) ( 3 ) The permutations optimizing Equation 3 are also known as Kemeny permutations or Kemeny rankings [ 9 ] . For example , consider the matrix W of Figure 1 . We do not show the computations here , but it turns out that the two most probable permutations of the objects are ( D , C , B , A ) and ( C , D , B , A ) , with all other permutations having lower probability . This result roughly matches our intuition , since object A was never voted to be greater than any of the other objects , and C and D have more votes in favor over B . We can derive the formula for the probability that a given object o j has a given rank k . Let π − 1 ( i ) denote the position of object i in the permutation associated with random variable π . We are interested in the probability P ( π − 1 ( k ) = j | W ) . Since the event ( π = π d ) is disjoint for different permutations π d , we have : P ( π − 1 ( k ) = j | W ) = X d : π − 1 d ( k ) = j P ( π d | W ) Substituting for P ( π d | W ) using Equation 1 and simplifying , we have : P ( π − 1 ( k ) = j | W ) = X d : π − 1 d ( k ) = j P ( W | π d ) X l P ( W | π l ) ( 4 ) Since we are interested in the object o j with the highest proba - bility of being rank 1 , e . g . , P ( π − 1 ( 1 ) = j | W ) , we now have the Maximum Likelihood formulation to the Judgment Problem : ML F ORMULATION 1 ( J UDGMENT ) . Given W and p , determine : arg max j P ( π − 1 ( 1 ) = j | W ) . In the example graph of Figure 1 , while C and D both have Kemeny permutations where they are the greatest objects , D is the more likely max over a large range of p values . For instance , for p = 0 . 75 , P ( π − 1 ( 1 ) = C | W ) = 0 . 36 while P ( π − 1 ( 1 ) = D | W ) = 0 . 54 . This also matches our intuition , since C has one vote where it is less than B , while D is never voted to be less than either A or B . Maximum Likelihood Strategy : Equation 4 implies that we only need to compute P ( W | π d ) for each possible permutation π d , us - ing Equation 2 , in order to determine P ( π − 1 ( k ) = j | W ) for all values j and k . In other words , by doing a single pass through all permutations , we can compute the probability that any object o j has a rank k , given the vote matrix W . We call this exhaustive computation of probabilities the Max - imum Likelihood Strategy and use it as a baseline in our experi - ments . Note that the ML strategy is the optimal feasible solution to the Judgment Problem . In the extended technical report [ 15 ] , we provide pseudocode for the computation of the scoring function based on our ML formulation . 2 . 3 Computational Complexity Hardness of the Judgment Problem : In Section 2 . 2 , we presented a formulation for the Judgment Problem based on ML for ﬁnding the object most likely to be the max ( maximum ) object in O . Un - fortunately , the strategy based on that formulation was computa - tionally infeasible , as it required computation across all n ! permu - tations of the objects in O . We now show that the optimal solution 387 to the problem of ﬁnding the maximum object is in fact NP - Hard using a reduction from the problem of determining Kemeny win - ners [ 17 ] . ( Hudry et al . [ 17 ] actually show that determining Slater winners in tournaments is NP - Hard , but their proof also holds for Kemeny winners . We will describe the Kemeny winner problem below . ) Our results and proof are novel . T HEOREM 1 . ( Hardness of the Judgment Problem ) Finding the maximum object given evidence is NP - Hard . P ROOF . We ﬁrst describe the Kemeny winner problem . In this proof , we use an alternate ( but equivalent ) view of a directed weighted graph like Figure 1 . In particular , we view weighted arcs as mul - tiple arcs . For instance , if there is an arc from vertex A to B with weight 3 , we can instead view it as 3 separate edges from A to B . We use this alternate representation in our proof . An arc i → j respects a permutation if the permutation has o j ranked higher than o i ( and does not if the permutation has o i ranked higher than o j ) . A Kemeny permutation is simply a permutation of the vertices ( objects ) , such that the number of arcs that do not respect the permutation is minimum . There may be many such permutations , but there always is at least one such permutation . The starting vertex ( rank 1 object ) in any of these permutations is a Kemeny winner . It can be shown that ﬁnding a Kemeny winner is NP - Hard ( using a reduction from the feedback arc set problem , similar to the proof in Hudry et al . [ 17 ] ) . We now reduce the Kemeny winner determination problem to one of ﬁnding the maximum object . Consider a directed weighted graph G , where we wish to ﬁnd a Kemeny winner . We show that with a suitable probability p , which we set , the maximum object ( i . e . , the solution to the Judgment Problem ) in G is a Kemeny win - ner . As before , the probability that a certain object o j is the maxi - mum object is the right hand side of Equation 4 with k set to 1 . The denominator can be ignored since it is a constant for all j . We set worker accuracy p to be very close to 1 . In particular , we choose a value p such that 1 − pp < 1 n ! . Now , consider all permutations π d that are not Kemeny permuta - tions . In this case , it can be shown that X d : π d is notKemeny P ( W | π d ) < P ( W | π s ) for any Kemeny permutation π s . Thus , the object o j that maximizes Equation 4 ( for k = 1 ) has to be one that is a Kemeny winner . To see why X d : π d isnot Kemeny P ( W | π d ) < P ( W | π s ) for a Ke - meny permutation π s , notice that the left hand side is at most n ! × P ( W | π (cid:3) d ) where π (cid:3) d is the permutation ( not Kemeny ) that has the least number of arcs that do not respect the permutation . Note that P ( W | π (cid:3) d ) is at most P ( W | π s ) × 1 − pp , since this permutation has at least one more mistake as compared to any Kemeny permutation . Therefore , we have shown that , for a suitable p , the maximum object in G is a Kemeny winner . Thus , we have a reduction from the Kemeny winner problem to the Judgement problem . Since ﬁnd - ing a Kemeny winner is NP - Hard , this implies that ﬁnding the max - imum object in G is NP - Hard . # P - Hardness of Probability Computations : In addition to being NP - Hard to ﬁnd the max object , we can show that evaluating the numerator of the right hand side of Equation 4 ( with k = 1 ) is # P - Hard , in other words : computing P ( π − 1 ( 1 ) = j , W ) is # P - Hard . We use a reduction from the problem of counting the number of linear extensions in a directed acyclic graph ( DAG ) , which is known to be # P - Hard . T HEOREM 2 . ( # P - Hardness of Probability Computation ) Com - puting P ( π − 1 ( 1 ) = j , W ) is # P - Hard . P ROOF . A linear extension is a permutation of the vertices , such that all arcs in the graph respect the permutation ( i . e . , a linear ex - tension is the same as a Kemeny permutation for a DAG ) . Consider a DAG G = ( V , A ) . We add an additional vertex x such that there is an arc from each of the vertices in G to x , giv - ing a new graph G (cid:3) = ( V (cid:3) , A (cid:3) ) . We now show that computing P ( π − 1 ( 1 ) = x , W ) in G (cid:3) can be used to compute the number of linear extensions in G . Notice that : P ( π − 1 ( 1 ) = x , W ) = | A (cid:3) | X i = 0 a i p i ( 1 − p ) | A (cid:3) | − i = p | A (cid:3) | × | A (cid:3) | X i = 0 a i ( 1 − p p ) | A (cid:3) | − i ( 5 ) where a i is the number of permutations where there are i arcs that respect the permutation . Clearly , the number that we wish to de - termine is a | A (cid:3) | , since that is the number of permutations that cor - respond to linear extensions . Equation 5 is a polynomial of degree | A (cid:3) | in 1 − pp , thus , we may simply choose | A (cid:3) | + 1 different values of 1 − pp , generate | A (cid:3) | + 1 different graphs G (cid:3) , and use the probabil - ity computation in Equation 5 to create a set of | A (cid:3) | + 1 equations involving the a i coefﬁcients . We may then derive the value of a | A | using Lagrange’s interpolation formula . Since vertex x is the only maximum vertex in G (cid:3) , by comput - ing P ( π − 1 ( 1 ) = x , W ) in G (cid:3) , we count the number of linear extensions in DAG G . Since counting the number of linear ex - tensions in a DAG is # P - Hard , this implies that the computation of P ( π − 1 ( 1 ) = x , W ) in G (cid:3) is # P - Hard , which implies that the com - putation of P ( π − 1 ( k ) = j , W ) for directed graph G v ( associated with vote matrix W ) is # P - Hard . 2 . 4 Heuristic Strategies The ML scoring function is computationally inefﬁcient and also requires prior knowledge of p , the average worker accuracy , which is not available to us in real - world scenarios . We next investigate the performance and efﬁciency of four heuristic strategies , each of which runs in polynomial time . The heuristics we present , exclud - ing the Indegree heuristic , do not require explicit knowledge of the worker accuracy p . Indegree Strategy : The ﬁrst heuristic we consider is an Indegree scoring function proposed by Coppersmith et al . [ 10 ] to approx - imate the optimal feedback arc set in a directed weighted graph where arc weights l ij , l ji satisfy l ij + l ji = 1 for each pair of ver - tices i and j . We can transform the vote matrix W to a graph where this Indegree scoring function can be directly applied . The idea is to construct a complete graph between all objects where arc weights l ji are equal to P ( π ( i ) < π ( j ) | w ij , w ji ) , where l ji reﬂects the probability that o i is greater than o j given the local evidence w ij and w ji . For details , see the extended technical report [ 15 ] . The Indegree scoring function computes the score of object o j as : s ( j ) = P i l ij . Intuitively , vertices with higher scores cor - respond to objects which have compared favorably to other ob - jects , and hence should be ranked higher . The predicted ranking has been shown to be a constant factor approximation to the feed - back arc set for directed graphs where all arcs ( i , j ) are present and l ij + l ji = 1 [ 10 ] . The running time of this heuristic is dominated by the time to do the ﬁnal sort of the scores . Local Strategy : The Indegree heuristic is simple to compute , but only takes into account local evidence . That is , the score of object o i only depends on the votes that include o i directly . We now con - sider a Local scoring function , adapted from a heuristic proposed by David [ 12 ] , which considers evidence two steps away from o i . This method was originally proposed to rank objects in incomplete 388 tournaments with ties . We adapted the scoring function to our set - ting , where there can be multiple comparisons between objects , and there are no ties in comparisons . This heuristic is based on the notion of wins and losses , deﬁned as follows : wins ( i ) = P j w ji and losses ( i ) = P i w ij . For instance , in Figure 1 , vertex B has 3 wins and 5 losses . The score s ( i ) has three components . The ﬁrst is simply wins ( i ) − losses ( i ) , reﬂecting the net number of votes in favor of o i . For vertex B , this ﬁrst component would be 3 − 5 = − 2 . Since this ﬁrst component does not reﬂect the “strength” of the objects o i was compared against , we next add a “reward” : for each o j such that w ji > w ij ( i has net wins over j ) , we add wins ( j ) to the score of o i . In our example , B only has net wins over A , so we reward B with wins ( A ) ( which in this case is zero ) . On the other hand , since C beat out B , then C gets a reward of wins ( B ) = 3 added to its score . Finally , we “penalize” s ( i ) by subtracting losses ( j ) for each o j that overall beat o i . In our example , we subtract from s ( B ) both losses ( C ) = 2 and losses ( D ) = 1 . Thus , the ﬁnal score s ( B ) is − 2 plus the reward minus the penalty , i . e . , s ( B ) = − 2 + 0 − 3 = − 5 . More formally , score s ( i ) is deﬁned as follows : s ( i ) = wins ( i ) − losses ( i ) + X j [ 1 ( w ji > w ij ) wins ( j ) ] − X j [ 1 ( w ij > w ji ) losses ( j ) ] ( 6 ) Having computed s ( · ) , we sort all objects by decreasing order of s . The resulting permutation is our predicted ranking , with the vertex having largest s being our predicted maximum object . PageRank Strategy : Both the Indegree and Local heuristics use only information one or two steps away to make inferences about the objects of O . We next consider a global heuristic scoring func - tion inspired by the PageRank [ 26 ] algorithm . The general idea be - hind using a PageRank - like procedure is to utilize the votes in W as a way for objects to transfer “strength” between each other . The use of PageRank to predict the maximum has been previously consid - ered [ 5 ] in the literature . Our contribution is a modiﬁed PageRank to predict the maximum object in O , which in particular , can handle directed cycles in the directed graph representing W . Consider again the directed graph G v representing the votes of W ( Figure 1 is an example ) . Let d + ( i ) to denote the outdegree of vertex i in G v , e . g . d + ( i ) = P j w ij . If d + ( i ) = 0 , we say that i is a sink vertex . Let pr t ( i ) represent the PageRank of vertex i in iteration t . We initialize each vertex to have the same initial PageRank , e . g . , pr 0 ( · ) = 1 n . In each iteration t + 1 , we apply the following update equation to each vertex i : pr t + 1 ( i ) = X j w ji d + ( j ) pr t ( j ) ( 7 ) For each iteration , each vertex j transfers all its PageRank ( from the previous iteration ) proportionally to the other vertices i whom workers have indicated may be greater than j , where the propor - tion of j ’s PageRank transferred to i is equal to w ji d + ( j ) . Intuitively , pr t ( i ) can be thought as a proxy for the probability that object o i is the maximum object in O ( during iteration t ) . What happens to the PageRank vector after performing many update iterations using Equation 7 ? Considering the strongly con - nected components ( SCCs ) of G v , let us deﬁne a terminal SCC to be a SCC whose vertices do not have arcs transitioning out of the SCC . After a sufﬁcient number of iterations , the PageRank prob - ability mass in G v becomes concentrated in the terminal SCCs of G v , with all other vertices outside of these SCCs having zero PageRank [ 4 ] . In the context of our problem , these terminal SCCs can be thought of as sets of objects which are ambiguous to order . Strategy 1 PageRank Require : n objects , vote matrix W , K iterations Ensure : ans = predicted maximum object construct G v = ( V , A ) from W compute d + [ · ] for each vertex { compute all outdegrees } for i : 1 . . . n do if d + [ i ] = = 0 then w ii ← 1 end if end for pr 0 [ · ] ← 1 n { pr 0 is the PageRank vector in iteration 0 } for k : 1 . . . K do for i : 1 . . . n do for j : 1 . . . n , j (cid:3) = i do pr k [ i ] ← pr k [ i ] + w ji d + [ j ] pr k − 1 [ j ] end for end for end for compute period [ · ] of each vertex using ﬁnal iterations of pr [ · ] for i : 1 . . . n do s [ i ] ← 0 { s [ · ] is a vector storing average PageRank } for j : 0 . . . period [ i ] − 1 do s [ i ] ← s [ i ] + pr K − j [ i ] end for s [ i ] ← s [ i ] period [ i ] end for ans ← argmax i s [ i ] Our proposed PageRank algorithm is described in Strategy 1 . How is our strategy different from the standard PageRank algo - rithm ? The original PageRank update equation is : pr t + 1 ( i ) = 1 − d n + d X j w ji d + ( j ) pr t ( j ) ) Comparing the original equation and Equation 7 , the primary dif - ference is that we use a damping factor d = 1 , e . g . we remove jump probabilities . PageRank was designed to model the behavior of a random surfer traversing the web , while for the problem of ranking objects , we do not need to model a random jump vector . A second difference between our modiﬁed PageRank and the original PageRank is that prior to performing any update iterations , for each sink vertex i , we set w ii equal to 1 in W . In our set - ting , sinks correspond to objects which may be the maximum object ( e . g . , no worker voted that o i is less than another object ) . By set - ting w ii to 1 initially , from one iteration to the next , the PageRank in sink i remains in sink i . This allows PageRank to accumulate in sinks . Contrast this with the standard PageRank methodology , where when a random surfer reaches a sink , it is assumed that ( s ) he transitions to all other vertices with equal probability . Finally , a caveat to our PageRank strategy is that the PageRank vector ( pr ( · ) in Strategy 1 ) may not converge for some vertices in terminal SCCs . To handle the oscillating PageRank in terminal SCCs , we execute our PageRank update equation ( Equation 7 ) for a large number of iterations , denoted as K in Strategy 1 . Then , we examine the ﬁnal iterations , say ﬁnal 10 % , of the PageRank vector to empirically determine the period of each vertex , where we de - ﬁne the period as the number of iterations for the PageRank value of a vertex to return to its current value . In practice , we ﬁnd that running PageRank for K iterations , where K = O ( n ) , is sufﬁcient to detect the period of nearly all vertices in terminal SCCs . For example , consider a graph among 3 objects A , B , C with 3 arcs : ( A , B ) , ( B , C ) , and ( C , B ) . All vertices initially have 13 PageR - ank probability . After 1 iteration , the PageRank vector is ( 0 , 23 , 13 ) . 389 After 2 iterations , the PageRank vector is ( 0 , 13 , 23 ) . And so on . In this example , object B and C each have periods of 2 . With the periods computed for each vertex , we compute an av - erage PageRank value for each vertex over its period . This aver - age PageRank is used as the scoring function s ( · ) for this strat - egy . After the termination of PageRank , we sort the vertices by decreasing order of s ( · ) , and predict that the vertex with maximum average PageRank corresponds to the maximum object in O . Note that our PageRank heuristic is primarily intended to predict a maxi - mum object , not to predict a ranking of all objects ( as many objects will end up with no PageRank ) . However , for completeness , when evaluating PageRank in later experiments , we still do consider the predicted ranking induced by PageRank . The details of our imple - mentation are displayed in Strategy 1 . Iterative Strategy : We next propose an Iterative heuristic strategy to determine the maximum object in O . The general framework is the following : 1 . Place all objects in a set . 2 . Rank the objects in the set by a scoring metric . 3 . Remove the lower ranked objects from the set . 4 . Repeat steps 3 and 4 until only one object remains . There are two parameters we can vary in this framework : the scoring metric and the number of objects eliminated each itera - tion . Let us deﬁne the dif ( i ) metric of object o i to be equal to wins ( i ) − losses ( i ) . An implementation of the Iterative strategy using the dif metric is displayed in Strategy 2 . In our particular im - plementation , we emphasize computational efﬁciency and remove half of the remaining objects each iteration . The Iterative strat - egy relies upon the elimination of lower ranked objects before re - ranking higher ranked objects . With each iteration , as more objects are removed , the difs of the higher ranked objects separate from the difs of the lower ranked objects . Basically , by removing lower ranked objects , the strategy is able to more accurately rank the re - maining set of objects . The strategy can be thought of as iteratively narrowing in on the maximum object . It is important to note that other scoring metrics can be used with this Iterative strategy as well . For example , by iteratively ranking with the Local heuristic , we were able to achieve ( slightly ) better performance than the simple dif metric . Our method is similar to the Greedy Order algorithm proposed by Cohen et al . [ 7 ] , who con - sidered a problem related to feedback arc set . Our strategy differs in that it is more general ( e . g . , it can utilize multiple metrics ) , and our strategy can be optimized ( e . g . , if we eliminate half of the ob - jects each iteration , we require only a logarithmic number of sorts , as opposed to a linear number ) . 2 . 5 Experiments In this section , we experimentally compare our heuristic strate - gies : Indegree ( DEG ) , Local ( LOC ) , PageRank , ( PR ) , and Itera - tive ( ITR ) . We also compare them with the Maximum Likelihood ( ML ) Strategy , which we consider the best possible way to select the maximum . However , since ML is computationally very ex - pensive , we only do this comparison on a small scenario . For our experiments , we synthetically generate problem instances , varying : n ( the number of objects in O ) , v ( the number of votes we sample for W ) , and p ( average worker accuracy ) . We prefer to use syn - thetic data , since it lets us study a wide spectrum of scenarios , with highly reliable or unreliable workers , and with many or few votes . In our base experiments , we vary the number of sampled votes v , from 0 to 5 n ( n − 1 ) and vary worker accuracy p from 0 . 55 to 0 . 95 . As a point of reference , we refer to n ( n − 1 ) 2 votes as v = 1x Edge Coverage , e . g . each pair of objects is sampled approximately once . So 5 n ( n − 1 ) votes is equivalent to v = 10x Edge Coverage in our experiments . Strategy 2 Iterative Require : n objects , vote matrix W Ensure : ans = predicted maximum object dif [ · ] ← 0 { dif [ · ] is the scoring metric } for i : 1 . . . n do for j : 1 . . . n , j (cid:3) = i do dif [ j ] ← dif [ j ] + w ij ; dif [ i ] ← dif [ i ] − w ij end for end for initialize set Q { which stores objects } for i : 1 . . . n do Q ← Q ∪ i end for while | Q | > 1 do sort objects in Q by dif [ · ] for r : ( | Q | 2 + 1 ) . . . | Q | do remove object i ( with rank r ) from Q for j : j ∈ Q do if w ij > 0 then dif [ j ] ← dif [ j ] − w ij ; dif [ i ] ← dif [ i ] + w ij end if if w ji > 0 then dif [ i ] ← dif [ i ] − w ji ; dif [ j ] ← dif [ j ] + w ji end if end for end for end while ans ← S [ 1 ] { S [ 1 ] is the ﬁnal object in S } Each data point ( given n , p , v values ) in our results graphs is obtained from 5 , 000 runs . Each run proceeds as follows : We ini - tialize W as an n × n null matrix and begin with an arbitrary true permutation π ∗ of the objects in O . Let U denote the set of all tu - ples ( i , j ) where i (cid:4) = j . We randomly sample v tuples from U with replacement . After sampling a tuple ( i , j ) , we simulate the human worker’s comparison of objects o i and o j . If π ∗ ( i ) < π ∗ ( j ) , with probability p , we increment w ji , and with probability 1 − p , we increment w ij . If π ∗ ( j ) < π ∗ ( i ) , with probability p , we increment w ij , and with probability 1 − p , we increment w ji . For each generated matrix W in a run , we apply each of our heuristic strategies to obtain predicted rankings of the objects in O . Comparing the predicted ranking with π ∗ we record a “yes” if the predicted maximum agrees with the true maximum . After all runs have completed , we compute Precision at 1 ( P @ 1 ) , the fraction of “yes” cases over the number of runs . For results with other evaluation metrics , see the extended technical report [ 15 ] . As a ﬁrst experiment , we consider the prediction performance of Maximum Likelihood ( ML ) and the four heuristics for a set of 5 objects with p = 0 . 75 , displayed in Figure 2 ( a ) . We choose a small set of objects , so that ML can be computed . We ﬁnd that as the number of votes sampled increases , the P @ 1 of all heuristics ( excluding PageRank ) increase in a concave manner , approaching a value of 0 . 9 for 10x Edge Coverage ( e . g . , if 5 n ( n − 1 ) votes are uniformly sampled , the heuristics can predict the maximum object 90 % of the time , even though average worker accuracy is 0 . 75 ) . ML has better performance than all the four heuristics . As expected , ML performs the best in Figure 2 ( a ) , but recall that ML requires explicit knowledge of p , and it is computationally very expensive . Still , the ML curve is useful , since it tells us how far the heuristics are from the optimal feasible solution ( ML ) . Also , note that PageRank ( PR ) performs poorly , indicating that PageRank is poor when the number of objects is small . Iterative is the best of the four heuristics when the number of votes sampled is n ( n − 1 ) 2 , e . g . 1x Edge Coverage . 390 0 . 3 0 . 4 0 . 5 0 . 6 0 . 7 0 . 8 0 . 9 1 1 2 3 4 5 6 7 8 9 10 P a t 1 Edge Coverage MLDEGLOCPRITR ( a ) p = 0 . 75 , 5 OBJ 0 . 02 0 . 04 0 . 06 0 . 08 0 . 1 0 . 12 0 . 14 0 . 16 0 . 18 1 2 3 4 5 6 7 8 9 10 P a t 1 Edge Coverage DEGLOCPRITR ( b ) p = 0 . 55 , 100 OBJ 0 . 1 0 . 2 0 . 3 0 . 4 0 . 5 0 . 6 0 . 7 0 . 8 0 . 9 1 1 2 3 4 5 6 7 8 9 10 P a t 1 Edge Coverage DEGLOCPRITR ( c ) p = 0 . 75 , 100 OBJ 0 . 2 0 . 3 0 . 4 0 . 5 0 . 6 0 . 7 0 . 8 0 . 9 1 1 2 3 4 5 6 7 8 9 10 P a t 1 Edge Coverage DEGLOCPRITR ( d ) p = 0 . 95 , 100 OBJ Figure 2 : Precision at 1 ( P @ 1 ) versus Edge Coverage . 0 0 . 1 0 . 2 0 . 3 0 . 4 0 . 5 0 . 6 0 . 7 0 . 8 0 . 55 0 . 6 0 . 65 0 . 7 0 . 75 0 . 8 0 . 85 0 . 9 0 . 95 P a t 1 Worker Accuracy DEGLOCPRITR 0 . 02 0 . 03 0 . 04 0 . 05 0 . 06 0 . 07 0 . 08 0 . 09 0 . 1 0 . 11 0 . 12 20 40 60 80 100 120 140 160 180 200 P a t 1 Votes DEGLOCPRITR Figure 3 : P @ 1 versus worker accuracy ( left ) , 1x Edge Coverage . P @ 1 versus number of votes ( right ) , p = 0 . 95 . 100 objects . For a larger experiment , we consider the problem of prediction for n = 100 objects in Figure 2 ( b ) ( c ) ( d ) . ML is necessarily omit - ted from this experiment . Looking at the graphs , we ﬁrst note that the Iterative ( ITR ) heuristic performs signiﬁcantly better than the other heuristics , particularly when p = 0 . 55 or p = 0 . 75 . This is best demonstrated by Figure 2 ( c ) , which shows that for p = 0 . 75 and 10x Edge Coverage , the Iterative heuristic has a P @ 1 of over 0 . 9 , whereas the second best heuristic , Indegree ( DEG ) , only has a P @ 1 of approximately 0 . 5 . Looking at the middle graph again , note how the performance gap between the Iterative heuristic and the other heuristics widens as the Edge Coverage increases from 1x to 5x . The strength of the Iterative strategy comes from its ability to leverage the large number of redundant votes , in order to itera - tively prune out lower - ranked objects until there is a predicted max - imum . The strategy is robust even when worker accuracy is low . When average worker accuracy is high , Figure 2 ( d ) , the Iterative heuristic still is the heuristic of choice , although the performance gap between the Iterative and Indegree or Local ( LOC ) heuristics decreases to a minimal amount , as the number of votes sampled becomes very large . PageRank is a poor heuristic when worker accuracy is low . However , when worker accuracy is reasonable , PageRank is quite effective , even when the number of votes is low . We next focus upon the performance of the PageRank ( PR ) heuris - tic . For p = 0 . 75 and p = 0 . 95 , the PageRank heuristic’s predic - tion curve crosses the prediction curves for the Indegree ( DEG ) and Local ( LOC ) heuristics . This is an indication that the PageR - ank heuristic is quite effective when the number of votes is low , but is unable to utilize the information from additional votes when the number of votes is large . We also observe the poor performance of PageRank when p = 0 . 55 , in Figure 2 ( b ) , indicating that PageRank is not a suitable heuristic when worker accuracy is low . Over various worker accuracies , Iterative is the best heuris - tic , followed by PageRank , Local and Indegree . From the prior experiments , we see that prediction performance for each strategy varies greatly with respect to the average worker accuracy p . We next directly investigate prediction performance ver - sus worker accuracy for a ﬁxed 1x Edge Coverage in Figure 3 ( left ) . We ﬁnd that for this ﬁxed Edge Coverage , the Iterative ( ITR ) strat - egy performs the best , followed by PageRank ( PR ) , then the Local ( LOC ) and Indegree ( DEG ) heuristics . As expected , prediction per - formance increases with worker accuracy across all strategies . In particular , note the large slope of the Iterative and PageRank pre - diction curves , as compared to the Local and Indegree prediction curves , which are near identical . PageRank is the best of the four heuristics when there are few votes and worker accuracy is high . All experiments considered thus far examine prediction when the number of votes is an order of magnitude larger than the number of objects . For a more difﬁcult scenario , we examine prediction performance when the number of votes is approximately the same as the number of objects . Figure 3 ( right ) displays P @ 1 for 100 objects when the number of votes is varied from 20 to 200 and p = 0 . 95 . We observe that PageRank ( PR ) has the highest pre - diction performance among the four heuristics . Conducting sev - eral other experiments , we ﬁnd that , so long as worker accuracy is high , PageRank facilitates good prediction , even when the number of votes is low relative to the number of objects . This fact will prove useful when we consider the problem of selecting which additional votes to request , given an initial sparse vote graph . From our experiments , we conclude that Iterative ( ITR ) is the strategy of choice when evaluating a large number of votes ( rela - tive to the number of objects ) , whereas PageRank is the preferred heuristic when evaluating a small number of votes . 3 . NEXT VOTES PROBLEM We now consider the second half of the Max Problem , the Next Votes Problem . Beginning with an initial vote matrix W , if we wish to submit additional vote requests to a crowdsourcing marketplace , which additional votes ( i . e . , comparisons between pairs of objects ) should be requested to augment our existing vote matrix W , and improve our prediction of the maximum object ? In particular , we assume that we are given a vote budget of b additional votes that may be requested . There are two ways in which we can use this vote budget : ( a ) an adaptive strategy , where we submit some initial votes , get some responses , then submit some more , get more re - sponses , and so on , or ( b ) a one - shot strategy , where we submit all votes at once . In this paper , we consider a one - shot strategy with a vote budget of b . This strategy is more relevant in a crowdsourc - ing setting since the latency of crowdsourcing is high . Once the responses for these vote requests are received , we assume that the entire evidence thus far is our new vote matrix W (cid:3) . Note that we can iteratively submit batches of votes to improve our prediction of the maximum object . As before , we assume that the response to each vote is i . i . d . correct with probability p . We deﬁne the Next Votes Problem as follows : P ROBLEM 2 ( N EXT V OTES ) . Given b , W , select b addi - tional votes and predict the maximum object in O , π ∗− 1 ( 1 ) . 3 . 1 Maximum Likelihood We ﬁrst present a Maximum Likelihood ( ML ) formulation of the selection of votes for the Next Votes Problem ; we directly compute the multiset of votes which most improves the prediction of the 391 maximum object in O . Assuming that average worker accuracy p is known , the ML vote selection formulation we present is the optimal feasible solution to the Next Votes Problem . Beforing presenting the ML formulation , we ﬁrst provide some deﬁnitions needed for the Next Votes Problem . Vote and Answer Multisets : We represent a potential vote ( com - parison ) between objects o i and o j as a unordered pair { o i , o j } . Given a vote budget b , all possible multisets Q of b votes are al - lowed ( note that repetition of votes is allowed ) . For a potential vote { o i , o j } , we deﬁne an answer to be a tuple ( { o i , o j } , o x ) , where the ﬁrst element of the tuple is an unordered pair , and the second ele - ment is one of the objects in the pair indicating the human worker’s answer ( e . g . , x = i if the worker states that o i is greater than o j , or x = j otherwise ) . For each vote multiset Q , we deﬁne an answer multiset a of Q to be a multiset of answer tuples , where there is a one - to - one mapping from each unordered pair in Q to an answer tuple in a . Note that each vote is answered ( independently ) with probability p . As an example , if Q = { { o i , o j } , { o k , o l } } , a possible answer multiset a that could be received from the workers is { ( { o i , o j } , o i ) , ( { o k , o l } , o k ) } . Note that for a multiset of b votes , there are 2 b pos - sible answer multisets . Let A ( Q ) denote the multiset of all possible answer multisets of Q . Having deﬁned vote and answer multisets , we next consider the probability of receiving an answer multiset given W , then explain how to compute the conﬁdence of the maximum object having re - ceived an answer multiset , before ﬁnally presenting the ML vote selection strategy . Probabilities of Multisets and Conﬁdences : Suppose that we submitted vote multiset Q and received answer multiset a from the crowdsourcing marketplace . Let P ( a | W ) denote the probability of observing an answer multiset a for Q , given initial vote matrix W . We have the following : P ( a | W ) = P ( a ∧ W ) P ( W ) ( 8 ) where a ∧ W is the new vote matrix formed by combining the votes of a and W . Our estimate for how well we are able to predict the maximum object in O is then the probability of the maximum object , given the votes of our new vote matrix , i . e . , a ∧ W . We denote this value by P max ( a ∧ W ) , i . e . , this value is our conﬁdence in the maximum object . The computation , based upon Equation 4 , is the following : P max ( a ∧ W ) = max i P ( π − 1 ( 1 ) = i | a ∧ W ) This simpliﬁes to give : P max ( a ∧ W ) = max i P ( π − 1 ( 1 ) = i , a ∧ W ) P ( a ∧ W ) ( 9 ) Maximum Likelihood Strategy : We can now deﬁne the Maxi - mum Likelihood formulation of the Next Votes Problem . We wish to ﬁnd the multiset Q of b votes such that , on average over all pos - sible answer multisets for Q ( and weighted by the probability of those answer multisets ) , our conﬁdence in the prediction of the maximum object is greatest . In other words , we want to ﬁnd the multiset that maximizes : X a ∈ A ( Q ) P ( a | W ) × P max ( a ∧ W ) which , on using Equations 8 and 9 , simpliﬁes to : 1 P ( W ) × X a ∈ A ( Q ) max i P ( π − 1 ( 1 ) = i , a ∧ W ) Since P ( W ) is a constant , independent of Q , we have : ML F ORMULATION 2 ( N EXT V OTES ) . Given b , W , ﬁnd the vote multiset Q , | Q | = b , that maximizes X a ∈ A ( Q ) max i P ( π − 1 ( 1 ) = i , a ∧ W ) ( 10 ) Let score ( Q ) be the value in Equation 10 . We now have an ex - haustive strategy to determine the best multiset Q : compute score ( · ) for all possible multisets of size b , and then choose the multiset with the highest score . Although this strategy is the optimal feasible so - lution to the Next Votes Problem , it is also computationally infea - sible , since a single iteration of ML itself requires enumeration of all n ! permutations of the objects in O . Additionally , knowledge of worker accuracy p is required for ML vote selection . This leads us to develop our own vote selection and evaluation framework en - abling more efﬁcient heuristics . 3 . 2 Computational Complexity As in the Judgment Problem , the Next Votes Problem also turns out to be NP - Hard , while the computation of the probabilities in - volved also turns out to be # P - Hard . While the proofs use reduc - tions from similar problems , the details are quite different . Hardness of the Next Votes Problem : We ﬁrst show that the ML formulation for the Next Votes Problem is NP - Hard , implying that ﬁnding the optimal set of next votes to request is intractable . T HEOREM 3 ( H ARDNESS OF N EXT V OTES ) . Finding the vote multiset Q that maximizes P a ∈ A ( Q ) max i P ( π − 1 ( 1 ) = i , a ∧ W ) is NP - Hard , even for a single vote . P ROOF . ( Sketch ) Our proof for the Next Votes problem uses a reduction from the same NP - Hard problem described in Sec - tion 2 . 3 , i . e . , determining Kemeny winners . We are given a graph G where we wish to ﬁnd a Kemeny winner . We add an extra vertex v to this graph to create a new graph , G (cid:3) , where v does not have any incoming or outgoing arcs . By deﬁni - tion , v is a Kemeny winner in G (cid:3) , since trivially , v can be placed anywhere in the permutation without changing the number of arcs that are respected . Therefore , there are at least two Kemeny win - ners in G (cid:3) . Recall , however , that our goal is to return a Kemeny winner in G (cid:3) , not in G . Now , consider the solution to the Next Votes problem on G (cid:3) , where an additional vote is requested . As in the proof of Theo - rem 1 , we set p to be very close to 1 . It can be shown that the solution to the Next Votes problem on G (cid:3) consists of two vertices , such that they are both Kemeny winners on G (cid:3) . ( Note that v may be one of the vertices , but at least one more vertex is returned . ) These vertices ( if they are not v ) are also Kemeny winners in G . Thus , the Kemeny winner determination problem on G can be reduced to the Next Votes ( with one vote ) problem on G (cid:3) . The details of this proof are available in the extended technical report [ 15 ] . # P - Hardness of Probability Computations : We next show that computing Equation 10 is # P - Hard . T HEOREM 4 ( # P - H ARDNESS OF N EXT V OTES ) . Computing P a ∈ A ( Q ) max i P ( π − 1 ( 1 ) = i , a ∧ W ) is # P - Hard , even for a Q with a single vote . P ROOF . ( Sketch ) Our proof uses a reduction from the # P - Hard problem of counting linear extensions in a DAG . Consider a DAG G = ( V , A ) . We now add two additional vertices , x and y , such that there is an arc from each of the vertices in G to x and to y giving a new graph G (cid:3) = ( V (cid:3) , A (cid:3) ) . 392 Figure 4 : How should we select additional votes to request ? Consider the computation of P a ∈ A ( Q ) max i P ( π − 1 ( 1 ) = i , a ∧ W ) for Q = { { x , y } } for G (cid:3) , which simpliﬁes to : max i P π : i wins P ( W ∧ ( x > y ) | π ) + max i P π : i wins P ( W ∧ ( y > x ) | π ) . The ﬁrst of these two terms is maximized when x is the maxi - mum , and the second term is maximized when y is the maximum . Both terms are identical , since x and y are identical , so we focus on only one of the terms . Let F ( p ) = P π : x wins P ( W ∧ x > y | π ) . Using a calculation similar to that used to derive Equation 5 , we have : F ( p ) = p | A (cid:3) | × P | A (cid:3) | i = 0 a i ( 1 − pp ) | A (cid:3) | − i . We are interested in a | A (cid:3) | , the number of permutations that correspond to linear exten - sions . Once again , by repeating the trick in Theorem 2 , we may use multiple values for p to generate different graphs G (cid:3) , and use the probability computation to derive many equations F ( p ) corre - sponding to different p , and then derive the value of a | A (cid:3) | using Lagrange’s interpolation . Therefore , counting the number of linear extensions in G can be reduced to a polynomial number of instances of computing the probability expression corresponding to the Next Votes problem . 3 . 3 Selection and Evaluation of Additional Votes We next present a general framework to select and evaluate ad - ditional votes for the Next Votes Problem . Our approach is the following : 1 . score all objects with a scoring function s using initial vote matrix W 2 . select a batch of b votes to request 3 . evaluate the new matrix W (cid:3) ( initial votes in W and addi - tional b votes ) with a scoring function f to predict the maxi - mum object in O . This framework is displayed in more detail in Algorithm 3 . In Step 1 , we use a scoring function s ( · ) to score each object , and in Step 3 , we use a scoring function f ( · ) to evaluate the new matrix W (cid:3) to predict the maximum object in O . We brieﬂy discuss the choice of these scoring functions when presenting experimental re - sults later in Section 3 . 4 . For now , we assume the use of a scoring function in Step 1 which scores objects proportional to the proba - bility that they are the maximum object in O . It is important to note that our general framework assumes no knowledge of worker accu - racy p , unlike in ML vote selection . We next focus our attention upon how to select b additional votes ( Step 2 ) . Algorithm 3 General Vote Selection Framework Require : n objects , vote matrix W , budget b Ensure : ans = predicted maximum object compute score s [ · ] for all objects using function s { Step 1 } initialize multiset Q { of votes to request } sort all objects by s [ · ] , store object indices in index [ · ] select b votes for Q using a vote selection strategy { Step 2 } submit batch Q update W with new votes from workers compute ﬁnal score f [ · ] for all objects using function f { Step 3 } ans ← argmax i f [ i ] Heuristic Vote Selection Strategies : How should we select pairs of objects for human workers to compare , when given a vote budget of b votes ? Since ML vote selection is computationally infeasible , we consider four efﬁcient polynomial - time vote selection strate - gies : Paired , Max , Greedy , and Complete Tournament strategies . For ease of explanation , we use the graph in Figure 4 as an ex - ample . Before executing a vote selection strategy , we assume that each object has been scored by a scoring function in Step 1 of the framework , denoted by s [ · ] in Algorithm 3 . As a running example to explain our strategies , we assume that our PageRank heuristic ( Section 2 . 4 ) is used as the scoring function in Step 1 : object A has score 0 . 5 , objects B and E each have score 0 . 25 , and objects C , D , and F have score 0 . Without loss of generality , assume that the ﬁnal rank order of the objects , before next vote selection , is ( A , B , E , C , D , F ) . The ﬁrst strategy we consider is Paired vote selection ( PAIR ) . In this strategy , pairs of objects are selected greedily , such that no object is included in more than one of the selected pairs . For ex - ample , with a budget of b = 2 , the strategy asks human workers to compare the rank 1 and rank 2 objects , and the rank 3 and rank 4 objects , where rank is determined by the scoring function from Step 1 in Algorithm 3 . The idea behind this strategy is to restrict each object to be involved in at most one of the additional votes , thus distributing the b votes among the largest possible set of ob - jects . This can be anticipated to perform well when there are many objects with similar scores , e . g . , when there are many objects in the initial vote graph G v which have equally high chances of being the maximum object . Considering the example in Figure 4 , for b = 2 , this strategy requests the votes ( A , B ) and ( E , C ) . The second strategy we consider is Max vote selection ( MAX ) . In this strategy , human workers are asked to compare the top - ranked object against other objects greedily . For example , with a budget of b = 2 , this strategy asks human workers to compare the rank 1 and rank 2 objects , and the rank 1 and rank 3 objects , where rank is determined by the scoring function in Step 1 in Algorithm 3 . Con - sidering again the example in Figure 4 , for b = 2 , this strategy requests the votes ( A , B ) and ( A , E ) . The third strategy we consider is Greedy vote selection ( GREEDY ) . In this strategy , all possible comparisons ( unordered object pairs ) are weighted by the product of the scores of the two objects , where the scores are determined in Step 1 of Algorithm 3 . In other words , a distribution is constructed across all possible object pairs , with higher weights assigned to object pairs involving high scoring ob - jects ( which are more likely to be the maximum object in O ) . After weighting all possible object pairs , this strategy submits the b high - est weight pairs for human comparison . Considering the example in Figure 4 , object pairs ( A , B ) and ( A , E ) has weight 0 . 125 , ( B , E ) has weight 0 . 0625 , and all other pairs have weight 0 . For a budget b = 2 , this strategy requests the votes ( A , B ) and ( A , E ) . The fourth strategy we consider is Complete Tournament vote se - lection ( COMPLETE ) . In this strategy , we construct a single round - robin tournament among the K objects with the highest scores from Step 1 of Algorithm 3 , where K is the largest number such that K ∗ ( K + 1 ) 2 ≤ b . In a single round - robin tournament , each of the K objects is compared against every other exactly once . For the re - maining r = b − K ∗ ( K + 1 ) 2 votes , we consider all object pairs con - taining the ( K + 1 ) st ( largest scoring ) object and one of the ﬁrst K objects , and weight each of these K object pairs by the prod - uct of the scores of the two objects ( as we did with Greedy vote selection ) . We then select the r object pairs with highest weight . The idea behind the Complete Tournament strategy is that a round - robin tournament will likely determine the largest object among the set of K objects . If the set of K objects contains the true max , this strategy can be anticipated to perform well . Regarding the selection of the remaining votes , the strategy can be thought of as augment - 393 0 0 . 2 0 . 4 0 . 6 0 . 8 1 50 100 150 200 P r e c i s i on a t 1 Initial Num Votes ML - ML ML - PR RANDPAIR GREEDY COMPLETEMAX 0 0 . 2 0 . 4 0 . 6 0 . 8 1 50 100 150 200 P r e c i s i on a t 1 Initial Num Votes ML - ML ML - PR RANDPAIR GREEDY COMPLETEMAX Figure 5 : Precision at 1 versus number of initial votes . 1 additional vote , 7 objects , p = 0 . 75 . ing the K object tournament to become an incomplete K + 1 object tournament , where the remaining votes are selected greedily to best determine if the ( K + 1 ) st object can possibly be the maximum ob - ject in O . Considering the example in Figure 4 , for b = 2 , there is a 2 - object tournament among objects A and B and vote ( A , B ) is re - quested . Then , for the remaining vote , the strategy greedily scores object pairs which contain both the next highest ranked object not in the tournament , object E , and one of the initial 2 objects . Object pair ( A , E ) will be scored 0 . 125 and ( B , E ) will be scored 0 . 0625 , so the second vote requested is ( A , E ) . 3 . 4 Experiments Which of our four vote selection heuristics ( PAIR , MAX , GREEDY , or COMPLETE ) is the best strategy ? We now describe a set of ex - periments measuring the prediction performance of our heuristics for various sets of parameters . When evaluating our vote selec - tion strategies , we utilized a uniform vote sampling procedure , de - scribed previously in Section 2 . 5 , to generate an initial vote matrix W . Then , in Step 1 of our vote selection framework ( Algorithm 3 ) , we adopted our PageRank heuristic ( Section 2 . 4 ) as our scoring function s ( · ) to score each object in O . In Step 2 , we executed each of our vote selection strategies using these scores . In Step 3 , we used our PageRank heuristic as our scoring function f ( · ) to score each object in the new matrix W (cid:3) ( composed of both the ini - tial votes in vote matrix W and the b requested additional votes ) , and generate ﬁnal predictions for the maximum object in O . Note that we performed several experiments contrasting prediction per - formance of PageRank versus other possible scoring functions and found PageRank to be superior to the other functions . Hence , we selected PageRank as the scoring function for both Step 1 and Step 3 of our vote selection framework . • ML vote selection outperforms heuristic strategies when results are evaluated with ML scoring . • However , when ML vote selection is evaluated with PageRank ( e . g . , like the heuristics ) , prediction perfor - mances of all methods are similar . For a ﬁrst experiment , we compare the prediction performance ( Precision at 1 ) of our four vote selection heuristics ( and random initial vote selection ( RAND ) ) against the “optimal” strategy , i . e . , the Maximum Likelihood ( ML ) vote selection procedure described in Section 3 . 1 . Recall that ML can be used in two places : when selecting additional votes ( as in Section 3 . 1 ) , and when predicting the max given the initial plus additional votes ( e . g . , ML evaluation in Section 2 . 2 ) . We use ML - ML to refer to using ML for both tasks , this gives the best possible strategy . To gain additional insights , we also consider ML - PR , a strategy where ML is used to select the ad - ditional votes , and PageRank is used to select the winner . Since ML is computationally very expensive , for this experiment we consider a small problem : select one additional vote given a set of 50 ( 2 . 5x 0 . 1 0 . 15 0 . 2 0 . 25 0 . 3 0 . 35 0 . 4 0 5 10 15 20 P a t 1 Num Additional Votes RANDPAIR GREEDY COMPLETEMAX - 0 . 1 0 0 . 1 0 . 2 0 . 3 0 . 4 0 . 5 0 . 6 0 . 7 0 2 4 6 8 10 12 14 16 18 20 G a i n ( P a t 1 ) Vote Number RANDPAIR GREEDY COMPLETEMAX Figure 6 : Precision at 1 versus number of additional votes ( left ) . Incremen - tal Gain ( P @ 1 ) of each vote relative to a 0 additional votes baseline ( right ) . 100 objects , p = 0 . 95 , 200 initial votes . 0 0 . 05 0 . 1 0 . 15 0 . 2 0 . 25 0 . 3 0 . 35 0 . 4 0 . 5 0 . 6 0 . 7 0 . 8 0 . 9 1 P a t 1 Worker Accuracy RANDPAIR GREEDY COMPLETEMAX 0 0 . 05 0 . 1 0 . 15 0 . 2 0 . 25 0 . 3 0 . 35 20 40 60 80 100 120 140 160 180 200 P a t 1 Initial Num Votes 5 OBJ 10 OBJ 20 OBJ Figure 7 : Precision at 1 versus worker accuracy ( left ) . 100 objects , 100 initial votes , 15 additional votes . Variations of the Complete Tournament strategy , 10 additional votes ( right ) . 5 OBJ = compare 5 objects 4 times each . 10 OBJ = compare 10 objects 2 times each . 20 OBJ = compare 20 objects 1 time each . 100 objects , p = 0 . 95 . Edge Coverage ) to 200 initial votes ( 10x Edge Coverage ) among a set of 7 objects , p = 0 . 75 . Our experimental results are displayed in Figure 5 . First , as ex - pected , ML - ML has the best performance . Clearly , ML - ML is do - ing a better job at selecting the additional vote and in selecting the winner . Of course , keep in mind that ML - ML is not feasible in most scenarios , and it also requires knowledge of the worker accuracy p . Nevertheless , the gap between ML - ML and the other strategies in - dicates there is potential room for future improvement beyond the heuristics we have developed . Second , we observe in Figure 5 that all other strategies , includ - ing ML - PR , perform similarly . The relative performance of ML - PR indicates that the gain achieved by ML - ML is due to its better pre - diction of the winner , as opposed to its choice for the next vote . In hindsight , this result is not surprising , since the selection of a single vote cannot be expected to have a large impact . ( We will observe larger impacts when we select multiple additional votes . ) The results also demonstrate that our vote selection heuristics show promise , since they seem to be doing equally well as ML , and since they often perform slightly better than RAND , at least for the se - lection of a single next vote . To evaluate our heuristics in larger scenarios , we conducted a series of experiments , and the results of some of those are summa - rized in Figures 6 , 7 ( left ) and 8 . To begin , we summarize some of the general trends that can be observed in these ﬁgures . General observations regarding all strategies : • As the number of additional votes increases , prediction performance increases . • As the number of additional votes increases , the gain from additional votes decreases ( though the decrease is not very dramatic ) . • As worker accuracy increases , prediction performance increases . • As worker accuracy increases , the gain from additional votes increases . We only explain the graph in Figure 6 ( right ) , since the others are self - explanatory . In this graph , the vertical axis shows the in - cremental P @ 1 gain at k additional votes , deﬁned as ( P @ 1 with k additional votes - P @ 1 with k − 1 additional votes ) / ( P @ 1 with 0 additional votes ) . As we can see , the information provided by 394 0 0 . 5 1 1 . 5 2 2 . 5 20 40 60 80 100 120 140 160 180 200 G a i n ( P a t 1 ) Initial Num Votes RANDPAIRMAX GREEDY COMPLETE 0 0 . 5 1 1 . 5 2 2 . 5 3 3 . 5 4 20 40 60 80 100 120 140 160 180 200 G a i n ( P a t 1 ) Initial Num Votes RANDPAIRMAX GREEDY COMPLETE Figure 8 : Gain ( P @ 1 ) relative to a 0 additional votes baseline vs number of initial votes . 100 objects , p = 0 . 95 . 5 add . votes ( left ) , 15 add . votes ( right ) . 0 0 . 5 1 1 . 5 2 2 . 5 3 3 . 5 4 20 40 60 80 100 120 140 160 180 200 G a i n ( P a t 1 ) Initial Num Votes RANDPAIRMAX GREEDY COMPLETE 0 0 . 5 1 1 . 5 2 2 . 5 3 3 . 5 4 4 . 5 5 20 40 60 80 100 120 140 160 180 200 G a i n ( P a t 1 ) Initial Num Votes RANDPAIRMAX GREEDY COMPLETE Figure 9 : Objects are divided into k initial object types . Gain ( P @ 1 ) rela - tive to a 0 additional votes baseline vs number of initial votes . 100 objects , p = 0 . 95 , 15 additional votes . 1 type ( left ) , 20 types ( right ) . additional votes is more valuable when there are fewer initial votes ( second bullet above ) . The Complete Tournament and Greedy strategies are signif - icantly better than the Max and Paired strategies . We can also use Figures 6 , 7 ( left ) and 8 to compare our heuris - tics . First , notice that the difference between heuristics can be very signiﬁcant . For instance , in Figure 8 ( left ) we see that the Paired ( PAIR ) strategy provides a 0 . 7x P @ 1 gain for 5 additional votes ( 100 initial votes , p = 0 . 95 ) , while the Complete Tournament ( COMPLETE ) strategy provides a 1 . 5x P @ 1 gain , where we mea - sure P @ 1 gain as ( P @ 1 with k votes - P @ 1 with 0 votes ) / ( P @ 1 with 0 votes ) . Second , we observe that the Complete Tournament and Greedy ( GREEDY ) vote selection strategies consistently out - perform the Max ( MAX ) and Paired strategies in all scenarios . In particular , in Figure 6 ( left ) , we observe that the prediction perfor - mances of the Complete Tournament and Greedy strategies steadily improve with additional votes , while the Max and Paired strategies taper off . This indicates that when a larger vote budget b is avail - able for additional votes , the additional votes will be better utilized by the more sophisticated strategies ( Complete Tournament and Greedy ) as compared to the simpler strategies ( Max and Paired ) . Given only votes between objects of the same type : • The value of additional votes is greater when it is more difﬁcult to predict the maximum object . • The Complete Tournament strategy is the best strategy . In our scenarios so far , the Complete Tournament and Greedy strategies perform similarly . To differentiate between the two , we explored different ways in which the initial votes could be gen - erated . ( Recall that up to this point we have been randomly se - lecting the pairs of objects that are compared by the initial votes . ) We next discuss one of these possible different vote generation schemes . Suppose that our objects are of different types ( e . g . , soft - cover books , hardcover books , e - books , etc . ) , and for some reason initial votes between objects of the same type are much more likely than across types . For example , it is more likely that two e - books have been compared , rather than one e - book and one hard - cover book . ( The situation is analogous to sporting events , where intra - league games are more likely than inter - league games . ) For our experiment , we consider an extreme instance where there are no initial votes involving objects of different types . In partic - ular , we divide our set O of n objects into k disjoint object types . When votes are sampled for the initial vote matrix W , sampling of votes is only permitted between objects of the same type . Keep in mind that predicting the maximum object in O is more difﬁ - cult when there are more object types because each object type will likely have a leader ( greatest object ) , each of these leaders will have on average similar probabilities of being the maximum object ( since object type groups are likely of similar size ) , and the ini - tial vote matrix W provides no information regarding comparisons between these leaders . We perform experiments for different values of k ( e . g . , different numbers of initial object types ) , Figure 9 displays Precision at 1 gain relative to a 0 additional votes baseline for k = 1 and k = 20 . See the extended technical report [ 15 ] for comprehensive results . We observe that the P @ 1 gain increases for the Complete Tourna - ment and Greedy strategies as k increases , implying that the value of additional votes is greater when it is more difﬁcult to predict the maximum object from the initial vote matrix . That is , in the harder problem instances ( larger k ) , the additional votes play a more crit - ical role in comparing the object type leaders . More importantly , the Complete Tournament strategy outperforms the Greedy strategy ( and the others too ) in this more challenging scenario . Finally , we conduct a more in - depth study of the Complete Tour - nament vote selection strategy and examine the beneﬁt of vote re - dundancy . Given a limited budget , should the Complete Tourna - ment strategy select fewer top objects and propose more redundant votes , or should it select more objects and ask fewer votes per pair ? For instance , the Complete Tournmament strategy could select the top three objects and submit four votes for each pair , for a total of 12 additional votes . Or it could select the top 4 objects , and for each of the possible 6 comparisons , request 2 votes ( for the same 12 total additional votes ) . What is the best approach ? Figure 7 ( right ) displays the Precision at 1 of the Complete Tour - nament strategy for 10 additional votes , where the votes are uni - formly and randomly distributed among the 5 , 10 , or 20 objects in O with highest score ( as provided in Step 1 of Algorithm 3 ) . We ﬁnd that distributing the 10 votes among 5 objects , where each object is compared against every other , leads to the best prediction performance . That is , we do not observe any beneﬁt for distributing votes among a larger set of objects when using the Complete Tour - nament strategy . The strategy performs well only when additional votes provide the ability to rank the objects in a set . Assuming that votes are distributed randomly among object pairs , the Complete Tournament strategy is able to order the set only when most objects in the set are compared against each other . Note that Figure 7 ( right ) is only an illustration of the interaction between the number of top objects selected , and the redundancy of votes . The results will vary depending upon worker accuracy and the vote budget b . 4 . RELATED WORK As far as we know , we are the ﬁrst to address the Next Votes Problem , and there is no relevant literature that directly addresses this problem . Thus , in this section , we review work related to the Judgment Problem . The algorithms and heuristics we presented for the Judgment Problem are primarily drawn from three diverse topic areas : paired comparisons , social choice , and ranking . The Judgment Problem has its roots in the paired comparisons problem , ﬁrst studied by statisticians decades ago [ 20 , 11 ] . In the paired comparisons problem , given a set of pairwise observations regarding a set of objects , it is desired to obtain a ranking of the objects . In contrast , in the Judgment Problem , we are interested in predicting the maximum object . The Judgment Problem also draws upon classical work in the economic and social choice literature regarding Winner Determi - nation in elections [ 25 , 31 ] . Numerous voting rules have been used ( Borda , Condorcet , Dodgson , etc . ) to determine winners in elec - 395 tions [ 28 ] . The voting rules most closely related to our work are the Kemeny rule [ 19 ] and Slater rule [ 29 ] . A Kemeny permutation minimizes the total number of pairwise inconsistencies among all votes , whereas a Slater permutation minimizes the total number of pairwise inconsistencies in the majority - vote graph [ 6 ] . An object is considered a Kemeny winner or Slater winner if it is the greatest object in a Kemeny permutation or Slater permutation . We believe our ML formulation is more principled than these voting rules , since ML aggregates information across all possible permutations . For example , in the graph of Figure 1 , while C and D are both admissible solutions for the Kemeny rule , ML returns D as an answer , since D has almost one and a half more times the probability of being the maximum object compared to C . No prior work about the Judgment Problem , to our knowledge , uses the same approach as our ML formulation . In the recent social choice literature , the research most closely related to ours has been work by Conitzer et al . regarding Kemeny permutations [ 9 ] . Conitzer has studied various voting rules and determined for which of them there exist voter error models where the rules are ML estimators [ 8 ] . In our study , we focused upon the opposite question : for a speciﬁc voter error model , we presented both Maximum Likelihood , as well as heuristic solutions , to predict the winner . Our work is also related to research in the theory community regarding ranking in the presence of errors [ 21 , 1 ] and noisy com - putation [ 13 , 2 ] . Both Kenyon et al . and Ailon et al . present ran - domized polynomial - time algorithms for feedback arc set in tour - nament graphs . Their algorithms are intended to approximate the optimal permutation , whereas we seek to predict the optimal win - ner . Feige et al . and Ajtai et al . present algorithms to solve a va - riety of problems , including the Max Problem , but their scenarios involve different comparison models or error models than ours . More generally , in the last several years , there has been a sig - niﬁcant amount of work regarding crowdsourcing systems , both inside [ 14 , 16 ] and outside [ 22 , 23 ] the database community . Of note is recent work by Tamuz et al . [ 30 ] on a crowdsourcing sys - tem that learns a similarity matrix across objects , while adaptively requesting votes . Not as much work has been done regarding gen - eral crowdsourcing algorithms [ 24 , 27 ] . Instead , most algorithmic work in crowdsourcing has focused upon quality control [ 3 , 18 ] . 5 . CONCLUSION In a conventional database system , ﬁnding the maximum ele - ment in a set is a relatively simple procedure . It is thus some - what surprising that in a crowdsourcing database system , ﬁnding the maximum is quite challenging , and there are many issues to consider . The main reason for the complexity , as we have seen , is that our underlying comparison operation may give an incorrect an - swer , or it may even not complete . Thus , we need to decide which is the “most likely” max ( Judgment Problem ) , and which additional votes to request to improve our answer ( Next Votes Problem ) . Our results show that solving either one of these problems op - timally is very hard , but fortunately we have proposed effective heuristics that do well . There is a gap between the optimal solution and what our heuristics ﬁnd ( as seen for example in Figure 5 ) , but we believe that it will be very hard to close this gap without incur - ring high computational costs . Among the heuristics , we observed signiﬁcant differences in their predictive ability , indicating that it is very important to carefully select a good heuristic . Our results indicate that in many cases ( but not all ) our proposed PageRank heuristic is the best for the Judgment Problem , while the Complete Tournament heuristic is the best for the Next Votes Problem . Our results are based on a relatively simple model where object comparisons are pairwise , and worker errors are independent . Of course , in a real crowdsourced database system these assumptions may not hold . Yet we believe it is important to know that even with the simple model , the optimal strategies for the Judgment Problem and Next Votes Problem are NP - Hard . Furthermore , our heuristics can be used even in more complex scenarios , since they do not de - pend on the evaluation model . Even though they can be used when the model assumptions do not hold , we believe it is important to un - derstand how the heuristics perform in the more tractable scenario we have considered here . Acknowledgements : This research has been supported by NSF grant IIS - 1009916 . 6 . REFERENCES [ 1 ] N . Ailon et al . Aggregating inconsistent information : ranking and clustering . JACM , 55 ( 5 ) , 2008 . [ 2 ] M . Ajtai et al . Sorting and selection with imprecise comparisons . Automata , Languages and Programming , 2009 . [ 3 ] O . Alonso et al . Crowdsourcing for relevance evaluation . In SIGIR Forum , 2008 . [ 4 ] P . Boldi et al . PageRank as a function of the damping factor . In WWW , 2005 . [ 5 ] F . Brandt et al . PageRank as a weak tournament solution . In WINE , 2007 . [ 6 ] Y . Chevaleyre et al . A short introduction to computational social choice . In SOFSEM , 2007 . [ 7 ] W . Cohen et al . Learning to order things . Journal of Artiﬁcial Intelligence Research , 10 : 243 – 270 , 1999 . [ 8 ] V . Conitzer et al . Common voting rules as maximum likelihood estimators . In UAI , 2005 . [ 9 ] V . Conitzer et al . Improved bounds for computing kemeny rankings . In AAAI , 2006 . [ 10 ] D . Coppersmith et al . Ordering by weighted number of wins gives a good ranking for weighted tournaments . In SODA , 2006 . [ 11 ] H . A . David . The method of paired comparisons . 1963 . [ 12 ] H . A . David . Ranking from unbalanced paired - comparison data . Biometrika , 74 ( 2 ) : 432 – 436 , 1987 . [ 13 ] U . Feige et al . Computing with noisy information . SIAM J . Comput . , 23 ( 5 ) : 1001 – 1018 , 1994 . [ 14 ] M . Franklin et al . CrowdDB : answering queries with crowdsourcing . In SIGMOD , 2011 . [ 15 ] S . Guo et al . So who won ? Dynamic max discovery with the crowd . Technical Report , 2011 . http : / / ilpubs . stanford . edu : 8090 / 1032 / [ 16 ] P . Heymann et al . Turkalytics : analytics for human computation . In WWW , 2011 . [ 17 ] O . Hudry . On the complexity of Slater’s problems . European Journal of Operational Research , 203 ( 1 ) : 216 – 221 , 2010 . [ 18 ] P . Ipeirotis et al . Quality management on amazon mechanical turk . In KDD Workshop on Human Computation , 2010 . [ 19 ] J . Kemeny . Mathematics without numbers . Daedalus , 1959 . [ 20 ] M . G . Kendall et al . On the method of paired comparisons . Biometrika , 31 ( 3 / 4 ) : 324 – 345 , 1940 . [ 21 ] C . Kenyon - Mathieu et al . How to rank with few errors . In STOC , 2007 . [ 22 ] A . Kittur et al . Crowdsourcing user studies with mechanical turk . In CHI , 2008 . [ 23 ] G . Little et al . TurKit : human computation algorithms on mechanical turk . In UIST , 2010 . [ 24 ] A . Marcus et al . Human - powered sorts and joins . PVLDB , 2011 . [ 25 ] H . Moulin . Choosing from a tournament . Social Choice and Welfare , 3 ( 4 ) : 271 – 291 , 1986 . [ 26 ] L . Page et al . The PageRank citation ranking : Bringing order to the web . Technical Report , 1998 . [ 27 ] A . Parameswaran et al . Human - assisted graph search : it’s okay to ask questions . PVLDB , 2011 . [ 28 ] D . Saari . Basic geometry of voting . 1995 . [ 29 ] P . Slater . Inconsistencies in a schedule of paired comparisons . Biometrika , 48 ( 3 / 4 ) : 303 – 312 , 1961 . [ 30 ] O . Tamuz et al . Adaptively learning the crowd kernel . In ICML , 2011 . [ 31 ] P . Young . Optimal voting rules . J . Econ . Perspectives , 1995 . 396