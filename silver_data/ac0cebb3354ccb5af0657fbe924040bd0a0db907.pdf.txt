Fast quantum state reconstruction via accelerated non - convex programming Junhyung Lyle Kim 1 , George Kollias 2 , Amir Kalev 3 , Ken X . Wei 2 , Anastasios Kyrillidis 1 1 Computer Science , Rice University , Houston , TX 77098 , USA 2 IBM Quantum , IBM T . J . Watson Research Center , Yorktown Heights , NY 10598 , USA 3 Information Sciences Institute , University of Southern California , Arlington , VA 22203 , USA March 24 , 2022 Abstract We propose a new quantum state reconstruction method that combines ideas from compressed sensing , non - convex optimization , and acceleration methods . The algorithm , called Momentum - Inspired Factored Gradient Descent ( MiFGD ) , extends the applicability of quantum tomography for larger systems . Despite being a non - convex method , MiFGD converges provably close to the true density matrix at an accelerated linear rate , in the absence of experimental and statistical noise , and under common assumptions . With this manuscript , we present the method , prove its convergence property and provide Frobenius norm bound guarantees with respect to the true density matrix . From a practical point of view , we benchmark the algorithm performance with respect to other existing methods , in both synthetic and real experiments performed on an IBM’s quantum processing unit . We ﬁnd that the proposed algorithm performs orders of magnitude faster than state of the art approaches , with the same or better accuracy . In both synthetic and real experiments , we observed accurate and robust reconstruction , despite experimental and statistical noise in the tomographic data . Finally , we provide a ready - to - use code for state tomography of multi - qubit systems . Introduction Quantum tomography is one of the main procedures to identify the nature of imperfections and deviations in quantum processing unit ( QPU ) implementation [ 9 , 27 ] . Generally , quantum tomography is composed of two main parts : i ) measuring the quantum system , and ii ) analyzing the measurement data to obtain an estimation of the density matrix ( in the case of state tomography [ 9 ] ) , or of the quantum process ( in the case of process tomography [ 66 ] ) . In this manuscript , we focus on the case of state tomography . As the number of free parameters that deﬁne quantum states and processes scale exponentially with the number of subsystems , generally quantum tomography is a non - scalable protocol [ 38 ] . In particular , quan - tum state tomography ( QST ) suffers from two bottlenecks related to its two main parts . The ﬁrst concerns with the large data one needs to collect to perform tomography ; the second concerns with numerically searching in an exponentially large space for a density matrix that is consistent with the data . There have been various approaches over the years to improve the scalability of QST , as compared to full QST [ 98 , 48 , 11 ] . Focusing on the data collection bottleneck , to reduce the resources required , prior in - formation about the unknown quantum state is often assumed . For example , in compressed sensing QST [ 38 , 49 ] , it is assumed that the density matrix of the system is low - rank . In neural network QST [ 93 , 12 , 94 ] , one assumes real and positive wavefunctions , which occupy a restricted place in the landscape of quan - tum states . Extensions of neural networks to complex wave - functions , or the ability to represent density matrices of mixed states , have been further considered in the literature , after proper reparameterization of the Restricted Boltzmann machines [ 93 ] . The prior information considered in these cases is that they are characterized by structured quantum states , which is the reason for the very high performances of neural 1 a r X i v : 2104 . 07006v4 [ qu a n t - ph ] 23 M a r 2022 network QST [ 93 ] . 1 Similarly , in matrix - product - state tomography [ 23 , 58 ] , one assumes that the state - to - be - estimated can be represented with low bond - dimension matrix - product state . Focusing on the computational bottleneck , several works introduce sophisticated numerical methods to improve the efﬁciency of QST . Particularly , variations of gradient descent convex solvers—e . g . , [ 35 , 16 , 86 , 44 ] —are time - efﬁcient in idealized ( synthetic ) scenarios [ 44 ] , and only after a proper distributed system design [ 42 ] . The problem is that achieving such results seems to require utilizing special - purpose hardware ( like GPUs ) . Thus , going beyond current capabilities requires novel methods that efﬁciently search in the space of density matrices under more realistic scenarios . Importantly , such numerical methods should come with guarantees on their performance and convergence . The setup we consider here is that of an n - qubit state , under the prior assumption that the state is close to a pure state , and thus its density matrix is of low - rank . This assumption is justiﬁed by state - of - the - art experiments , where our aim is to manipulate the pure states by unitary maps . From a theoretical perspective , the low - rank assumption means that we can use compressed sensing techniques , which allow the recovery of the density matrix from relatively few measurement data [ 63 ] . Indeed , by now , compressed sensing QST is widely used for estimating highly - pure quantum states , e . g . , [ 83 , 54 , 28 , 38 ] . However , compressed sensing QST usually relies on convex optimization for the estimation part [ 49 ] ; this limits the applicability to relatively small system sizes [ 38 ] . On the other hand , non - convex optimization can preform much faster than its convex counterpart [ 57 ] . Although non - convex optimization typically lacks convergence guarantees , it was recently shown that one can formulate compressed sensing QST as a non - convex problem and solve it with rigorous convergence guarantees ( under certain but generic conditions ) , allowing state estimation of larger system sizes [ 57 ] . Following the non - convex path , we introduce a new algorithm to the toolbox of QST—the Momentum - Inspired Factored Gradient Descent ( MiFGD ) . Our approach combines ideas from compressed sensing , non - convex optimization , and acceleration techniques , to allow pushing QST beyond current capabilities . MiFGD includes acceleration motions per iteration , that non - trivially complicate theoretical convergence analysis . Nevertheless , we justify the efﬁcacy of the algorithm both in theory – by achieving an accelerated linear rate – and in practice . The contributions of the paper are summarized as follows : i ) We prove that the non - convex MiFGD algorithm has indeed accelerated linear convergence rate , in terms of iterate distance , in the noiseless measurement data case and under common assumptions . ii ) We provide QST results based on real data from IBM’s quantum computers up to 8 - qubits , contributing to recent efforts on testing QST algorithms in real quantum data [ 83 ] . Our synthetic examples scale up to 12 - qubits effortlessly , leaving the space for an efﬁcient , hardware - aware implementation open for future work . iii ) We show in practice that MiFGD allows faster estimation of quantum states compared to state - of - the - art convex and non - convex algorithms , including recent deep learning approaches [ 93 , 12 , 94 , 31 ] , even in the presence of statistical noise in the measurement data . iv ) We exploit parallel computations in MiFGD by extending its implementation to enable efﬁcient , parallel execution over shared and distributed memory systems . This way , we experimentally showcase the scalability of this work , which is particularly critical for tackling larger quantum system sizes . v ) We provide implementation of our approach , compatible to the open - source software Qiskit [ 81 ] , at https : / / github . com / gidiko / MiFGD . 1 [ 93 ] considers also the case of a completely unstructured case and test the limitation of this technique , which does not perform as expected due to lack of structure . 2 Results Setup We consider the estimation of a low - rank density matrix ρ (cid:63) ∈ C d × d on an n - qubit Hilbert space , d = 2 n , through the following (cid:96) 2 - norm reconstruction objective : min ρ ∈ C d × d f ( ρ ) : = 12 (cid:107)A ( ρ ) − y (cid:107) 22 subject to ρ (cid:23) 0 , rank ( ρ ) ≤ r . ( 1 ) Here , y ∈ R m is the measured data 2 ( observations ) , and A ( · ) : C d × d → R m is the linear sensing map , where m (cid:28) d 2 . The sensing map relates the density matrix ρ (cid:63) to ( expected , noiseless ) observations through the Born rule , ( A ( ρ ) ) i = Tr ( A i ρ ) , where A i ∈ C d × d , i = 1 , . . . , m , are matrices closely related to the mea - sured observable or the POVM elements of appropriate dimensions . For concreteness , we focus on the least squares objective function . 3 The constraint that a density matrix is a non - negative matrix , ρ (cid:23) 0 , is a convex constraint . In contrast , the constraint on its rank , rank ( ρ ) ≤ r , is a non - convex constraint that promotes a low - rank solution . Following compressed sensing QST results [ 49 ] , the constraint Tr ( ρ ) = 1 ( that should be satisﬁed , by deﬁnition , by any density matrix ) can be ignored , without affecting the scaling of the precision of the ﬁnal estimation . A pivotal assumption is that the linear map A satisﬁes the restricted isometry property : Deﬁnition 1 ( Restricted Isometry Property ( RIP ) [ 82 ] ) . A linear operator A : C d × d → R m satisﬁes the RIP on rank - r matrices , with parameter δ r ∈ ( 0 , 1 ) , if the following holds for any rank - r matrix X ∈ C d × d , with high probability : ( 1 − δ r ) · (cid:107) X (cid:107) 2 F ≤ (cid:107)A ( X ) (cid:107) 22 ≤ ( 1 + δ r ) · (cid:107) X (cid:107) 2 F . ( 2 ) Such maps ( almost ) preserve the Frobenius norm of low - rank matrices , and , as an extension , of low - rank Hermitian matrices . The intuition behind RIP is that A ( · ) behaves as almost a bijection between the subspaces C d × d and R m , when we focus on low rank matrices . Following recent works [ 57 ] , instead of solving Eq . ( 1 ) , we propose to solve a factorized version of it : min U ∈ C d × r 12 (cid:107)A ( UU † ) − y (cid:107) 22 , ( 3 ) where U † ∈ C r × d denotes the adjoint of U . The motivation for this reformulation is as follows : instead of representing the density matrix ρ as a d × d Hermitian matrix , and imposing the low - rank constraint as in Eq . ( 1 ) , we work in a space where low - rank density matrices are represented through factors U ∈ C d × r . The low - rankness of ρ is enforced through the factorization of the density matrix into a outer product of such a rectangular matrix representation U ∈ C d × r with its Hermitian conjugate , where d (cid:29) r . By rewriting ρ = UU † , for U ∈ C d × r , both the PSD constraint ( ρ (cid:23) 0 ) and the low - rankness constraint ( rank ( ρ ) ≤ r ) are directly satisﬁed , leading to the non - convex formulation ( 3 ) . Working in the factored space was shown [ 57 , 79 , 78 , 96 , 102 , 103 ] to improve time and space complexities . A common approach to solve ( 3 ) is to use gradient descent on the parameter U , with iterates generated by the rule : 4 U i + 1 = U i − η ∇ f ( U i U † i ) · U i ( 4 ) = U i − η A † (cid:16) A ( U i U † i ) − y (cid:17) · U i . ( 5 ) Here , U i ∈ C d × r , ∀ i . The operator A † : R m → C d × d is the adjoint of A , deﬁned as A † ( x ) = (cid:80) mi = 1 x i A i , for x ∈ R m . The hyperparameter η > 0 is the step size . This algorithm has been studied in [ 14 , 103 , 96 , 80 , 32 , 43 ] . We will refer to the above iteration as the Factored Gradient Descent ( FGD ) algorithm , as in [ 79 ] . In what follows , we will study the MiFGD algorithm , a momentum - inspired factored gradient descent . 2 Speciﬁc description on how y is generated and what it represents will follow . 3 Our results rely on standard optimization assumptions ( restricted smoothness and restricted strong convexity assumptions [ 68 ] ) . 4 We assume cases where ∇ f ( · ) = ∇ f ( · ) † . If this does not hold , the theory still holds by carrying around ∇ f ( · ) + ∇ f ( · ) † instead of just ∇ f ( · ) , after proper scaling . 3 Momentum - Inspired Factored Gradient Descent and Main Results The MiFGD algorithm is given in the Methods section . It is a two - step variant of FGD : U i + 1 = Z i − η A † (cid:16) A ( Z i Z † i ) − y (cid:17) · Z i , ( 6 ) Z i + 1 = U i + 1 + µ ( U i + 1 − U i ) . ( 7 ) Here , Z i is a rectangular matrix ( with the same dimension as U i ) that accumulates the “momentum” of the iterates U i . µ is the momentum parameter that weighs how the previous estimates U i will be mixed with the current estimate U i + 1 to generate Z i + 1 . The above iteration is an adaptation of Nesterov’s accelerated ﬁrst - order method for convex problems [ 69 ] . We borrow this momentum formulation , and we study how constant µ selections behave in non - convex problem formulations , such as in ( 3 ) . We note that the theory and algorithmic conﬁgurations in [ 69 ] do not generalize to non - convex problems , which is one of the contributions of this work . Albeit being a non - convex problem , we show that MiFGD converges at an accelerated linear rate around a neighborhood of the optimal value , akin to convex optimization problems [ 69 ] . An important observation is that the factorization ρ = UU † is not unique . For instance , suppose that U (cid:63) is an optimal solution for ( 3 ) ; then , for any rotation matrix R ∈ C r × r satisfying RR † = I , the matrix (cid:98) U = U (cid:63) R is also optimal for ( 3 ) . 5 To resolve this ambiguity , we use the distance between a pair of matrices as the minimum distance min R ∈O (cid:107) U − U (cid:63) R (cid:107) F up to rotations , where O = { R ∈ C r × r | RR † = I } . In words , we want to track how close an estimate U is to U (cid:63) , up to the minimizing rotation matrix . We are now ready to state the main theorem regarding the MiFGD algorithm : Theorem 1 ( MiFGD convergence rate ( Informal ) ) . Assume that A satisﬁes the RIP for some constant 0 < δ 2 r < 1 . Let y = A ( ρ (cid:63) ) denote a data set obtained by measuring a quantum system in a state ρ (cid:63) . Given a good initialization point U 0 and setting step size η and momentum µ appropriately , MiFGD converges with an accelerated linear rate to a region—with radius that depends on O ( µ ) —around ρ (cid:63) . “Accelerated linear rate” intuitively means that MiFGD ( provably ) enjoys smaller contraction factor com - pared to that of vanilla FGD . We refer to Theorem 2 of the Methods section for a formal statement . There , we state the conditions under which the simple MiFGD recursion in Eqs . ( 14 ) - ( 15 ) has an accelerated linear convergence rate in iterate distance , up to a constant error level proportional to the momentum parameter µ . The theorem assumes that the observations are noiseless ; that is , the observed data is y = A ( ρ (cid:63) ) , where ρ (cid:63) is the state of the system . Nevertheless , our experiments suggest that MiFGD is robust to statistical errors and noise in the data . The formal analysis of robustness to noisy data can be derived from our analysis and considered future work ; here , for clarity , we consider this work as the basis for that analysis . Experimental setup ρ (cid:63) density matrices and quantum circuits 6 In our numerical and real experiments , we have considered ( different subsets of ) the following n - qubit pure quantum states : 1 . The ( generalized ) GHZ state : | GHZ ( n ) (cid:105) = | 0 (cid:105) ⊗ n + | 1 (cid:105) ⊗ n √ 2 , n > 2 . 2 . The ( generalized ) GHZ - minus state : | GHZ − ( n ) (cid:105) = | 0 (cid:105) ⊗ n − | 1 (cid:105) ⊗ n √ 2 , n > 2 . 5 To see this , observe that ρ (cid:63) = U (cid:63) U (cid:63) † = U (cid:63) IU (cid:63) † = U (cid:63) RR † U (cid:63) † = (cid:98) U (cid:98) U † . 6 The content in this subsection is implemented in the states . py component of our complementary software package . 4 3 . The Hadamard state : | Hadamard ( n ) (cid:105) = (cid:18) | 0 (cid:105) + | 1 (cid:105) √ 2 (cid:19) ⊗ n . 4 . A random state | Random ( n ) (cid:105) . We have implemented these states ( on the IBM quantum simulator and / or the IBM’s QPU ) using the fol - lowing circuits . The GHZ state | GHZ ( n ) (cid:105) is generated by applying the Hadamard gate to one of the qubits , and then applying n − 1 CNOT gates between this qubit ( as a control ) and the remaining n − 1 qubits ( as targets ) . The GHZ - minus state | GHZ − ( n ) (cid:105) is generated by applying the X gate to one of the qubits ( e . g . , the ﬁrst qubit ) and the Hadamard gate to the remaining n − 1 qubits , followed by applying n − 1 CNOT gates between the ﬁrst qubit ( as a target ) and the other n − 1 qubits ( as controls ) . Finally , we apply the Hadamard gate to all of the qubits . The Hadamard state | Hadamard ( n ) (cid:105) is a separable state , and it is generated by applying the Hadamard gate to all of the qubits . The random state | Random ( n ) (cid:105) is generated by a random quantum gate selection : In particular , for a given circuit depth , we uniformly select among generic single - qubit rotation gates with 3 Euler angles , and controlled - X gates , for every step in the circuit sequence . For the rotation gates , the qubits involved are selected uniformly at random , as well as the angles from the range [ 0 , 1 ] . For the controlled - X gates , the source and target qubits are also selected uniformly at random . We generically denote the density matrix that correspond to pure state | ψ (cid:105) as ρ (cid:63) = | ψ (cid:105) (cid:104) ψ | . For clarity , we will drop the bra - ket notation when we refer to | GHZ ( n ) (cid:105) , | GHZ − ( n ) (cid:105) , | Hadamard ( n ) (cid:105) and | Random ( n ) (cid:105) . While the density matrices of the GHZ ( n ) and GHZ − ( n ) are sparse in the { | 0 (cid:105) , | 1 (cid:105) } n basis , the density matrix of Hadamard ( n ) state is fully - dense in this basis , and the sparsity of the density matrix that of Random ( n ) may be different form one state to another . Measuring quantum states 7 The quantum measurement model . In our experiments ( both synthetic and real ) we measure the qubits in the Pauli basis [ 3 ] . 8 A Pauli basis measurement on an n - qubit system has d = 2 n possible outcomes . The Pauli basis measurement is uniquely deﬁned by the measurement setting . A Pauli measurement is a string of n letters α : = ( α 1 , α 2 , . . . , α n ) such that α k ∈ { x , y , z } for all k ∈ [ n ] . Note that there are at most 3 n distinct Pauli strings . To deﬁne the Pauli basis measurement that associated with a given measurement string α , we ﬁrst deﬁne the the following three bases on C 2 × 2 : B x = (cid:26) | x , 0 (cid:105) : = 1 √ 2 ( | 0 (cid:105) + | 1 (cid:105) ) , | x , 1 (cid:105) : = 1 √ 2 ( | 0 (cid:105) − | 1 (cid:105) ) (cid:27) , B y = (cid:26) | y , 0 (cid:105) : = 1 √ 2 ( | 0 (cid:105) + i | 1 (cid:105) ) , | y , 1 (cid:105) : = 1 √ 2 ( | 0 (cid:105) − i | 1 (cid:105) ) (cid:27) , B z = { | z , 0 (cid:105) : = | 0 (cid:105) , | z , 1 (cid:105) : = | 1 (cid:105) } . These are the eigenbases of the single - qubit Pauli operators , σ x , σ y , and σ z , whose 2 × 2 matrix representation is given by : σ x = (cid:20) 0 1 1 0 (cid:21) , σ y = (cid:20) 0 − i i 0 (cid:21) , σ z = (cid:20) 1 0 0 − 1 (cid:21) . Given a Pauli setting α , the Pauli basis measurement Π α is deﬁned by the 2 n projectors : Π α = (cid:40)(cid:12)(cid:12) (cid:12) v ( α ) (cid:96) (cid:69) (cid:68) v ( α ) (cid:96) (cid:12)(cid:12) (cid:12) = n (cid:79) k = 1 | α k , (cid:96) k (cid:105) (cid:104) α k , (cid:96) k | : (cid:96) k ∈ { 0 , 1 } ∀ k ∈ [ 1 , n ] (cid:41) , where (cid:96) denotes the bit string ( (cid:96) k 1 , (cid:96) k 2 , . . . , (cid:96) k n ) . Since there are 3 n distinct Pauli measurement settings , there are the same number of possible Pauli basis measurements . 7 The content in this subsection is implemented in the measurements . py component of our complementary software package . 8 This is the non - commutative analogue of the Fourier basis , for the case of sparse vectors [ 84 , 19 ] . 5 Technically , this set forms a positive operator - valued measure ( POVM ) . The projectors that form Π α are the measurement outcomes ( or POVM elements ) and the probability to obtain an outcome | v ( α ) (cid:96) (cid:105)(cid:104) v ( α ) (cid:96) | – when the state of the system is ρ (cid:63) – is given by the Born rule : (cid:104) v ( α ) (cid:96) | ρ (cid:63) | v ( α ) (cid:96) (cid:105) = Tr (cid:0) | v ( α ) (cid:96) (cid:105)(cid:104) v ( α ) (cid:96) | · ρ (cid:63) (cid:1) . The RIP and expectation values of Pauli observables . Starting with the requirements of our algorithm , the sens - ing mapping A ( · ) : C d × d → R m we consider is comprised of a collection of A i ∈ C d × d , i = 1 , . . . , m matrices , such that y i = Tr ( A i ρ (cid:63) ) . We denote the vector ( y 1 , . . . , y m ) by y . When no prior information about the quantum state is assumed , to ensure its ( robust ) recovery , one must choose a set m sensing matrices A i , so that d 2 of them are linearly independent . One example of such choice is the POVM elements of the 3 n Pauli basis measurements . Yet , when it is known that the state - to - be - reconstructed is of low - rank , theory on low - rank recovery problems suggests that A i could just be “incoherent” enough with respect to ρ (cid:63) [ 37 ] , so that recovery is possible from a limited set of measurements , i . e . , with m (cid:28) d 2 . In particular , it is known [ 63 , 37 , 38 ] that if the sensing matrices correspond to random Pauli monomials , then m = O ( r · d · poly ( log d ) ) A i ’s are sufﬁcient for a successful recovery of ρ (cid:63) , using convex solvers for ( 1 ) . 9 A Pauli monomial P i is an operator in the set P i ∈ { 1 , σ x , σ y , σ z } ⊗ n , that is , an n - fold tensor product of single - qubit Pauli operators ( including the identity operator ) . For convenience we relabel the single - qubit Pauli operators as σ 0 : = 1 , σ 1 : = σ x , σ 2 : = σ y , and σ 3 : = σ z , so that we can also write P i = (cid:78) nk = 1 σ i k with i k ∈ { 0 , . . . , 3 } for all k ∈ [ n ] . These results [ 63 , 37 , 38 ] are feasible since the Pauli - monomial - based sensing map A ( · ) obeys the RIP property , as in Deﬁnition 1 . 10 For the rest of the text , we will use the term “ Pauli expectation value ” to denote Tr ( A i ρ (cid:63) ) = Tr ( P i ρ (cid:63) ) . From Pauli basis measurements to Pauli expectation values . While the theory for compressed sensing was proven for Pauli expectation values , in real QPUs , experimental data is obtained from Pauli basis measurements . Therefore , to make sure we are respecting the compressed sensing requirements on the sensing map , we follow this protocol : i ) We sample m = O ( r · d · poly ( log d ) ) or m = measpc · d 2 Pauli monomials uniformly over { σ i } ⊗ n with i ∈ { 0 , . . . , 3 } , where measpc ∈ [ 0 , 1 ] represents the percentage of measurements out of full tomography . ii ) For every monomial , P i , in the generated set , we identify an experimental setting α ( i ) that corre - sponds to the monomial . There , qubits , for which their Pauli operator in P i is the identity operator , are measured , without loss of generality , in the σ 3 basis . For example , for n = 3 and P i = σ 0 ⊗ σ 1 ⊗ σ 1 , we identify the measurement setting α ( i ) = ( z , x , x ) . iii ) We measure the quantum state in the Pauli basis that corresponds to α ( i ) , and record the outcomes . To connect the measurement outcomes to the expectation value of the Pauli monomial , we use the relation : Tr ( P i ρ (cid:63) ) = (cid:88) (cid:96) ∈ { 0 , 1 } n ( − 1 ) χ f ( (cid:96) ) · Tr (cid:16) | v ( α ( i ) ) (cid:96) (cid:105)(cid:104) v ( α ( i ) ) (cid:96) | · ρ (cid:63) (cid:17) , ( 8 ) where f ( (cid:96) ) : { 0 , 1 } n → { 0 , 1 } n is a mapping that takes a bit string (cid:96) and returns a new bit string ˜ (cid:96) ( of the same size ) such that ˜ (cid:96) k = 0 for all k ’s for which i k = 0 ( that is , the locations of the identity operators in P i ) , and χ ˜ (cid:96) is the parity of the bit string ˜ (cid:96) . Algorithmic setup In our implementation , we explore a number of control parameters , including the maximum number of iterations maxiters , the learning rate η , the relative error from successive state iterates reltol , the ac - celeration parameter µ , the percentage of the complete set of measurements ( i . e . over all possible Pauli 9 The main difference between [ 37 , 38 ] and [ 63 ] is that the former guarantees recovery for almost all choices of m = O ( r · d · poly ( log d ) ) random Pauli monomials , while the latter proves that there exists a universal set of m = O ( r · d · poly ( log d ) ) Pauli monomials A i that guarantees successful recovery . 10 In particular , the RIP is satisﬁed for the sensing mechanisms that obeys ( A ( ρ (cid:63) ) ) i = d √ m Tr ( A ∗ i ρ (cid:63) ) , i = 1 , . . . , m . Further , the case considered in [ 63 ] holds for a slightly larger set than the set of rank - r density matrices : for all ρ ∈ C d × d such that (cid:107) ρ (cid:107) ∗ ≤ √ r (cid:107) ρ (cid:107) F . 6 monomials ) measpc , and the seed . In the sequel experiments we set maxiters = 1000 , η = 10 − 3 , reltol = 5 × 10 − 4 unless stated differently . Regarding acceleration , µ = 0 when acceleration is muted ; we experiment over the range of values µ ∈ { 18 , 14 , 13 , 34 } when investigating the acceleration effect , be - yond the theoretically suggested µ (cid:63) . In order to explore the dependence of our approach on the number of measurements available , measpc varies over the set of { 5 % , 10 % , 15 % , 20 % , 40 % , 60 % } ; seed is used for differentiating repeating runs with all other parameters kept ﬁxed . 11 Denoting (cid:98) ρ the estimate of ρ (cid:63) by MiFGD , we report on outputs including : • The evolution with respect to the distance between (cid:98) ρ and ρ (cid:63) : (cid:107) (cid:98) ρ − ρ (cid:63) (cid:107) F , for various µ ’s . • The number of iterations to reach reltol to ρ (cid:63) for various µ ’s . • The ﬁdelity of (cid:98) ρ , deﬁned as Tr (cid:0) ρ (cid:63) (cid:98) ρ (cid:1) ( for rank - 1 ρ (cid:63) ) , as a function of the acceleration parameter µ in the default set . In our plots , we sweep over our default set of measpc values , repeat 5 times for each individual setup , varying supplied seed , and depict their 25 - , 50 - and 75 - percentiles . Experimental setup on quantum processing unit ( QPU ) We show empirical results on 6 - and 8 - qubit real data , obtained on the 20 - qubit IBM QPU ibmq boeblingen . The layout / connectivity of the device is shown in Figure 1 . The 6 - qubit data was from qubits [ 0 , 1 , 2 , 3 , 8 , 9 ] , and the 8 - qubit data was from [ 0 , 1 , 2 , 3 , 8 , 9 , 6 , 4 ] . The T 1 coherence times are [ 39 . 1 , 75 . 7 , 66 . 7 , 100 . 0 , 120 . 3 , 39 . 2 , 70 . 7 , 132 . 3 ] µs , and T 2 coherence times are [ 86 . 8 , 94 . 8 , 106 . 8 , 63 . 6 , 156 . 5 , 66 . 7 , 104 . 5 , 134 . 8 ] µs . The circuit for generating 6 - qubit and 8 - qubit GHZ states are shown in Fig 1 . The typical two qubit gate errors measured from ran - domized benchmarking ( RB ) for relevant qubits are summarized in Table 1 . C 0 X 1 C 1 X 2 C 2 X 3 C 3 X 8 C 8 X 9 C 3 X 4 C 1 X 6 0 . 0072 0 . 0062 0 . 0087 0 . 0077 0 . 0152 0 . 0167 0 . 0133 Table 1 : Two qubit error rates for the relevant gates used in generating 6 - qubit and 8 - qubit GHZ states on ibmq boeblingen . Figure 1 : Left panel : Layout connectivity of IBM backend ibmq boeblingen ; Middle and right panels : Circuits used to generate 6 - qubit state ( left ) and 8 - qubit GHZ state ( right ) . qbit refers to the quantum regis - ters used in qiskit , and q corresponds to qubits on the real device . The QST circuits were generated using the tomography module in qiskit - ignis . 12 For complete QST of a n - qubits state 3 n circuits are needed . The result of each circuit is averaged over 8192 , 4096 or 2048 , for different n - qubit scenarios . To mitigate for readout errors , we prepare and measure all of the 2 n computational basis states in the computation basis to construct a calibration matrix C . C has dimension 2 n by 2 n , where each column vector corresponds to the measured outcome of a prepared basis state . In the ideal case of no readout error , C is an identity matrix . We use C to correct for the measured outcomes of the experiment by minimizing the function : min v cal ∈ R d (cid:107) Cv cal − v meas (cid:107) 2 subject to (cid:88) i v cal i = 1 , v cal i ≥ 0 , ∀ i = 1 , . . . , d ( 9 ) 11 maxiters is num iterations in the code ; also reltol is relative error tolerance , measpc is complete measurements percentage . 12 https : / / github . com / Qiskit / qiskit - ignis . 7 Here v meas and v cal are the measured and calibrated outputs , respectively . The minimization problem is then formulated as a convex optimization problem and solved by quadratic programming using the package cvxopt [ 97 ] . MiFGD on 6 - and 8 - qubit real quantum data We realize two types of quantum states on IBM QPUs , parameterized by the number of qubits n for each case : these are the GHZ − ( n ) and Hadamard ( n ) circuits . We collected measurements over all possible Pauli settings by repeating the experiment for each setting a number of times : these are the number of shots for each setting . The ( circuit , number of shots ) measurement conﬁgurations from IBM Quantum devices are summarized in Table 2 . Circuit # shots GHZ − ( 6 ) 2048 GHZ − ( 6 ) 8192 GHZ − ( 8 ) 2048 GHZ − ( 8 ) 4096 Hadamard ( 6 ) 8192 Hadamard ( 8 ) 4096 Table 2 : QPU settings . In the Appendix , we provide target error list plots for the evolution of (cid:107) (cid:98) ρ − ρ (cid:63) (cid:107) 2 F for reconstructing all the settings in Table 2 , both for real data and for simulated scenarios . Further , we provide plots that relate the effect of momentum acceleration on the ﬁnal ﬁdelity observed for these cases . For clarity , in Figure 2 , we summarize the efﬁciency of mo - mentum acceleration , by showing the reconstruction error only for the following settings : maxiters = 1000 , η = 10 − 3 , reltol = 5 × 10 − 4 , and measpc = 20 % . In the plots , µ = 0 corresponds to the FGD algo - rithm in [ 79 ] , µ (cid:63) corresponds to the value obtained through our theory , while we use µ ∈ (cid:8) 18 , 14 , 13 , 34 (cid:9) to study the acceleration effect . For µ (cid:63) , per our theory , we follow the rule µ (cid:63) ≈ ε / 2211 for ε ∈ ( 0 , 1 ] ; see also the Methods section for more details . 13 Note that , in most of the cases , the curve corresponding to µ = 0 is hidden behind the curve corresponding to µ ≈ µ (cid:63) . We run each QST ex - periment for 5 times for random initializations . We record the evolution of the (cid:107) (cid:98) ρ − ρ (cid:63) (cid:107) 2 F error at each step , and stop when the relative error of successive iterates gets smaller than reltol or the number of iterations exceeds maxiters ( whichever happens ﬁrst ) . To implement measpc = 20 % , we follow the description given above Eq . ( 8 ) with m = measpc · d 2 . To highlight the level of noise existing in real quantum data , in Figure 3 , we repeat the same setting using the QASM simulator in qiskit - aer . This is a parallel , high performance quantum circuit simulator written in C + + that can support a variety of realistic circuit level noise models . Figure 2 summarizes the performance of our proposal on different ρ (cid:63) , and for different µ values on real IBM QPU data . All plots show the evolution of (cid:107) (cid:98) ρ − ρ (cid:63) (cid:107) F across iterations , featuring a steep dive to convergence for the largest value of µ we tested : we report that we also tested µ = 0 , which shows only slight worse performances than µ (cid:63) . Figure 2 highlights the universality of our approach : its performance is oblivious to the quantum state reconstructed , as long as it satisﬁes purity or it is close to a pure state . Our method does not require any additional structure assumptions in the quantum state . To highlight the effect of real noise on the performance of MiFGD , we further plot its performance on the same settings but using measurements coming from an idealized quantum simulator . Figure 3 considers the exact same settings as in Figure 2 . It is obvious that MiFGD can achieve better reconstruction performance when data are less erroneous . This also highlights that , in real noisy scenarios , the radius of the convergence region of MiFGD around ρ (cid:63) is controlled mostly by the the noise level , rather than by the inclusion of momentum acceleration . Finally , in Figure 4 , we depict the ﬁdelity of (cid:98) ρ achieved using MiFGD , deﬁned as Tr (cid:0) ρ (cid:63) (cid:98) ρ (cid:1) , versus various µ values and for different circuits ( ρ (cid:63) ) . Shaded area denotes standard deviation around the mean over repeated runs in all cases . The plots show the signiﬁcant gap in performance when using real quantum data versus using synthetic simulated data within a controlled environment . 13 For this application , σ r ( ρ (cid:63) ) = 1 , τ ( ρ (cid:63) ) = 1 , and r = 1 by construction ; we also approximated κ = 1 . 223 , which , for user - deﬁned ε = 1 , results in µ (cid:63) = 4 . 5 · 10 − 4 . Note that smaller ε values result into a smaller radius of the convergence region ; however , more pessimistic ε values result into small µ , with no practical effect in accelerating the algorithm . 8 0 500 1000 Iterations 6 × 10 − 1 1 . 2 × 10 0 k b ρ − ρ ? k 2 F µ = 0 µ = 1 / 8 µ = 1 / 4 µ = 1 / 3 µ = 3 / 4 µ = µ ? 0 500 1000 Iterations 6 × 10 − 1 1 . 2 × 10 0 k b ρ − ρ ? k 2 F µ = 0 µ = 1 / 8 µ = 1 / 4 µ = 1 / 3 µ = 3 / 4 µ = µ ? 0 100 200 Iterations 10 0 6 × 10 − 1 k b ρ − ρ ? k 2 F µ = 0 µ = 1 / 8 µ = 1 / 4 µ = 1 / 3 µ = 3 / 4 µ = µ ? 0 100 200 Iterations 10 0 6 × 10 − 1 k b ρ − ρ ? k 2 F µ = 0 µ = 1 / 8 µ = 1 / 4 µ = 1 / 3 µ = 3 / 4 µ = µ ? 0 500 1000 Iterations 10 0 k b ρ − ρ ? k 2 F µ = 0 µ = 1 / 8 µ = 1 / 4 µ = 1 / 3 µ = 3 / 4 µ = µ ? 0 100 200 Iterations 4 × 10 − 1 1 . 2 × 10 0 k b ρ − ρ ? k 2 F µ = 0 µ = 1 / 8 µ = 1 / 4 µ = 1 / 3 µ = 3 / 4 µ = µ ? Figure 2 : Target error list plots (cid:107) (cid:98) ρ − ρ (cid:63) (cid:107) 2 F versus method iterations using real IBM QPU data . Top - left : GHZ − ( 6 ) with 2048 shots ; Top - middle : GHZ − ( 6 ) with 8192 shots ; Top - right : GHZ − ( 8 ) with 2048 shots ; Bottom - left : GHZ − ( 8 ) with 4096 shots / copies of ρ (cid:63) ; Bottom - middle : Hadamard ( 6 ) with 8192 shots ; Bottom - right : Hadamard ( 8 ) with 4096 shots . All cases have measpc = 20 % . Shaded area denotes standard devia - tion around the mean over repeated runs in all cases . Performance comparison with full tomography methods in Qiskit We compare MiFGD with publicly available implementations for QST reconstruction . Two common tech - niques for QST , included in the qiskit - ignis distribution [ 81 ] , are : i ) the CVXPY ﬁtter method , that uses the CVXPY convex optimization package [ 26 , 5 ] ; and ii ) the lstsq method , that uses least - squares ﬁtting [ 88 ] . Both methods solve the full tomography problem 14 according to the following expression : min ρ ∈ C d × d f ( ρ ) : = 12 (cid:107)A ( ρ ) − y (cid:107) 22 subject to ρ (cid:23) 0 , Tr ( ρ ) = 1 . ( 10 ) We note that MiFGD is not restricted to “tall” U scenarios to encode PSD and rank constraints : even without rank constraints , one could still exploit the matrix decomposition ρ = UU † to avoid the PSD projection , ρ (cid:23) 0 , where U ∈ C d × d . For the lstsq ﬁtter method , the putative estimate (cid:98) ρ is rescaled using the method proposed in [ 88 ] . For CVXPY , the convex constraint makes the optimization problem a semideﬁnite pro - gramming ( SDP ) instance . By default , CVXPY calls the SCS solver that can handle all problems ( including SDPs ) [ 73 , 74 ] . Further comparison results with matrix factorization techniques from the machine learning community is provided in the Appendix for n = 12 . 14 In Ref . [ 49 ] it was sown that the minimization program ( 10 ) yields a robust estimation of low - rank states in the compressed sensing . Thus , one can use CVXPY ﬁtter method to solve ( 10 ) with m (cid:28) d 2 Pauli expectation value to obtain a robust reconstruction of ρ (cid:63) . 9 0 500 1000 Iterations 10 − 1 10 0 k b ρ − ρ ? k 2 F µ = 0 µ = 1 / 8 µ = 1 / 4 µ = 1 / 3 µ = 3 / 4 µ = µ ? 0 500 1000 Iterations 10 − 1 10 0 k b ρ − ρ ? k 2 F µ = 0 µ = 1 / 8 µ = 1 / 4 µ = 1 / 3 µ = 3 / 4 µ = µ ? 0 100 200 Iterations 10 − 1 10 0 k b ρ − ρ ? k 2 F µ = 0 µ = 1 / 8 µ = 1 / 4 µ = 1 / 3 µ = 3 / 4 µ = µ ? 0 100 200 Iterations 10 − 1 10 0 k b ρ − ρ ? k 2 F µ = 0 µ = 1 / 8 µ = 1 / 4 µ = 1 / 3 µ = 3 / 4 µ = µ ? 0 500 1000 Iterations 10 − 1 10 0 k b ρ − ρ ? k 2 F µ = 0 µ = 1 / 8 µ = 1 / 4 µ = 1 / 3 µ = 3 / 4 µ = µ ? 0 100 200 Iterations 10 − 1 10 0 k b ρ − ρ ? k 2 F µ = 0 µ = 1 / 8 µ = 1 / 4 µ = 1 / 3 µ = 3 / 4 µ = µ ? Figure 3 : Target error list plots (cid:107) (cid:98) ρ − ρ (cid:63) (cid:107) 2 F versus method iteration using synthetic IBM’s quantum simu - lator data . Top - left : GHZ − ( 6 ) with 2048 shots ; Top - middle : GHZ − ( 6 ) with 8192 shots ; Top - right : GHZ − ( 8 ) with 2048 shots ; Bottom - left : GHZ − ( 8 ) with 4096 shots ; Bottom - middle : Hadamard ( 6 ) with 8192 shots ; Bottom - right : Hadamard ( 8 ) with 4096 shots . All cases have measpc = 20 % . Shaded area denotes standard deviation around the mean over repeated runs in all cases . µ ? 18 14 13 34 Momentum µ 0 . 90 0 . 95 F i d e li t y µ ? 18 14 13 34 Momentum µ 0 . 93 0 . 96 0 . 99 µ ? 18 14 13 34 Momentum µ 0 . 80 0 . 88 µ ? 18 14 13 34 Momentum µ 0 . 80 0 . 88 0 . 96 µ ? 18 14 13 34 Momentum µ 0 . 0 0 . 4 0 . 8 µ ? 18 14 13 34 Momentum µ 0 . 94 0 . 96 Qiskit simulator IBMQ device Figure 4 : Fidelity list plots where we depict the ﬁdelity of (cid:98) ρ to ρ (cid:63) . From left to right : i ) GHZ − ( 6 ) with 2048 shots ; ii ) GHZ − ( 6 ) with 8192 shots ; iii ) GHZ − ( 8 ) with 2048 shots ; iv ) GHZ − ( 8 ) with 4096 shots ; v ) Hadamard ( 6 ) with 8192 shots ; vi ) Hadamard ( 8 ) with 4096 shots . All cases have measpc = 20 % . Shaded area denotes standard deviation around the mean over repeated runs in all cases . The settings we consider for full tomography are the following : GHZ ( n ) , Hadamard ( n ) and Random ( n ) quantum states ( for n = 3 , . . . , 8 ) . We focus on ﬁdelity of reconstruction and computation timings perfor - mance between CVXPY , lstsq and MiFGD . We use 100 % of the measurements . We experimented with states 10 simulated in QASM and measured taking 2 , 048 shots . For MiFGD , we set η = 0 . 001 , µ = 34 , and stopping criterion / tolerance reltol = 10 − 5 . All experiments are run on a Macbook Pro with 2 . 3 GHz Quad - Core Intel Core i7CPU and 32GB RAM . The results are shown in Figure 5 ; higher - dimensional cases are provided in Table 3 . Some notable remarks : i ) For small - scale scenarios ( n = 3 , 4 ) , CVXPY and lstsq attain almost perfect ﬁdelity , while being comparable or faster than MiFGD . ii ) The difference in performance becomes apparent from n = 6 and on : while MiFGD attains 98 % ﬁdelity in < 5 seconds , CVXPY and lstsq require up to hundreds of seconds to ﬁnd a good solution . iii ) Finally , while MiFGD gets to high - ﬁdelity solutions in seconds for n = 7 , 8 , CVXPY and lstsq methods could not ﬁnish tomography as their memory usage exceeded the system’s available memory . It is noteworthy that the reported ﬁdelities for MiFGD are the ﬁdelities at the last iteration , before the stopping criterion is activated , or the maximum number of iterations is exceeded . However , the reported ﬁdelity is not necessarily the best one during the whole execution : for all cases , we observe that MiFGD ﬁnds intermediate solutions with ﬁdelity > 99 % . Though , it is not realistic to assume that the iteration with the best ﬁdelity is known a priori , and this is the reason we report only the ﬁnal iteration ﬁdelity . Circuit Method Fidelity Time ( secs ) GHZ ( 7 ) MiFGD 0 . 969397 10 . 6709 Hadamard ( 7 ) MiFGD 0 . 969397 10 . 4926 Random ( 7 ) MiFGD 0 . 968553 9 . 59607 All above lstsq , CVXPY Memory limit exceeded GHZ ( 8 ) MiFGD 0 . 940389 35 . 0666 Hadamard ( 8 ) MiFGD 0 . 940390 37 . 5331 Random ( 8 ) MiFGD 0 . 942815 36 . 3251 All above lstsq , CVXPY Memory limit exceeded Table 3 : Fidelity of reconstruction and computation timings using 100 % of the complete measurements . Rows correspond to combinations of number of qubits ( 7 ∼ 8 ) , synthetic circuit , and tomographic method ( MiFGD , Qiskit’s lstsq and CVXPY ﬁtters . 2048 shots per measurement circuit . For MiFGD , η = 0 . 001 , µ = 34 , reltol = 10 − 5 . All experiments are run on a 13” Macbook Pro with 2 . 3 GHz Quad - Core Intel Core i7 CPU and 32 GB RAM . 3 4 5 6 7 Number of qubits 0 . 97 0 . 98 0 . 99 1 . 00 F i d e li t y GHZ / MiFGD GHZ / CVXPY GHZ / lstsq 3 4 5 6 7 Number of qubits 0 . 97 0 . 98 0 . 99 1 . 00 F i d e li t y Hadamard / MiFGD Hadamard / CVXPY Hadamard / lstsq 3 4 5 6 7 Number of qubits 0 . 97 0 . 98 0 . 99 1 . 00 F i d e li t y Random / MiFGD Random / CVXPY Random / lstsq 3 4 5 6 7 Number of qubits 0 500 1000 T i m e ( s ec s ) GHZ / MiFGD GHZ / CVXPY GHZ / lstsq 3 4 5 6 7 Number of qubits 0 200 400 T i m e ( s ec s ) Hadamard / MiFGD Hadamard / CVXPY Hadamard / lstsq 3 4 5 6 7 Number of qubits 0 200 400 T i m e ( s ec s ) Random / MiFGD Random / CVXPY Random / lstsq Figure 5 : Fidelity versus time plots using synthetic IBM’s quantum simulator data . Left panel : GHZ − ( n ) for n = 3 , 4 ; Middle panel : Hadamard − ( n ) for n = 3 , 4 ; Right panel : Random − ( n ) for n = 3 , 4 . 11 Performance comparison of MiFGD with neural - network quantum state tomography We compare the performance of MiFGD with neural network approaches . Per [ 93 , 12 , 94 , 31 ] , we model a quantum state with a two - layer Restricted Boltzmann Machine ( RBM ) . RBMs are stochastic neural net - works , where each layer contains a number of binary stochastic variables : the size of the visible layer cor - responds to the number of input qubits , while the size of the hidden layer is a hyperparameter controlling the representation error . We experiment with three types of RBMs for reconstructing either the positive - real wave function , the complex wave function , or the density matrix of the quantum state . In the ﬁrst two cases the state is assumed pure while in the last , general mixed quantum states can be represented . We leverage the implementation in QuCumber [ 12 ] , PositiveRealWaveFunction ( PRWF ) , ComplexWaveFunction ( CWF ) , and DensityMatrix ( DM ) , respectively . We reconstruct GHZ ( n ) , Hadamard ( n ) and Random ( n ) quantum states ( for n = 3 , . . . , 8 ) , by training PRWF , CWF , and DM neural networks 15 with measurements collected by the QASM Simulator . For our setting , we consider measpc = 50 % and shots = 2048 . The set of measurements is presented to the RBM implementation , along with the target positive - real wave function ( for PRWF ) , complex wave - function ( for CWF ) or the target density matrix ( for DM ) in a suitable format for training . We train Hadamard and Random states with 20 epochs , and GHZ state with 100 epochs . 16 We set the number of hidden variables ( and also of additional auxilliary variables for DM ) to be equal to the number of input variables n and we use 100 data points for both the positive and the negative phase of the gradient ( as per the recommendation for the defaults ) . We choose k = 10 contrastive divergence steps and ﬁxed the learning rate to 10 ( per hyperpa - rameter tuning ) . Lastly , we limit the ﬁtting time of Qucumber methods ( excluding data preparation time ) to be three hours . To compare to the RBM results , we run MiFGD with η = 0 . 001 , µ = 34 , reltol = 10 − 5 and using measpc = 50 % , keeping previously chosen values for all other hyperparameters . We report the ﬁdelity of the reconstruction as a function of elapsed training time for n = 3 , 4 in Figure 6 for PRWF , CWF , and DM . We observe that for all cases , Qucumber methods are orders of magnitude slower than MiFGD . E . g . , for n = 8 , for all three states , CWF and DM did not ﬁnish a single epoch in 3 hours , while MiFG achieves high ﬁdelity in less than 30 seconds . For the Hadamard ( n ) and Random ( n ) , reaching rea - sonable ﬁdelities is signiﬁcantly slower for both CWF and DM , while PRWF hardly improves its performance throughout the training . For the GHZ case , CWF and DM also shows non - monotonic behaviors : even after a few thousands of seconds , ﬁdelities have not “stabilized” , while PRWF stabilizes in very low ﬁdelities . In compar - ison MiFGD is several orders of magnitude faster than both CWF and DM and ﬁdelity smoothly increases to comparable or higher values . Further , in Table 4 , we report ﬁnal ﬁdelities ( within the 3 hour time window ) , and reported times . The effect of parallelization We study the effect of parallelization in running MiFGD . We parallelize the iteration step across a number of processes , that can be either distributed and network connected , or sharing memory in a multicore envi - ronment . Our approach is based on Message Passing Interface ( MPI ) speciﬁcation [ 30 ] , which is the lingua franca for interprocess communication in high performance parallel and supercomputing applications . A MPI implementation provides facilities for launching processes organized in a virtual topology and highly tuned primitives for point - to - point and collective communication between them . We assign to each process a subset of the measurement labels consumed by the parallel computation . At each step , a process ﬁrst computes the local gradient - based corrections due only to its assigned Pauli monomials and corresponding measurements . These local gradient - based corrections will then ( i ) need to be communicated , so that they can be added , and ( ii ) ﬁnally , their sum will be shared across all processes to produce a global update for U for next step . We accomplish this structure in MPI using MPI Allreduce collective communication primitive with MPI SUM as its reduction operator : the underlying implementa - tion will ensure minimum communication complexity for the operation ( e . g . log p steps for p processes organized in a communication ring ) and thus maximum performance . 17 We leverage mpi4py [ 25 ] bindings to issue MPI calls in our parallel Python code . 15 We utilize GPU ( NVidia GeForce GTX 1080 TI , 11GB RAM ) for faster training of the neural networks . 16 We experimented higher number of epochs ( up to 500 ) for all cases , but after the reported number of epochs , Qucumber methods did not improve , if not worsened . 17 This communication pattern can alternatively be realized in two stages , as naturally suggested in its structure : ( i ) ﬁrst invoke 12 Circuit Method MiFGD FGD PRWF CWF DM GHZ ( 3 ) Fidelity 0 . 997922 0 . 997857 0 . 314167 0 . 401737 0 . 005389 Time ( secs ) 0 . 348652 1 . 061421 42 . 27607 1649 . 224 3279 . 118 Hadamard ( 3 ) Fidelity 0 . 997229 0 . 994191 0 . 912268 0 . 997914 0 . 997222 Time ( secs ) 0 . 706872 2 . 399405 8 . 492405 325 . 7040 656 . 6696 Random ( 3 ) Fidelity 0 . 991063 0 . 988746 0 . 074774 0 . 997493 0 . 989754 Time ( secs ) 1 . 447057 3 . 431218 8 . 345135 322 . 4730 640 . 8185 GHZ ( 4 ) Fidelity 0 . 996029 0 . 996041 0 . 204313 0 . 276491 0 . 138459 Time ( secs ) 0 . 733128 2 . 081035 126 . 2749 10756 . 87 > 3h Hadamard ( 4 ) Fidelity 0 . 996078 0 . 996083 0 . 894883 0 . 998071 0 . 997389 Time ( secs ) 0 . 852895 2 . 368223 25 . 15520 2087 . 540 4613 . 964 Random ( 4 ) Fidelity 0 . 998850 0 . 998876 0 . 152971 0 . 984164 0 . 972877 Time ( secs ) 0 . 713302 2 . 380326 26 . 18863 2185 . 091 4802 . 495 GHZ ( 5 ) Fidelity 0 . 992105 0 . 992106 0 . 132725 0 . 274665 0 . 005138 Time ( secs ) 0 . 946350 3 . 287358 395 . 3379 > 3h > 3h Hadamard ( 5 ) Fidelity 0 . 992102 0 . 992100 0 . 869603 0 . 998246 0 . 996516 Time ( secs ) 1 . 183290 3 . 895312 79 . 39444 9319 . 140 > 3h Random ( 5 ) Fidelity 0 . 995126 0 . 995109 0 . 015913 0 . 623273 0 . 086777 Time ( secs ) 0 . 988173 3 . 407487 79 . 22450 9275 . 836 > 3h GHZ ( 6 ) Fidelity 0 . 984352 0 . 984340 0 . 089355 0 . 437323 0 . 310067 Time ( secs ) 3 . 829866 13 . 306954 1167 . 985 > 3h > 3h Hadamard ( 6 ) Fidelity 0 . 984384 0 . 984377 0 . 842515 0 . 990849 0 . 998077 Time ( secs ) 2 . 500354 8 . 661999 246 . 0011 > 3h > 3h Random ( 6 ) Fidelity 0 . 989543 0 . 989536 0 . 143145 0 . 784873 0 . 302534 Time ( secs ) 1 . 991154 7 . 604232 237 . 7037 > 3h > 3h GHZ ( 7 ) Fidelity 0 . 969174 0 . 969168 0 . 058387 0 . 080648 N / A Time ( secs ) 6 . 174129 15 . 895504 3633 . 082 > 3h > 3h Hadamard ( 7 ) Fidelity 0 . 969156 0 . 969156 0 . 818174 0 . 996586 N / A Time ( secs ) 6 . 324469 16 . 283301 713 . 9404 > 3h > 3h Random ( 7 ) Fidelity 0 . 967640 0 . 967619 0 . 141745 0 . 06568 N / A Time ( secs ) 6 . 802577 16 . 594162 746 . 2630 > 3h > 3h GHZ ( 8 ) Fidelity 0 . 940601 0 . 940600 0 . 0400391 N / A N / A Time ( secs ) 21 . 16011 36 . 892739 > 3h > 3h > 3h Hadamard ( 8 ) Fidelity 0 . 940638 0 . 940638 0 . 794892 N / A N / A Time ( secs ) 22 . 30246 41 . 472961 2344 . 796 > 3h > 3h Random ( 8 ) Fidelity 0 . 939418 0 . 939416 0 . 050521 N / A N / A Time ( secs ) 22 . 81059 41 . 193810 2196 . 259 > 3h > 3h Table 4 : Fidelity of reconstruction and computation timings using measpc = 50 % and shots = 2048 . Rows correspond to combinations of number of qubits ( 3 ∼ 8 ) , ﬁnal ﬁdelity within the 3h time limit , and computation time . For MiFGD , η = 0 . 001 , µ = 34 , tol = 10 − 5 . For FGD , η = 0 . 001 , tol = 10 − 5 . “N / A” indicates that the method could not complete a single epoch in 3 hour training time limit , and thus could not provide any ﬁdelity result . All experiments are run on a NVidia GeForce GTX 1080 TI , 11 GB RAM . 13 10 − 1 10 1 10 3 Time ( secs ) 0 . 00 0 . 25 0 . 50 0 . 75 1 . 00 F i d e li t y GHZ ( 3 ) / MiFGD GHZ ( 3 ) / PRWF GHZ ( 3 ) / CWF GHZ ( 3 ) / DM 10 − 1 10 1 10 3 Time ( secs ) 0 . 4 0 . 6 0 . 8 1 . 0 F i d e li t y Hadamard ( 3 ) / MiFGD Hadamard ( 3 ) / PRWF Hadamard ( 3 ) / CWF Hadamard ( 3 ) / DM 10 − 1 10 1 10 3 Time ( secs ) 0 . 25 0 . 50 0 . 75 1 . 00 F i d e li t y Random ( 3 ) / MiFGD Random ( 3 ) / PRWF Random ( 3 ) / CWF Random ( 3 ) / DM 10 − 1 10 1 10 3 Time ( secs ) 0 . 00 0 . 25 0 . 50 0 . 75 1 . 00 F i d e li t y GHZ ( 4 ) / MiFGD GHZ ( 4 ) / PRWF GHZ ( 4 ) / CWF GHZ ( 4 ) / DM 10 − 1 10 1 10 3 Time ( secs ) 0 . 4 0 . 6 0 . 8 1 . 0 F i d e li t y Hadamard ( 4 ) / MiFGD Hadamard ( 4 ) / PRWF Hadamard ( 4 ) / CWF Hadamard ( 4 ) / DM 10 0 10 2 Time ( secs ) 0 . 2 0 . 4 0 . 6 0 . 8 1 . 0 F i d e li t y Random ( 4 ) / MiFGD Random ( 4 ) / PRWF Random ( 4 ) / CWF Random ( 4 ) / DM Figure 6 : Fidelity versus time plots on MiFGD , PRWF , CWF , and DM , using synthetic IBM’s quantum simulator data . Left panel : GHZ ( n ) for n = 3 , 4 ; Middle panel : Hadamard ( n ) for n = 3 , 4 ; Right panel : Random ( n ) for n = 3 , 4 . We conducted our parallel experiments on a server equipped with 4 x E7 - 4850 v2 CPUs @ 2 . 30GHz ( 48 / 96 physical / virtual cores ) , 256 GB RAM , using shared memory multiprocessing over multiple cores . We experimented with states simulated in QASM and measured taking 8 , 192 shots ; parallel MiFGD runs with default parameters and using all measurements ( measpc = 100 % ) . Reported times are wall - clock com - putation time . These exclude initialization time for all processes to load Pauli monomials and measure - ments : we here target parallelizing computation proper in MiFGD . In our ﬁrst round of experiments , we investigate the scalability of our approach . We vary the number p of parallel processes ( p = 1 , 2 , 4 , 8 , 16 , 32 , 48 , 64 , 80 , 96 ) , collect timings for reconstructing GHZ ( 4 ) , Random ( 6 ) and GHZ − ( 8 ) states and report speedups T p / T 1 we gain from MiFGD in Figure 7 ( Left panel ) . We observe that the beneﬁts of parallelization are pronounced for bigger problems ( here : n = 8 qubits ) and maximum scalability results when we use all physical cores ( 48 in our platform ) . Further , we move to larger problems ( n = 10 qubits : reporting on reconstructing Hadamard ( 10 ) state ) and focus on the effect parallelization to achieving a given level of ﬁdelity in reconstruction . In Figure 7 ( Middle panel ) we illustrate the ﬁdelity as a function of the time spent in the iteration loop of MiFGD for ( p = 8 , 16 , 32 , 48 , 64 ) : we observe the smooth path to convergence in all p counts which again minimizes compute time for p = 48 . Note that in this case we use measpc = 10 % and µ = 14 . Finally , in Figure 7 ( Right panel ) , we ﬁx the number of processes to p = 48 , in order to minimize compute time and increase the percentage of used measurements to 20 % of the total available for Hadamard ( 10 ) . We vary the acceleration parameter , µ = 0 ( no acceleration ) to µ = 14 and conﬁrm that we indeed get faster convergence times in the latter case while the ﬁdelity value remains the same ( i . e . coinciding upper plateau value in the plots ) . We can also compare with the previous ﬁdelity versus time plot , where the same µ but half the measurements are consumed : more measurements translate to faster convergence times ( plateau is reached roughly 25 % faster ; compare the green line with the yellow line in the previous plot ) . MPI’s MPI Reduce primitive , with MPI SUM as its reduction operator , which results in the element - wise accumulation of local cor - rections ( vector sum ) at a single , designated root process , and ( ii ) ﬁnally , send a “copy” of this sum from root process to each pro - cess participating in the parallel computation ( broadcasting ) ; MPI Bcast primitive can be utilized for this latter stage . However , MPI Allreduce is typically faster , since its actual implementation is not constrained by the requirement to have the sum available at a speciﬁc , root process , at an intermediate time point - as the two - stage approach implies . 14 0 25 50 75 100 Number of processes 0 5 10 15 S p ee dup GHZ ( 4 ) Random ( 6 ) GHZMinus ( 8 ) 0 20 40 60 80 Time ( secs ) 0 . 0 0 . 2 0 . 4 0 . 6 0 . 8 F i d e li t y 8 procs 16 procs 32 procs 48 procs 64 procs 0 10 20 30 40 Time ( secs ) 0 . 0 0 . 2 0 . 4 0 . 6 0 . 8 F i d e li t y 48 procs , µ = 0 48 procs , µ = 1 / 4 Figure 7 : Left panel : Scalability of our approach as we vary the number p of parallel processes . Middle panel : Fidelity function versus time consumed for different number of processes p . Right panel : The effect of momentum for a ﬁxed scenario with Hadamard ( 10 ) state , p = 48 , and varying momentum from µ = 0 to µ = 14 . Discussion We have introduced the MiFGD algorithm for the factorized form of the low - rank QST problems . We proved that , under certain assumptions on the problem parameters , MiFGD converges linearly to a neighborhood of the optimal solution , whose size depends on the momentum parameter µ , while using acceleration mo - tions in a non - convex setting . We demonstrate empirically , using both simulated and real data , that MiFGD outperforms non - accelerated methods on both the original problem domain and the factorized space , con - tributing to recent efforts on testing QST algorithms in real quantum data [ 83 ] . These results expand on existing work in the literature illustrating the promise of factorized methods for certain low - rank ma - trix problems . Finally , we provide a publicly available implementation of our approach , compatible to the open - source software Qiskit [ 81 ] , where we further exploit parallel computations in MiFGD by extending its implementation to enable efﬁcient , parallel execution over shared and distributed memory systems . Despite our theory does not apply to the Pauli basis measurement directly ( i . e . , using randomly selected Pauli bases Π α , does not lead to the (cid:96) 2 - norm RIP ) , using the data from random Pauli basis measurements directly could provide excellent tomographic reconstruction with MiFGD . Preliminary results suggest that only O ( r · log d ) random Pauli bases should be taken for a reconstruction , with the same level of accuracy as with O ( r · d · log d ) expectation values of random Pauli matrices . We leave the analysis of our algorithm in this case for future work , along with detailed experiments . Related Work Matrix sensing . The problem of low - rank matrix reconstruction from few samples was ﬁrst studied within the paradigm of convex optimization , using the nuclear norm minimization [ 82 , 60 , 64 ] . The use of non - convex approaches for low - rank matrix recovery—by imposing rank - constraints—has been proposed in [ 47 , 61 , 56 ] . In all these works , the convex and non - convex algorithms involve a full , or at least a truncated , singular value decomposition ( SVD ) per algorithm iteration . Since SVD can be prohibitive , these methods are limited to relatively small system sizes . Momentum acceleration methods are used regularly in the convex setting , as well as in machine learning practical scenarios [ 53 , 92 , 53 , 13 , 72 , 17 , 34 ] . While momentum acceleration was previously studied in non - convex programming setups , it mostly involve non - convex constraints with a convex objective function [ 55 , 56 , 52 , 101 ] ; and generic non - convex settings but only considering with the question of whether momentum acceleration leads to fast convergence to a saddle point or to a local minimum , rather than to a global optimum [ 33 , 59 , 20 , 4 ] . The factorized version for semi - deﬁnite programming was popularized in [ 18 ] . Effectively the factor - ization of a the set of PSD matrices to a product of rectangular matrices results in a non - convex setting . This approach have been heavily studied recently , due to computational and space complexity advantages [ 46 , 21 , 102 , 103 , 96 , 78 , 80 , 89 , 14 , 15 , 79 , 32 , 43 , 57 ] . None of the works above consider the inclusion and anal - ysis of momentum . Moreover , the Procrustes Flow approach [ 103 , 96 ] uses certain initializations techniques , and thus relies on multiple SVD computations . Our approach on the other hand uses a single , unique , top - r 15 SVD computation . Comparison results beyond QST are provided in the appendix . Compressed sensing QST using non - convex optimization . There are only few works that study non - convex optimization in the context of compressed sensing QST . The authors of [ 86 ] propose a hybrid algorithm that i ) starts with a conjugate - gradient ( CG ) algorithm in the factored space , in order to get initial rapid descent , and ii ) switch over to accelerated ﬁrst - order methods in the original ρ space , provided one can determine the switch - over point cheaply . Using the multinomial maximum likelihood objective , in the ini - tial CG phase , the Hessian of the objective is computed per iteration ( i . e . , a 4 n × 4 n matrix ) , along with its eigenvalue decomposition . Such an operation is costly , even for moderate values of qubit number n , and heuristics are proposed for its completion . From a theoretical perspective , [ 86 ] provide no convergence or convergence rate guarantees . From a different perspective , [ 71 ] relies on spectrum estimation techniques [ 39 , 22 ] and the Empirical Young Diagram algorithm [ 8 , 51 ] to prove that O ( rd / ε ) copies sufﬁce to obtain an estimate ˆ ρ that satisﬁes (cid:107) ˆ ρ − ρ (cid:63) (cid:107) 2 F ≤ ε ; however , to the best of our knowledge , there is no concrete implementation of this technique to compare with respect to scalability . Ref . [ 95 ] proposes an efﬁcient quantum tomography protocol by determining the permutationally in - variant part of the quantum state . The authors determine the minimal number of local measurement set - tings , which scales quadratically with the number of qubits . The paper determines which quantities have to be measured in order to get the smallest uncertainty possible . See [ 67 ] for a more recent work on permu - tationally invariant tomography . The method has been tested in a six - qubit experiment in [ 85 ] . Ref . [ 83 ] presented an experimental implementation of compressed sensing QST of a n = 7 qubit sys - tem , where only 127 Pauli basis measurements are available . To achieve recovery in practice , the authors proposed a computationally efﬁcient estimator , based on gradient descent method in the factorized space . The authors of [ 83 ] focus on the experimental efﬁciency of the method , and provide no speciﬁc results on the optimization efﬁciency , neither convergence guarantees of the algorithm . Further , there is no available implementation publicly available . Similar to [ 83 ] , Ref . [ 57 ] also proposes a non - convex projected gradient decent algorithm that works on the factorized space in the QST setting . The authors prove a rigorous convergence analysis and show that , under proper initialization and step - size , the algorithm is guaranteed to converge to the global minimum of the problem , thus ensuring a provable tomography procedure . Our results extend these results by including acceleration techniques in the factorized space . The key contribution of our work is proving convergence of the proposed algorithm in a linear rate to the global minimum of the problem , under common assumptions . Proving our results required developing a whole set of new techniques , which are not based on a mere extension of existing results . Compressed sensing QST using convex optimization . The original formulation of compressed sensing QST [ 38 ] is based on convex optimization methods , solving the trace - norm minimization , to obtain an estimation of the low - rank state . It was later shown [ 49 ] that essentially any convex optimization program can be used to robustly estimate the state . In general , there are two drawbacks in using convex optimization optimization in QST . Firstly , as the dimension of density matrices grow exponentially in the number of qubits , the search space in convex optimization grows exponentially in the number of qubits . Secondly , the optimization requires projection onto the PSD cone at every iteration , which becomes exponentially hard in the number of qubits . We avoid these two drawbacks by working in the factorized space . Using this factorization results in a search space that is substantially smaller than its convex counterpart , and moreover , in a single use of top - r SVD during the entire execution algorithm . Bypassing these drawbacks , together with accelerating motions , allows us to estimate quantum states of larger qubit systems than state - of - the - art algorithms . Full QST using non - convex optimization . The use of non - convex algorithms in QST was studied in the con - text of full tomography as well . By “full tomography” we refer to the situation where an informationally complete measurement is performed , so that the input data to the algorithm is of size 4 n . The exponential scaling of the data size restrict the applicability of full tomography to relatively small system sizes . In this setting non - convex algorithms which work in the factored space were studied [ 10 , 77 , 99 , 36 , 91 ] . Except of the work [ 36 ] , we are not aware of theoretical results on the convergence of the proposed algorithm due to the presence of spurious local minima . The authors of [ 36 ] characterize the local vs . the global behav - ior of the objective function under the factorization ρ = UU † and discuss how existing methods fail due to improper stopping criteria or due to the lack of algorithmic convergence results . Their work highlights 16 the lack of rigorous convergence results of non - convex algorithms used in full quantum state tomography . There is no available implementation publicly available for these methods as well . Full QST using convex optimization . Despite the non - scalability of full QST , and the limitation of convex op - timization , a lot of research was devoted to this topic . Here , we mention only a few notable results that extend the applicability of full QST using speciﬁc techniques in convex optimization . Ref [ 88 ] shows that for given measurement schemes the solution for the maximum likelihood is given by a linear inversion scheme , followed by a projection onto the set of density matrices . More recently , the authors of [ 42 ] used a combination of the techniques of [ 88 ] with the sparsity of the Pauli matrices and the use of GPUs to per - form a full QST of 14 qubits . While pushing the limit of full QST using convex optimization , obtaining full tomographic experimental data for more than a dozen qubits is signiﬁcantly time - intensive . Moreover , this approach is highly centralized , in comparison to our approach that can be distributed . Using the sparsity pattern property of the Pauli matrices and GPUs is an excellent candidate approach to further enhance the performance of non - convex compressed sensing QST . QST using neural networks . Deep neural networks are ubiquitous , with many applications to science and industry . Recently , [ 93 , 12 , 94 , 31 ] show how machine learning and neural networks can be used to perform QST , driven by experimental data . The neural network architecture used is based on restricted Boltzmann machines ( RBMs ) [ 90 ] , which feature a visible and a hidden layer of stochastic binary neurons , fully con - nected with weighted edges . Test cases considered include reconstruction of W state , magnetic observables of local Hamiltonians , the unitary dynamics induced by Hamiltonian evolution . Comparison results are provided in the Main Results section . Alternative approaches include conditional generative adversarial networks ( CGANs ) [ 7 , 6 ] : in this case , two dueling neural networks , a generator and a discriminator , learn to generate and identify multi - modal models from data . QST for Matrix Product States ( MPS ) . This is the case of highly structured quantum states where the state is well - approximated by a MPS of low bond dimension [ 23 , 58 ] . The idea behind this approach is , in or - der to overcome exponential bottlenecks in the general QST case , we require highly structured subsets of states , similar to the assumptions made in compressed sensing QST . MPS QST is considered an alternative approach to reduce the computational and storage complexity of QST . Direct ﬁdelity estimation . Rather than focusing on entrywise estimation of density matrices , the direct ﬁ - delity estimation procedure focuses on checking how close is the state of the system to a target state , where closeness is quantiﬁed by the ﬁdelity metric . Classic techniques require up to 2 n / (cid:15) 4 number of samples , where (cid:15) denotes the accuracy of the ﬁdelity term , when considering a general quantum state [ 76 , 45 ] , but can be reduced to almost dimensionality - free 1 / (cid:15) 2 number of samples for speciﬁc cases , such as stabilizer states [ 29 , 24 , 50 ] . Shadow tomography is considered as an alternative and generalization of this technique [ 1 , 2 ] ; however , as noted in [ 45 ] , the procedure in [ 1 , 2 ] requires exponentially long quantum circuits that act collectively on all the copies of the unknown state stored in a quantum memory , and thus has not been implemented fully on real quantum machines . A recent neural network - based implementation of such in - direct QST learning methods is provided here [ 87 ] . The work in [ 76 , 45 ] , goes beyond simple ﬁdelity estimation , and utilizes random single qubit rotations to learn a minimal sketch of the unknown quantum state by which one that can predict arbitrary linear function of the state . Such methods constitute a favorable alternative to QST as they do not require number of samples that scale polynomially with the dimension ; however , this , in turn , implies that these methods cannot be used in general to estimate the density matrix itself . Methods MiFGD algorithm . Algorithm 1 contains the details of the Momentum - Inspired Factored Gradient Descent . The initial point U 0 is either randomly selected [ 15 , 80 ] , or set according to Lemma 4 in [ 57 ] to : ρ 0 = U 0 U † 0 = Π C (cid:0) − 1 1 + δ 2 r · ∇ f ( 0 ) (cid:1) = 1 1 + δ 2 r Π C (cid:18) m (cid:88) i = 1 y i A i (cid:19) ( 11 ) 17 Algorithm 1 Momentum - Inspired Factored Gradient Descent Input : A , y , r , µ , and # iterations J . Set U 0 randomly or as in ( 11 ) . Set Z 0 = U 0 . Set η as in ( 12 ) . for i = 0 to J − 1 do U i + 1 = Z i − η A † (cid:0) A ( ZZ † ) − y (cid:1) · Z i Z i + 1 = U i + 1 + µ ( U i + 1 − U i ) end for Output : ρ = U J U † J where Π C ( · ) is the projection onto the set of PSD matrices , δ 2 r ∈ ( 0 , 1 ) is the RIP constant and ∇ f ( 0 ) denoted the gradient of f evaluated at the all - zero matrix . Since computing the RIP constants is NP - hard , in practice we compute U 0 through ρ 0 = − 1 (cid:98) L Π C (cid:0) (cid:80) mi = 1 y i A i (cid:1) , where (cid:98) L ∈ ( 1 , 11 / 10 ] , see Theorem 2 below . Compared to randomly selecting U 0 , Eq . 11 involves a gradient descent computation and a top - r eigenvalue calculation . As for the step size in algorithm 1 , following Lemma 4 below , it is set to η = 1 4 ( ( 1 + δ 2 r ) (cid:107) Z 0 Z † 0 (cid:107) 2 + (cid:107)A † ( A ( Z 0 Z † 0 ) − y ) (cid:107) 2 ) , ( 12 ) where Z 0 = U 0 . Here as well , in practice we replace δ 2 r by (cid:98) L . The step size η remains constant at every iteration step of the algorithm , and requires only two top - eigenvalue computations to calculate the spectral norms (cid:107) Z 0 Z † 0 (cid:107) 2 and (cid:107)A † (cid:0) A ( Z 0 Z † 0 − y (cid:1) (cid:107) 2 . These computations can be efﬁciently implemented by any off - the - shelf eigenvalue solver , such as the Power Method or the Lanczos method . We now present the formal convergence theorem , where under certain conditions , MiFGD achieves an accelerated linear rate . Theorem 2 ( Accelerated convergence rate ) . Assume that A satisﬁes the RIP with constant δ 2 r ≤ 1 / 10 . Let U 0 and U − 1 be such that min R ∈O (cid:107) U 0 − U (cid:63) R (cid:107) F , min R ∈O (cid:107) U − 1 − U (cid:63) R (cid:107) F ≤ √ σ r ( ρ (cid:63) ) 10 3 √ κτ ( ρ (cid:63) ) , where κ : = 1 + δ 2 r 1 − δ 2 r , τ ( ρ ) : = σ 1 ( ρ ) σ r ( ρ ) for rank - r ρ , and σ i ( ρ ) is the i th singular value of ρ . Set step size η such that (cid:20) 1 − (cid:16) √ 1 + δ 2 r −√ 1 − δ 2 r ( √ 2 + 1 ) √ 1 + δ 2 r (cid:17) 4 (cid:21) · 10 4 σ r ( ρ (cid:63) ) ( 1 − δ 2 r ) ≤ η ≤ 10 4 σ r ( ρ (cid:63) ) ( 1 − δ 2 r ) , and the momentum parameter µ = ε 2 · 10 3 rτ ( ρ (cid:63) ) √ κ , for user - deﬁned ε ∈ ( 0 , 1 ] . For y = A ( ρ (cid:63) ) where rank ( ρ (cid:63) ) = r , MiFGD returns a solution such that min R ∈O (cid:107) U J + 1 − U (cid:63) R (cid:107) F ≤ (cid:18) 1 − (cid:113) 1 − δ 2 r 1 + δ 2 r (cid:19) J + 1 (cid:18) min R ∈O (cid:107) U 0 − U (cid:63) R (cid:107) 2 F + min R ∈O (cid:107) U − 1 − U (cid:63) R (cid:107) 2 F (cid:19) 1 / 2 + ξ · | µ | · σ 1 ( ρ (cid:63) ) 1 / 2 · r · (cid:32) 1 − (cid:18) 1 − (cid:113) 1 − δ 2 r 1 + δ 2 r (cid:19) J + 1 (cid:33) (cid:18) 1 − (cid:113) 1 − δ 2 r 1 + δ 2 r (cid:19) − 1 (cid:47) (cid:18) 1 − (cid:113) 1 − δ 2 r 1 + δ 2 r (cid:19) J + 1 (cid:18) min R ∈O (cid:107) U 0 − U (cid:63) R (cid:107) 2 F + min R ∈O (cid:107) U − 1 − U (cid:63) R (cid:107) 2 F (cid:19) 1 / 2 + O ( µ ) , ( 13 ) where ξ = (cid:113) 1 − 4 ησ r ( ρ (cid:63) ) ( 1 − δ 2 r ) 10 . That is , the algorithm has an accelerated linear convergence rate in iterate distances up to a constant proportional to the momentum parameter µ . The interpretation of the theorem is that the right hand side of Eq . ( 13 ) depends on the initial distances min R ∈O (cid:107) U 0 − U (cid:63) R (cid:107) F and min R ∈O (cid:107) U − 1 − U (cid:63) R (cid:107) F as in convex optimization , where (cid:16) 1 − (cid:113) 1 − δ 2 r 1 + δ 2 r (cid:17) appear as a contraction constant . In contrast , the contraction factor of vanilla FGD [ 57 ] is of the form (cid:16) 1 − 1 − δ 2 r 1 + δ 2 r (cid:17) , ignoring some constants . 18 As we assume the sensing map A satisﬁes RIP , the condition number of f depends on the RIP constants δ such that Lµ ∝ 1 + δ 1 − δ , since the eigenvalues of the Hessian of f , A † A ( · ) , lie between 1 − δ and 1 + δ , when restricted to low - rank matrices . Hence , MiFGD has better dependency on the ( inverse ) condition number of f than FGD . Such improvement of the dependency on the condition number is called “acceleration” in convex optimization [ 70 , 20 ] . Thus , assuming that the initial points U 0 and U − 1 are close enough to the optimum , as stated in the theorem , MiFGD decreases its distance to U (cid:63) with an accelerated linear rate , up to an “error” level that depends on the momentum parameter µ and it is bounded by 1 2 · 10 3 rτ ( ρ (cid:63) ) √ κ . Theorem 2 requires a strong assumption on the momentum parameter µ , which depends on quantities that might not be known a priori for general problems . However , we note that for the special case of QST , we know these quantities exactly : r is the rank of density matrix—thus , for pure states this value is equal to r = 1 ; τ ( ρ (cid:63) ) is the ( rank - restricted ) condition number of the density matrix ρ —for pure states , τ ( ρ (cid:63) ) = σ 1 ( ρ ) σ r ( ρ ) = σ 1 ( ρ ) σ 1 ( ρ ) = 1 ; and , ﬁnally , κ is the condition number of the sensing map , where , given the constraint δ 2 r ≤ 1 / 10 , leads to the following bound : κ ≤ 11 / 9 . The above lead to a momentum value µ ≈ ε / 2211 . However , as we show in the numerical experiments , the theory is conservative ; much larger values of µ lead to stable , improved performance . Finally , the bound on the condition number in Theorem 2 is not strict , and comes out of the analysis we follow ; we point the reader to similar assumptions made where τ ( ρ (cid:63) ) is assumed constant O ( 1 ) [ 62 ] . The detailed proof is provided in the supplementary material . To the best of our knowledge , this is the ﬁrst proof for momentum - inspired factorization technique , under common assumptions : both regarding the problem setting , and the assumptions made for its completion . The proof differs from state of the art proofs for non - accelerated factored gradient descent : due to the inclusion of the memory term , three differ - ent terms – U i + 1 , U i , U i − 1 – need to be handled simultaneously . Further , the proof differs from recent proofs on non - convex , but non - factored , gradient descent methods , as in [ 52 ] : the distance metric over rotations min R ∈O (cid:107) Z i − U (cid:63) R (cid:107) F , where Z i includes estimates from two steps in history , is not amenable to simple triangle inequality bounds , and a careful analysis is required . The analysis requires the design of two - dimensional dynamical systems , where we require to characterize and bound the eigenvalues of a 2 × 2 contraction matrix . Acknowledgements Anastasios Kyrillidis and Amir Kalev acknowledge funding by the NSF ( CCF - 1907936 ) . Anastasios Kyril - lidis thanks Mads Mikkelsen for his performance in “Jagten” and “Druk” . Data availability The empirical results were obtained via synthetic and real experiments ; the algorithm’s implementation is available at https : / / github . com / gidiko / MiFGD . Competing interests The authors declare no competing ﬁnancial or non - ﬁnancial interests . Author contribution All authors have made substantial contributions to the paper : design of the work , drafting the manuscript , ﬁnal approval and accountability for all aspects of the work . 19 References [ 1 ] Scott Aaronson . Shadow tomography of quantum states . In Proceedings of the 50th Annual ACM SIGACT Symposium on Theory of Computing , pages 325 – 338 , 2018 . [ 2 ] Scott Aaronson and Guy N Rothblum . Gentle measurement of quantum states and differential pri - vacy . In Proceedings of the 51st Annual ACM SIGACT Symposium on Theory of Computing , pages 322 – 333 , 2019 . [ 3 ] P . Achuthan and K . Venkatesan . General principles of quantum mechanics . Handbuch der Physik , 5 ( Part 1 ) , 1958 . [ 4 ] N . Agarwal , Z . Allen - Zhu , B . Bullins , E . Hazan , and T . Ma . Finding approximate local minima for nonconvex optimization in linear time . arXiv preprint arXiv : 1611 . 01146 , 2016 . [ 5 ] A . Agrawal , R . Verschueren , S . Diamond , and S . Boyd . A rewriting system for convex optimization problems . Journal of Control and Decision , 5 ( 1 ) : 42 – 60 , 2018 . [ 6 ] S . Ahmed , C . Mu˜noz , F . Nori , and A . Kockum . Classiﬁcation and reconstruction of optical quantum states with deep neural networks . arXiv preprint arXiv : 2012 . 02185 , 2020 . [ 7 ] S . Ahmed , C . S´anchez Mu˜noz , F . Nori , and A . Kockum . Quantum state tomography with conditional generative adversarial networks . arXiv preprint arXiv : 2008 . 03240 , 2020 . [ 8 ] Robert Alicki , Sl / awomir Rudnicki , and Sl / awomir Sadowski . Symmetry properties of product states for the system of n n - level atoms . Journal of mathematical physics , 29 ( 5 ) : 1158 – 1162 , 1988 . [ 9 ] Joseph B Altepeter , Daniel FV James , and Paul G Kwiat . 4 qubit quantum state tomography . In Quantum state estimation , pages 113 – 145 . Springer , 2004 . [ 10 ] K . Banaszek , G . M . D’Ariano , M . G . A . Paris , and M . F . Sacchi . Maximum - likelihood estimation of the density matrix . Physical Review A , 61 ( 1 ) : 010304 , 1999 . [ 11 ] Konrad Banaszek , Marcus Cramer , and David Gross . Focus on quantum tomography . New Journal of Physics , 15 ( 12 ) : 125020 , 2013 . [ 12 ] Matthew JS Beach , Isaac De Vlugt , Anna Golubeva , Patrick Huembeli , Bohdan Kulchytskyy , Xiuzhe Luo , Roger G Melko , Ejaaz Merali , and Giacomo Torlai . Qucumber : wavefunction reconstruction with neural networks . SciPost Physics , 7 ( 1 ) : 009 , 2019 . [ 13 ] A . Beck and M . Teboulle . A fast iterative shrinkage - thresholding algorithm for linear inverse prob - lems . SIAM journal on imaging sciences , 2 ( 1 ) : 183 – 202 , 2009 . [ 14 ] Srinadh Bhojanapalli , Anastasios Kyrillidis , and Sujay Sanghavi . Dropping convexity for faster semi - deﬁnite optimization . In Conference on Learning Theory , pages 530 – 582 , 2016 . [ 15 ] Srinadh Bhojanapalli , Behnam Neyshabur , and Nati Srebro . Global optimality of local search for low rank matrix recovery . In Advances in Neural Information Processing Systems , pages 3873 – 3881 , 2016 . [ 16 ] E . Bolduc , G . Knee , E . Gauger , and J . Leach . Projected gradient descent algorithms for quantum state tomography . npj Quantum Information , 3 ( 1 ) : 44 , 2017 . [ 17 ] S . Bubeck , Y . T . Lee , and M . Singh . A geometric alternative to Nesterov’s accelerated gradient descent . arXiv preprint arXiv : 1506 . 08187 , 2015 . [ 18 ] Samuel Burer and Renato DC Monteiro . A nonlinear programming algorithm for solving semideﬁnite programs via low - rank factorization . Mathematical Programming , 95 ( 2 ) : 329 – 357 , 2003 . [ 19 ] E . Candes and T . Tao . Near - optimal signal recovery from random projections : Universal encoding strategies ? IEEE transactions on information theory , 52 ( 12 ) : 5406 – 5425 , 2006 . 20 [ 20 ] Y . Carmon , J . Duchi , O . Hinder , and A . Sidford . Accelerated methods for non - convex optimization . arXiv preprint arXiv : 1611 . 00756 , 2016 . [ 21 ] Yudong Chen and Martin J Wainwright . Fast low - rank estimation by projected gradient descent : General statistical and algorithmic guarantees . arXiv preprint arXiv : 1509 . 03025 , 2015 . [ 22 ] Matthias Christandl and Graeme Mitchison . The spectra of quantum states and the kronecker coefﬁ - cients of the symmetric group . Communications in mathematical physics , 261 ( 3 ) : 789 – 797 , 2006 . [ 23 ] M . Cramer , M . B . Plenio , S . T . Flammia , R . Somma , D . Gross , S . D . Bartlett , O . Landon - Cardinal , D . Poulin , and Y . - K . Liu . Efﬁcient quantum state tomography . Nat . Comm . , 1 : 149 , 2010 . [ 24 ] Marcus P da Silva , Olivier Landon - Cardinal , and David Poulin . Practical characterization of quantum devices without tomography . Physical Review Letters , 107 ( 21 ) : 210404 , 2011 . [ 25 ] Lisandro D Dalcin , Rodrigo R Paz , Pablo A Kler , and Alejandro Cosimo . Parallel distributed comput - ing using python . Advances in Water Resources , 34 ( 9 ) : 1124 – 1139 , 2011 . [ 26 ] Steven Diamond and Stephen Boyd . CVXPY : A Python - embedded modeling language for convex optimization . Journal of Machine Learning Research , 17 ( 83 ) : 1 – 5 , 2016 . [ 27 ] Jens Eisert , Dominik Hangleiter , Nathan Walk , Ingo Roth , Damian Markham , Rhea Parekh , Ulysse Chabaud , and Elham Kasheﬁ . Quantum certiﬁcation and benchmarking . arXiv preprint arXiv : 1910 . 06343 , 2019 . [ 28 ] Steven T Flammia , David Gross , Yi - Kai Liu , and Jens Eisert . Quantum tomography via com - pressed sensing : error bounds , sample complexity and efﬁcient estimators . New Journal of Physics , 14 ( 9 ) : 095022 , 2012 . [ 29 ] Steven T Flammia and Yi - Kai Liu . Direct ﬁdelity estimation from few pauli measurements . Physical review letters , 106 ( 23 ) : 230501 , 2011 . [ 30 ] The MPI Forum . Mpi : A message passing interface . In Proceedings of the 1993 ACM / IEEE Conference on Supercomputing , Supercomputing ’93 , page 878 – 883 , New York , NY , USA , 1993 . Association for Computing Machinery . [ 31 ] Xun Gao and Lu - Ming Duan . Efﬁcient representation of quantum many - body states with deep neural networks . Nature communications , 8 ( 1 ) : 1 – 6 , 2017 . [ 32 ] Rong Ge , Chi Jin , and Yi Zheng . No spurious local minima in nonconvex low rank problems : A uniﬁed geometric analysis . arXiv preprint arXiv : 1704 . 00708 , 2017 . [ 33 ] S . Ghadimi and G . Lan . Stochastic ﬁrst - and zeroth - order methods for nonconvex stochastic program - ming . SIAM Journal on Optimization , 23 ( 4 ) : 2341 – 2368 , 2013 . [ 34 ] G . Goh . Why momentum really works . Distill , 2017 . [ 35 ] D . Gonc¸alves , M . Gomes - Ruggiero , and C . Lavor . A projected gradient method for optimization over density matrices . Optimization Methods and Software , 31 ( 2 ) : 328 – 341 , 2016 . [ 36 ] D . Gonc¸alves , M . Gomes - Ruggiero , C . Lavor , O . J . Farias , and P . Ribeiro . Local solutions of maxi - mum likelihood estimation in quantum state tomography . Quantum Information & Computation , 12 ( 9 - 10 ) : 775 – 790 , 2012 . [ 37 ] D . Gross . Recovering low - rank matrices from few coefﬁcients in any basis . IEEE Transactions on Information Theory , 57 ( 3 ) : 1548 – 1566 , 2011 . [ 38 ] D . Gross , Y . - K . Liu , S . Flammia , S . Becker , and J . Eisert . Quantum state tomography via compressed sensing . Physical review letters , 105 ( 15 ) : 150401 , 2010 . 21 [ 39 ] Masahito Hayashi and Keiji Matsumoto . Quantum universal variable - length source coding . Physical Review A , 66 ( 2 ) : 022311 , 2002 . [ 40 ] Bingsheng He and Xiaoming Yuan . On the convergence rate of douglas – rachford operator splitting method . Mathematical Programming , 153 ( 2 ) : 715 – 722 , 2015 . [ 41 ] R . Horn and Ch . Johnson . Matrix analysis . Cambridge university press , 1990 . [ 42 ] Zhibo Hou , Han - Sen Zhong , Ye Tian , Daoyi Dong , Bo Qi , Li Li , Yuanlong Wang , Franco Nori , Guo - Yong Xiang , Chuan - Feng Li , et al . Full reconstruction of a 14 - qubit state within four hours . New Journal of Physics , 18 ( 8 ) : 083036 , 2016 . [ 43 ] Ya - Ping Hsieh , Yu - Chun Kao , Rabeeh Karimi Mahabadi , Yurtsever Alp , Anastasios Kyrillidis , and Volkan Cevher . A non - euclidean gradient descent framework for non - convex matrix factorization . Technical report , Institute of Electrical and Electronics Engineers , 2017 . [ 44 ] Zhilin Hu , Kezhi Li , Shuang Cong , and Yaru Tang . Reconstructing pure 14 - qubit quantum states in three hours using compressive sensing . IFAC - PapersOnLine , 52 ( 11 ) : 188 – 193 , 2019 . 5th IFAC Confer - ence on Intelligent Control and Automation Sciences ICONS 2019 . [ 45 ] Hsin - Yuan Huang , Richard Kueng , and John Preskill . Predicting many properties of a quantum sys - tem from very few measurements . arXiv preprint arXiv : 2002 . 08953 , 2020 . [ 46 ] Prateek Jain and Inderjit S Dhillon . Provable inductive matrix completion . arXiv preprint arXiv : 1306 . 0626 , 2013 . [ 47 ] Prateek Jain , Raghu Meka , and Inderjit S Dhillon . Guaranteed rank minimization via singular value projection . In Advances in Neural Information Processing Systems , pages 937 – 945 , 2010 . [ 48 ] Miroslav Jeˇzek , Jarom´ır Fiur´aˇsek , and Zdenˇek Hradil . Quantum inference of states and processes . Physical Review A , 68 ( 1 ) : 012305 , 2003 . [ 49 ] A . Kalev , R . Kosut , and I . Deutsch . Quantum tomography protocols with positivity are compressed sensing protocols . NPJ Quantum Information , 1 : 15018 , 2015 . [ 50 ] Amir Kalev , Anastasios Kyrillidis , and Norbert M Linke . Validating and certifying stabilizer states . Physical Review A , 99 ( 4 ) : 042337 , 2019 . [ 51 ] Michael Keyl and Reinhard F Werner . Estimating the spectrum of a density operator . In Asymptotic Theory Of Quantum Statistical Inference : Selected Papers , pages 458 – 467 . World Scientiﬁc , 2005 . [ 52 ] R . Khanna and A . Kyrillidis . IHT dies hard : Provable accelerated iterative hard thresholding . arXiv preprint arXiv : 1712 . 09379 , 2017 . [ 53 ] D . Kingma and J . Ba . Adam : A method for stochastic optimization . arXiv preprint arXiv : 1412 . 6980 , 2014 . [ 54 ] Martin Kliesch , Richard Kueng , Jens Eisert , and David Gross . Guaranteed recovery of quantum pro - cesses from few measurements . Quantum , 3 : 171 , 2019 . [ 55 ] A . Kyrillidis and V . Cevher . Recipes on hard thresholding methods . In Computational Advances in Multi - Sensor Adaptive Processing ( CAMSAP ) , 2011 4th IEEE International Workshop on , pages 353 – 356 . IEEE , 2011 . [ 56 ] A . Kyrillidis and V . Cevher . Matrix recipes for hard thresholding methods . Journal of mathematical imaging and vision , 48 ( 2 ) : 235 – 265 , 2014 . [ 57 ] A . Kyrillidis , A . Kalev , D . Park , S . Bhojanapalli , C . Caramanis , and S . Sanghavi . Provable quantum state tomography via non - convex methods . npj Quantum Information , 4 ( 36 ) , 2018 . 22 [ 58 ] BP Lanyon , C Maier , Milan Holz¨apfel , Tillmann Baumgratz , C Hempel , P Jurcevic , Ish Dhand , AS Buyskikh , AJ Daley , Marcus Cramer , et al . Efﬁcient tomography of a quantum many - body system . Nature Physics , 13 ( 12 ) : 1158 – 1162 , 2017 . [ 59 ] J . Lee , M . Simchowitz , M . Jordan , and B . Recht . Gradient descent only converges to minimizers . In Conference on Learning Theory , pages 1246 – 1257 , 2016 . [ 60 ] Kiryung Lee and Yoram Bresler . Guaranteed minimum rank approximation from linear observations by nuclear norm minimization with an ellipsoidal constraint . arXiv preprint arXiv : 0903 . 4742 , 2009 . [ 61 ] Kiryung Lee and Yoram Bresler . Admira : Atomic decomposition for minimum rank approximation . IEEE Transactions on Information Theory , 56 ( 9 ) : 4402 – 4416 , 2010 . [ 62 ] Yuanxin Li , Cong Ma , Yuxin Chen , and Yuejie Chi . Nonconvex matrix factorization from rank - one measurements . In International Conference on Artiﬁcial Intelligence and Statistics , 2019 . [ 63 ] Y . - K . Liu . Universal low - rank matrix recovery from Pauli measurements . In Advances in Neural Infor - mation Processing Systems , pages 1638 – 1646 , 2011 . [ 64 ] Zhang Liu and Lieven Vandenberghe . Interior - point method for nuclear norm approximation with application to system identiﬁcation . SIAM Journal on Matrix Analysis and Applications , 31 ( 3 ) : 1235 – 1256 , 2009 . [ 65 ] L . Mirsky . A trace inequality of John von Neumann . Monatshefte f¨ur mathematik , 79 ( 4 ) : 303 – 306 , 1975 . [ 66 ] Masoud Mohseni , AT Rezakhani , and DA Lidar . Quantum - process tomography : Resource analysis of different strategies . Physical Review A , 77 ( 3 ) : 032322 , 2008 . [ 67 ] T . Moroder , P . Hyllus , G . T´oth , C . Schwemmer , A . Niggebaum , S . Gaile , O . G¨uhne , and H . Weinfurter . Permutationally invariant state reconstruction . New Journal of Physics , 14 ( 10 ) : 105001 , 2012 . [ 68 ] S . Negahban and M . Wainwright . Restricted strong convexity and weighted matrix completion : Op - timal bounds with noise . The Journal of Machine Learning Research , 13 ( 1 ) : 1665 – 1697 , 2012 . [ 69 ] Y . Nesterov . A method of solving a convex programming problem with convergence rate O ( 1 k 2 ) . In Soviet Mathematics Doklady , volume 27 , pages 372 – 376 , 1983 . [ 70 ] Y . Nesterov . Introductory lectures on convex optimization : A basic course , volume 87 . Springer Science & Business Media , 2013 . [ 71 ] Ryan O’Donnell and John Wright . Efﬁcient quantum tomography . In Proceedings of the forty - eighth annual ACM symposium on Theory of Computing , pages 899 – 912 , 2016 . [ 72 ] B . O’Donoghue and E . Candes . Adaptive restart for accelerated gradient schemes . Foundations of computational mathematics , 15 ( 3 ) : 715 – 732 , 2015 . [ 73 ] B . O’Donoghue , E . Chu , N . Parikh , and S . Boyd . Conic optimization via operator splitting and homo - geneous self - dual embedding . Journal of Optimization Theory and Applications , 169 ( 3 ) : 1042 – 1068 , June 2016 . [ 74 ] B . O’Donoghue , E . Chu , N . Parikh , and S . Boyd . SCS : Splitting conic solver , version 2 . 1 . 2 . https : / / github . com / cvxgrp / scs , November 2019 . [ 75 ] Brendan O’Donoghue . Operator splitting for a homogeneous embedding of the linear complemen - tarity problem . SIAM Journal on Optimization , 31 : 1999 – 2023 , August 2021 . [ 76 ] Marco Paini , Amir Kalev , Dan Padilha , and Brendan Ruck . Estimating expectation values using ap - proximate quantum states . Quantum , 5 : 413 , Mar 2021 . [ 77 ] M . Paris , G . D’Ariano , and M . Sacchi . Maximum - likelihood method in quantum estimation . In AIP Conference Proceedings , volume 568 , pages 456 – 467 . AIP , 2001 . 23 [ 78 ] Dohyung Park , Anastasios Kyrillidis , Srinadh Bhojanapalli , Constantine Caramanis , and Sujay Sang - havi . Provable burer - monteiro factorization for a class of norm - constrained matrix problems . arXiv preprint arXiv : 1606 . 01316 , 2016 . [ 79 ] Dohyung Park , Anastasios Kyrillidis , Constantine Caramanis , and Sujay Sanghavi . Finding low - rank solutions to matrix problems , efﬁciently and provably . arXiv preprint arXiv : 1606 . 03168 , 2016 . [ 80 ] Dohyung Park , Anastasios Kyrillidis , Constantine Caramanis , and Sujay Sanghavi . Non - square matrix sensing without spurious local minima via the burer - monteiro approach . arXiv preprint arXiv : 1609 . 03240 , 2016 . [ 81 ] QISKit Development Team . Qiskit . [ 82 ] Benjamin Recht , Maryam Fazel , and Pablo A Parrilo . Guaranteed minimum - rank solutions of linear matrix equations via nuclear norm minimization . SIAM review , 52 ( 3 ) : 471 – 501 , 2010 . [ 83 ] C . Riofr´ıo , D . Gross , S . T . Flammia , T . Monz , D . Nigg , R . Blatt , and J . Eisert . Experimental quantum compressed sensing for a seven - qubit system . Nature Communications , 8 , 2017 . [ 84 ] M . Rudelson and R . Vershynin . On sparse reconstruction from Fourier and Gaussian measurements . Communications on Pure and Applied Mathematics : A Journal Issued by the Courant Institute of Mathematical Sciences , 61 ( 8 ) : 1025 – 1045 , 2008 . [ 85 ] C . Schwemmer , G . T´oth , A . Niggebaum , T . Moroder , D . Gross , O . G¨uhne , and H . Weinfurter . Ex - perimental comparison of efﬁcient tomography schemes for a six - qubit state . Physical review letters , 113 ( 4 ) : 040503 , 2014 . [ 86 ] Jiangwei Shang , Zhengyun Zhang , and Hui Khoon Ng . Superfast maximum - likelihood reconstruc - tion for quantum tomography . Phys . Rev . A , 95 : 062336 , Jun 2017 . [ 87 ] A . Smith , Johnnie Gray , and M . Kim . Efﬁcient approximate quantum state tomography with basis dependent neural - networks . arXiv preprint arXiv : 2009 . 07601 , 2020 . [ 88 ] J . A . Smolin , J . M . Gambetta , and G . Smith . Efﬁcient method for computing the maximum - likelihood quantum state from measurements with additive Gaussian noise . Physical review letters , 108 ( 7 ) : 070502 , 2012 . [ 89 ] Ruoyu Sun and Zhi - Quan Luo . Guaranteed matrix completion via non - convex factorization . IEEE Transactions on Information Theory , 62 ( 11 ) : 6535 – 6579 , 2016 . [ 90 ] Ilya Sutskever , Geoffrey E Hinton , and Graham W Taylor . The recurrent temporal restricted boltz - mann machine . In Advances in neural information processing systems , pages 1601 – 1608 , 2009 . [ 91 ] Y . S . Teo , J . ˇReh ´ a ˇ cek , and Z . Hradil . Informationally incomplete quantum tomography . Quantum Measurements and Quantum Metrology , 1 , 2013 . [ 92 ] T . Tieleman and G . Hinton . Lecture 6 . 5 - RMSPro : Divide the gradient by a running average of its recent magnitude . COURSERA : Neural networks for machine learning , 4 ( 2 ) : 26 – 31 , 2012 . [ 93 ] Giacomo Torlai , Guglielmo Mazzola , Juan Carrasquilla , Matthias Troyer , Roger Melko , and Giuseppe Carleo . Neural - network quantum state tomography . Nat . Phys . , 14 : 447 – 450 , May 2018 . [ 94 ] Giacomo Torlai and Roger Melko . Machine - learning quantum states in the NISQ era . Annual Review of Condensed Matter Physics , 11 , 2019 . [ 95 ] G . T´oth , W . Wieczorek , D . Gross , R . Krischek , C . Schwemmer , and H . Weinfurter . Permutationally invariant quantum tomography . Physical review letters , 105 ( 25 ) : 250403 , 2010 . [ 96 ] S . Tu , R . Boczar , M . Simchowitz , M . Soltanolkotabi , and B . Recht . Low - rank solutions of linear ma - trix equations via Procrustes ﬂow . In Proceedings of the 33rd International Conference on International Conference on Machine Learning - Volume 48 , pages 964 – 973 . JMLR . org , 2016 . 24 [ 97 ] L . Vandenberghe . The CVXOPT linear and quadratic cone program solvers . Online : http : / / cvxopt . org / documentation / coneprog . pdf , 2010 . [ 98 ] K Vogel and H Risken . Determination of quasiprobability distributions in terms of probability distri - butions for the rotated quadrature phase . Physical Review A , 40 ( 5 ) : 2847 , 1989 . [ 99 ] J . ˇReh´aˇcek , Z . Hradil , E . Knill , and A . I . Lvovsky . Diluted maximum - likelihood algorithm for quan - tum tomography . Phys . Rev . A , 75 : 042108 , 2007 . [ 100 ] Andrew E Waters , Aswin C Sankaranarayanan , and Richard Baraniuk . Sparcs : Recovering low - rank and sparse matrices from compressive measurements . In Advances in neural information processing systems , pages 1089 – 1097 , 2011 . [ 101 ] Peng Xu , Bryan He , Christopher De Sa , Ioannis Mitliagkas , and Chris Re . Accelerated stochastic power iteration . In International Conference on Artiﬁcial Intelligence and Statistics , pages 58 – 67 , 2018 . [ 102 ] Tuo Zhao , Zhaoran Wang , and Han Liu . A nonconvex optimization framework for low rank matrix estimation . In Advances in Neural Information Processing Systems , pages 559 – 567 , 2015 . [ 103 ] Qinqing Zheng and John Lafferty . A convergent gradient descent algorithm for rank minimization and semideﬁnite programming from random linear measurements . In Advances in Neural Information Processing Systems , pages 109 – 117 , 2015 . 25 Appendix IBM Quantum system experiments : GHZ − ( 6 ) circuit , 2048 shots 0 1000 Iterations 1 . 2 × 10 0 1 . 4 × 10 0 k b ρ − ρ ? k 2 F 0 1000 Iterations 6 × 10 − 1 1 . 2 × 10 0 0 1000 Iterations 6 × 10 − 1 1 . 2 × 10 0 0 1000 Iterations 6 × 10 − 1 1 . 2 × 10 0 0 250 Iterations 6 × 10 − 1 1 . 2 × 10 0 0 200 Iterations 6 × 10 − 1 1 . 2 × 10 0 µ = 0 µ = 1 / 8 µ = 1 / 4 µ = 1 / 3 µ = 3 / 4 µ = µ ? Figure 8 : Target error list plots for reconstructing GHZ − ( 6 ) circuit using real measurements from IBM Quan - tum system experiments . 0 1000 Iterations 1 . 2 × 10 0 1 . 4 × 10 0 k b ρ − ρ ? k 2 F 0 1000 Iterations 10 0 1 . 25 × 10 0 0 1000 Iterations 10 0 1 . 25 × 10 0 0 1000 Iterations 10 − 1 10 0 0 500 Iterations 10 − 1 10 0 0 250 Iterations 10 − 1 1 0 0 µ = 0 µ = 1 / 8 µ = 1 / 4 µ = 1 / 3 µ = 3 / 4 µ = µ ? Figure 9 : Target error list plots for reconstructing GHZ − ( 6 ) circuit using synthetic measurements from IBM’s quantum simulator . µ ? 18 14 13 34 Momentum µ 800 900 1000 I t e r a t i o n s µ ? 18 14 13 34 Momentum µ 700 800 900 1000 µ ? 18 14 13 34 Momentum µ 600 800 1000 µ ? 18 14 13 34 Momentum µ 200 400 600 800 µ ? 18 14 13 34 Momentum µ 100 200 300 400 µ ? 18 14 13 34 Momentum µ 50 100 150 200 GHZMinus / Qiskit simulator GHZMinus / IBMQ device Figure 10 : Convergence iteration plots for reconstructing GHZ − ( 6 ) circuit using using real measurements from IBM Quantum system experiments and synthetic measurements from Qiskit simulation experiments . µ ? 18 14 13 34 Momentum µ 0 . 00 0 . 05 0 . 10 F i d e li t y µ ? 18 14 13 34 Momentum µ 0 . 0 0 . 4 0 . 8 µ ? 18 14 13 34 Momentum µ 0 . 0 0 . 4 0 . 8 µ ? 18 14 13 34 Momentum µ 0 . 90 0 . 95 µ ? 18 14 13 34 Momentum µ 0 . 92 0 . 96 µ ? 18 14 13 34 Momentum µ 0 . 92 0 . 96 GHZMinus / Qiskit simulator GHZMinus / IBMQ device Figure 11 : Fidelity list plots for reconstructing GHZ − ( 6 ) circuit using using real measurements from IBM Quantum system experiments and synthetic measurements from Qiskit simulation experiments . 26 IBM Quantum system experiments : GHZ − ( 6 ) circuit , 8192 shots 0 1000 Iterations 1 . 2 × 10 0 1 . 4 × 10 0 k b ρ − ρ ? k 2 F 0 1000 Iterations 10 0 1 . 25 × 10 0 0 1000 Iterations 10 0 1 . 25 × 10 0 0 1000 Iterations 6 × 10 − 1 1 . 2 × 10 0 0 250 Iterations 6 × 10 − 1 1 . 2 × 10 0 0 200 Iterations 6 × 10 − 1 1 . 2 × 10 0 µ = 0 µ = 1 / 8 µ = 1 / 4 µ = 1 / 3 µ = 3 / 4 µ = µ ? Figure 12 : Target error list plots for reconstructing GHZ − ( 6 ) circuit using real measurements from IBM Quantum system experiments . 0 1000 Iterations 1 . 2 × 1 0 0 1 . 4 × 10 0 k b ρ − ρ ? k 2 F 0 1000 Iterations 10 0 1 . 2 5 × 10 0 0 1000 Iterations 10 0 1 . 25 × 10 0 0 1000 Iterations 10 − 1 10 0 0 500 Iterations 10 − 1 10 0 0 250 Iterations 10 − 1 10 0 µ = 0 µ = 1 / 8 µ = 1 / 4 µ = 1 / 3 µ = 3 / 4 µ = µ ? Figure 13 : Target error list plots for reconstructing GHZ − ( 6 ) circuit using synthetic measurements from IBM’s quantum simulator . µ ? 18 14 13 34 Momentum µ 800 900 1000 I t e r a t i o n s µ ? 18 14 13 34 Momentum µ 700 800 900 1000 µ ? 18 14 13 34 Momentum µ 600 800 1000 µ ? 18 14 13 34 Momentum µ 200 400 600 800 µ ? 18 14 13 34 Momentum µ 100 200 300 400 µ ? 18 14 13 34 Momentum µ 50 100 150 200 GHZMinus / Qiskit simulator GHZMinus / IBMQ device Figure 14 : Convergence iteration plots for reconstructing GHZ − ( 6 ) circuit using using real measurements from IBM Quantum system experiments and synthetic measurements from Qiskit simulation experiments . µ ? 18 14 13 34 Momentum µ 0 . 00 0 . 04 0 . 08 F i d e li t y µ ? 18 14 13 34 Momentum µ 0 . 0 0 . 1 0 . 2 0 . 3 µ ? 18 14 13 34 Momentum µ 0 . 00 0 . 05 0 . 10 µ ? 18 14 13 34 Momentum µ 0 . 93 0 . 96 0 . 99 µ ? 18 14 13 34 Momentum µ 0 . 94 0 . 96 0 . 98 µ ? 18 14 13 34 Momentum µ 0 . 94 0 . 96 0 . 98 GHZMinus / Qiskit simulator GHZMinus / IBMQ device Figure 15 : Fidelity list plots for reconstructing GHZ − ( 6 ) circuit using using real measurements from IBM Quantum system experiments and synthetic measurements from Qiskit simulation experiments . 27 IBM Quantum system experiments : GHZ − ( 8 ) circuit , 2048 shots 0 1000 Iterations 10 0 6 × 10 − 1 k b ρ − ρ ? k 2 F 0 500 Iterations 10 0 6 × 10 − 1 0 200 Iterations 10 0 6 × 10 − 1 0 200 Iterations 10 0 6 × 10 − 1 0 100 Iterations 10 0 6 × 10 − 1 0 50 Iterations 10 0 6 × 10 − 1 µ = 0 µ = 1 / 8 µ = 1 / 4 µ = 1 / 3 µ = 3 / 4 µ = µ ? Figure 16 : Target error list plots for reconstructing GHZ − ( 8 ) circuit using real measurements from IBM Quantum system experiments . 0 1000 Iterations 10 0 k b ρ − ρ ? k 2 F 0 500 Iterations 10 0 0 200 Iterations 10 − 1 10 0 0 200 Iterations 10 − 1 10 0 0 100 Iterations 10 − 1 10 0 0 50 Iterations 10 − 1 10 0 µ = 0 µ = 1 / 8 µ = 1 / 4 µ = 1 / 3 µ = 3 / 4 µ = µ ? Figure 17 : Target error list plots for reconstructing GHZ − ( 8 ) circuit using synthetic measurements from IBM’s quantum simulator . µ ? 18 14 13 34 Momentum µ 400 600 800 1000 I t e r a t i o n s µ ? 18 14 13 34 Momentum µ 200 400 µ ? 18 14 13 34 Momentum µ 100 200 300 µ ? 18 14 13 34 Momentum µ 100 150 200 µ ? 18 14 13 34 Momentum µ 40 60 80 100 µ ? 18 14 13 34 Momentum µ 40 60 GHZMinus / Qiskit simulator GHZMinus / IBMQ device Figure 18 : Convergence iteration plots for reconstructing GHZ − ( 8 ) circuit using using real measurements from IBM Quantum system experiments and synthetic measurements from Qiskit simulation experiments . µ ? 18 14 13 34 Momentum µ 0 . 7 0 . 8 0 . 9 F i d e li t y µ ? 18 14 13 34 Momentum µ 0 . 8 0 . 9 µ ? 18 14 13 34 Momentum µ 0 . 8 0 . 9 µ ? 18 14 13 34 Momentum µ 0 . 8 0 . 9 µ ? 18 14 13 34 Momentum µ 0 . 8 0 . 9 µ ? 18 14 13 34 Momentum µ 0 . 8 0 . 9 GHZMinus / Qiskit simulator GHZMinus / IBMQ device Figure 19 : Fidelity list plots for reconstructing GHZ − ( 8 ) circuit using using real measurements from IBM Quantum system experiments and synthetic measurements from Qiskit simulation experiments . 28 IBM Quantum system experiments : GHZ − ( 8 ) circuit , 4096 shots 0 1000 Iterations 10 0 6 × 10 − 1 k b ρ − ρ ? k 2 F 0 500 Iterations 10 0 6 × 10 − 1 0 200 Iterations 10 0 6 × 10 − 1 0 200 Iterations 10 0 6 × 10 − 1 0 100 Iterations 10 0 6 × 10 − 1 0 50 Iterations 10 0 6 × 10 − 1 µ = 0 µ = 1 / 8 µ = 1 / 4 µ = 1 / 3 µ = 3 / 4 µ = µ ? Figure 20 : Target error list plots for reconstructing GHZ − ( 8 ) circuit using real measurements from IBM Quantum system experiments . 0 1000 Iterations 10 − 1 10 0 k b ρ − ρ ? k 2 F 0 500 Iterations 10 − 1 10 0 0 200 Iterations 10 − 1 10 0 0 200 Iterations 10 − 1 10 0 0 100 Iterations 10 − 1 10 0 0 50 Iterations 10 − 1 10 0 µ = 0 µ = 1 / 8 µ = 1 / 4 µ = 1 / 3 µ = 3 / 4 µ = µ ? Figure 21 : Target error list plots for reconstructing GHZ − ( 8 ) circuit using synthetic measurements from IBM’s quantum simulator . µ ? 18 14 13 34 Momentum µ 400 600 800 1000 I t e r a t i o n s µ ? 18 14 13 34 Momentum µ 200 400 µ ? 18 14 13 34 Momentum µ 100 200 µ ? 18 14 13 34 Momentum µ 50 100 150 200 µ ? 18 14 13 34 Momentum µ 40 60 80 100 µ ? 18 14 13 34 Momentum µ 40 60 GHZMinus / Qiskit simulator GHZMinus / IBMQ device Figure 22 : Convergence iteration plots for reconstructing GHZ − ( 8 ) circuit using using real measurements from IBM Quantum system experiments and synthetic measurements from Qiskit simulation experiments . µ ? 18 14 13 34 Momentum µ 0 . 8 0 . 9 F i d e li t y µ ? 18 14 13 34 Momentum µ 0 . 8 0 . 9 µ ? 18 14 13 34 Momentum µ 0 . 80 0 . 88 0 . 96 µ ? 18 14 13 34 Momentum µ 0 . 80 0 . 88 0 . 96 µ ? 18 14 13 34 Momentum µ 0 . 80 0 . 88 0 . 96 µ ? 18 14 13 34 Momentum µ 0 . 80 0 . 88 0 . 96 GHZMinus / Qiskit simulator GHZMinus / IBMQ device Figure 23 : Fidelity list plots for reconstructing GHZ − ( 8 ) circuit using using real measurements from IBM Quantum system experiments and synthetic measurements from Qiskit simulation experiments . 29 IBM Quantum system experiments : Hadamard ( 6 ) circuit , 8192 shots 0 1000 Iterations 1 . 2 × 10 0 1 . 4 × 10 0 k b ρ − ρ ? k 2 F 0 1000 Iterations 1 . 2 × 10 0 1 . 4 × 10 0 0 1000 Iterations 10 0 0 1000 Iterations 10 0 0 500 Iterations 10 − 1 10 0 0 200 Iterations 10 − 1 10 0 µ = 0 µ = 1 / 8 µ = 1 / 4 µ = 1 / 3 µ = 3 / 4 µ = µ ? Figure 24 : Target error list plots for reconstructing Hadamard ( 6 ) circuit using real measurements from IBM Quantum system experiments . 0 1000 Iterations 1 . 2 × 10 0 1 . 4 × 10 0 k b ρ − ρ ? k 2 F 0 1000 Iterations 1 . 2 × 1 0 0 1 . 4 × 10 0 0 1000 Iterations 10 − 1 10 0 0 1000 Iterations 10 − 1 10 0 0 250 Iterations 10 − 1 10 0 0 200 Iterations 10 − 1 10 0 µ = 0 µ = 1 / 8 µ = 1 / 4 µ = 1 / 3 µ = 3 / 4 µ = µ ? Figure 25 : Target error list plots for reconstructing Hadamard ( 6 ) circuit using synthetic measurements from IBM’s quantum simulator . µ ? 18 14 13 34 Momentum µ 800 900 1000 I t e r a t i o n s µ ? 18 14 13 34 Momentum µ 600 800 1000 µ ? 18 14 13 34 Momentum µ 400 600 800 1000 µ ? 18 14 13 34 Momentum µ 250 500 750 1000 µ ? 18 14 13 34 Momentum µ 200 400 µ ? 18 14 13 34 Momentum µ 100 200 Hadamard / Qiskit simulator Hadamard / IBMQ device Figure 26 : Convergence iteration plots for reconstructing Hadamard ( 6 ) circuit using using real measure - ments from IBM Quantum system experiments and synthetic measurements from Qiskit simulation . µ ? 18 14 13 34 Momentum µ 0 . 00 0 . 05 0 . 10 F i d e li t y µ ? 18 14 13 34 Momentum µ 0 . 00 0 . 05 0 . 10 µ ? 18 14 13 34 Momentum µ 0 . 25 0 . 50 0 . 75 1 . 00 µ ? 18 14 13 34 Momentum µ 0 . 0 0 . 5 1 . 0 µ ? 18 14 13 34 Momentum µ 0 . 985 0 . 990 0 . 995 µ ? 18 14 13 34 Momentum µ 0 . 988 0 . 992 0 . 996 Hadamard / Qiskit simulator Hadamard / IBMQ device Figure 27 : Fidelity list plots for reconstructing Hadamard ( 6 ) circuit using using real measurements from IBM Quantum system experiments and synthetic measurements from Qiskit simulation experiments . 30 IBM Quantum system experiments : Hadamard ( 8 ) circuit , 4096 shots 0 1000 Iterations 6 × 10 − 1 1 . 2 × 10 0 k b ρ − ρ ? k 2 F 0 500 Iterations 6 × 10 − 1 1 . 2 × 10 0 0 200 Iterations 6 × 10 − 1 1 . 2 × 10 0 0 200 Iterations 6 × 10 − 1 1 . 2 × 10 0 0 100 Iterations 6 × 10 − 1 1 . 2 × 10 0 0 50 Iterations 6 × 10 − 1 1 . 2 × 10 0 µ = 0 µ = 1 / 8 µ = 1 / 4 µ = 1 / 3 µ = 3 / 4 µ = µ ? Figure 28 : Target error list plots for reconstructing Hadamard ( 8 ) circuit using real measurements from IBM Quantum system experiments . 0 1000 Iterations 10 − 1 10 0 k b ρ − ρ ? k 2 F 0 500 Iterations 10 − 1 10 0 0 200 Iterations 10 − 1 10 0 0 200 Iterations 10 − 1 10 0 0 100 Iterations 10 − 1 10 0 0 50 Iterations 10 − 1 10 0 µ = 0 µ = 1 / 8 µ = 1 / 4 µ = 1 / 3 µ = 3 / 4 µ = µ ? Figure 29 : Target error list plots for reconstructing Hadamard ( 8 ) circuit using synthetic measurements from IBM’s quantum simulator . µ ? 18 14 13 34 Momentum µ 400 600 800 1000 I t e r a t i o n s µ ? 18 14 13 34 Momentum µ 200 400 µ ? 18 14 13 34 Momentum µ 100 200 300 µ ? 18 14 13 34 Momentum µ 100 150 200 µ ? 18 14 13 34 Momentum µ 40 60 80 100 µ ? 18 14 13 34 Momentum µ 40 50 60 Hadamard / Qiskit simulator Hadamard / IBMQ device Figure 30 : Convergence iteration plots for reconstructing Hadamard ( 8 ) circuit using using real measure - ments from IBM Quantum system experiments and synthetic measurements from Qiskit simulation . µ ? 18 14 13 34 Momentum µ 0 . 8 0 . 9 F i d e li t y µ ? 18 14 13 34 Momentum µ 0 . 92 0 . 94 0 . 9 6 µ ? 18 14 13 34 Momentum µ 0 . 94 0 . 96 µ ? 18 14 13 34 Momentum µ 0 . 94 0 . 96 µ ? 18 14 13 34 Momentum µ 0 . 94 0 . 9 6 µ ? 18 14 13 34 Momentum µ 0 . 94 0 . 96 Hadamard / Qiskit simulator Hadamard / IBMQ device Figure 31 : Fidelity list plots for reconstructing Hadamard ( 8 ) circuit using using real measurements from IBM Quantum system experiments and synthetic measurements from Qiskit simulation experiments . 31 Synthetic experiments for n = 12 We compare MiFGD with i ) the Matrix ALPS framework [ 56 ] , a state of the art projected gradient descent algorithm , and an optimized version of matrix iterative hard thresholding , operating on the full matrix variable ρ , with adaptive step size η ( we note that this algorithm has outperformed most of the schemes that work on the original space ρ ; see [ 56 ] ) ; ii ) the plain Procrustes Flow / FGD algorithm [ 96 , 14 , 57 ] , where we use the step size as reported in [ 14 ] , since the later has reported better performance than vanilla Procrustes Flow . We note that the Procrustes Flow / FGD algorithm is similar to our algorithm without acceleration . Further , the original Procrustes Flow / FGD algorithm relies on performing many iterations in the original space ρ as an initialization scheme , which is often prohibitive as the problem dimensions grow . Both for our algorithm and the plain Procrustes Flow / FGD scheme , we use random initialization . To properly compare the algorithms in the above list , we pre - select a common set of problem parameters . We ﬁx the dimension d = 4096 ( equivalent to n = 12 qubits ) , and the rank of the optimal matrix ρ (cid:63) ∈ R d × d to be r = 10 ( equivalent to a mixed quantum state reconstruction ) . Similar behavior has been observed for other values of r , and are omitted . We ﬁx the number of observables m to be m = c · d · r , where c ∈ { 3 , 5 } . In all algorithms , we ﬁx the maximum number of iterations to 4000 , and we use the same stopping criterion : (cid:107) ρ i + 1 − ρ i (cid:107) F / (cid:107) ρ i (cid:107) F ≤ tol = 10 − 3 . For the implementation of MiFGD , we have used the momentum parameter µ = 2 3 , as well as the theoretical µ value . 0 50 100 150 200 10 - 3 10 - 2 10 - 1 10 0 0 500 1000 10 - 3 10 - 2 10 - 1 10 0 0 500 1000 10 - 3 10 - 2 10 - 1 10 0 0 50 100 150 200 250 10 - 3 10 - 2 10 - 1 10 0 0 200 400 600 10 - 3 10 - 2 10 - 1 10 0 0 200 400 600 10 - 3 10 - 2 10 - 1 10 0 Figure 32 : Synthetic example results on low - rank matrix sensing in higher dimensions ( equivalent to n = 12 qubits ) . Top row : Convergence behavior vs . time elapsed . Bottom row : Convergence behavior vs . number of iterations . Left panel : c = 5 , noiseless case ; Center panel : c = 3 , noiseless case ; Right panel : c = 5 , noisy case , (cid:107) w (cid:107) 2 = 0 . 01 . The procedure to generate synthetically the data is as follows : The observations y are set to y = A ( ρ (cid:63) ) + w for some noise vector w ; while the theory holds for the noiseless case , we show empirically that noisy cases are robustly handled by the same algorithm . We use permuted and subsampled noiselets for the linear operator A [ 100 ] . The optimal matrix ρ (cid:63) is generated as the multiplication of a tall matrix U (cid:63) ∈ R d × r such that ρ (cid:63) = U (cid:63) U (cid:63) (cid:62) , and (cid:107) ρ (cid:63) (cid:107) F = 1 , without loss of generality . The entries of U (cid:63) are drawn i . i . d . from a Gaussian distribution with zero mean and unit variance . In the noisy case , w has the same dimensions with y , its entries are drawn from a zero mean Gaussian distribution with norm (cid:107) w (cid:107) 2 = 0 . 01 . The random initialization is deﬁned as U 0 drawn i . i . d . from a Gaussian distribution with zero mean and unit variance . The results are shown in Figure 32 . Some notable remarks : i ) While factorization techniques might take more iterations to converge compared to non - factorized algorithms , the per iteration time complexity is much less , such that overall , factorized gradient descent converges more quickly in terms of total execution 32 time . ii ) Our proposed algorithm , even under the restrictive assumptions on acceleration parameter µ , performs better than the non - accelerated factored gradient descent algorithms , such as Procrustes Flow . iii ) Our theory is conservative : using a much larger µ we obtain a faster convergence ; the proof for less strict as - sumptions for µ is an interesting future direction . In all cases , our ﬁndings illustrate the effectiveness of the proposed schemes on different problem conﬁgurations . Asymptotic complexity comparison of lstsq , CVXPY , and MiFGD We ﬁrst note that lstsq can be only applied to the case we have a full tomographic set of measure - ments ; this makes lstsq algorithm inapplicable in the compressed sensing scenario , where the number of measurements can be signiﬁcantly reduced . Yet , we make the comparison by providing information - theoretically complete set of measurements to lstsq and CVXPY , as well as to MiFGD , to highlight the efﬁciency of our proposed method , even in the scenario that is not exactly intended in our work . Given this , we compare in detail the asymptotic scailing of MiFGD with lstsq and CVXPY below : • lstsq is based on the computation of eigenvalues / eigenvector pairs ( among other steps ) of a matrix of size equal to the density matrix we want to reconstruct . Based on our notation , the density matrices are denoted as ρ with dimensions 2 n × 2 n . Here , n is the number of qubits in the quantum system . Standard libraries for eigenvalue / eigenvector calculations , like LAPACK , reduce a Hermitian matrix to tridiagonal form using the Householder method , which takes overall a O (cid:0) ( 2 n ) 3 (cid:1) computational complexity . The other steps in the lstsq procedure either take constant time , or O ( 2 n ) complexity . Thus , the actual run - time of an implementation depends on the eigensystem solver that is being used . • CVXPY is distributed with the open source solvers ; for the case of SDP instances , CVXPY utilizes the Splitting Conic Solver ( SCS ) 18 , a general numerical optimization package for solving large - scale con - vex cone problems . SCS applies Douglas - Rachford splitting to a homogeneous embedding of the quadratic cone program . Based on the PSD constraint , this again involves the computation of eigen - values / eigenvector pairs ( among other steps ) of a matrix of size equal to the density matrix we want to reconstruct . This takes overall a O (cid:0) ( 2 n ) 3 (cid:1) computational complexity , not including the other steps performed within the SCS solver . This is an iterative algorithm that requires such complexity per iter - ation . Douglas - Rachford splitting methods enjoy O ( 1 ε ) convergence rate in general [ 40 , 73 , 75 ] . This leads to a rough O ( ( 2 n ) 3 · 1 ε ) overall iteration complexity . 19 • For MiFGD , and for sufﬁciently small momentum value , we require O ( √ κ · log ( 1 ε ) ) iterations to get close to the optimal value . Per iteration , MiFGD does not involve any expensive eigensystem solvers , but relies only on matrix - matrix and matrix - vector multiplications . In particular , the main computa - tional complexity per iteration origins from the iteration : U i + 1 = Z i − η A † (cid:16) A ( Z i Z † i ) − y (cid:17) · Z i , ( 14 ) Z i + 1 = U i + 1 + µ ( U i + 1 − U i ) . ( 15 ) Here , U i , Z i ∈ R 2 n × r for all i . Observe that A ( Z i Z † i ) ∈ R m where each element is computed indepen - dently . For an index j ∈ [ m ] , ( A ( Z i Z † i ) ) j = Tr ( A j Z i Z † i ) requires O ( ( 2 n ) 2 · r ) complexity , and thus computing A ( Z i Z † i ) − y requires O ( ( 2 n ) 2 · r ) complexity , overall . By deﬁnition the adjoing operation A † : R m → C 2 n × 2 n satisﬁes : A † ( x ) = (cid:80) mi = 1 x i A i ; thus , the operation A † (cid:16) A ( Z i Z † i ) − y (cid:17) is still domi - nated by O ( ( 2 n ) 2 · r ) complexity . Finally , we perform one more matrix - matrix multiplication with Z i , which results into an additional O ( ( 2 n ) 2 · r ) complexity . The rest of the operations involve adding 2 n × r matrices , which does not dominate the overall complexity . Combining the iteration complexity with the per - iteration computational complexity , MiFGD has a O ( ( 2 n ) 2 · r · √ κ · log ( 1 ε ) ) complexity . 18 https : / / github . com / cvxgrp / scs 19 This is an optimistic complexity bound since we have skipped several details within the Douglas - Rachford implementation of CVXPY . 33 Combining the above , we summarize the following complexities : O ( ( 2 n ) 3 ) (cid:124) (cid:123)(cid:122) (cid:125) lstsq vs O ( ( 2 n ) 3 · 1 ε ) (cid:124) (cid:123)(cid:122) (cid:125) CVXPY vs O ( ( 2 n ) 2 · r · √ κ · log ( 1 ε ) ) (cid:124) (cid:123)(cid:122) (cid:125) MiFGD Observe that i ) MiFGD has the best dependence on the number of qubits and the ambient dimension of the problem , 2 n ; ii ) MiFGD applies to cases that lstsq is inapplicable ; iii ) MiFGD has a better iteration complexity than other iterative algorithms , while has a better polynomial dependency on 2 n . Detailed proof of Theorem 2 We ﬁrst denote U + ≡ U i + 1 , U ≡ U i , U − ≡ U i − 1 and Z ≡ Z i . Let us start with the following equality . For R Z ∈ O as the minimizer of min R ∈O (cid:107) Z − U (cid:63) R (cid:107) F , we have : (cid:107) U + − U (cid:63) R Z (cid:107) 2 F = (cid:107) U + − Z + Z − U (cid:63) R Z (cid:107) 2 F ( 16 ) = (cid:107) U + − Z (cid:107) 2 F + (cid:107) Z − U (cid:63) R Z (cid:107) 2 F − 2 (cid:104) U + − Z , U (cid:63) R Z − Z (cid:105) ( 17 ) The proof focuses on how to bound the last part on the right - hand side . By deﬁnition of U + , we get : (cid:104) U + − Z , U (cid:63) R Z − Z (cid:105) = (cid:10) Z − η A † (cid:0) A ( ZZ † ) − y (cid:1) Z − Z , U (cid:63) R Z − Z (cid:11) ( 18 ) = η (cid:10) A † (cid:0) A ( ZZ † ) − y (cid:1) Z , Z − U (cid:63) R Z (cid:11) ( 19 ) Observe the following : (cid:68) A † (cid:16) A ( ZZ † ) − y (cid:17) Z , Z − U (cid:63) R Z (cid:69) = (cid:68) A † (cid:16) A ( ZZ † ) − y (cid:17) , ZZ † − U (cid:63) R Z Z † (cid:69) ( 20 ) = (cid:68) A † (cid:16) A ( ZZ † ) − y (cid:17) , ZZ † − 12 U (cid:63) U (cid:63) † + 12 U (cid:63) U (cid:63) † − U (cid:63) R Z Z † (cid:69) ( 21 ) = 12 (cid:68) A † (cid:16) A ( ZZ † ) − y (cid:17) , ZZ † − U (cid:63) U (cid:63) † (cid:69) ( 22 ) + (cid:68) A † (cid:16) A ( ZZ † ) − y (cid:17) , 12 ( ZZ † + U (cid:63) U (cid:63) † ) − U (cid:63) R Z Z † (cid:69) ( 23 ) = 12 (cid:68) A † (cid:16) A ( ZZ † ) − y (cid:17) , ZZ † − U (cid:63) U (cid:63) † (cid:69) ( 24 ) + 12 (cid:68) A † (cid:16) A ( ZZ † ) − y (cid:17) , ( Z − U (cid:63) R Z ) ( Z − U (cid:63) R Z ) † (cid:69) ( 25 ) By Lemmata 5 and 6 , we have : (cid:107) U + − U (cid:63) R Z (cid:107) 2 F = (cid:107) U + − Z (cid:107) 2 F + (cid:107) Z − U (cid:63) R Z (cid:107) 2 F − 2 (cid:104) U + − Z , U (cid:63) R Z − Z (cid:105) ( 26 ) = η 2 (cid:107)A † (cid:16) A ( ZZ † ) − y (cid:17) Z (cid:107) 2 F + (cid:107) Z − U (cid:63) R Z (cid:107) 2 F ( 27 ) − η (cid:68) A † (cid:16) A ( ZZ † ) − y (cid:17) , ZZ † − U (cid:63) U (cid:63) † (cid:69) ( 28 ) − η (cid:68) A † (cid:16) A ( ZZ † ) − y (cid:17) , ( Z − U (cid:63) R Z ) ( Z − U (cid:63) R Z ) † (cid:69) ( 29 ) ≤ η 2 (cid:107)A † (cid:16) A ( ZZ † ) − y (cid:17) Z (cid:107) 2 F + (cid:107) Z − U (cid:63) R Z (cid:107) 2 F ( 30 ) − 1 . 0656 η 2 (cid:13)(cid:13)(cid:13) A † ( A ( ZZ † ) − y ) Z (cid:13)(cid:13)(cid:13) 2 F − η 1 − δ 2 r 2 (cid:107) U (cid:63) U (cid:63) † − ZZ † (cid:107) 2 F ( 31 ) + η (cid:32) θσ r ( ρ (cid:63) ) · (cid:107) Z − U (cid:63) R Z (cid:107) 2 F ( 32 ) + 1200 β 2 · (cid:98) η · (cid:18) 3 2 + 2 | µ | (cid:19) 2 (cid:18) 1 − (cid:18) 32 + 2 | µ | (cid:19) 110 3 (cid:19) 2 · (cid:107)A † ( A ( ZZ † ) − y ) · Z (cid:107) 2 F (cid:33) ( 33 ) Next , we use the following lemma : 34 Lemma 1 . [ 96 , Lemma 5 . 4 ] For any W , V ∈ C d × r , the following holds : (cid:107) WW † − V V † (cid:107) 2 F ≥ 2 ( √ 2 − 1 ) · σ r ( V V † ) · min R ∈O (cid:107) W − V R (cid:107) 2 F . ( 34 ) From Lemma 1 , the quantity (cid:107) U (cid:63) U (cid:63) † − ZZ † (cid:107) 2 F satisﬁes : (cid:107) U (cid:63) U (cid:63) † − ZZ † (cid:107) 2 F ≥ 2 ( √ 2 − 1 ) · σ r ( ρ (cid:63) ) · min R ∈O (cid:107) Z − U (cid:63) R (cid:107) 2 F = 2 ( √ 2 − 1 ) · σ r ( ρ (cid:63) ) · (cid:107) Z − U (cid:63) R Z (cid:107) 2 F , ( 35 ) which , in our main recursion , results in : (cid:107) U + − U (cid:63) R Z (cid:107) 2 F ≤ η 2 (cid:107)A † (cid:16) A ( ZZ † ) − y (cid:17) Z (cid:107) 2 F + (cid:107) Z − U (cid:63) R Z (cid:107) 2 F ( 36 ) − 1 . 0656 η 2 (cid:13)(cid:13)(cid:13) A † ( A ( ZZ † ) − y ) Z (cid:13)(cid:13)(cid:13) 2 F − η ( √ 2 − 1 ) ( 1 − δ 2 r ) σ r ( ρ (cid:63) ) (cid:107) Z − U (cid:63) R Z (cid:107) 2 F ( 37 ) + η (cid:32) θσ r ( ρ (cid:63) ) · (cid:107) Z − U (cid:63) R Z (cid:107) 2 F ( 38 ) + 1200 β 2 · (cid:98) η · (cid:18) 32 + 2 | µ | (cid:19) 2 (cid:18) 1 − (cid:18) 32 + 2 | µ | (cid:19) 110 3 (cid:19) 2 · (cid:107)A † ( A ( ZZ † ) − y ) · Z (cid:107) 2 F (cid:33) ( 39 ) ( i ) ≤ η 2 (cid:107)A † (cid:16) A ( ZZ † ) − y (cid:17) Z (cid:107) 2 F + (cid:107) Z − U (cid:63) R Z (cid:107) 2 F ( 40 ) − 1 . 0656 η 2 (cid:13)(cid:13)(cid:13) A † ( A ( ZZ † ) − y ) Z (cid:13)(cid:13)(cid:13) 2 F − η ( √ 2 − 1 ) ( 1 − δ 2 r ) σ r ( ρ (cid:63) ) (cid:107) Z − U (cid:63) R Z (cid:107) 2 F ( 41 ) + η (cid:32) θσ r ( ρ (cid:63) ) · (cid:107) Z − U (cid:63) R Z (cid:107) 2 F ( 42 ) + 1200 β 2 · 109 η · (cid:18) 32 + 2 | µ | (cid:19) 2 (cid:18) 1 − (cid:18) 32 + 2 | µ | (cid:19) 110 3 (cid:19) 2 · (cid:107)A † ( A ( ZZ † ) − y ) · Z (cid:107) 2 F (cid:33) ( 43 ) ( ii ) =   1 + 1200 β 2 · 109 · (cid:18) 32 + 2 | µ | (cid:19) 2 (cid:18) 1 − (cid:18) 32 + 2 | µ | (cid:19) 110 3 (cid:19) 2 − 1 . 0656   η 2 (cid:107)A † ( A ( ZZ † ) − y ) · Z (cid:107) 2 F ( 44 ) + (cid:16) 1 + ηθσ r ( ρ (cid:63) ) − η ( √ 2 − 1 ) ( 1 − δ 2 r ) σ r ( ρ (cid:63) ) (cid:17) (cid:107) Z − U (cid:63) R Z (cid:107) 2 F ( 45 ) where ( i ) is due to Lemma 4 , and ( ii ) is due to the deﬁnition of U + . Under the facts that µ = σ r ( ρ (cid:63) ) 1 / 2 10 3 √ κτ ( ρ (cid:63) ) · ε 4 · σ 1 ( ρ (cid:63) ) 1 / 2 · r , for ε ∈ ( 0 , 1 ) user - deﬁned , and δ 2 r ≤ 110 , the main constant quantities in our proof so far simplify into : β = 1 + (cid:0) 32 + 2 | µ | (cid:1) · 110 3 1 − (cid:0) 32 + 2 | µ | (cid:1) · 110 3 = 1 . 003 , and β 2 = 1 . 006 , ( 46 ) by Corollary 3 . Thus : 1 + 1200 β 2 · 109 · (cid:16) 32 + 2 | µ | (cid:17) 2 (cid:16) 1 − (cid:16) 32 + 2 | µ | (cid:17) 110 3 (cid:17) 2 − 1 . 0656 ≤ − 0 . 0516 , ( 47 ) and our recursion becomes : (cid:107) U + − U (cid:63) R Z (cid:107) 2 F ≤ − 0 . 0516 · η 2 · (cid:107)A † ( A ( ZZ † ) − y ) · Z (cid:107) 2 F ( 48 ) + (cid:16) 1 + ηθσ r ( ρ (cid:63) ) − η ( √ 2 − 1 ) ( 1 − δ 2 r ) σ r ( ρ (cid:63) ) (cid:17) (cid:107) Z − U (cid:63) R Z (cid:107) 2 F ( 49 ) Finally , θ = ( 1 − δ 2 r ) (cid:18) 1 + (cid:18) 32 + 2 | µ | (cid:19) 110 3 (cid:19) 2 10 3 + ( 1 + δ 2 r ) (cid:0) 2 + (cid:0) 32 + 2 | µ | (cid:1) · 110 3 (cid:1) (cid:0) 32 + 2 | µ | (cid:1) · 110 3 ( 50 ) ( i ) = ( 1 − δ 2 r ) ·   (cid:18) 1 + ( 32 + 2 | µ | ) 110 3 (cid:19) 2 10 3 + κ (cid:0) 2 + (cid:0) 32 + 2 | µ | (cid:1) · 110 3 (cid:1) (cid:0) 32 + 2 | µ | (cid:1) · 110 3   ( 51 ) ≤ 0 . 0047 · ( 1 − δ 2 r ) . ( 52 ) 35 where ( i ) is by the deﬁnition of κ : = 1 + δ 2 r 1 − δ 2 r ≤ 1 . 223 for δ 2 r ≤ 110 , by assumption . Combining the above in our main inequality , we obtain : (cid:107) U + − U (cid:63) R Z (cid:107) 2 F ≤ − 0 . 0516 · η 2 · (cid:107)A † ( A ( ZZ † ) − y ) · Z (cid:107) 2 F + (cid:16) 1 + ησ r ( ρ (cid:63) ) ( 1 − δ 2 r ) · ( 0 . 0047 − √ 2 + 1 ) (cid:17) (cid:107) Z − U (cid:63) R Z (cid:107) 2 F ≤ (cid:16) 1 − 4 ησ r ( ρ (cid:63) ) ( 1 − δ 2 r ) 10 (cid:17) (cid:107) Z − U (cid:63) R Z (cid:107) 2 F ( 53 ) Taking square root on both sides , we obtain : (cid:107) U + − U (cid:63) R Z (cid:107) F ≤ (cid:113) 1 − 4 ησ r ( ρ (cid:63) ) ( 1 − δ 2 r ) 10 · (cid:107) Z − U (cid:63) R Z (cid:107) F ( 54 ) Let us deﬁne ξ = (cid:113) 1 − 4 ησ r ( ρ (cid:63) ) ( 1 − δ 2 r ) 10 . Using the deﬁnitions Z = U + µ ( U − U − ) and R Z ∈ arg min R ∈O (cid:107) Z − U (cid:63) R (cid:107) F , we get (cid:107) U + − U (cid:63) R Z (cid:107) F ≤ ξ · min R ∈O (cid:107) Z − U (cid:63) R (cid:107) F = ξ · min R ∈O (cid:107) U + µ ( U − U − ) − U (cid:63) R (cid:107) F = ξ · min R ∈O (cid:107) U + µ ( U − U − ) − ( 1 − µ + µ ) U (cid:63) R (cid:107) F ( i ) ≤ ξ · | 1 + µ | · min R ∈O (cid:107) U − U (cid:63) R (cid:107) F + ξ · | µ | · min R ∈O (cid:107) U − − U (cid:63) R (cid:107) F + ξ · | µ | · rσ 1 ( ρ (cid:63) ) 1 / 2 where ( i ) follows from steps similar to those in Lemma 3 . Further observe that min R ∈O (cid:107) U + − U (cid:63) R (cid:107) F ≤ (cid:107) U + − U (cid:63) R Z (cid:107) F , thus leading to : min R ∈O (cid:107) U + − U (cid:63) R (cid:107) F ≤ ξ · | 1 + µ | · min R ∈O (cid:107) U − U (cid:63) R (cid:107) F + ξ · | µ | · min R ∈O (cid:107) U − − U (cid:63) R (cid:107) F + ξ · | µ | · rσ 1 ( ρ (cid:63) ) 1 / 2 ( 55 ) Including two subsequent iterations in a single two - dimensional ﬁrst - order system , we get the following characterization : (cid:20) min R ∈O (cid:107) U i + 1 − U (cid:63) R (cid:107) F min R ∈O (cid:107) U i − U (cid:63) R (cid:107) F (cid:21) ≤ (cid:20) ξ · | 1 + µ | ξ · | µ | 1 0 (cid:21) · (cid:20) min R ∈O (cid:107) U i − U (cid:63) R (cid:107) F min R ∈O (cid:107) U i − 1 − U (cid:63) R (cid:107) F (cid:21) ( 56 ) + (cid:20) 10 (cid:21) · ξ · | µ | · σ 1 ( ρ (cid:63) ) 1 / 2 · r . ( 57 ) Now , let x j = min R ∈O (cid:107) U j − U (cid:63) R (cid:107) F . Then , we can write the above relation as (cid:20) x i + 1 x i (cid:21) ≤ (cid:20) ξ · | 1 + µ | ξ · | µ | 1 0 (cid:21) (cid:124) (cid:123)(cid:122) (cid:125) : = A · (cid:20) x i x i − 1 (cid:21) + (cid:20) 10 (cid:21) · ξ · | µ | · σ 1 ( ρ (cid:63) ) 1 / 2 · r , where we denote the “contraction matrix” by A . Taking norms on both sides , we get (cid:13)(cid:13)(cid:13) (cid:13) (cid:20) x i + 1 x i (cid:21)(cid:13)(cid:13)(cid:13) (cid:13) 2 ≤ (cid:13)(cid:13)(cid:13) (cid:13) A · (cid:20) x i x i − 1 (cid:21) + (cid:20) 10 (cid:21) · ξ · | µ | · σ 1 ( ρ (cid:63) ) 1 / 2 · r (cid:13)(cid:13)(cid:13) (cid:13) 2 ( i ) ≤ (cid:13)(cid:13) (cid:13)(cid:13) A · (cid:20) x i x i − 1 (cid:21)(cid:13)(cid:13) (cid:13)(cid:13) 2 + (cid:13)(cid:13) (cid:13)(cid:13)(cid:20) 10 (cid:21) · ξ · | µ | · σ 1 ( ρ (cid:63) ) 1 / 2 · r (cid:13)(cid:13) (cid:13)(cid:13) 2 ( ii ) ≤ (cid:107) A (cid:107) 2 · (cid:13)(cid:13) (cid:13)(cid:13) (cid:20) x i x i − 1 (cid:21) (cid:13)(cid:13) (cid:13)(cid:13) 2 + (cid:13)(cid:13) (cid:13)(cid:13)(cid:20) 10 (cid:21) · ξ · | µ | · σ 1 ( ρ (cid:63) ) 1 / 2 · r (cid:13)(cid:13) (cid:13)(cid:13) 2 , ( 58 ) where ( i ) is by triangle inequality , and ( ii ) is by Cauchy – Schwarz inequality . Therefore , the convergence rate will be determined by the ( maximum ) eigenvalue of the contraction matrix A , which is given by λ 1 , 2 = ξ · | 1 + µ | 2 ± (cid:114) ξ 2 ( 1 + µ ) 2 4 + ξ · | µ | ( i ) = ⇒ max { λ 1 , λ 2 } = λ 1 = ξ · | 1 + µ | 2 + (cid:114) ξ 2 ( 1 + µ ) 2 4 + ξ · | µ | , 36 where ( i ) follows since every term in λ 1 , 2 is positive . To show accelerated convergence rate , we want the above eigenvalue ( which determines the conver - gence rate ) to be bounded by 1 − (cid:113) 1 − δ 2 r 1 + δ 2 r . To show this , ﬁrst note that this term is bounded above as follows : λ 1 = ξ · | 1 + µ | 2 + (cid:114) ξ 2 ( 1 + µ ) 2 4 + ξ · | µ | ( i ) ≤ ξ + (cid:112) ξ 2 + ξ ( ii ) ≤ ξ + (cid:112) 2 ξ ( ii ) ≤ ( √ 2 + 1 ) (cid:112) ξ , where ( i ) is by the conventional bound on momentum : 0 < µ < 1 , and ( ii ) is by the relation ξ 2 ≤ ξ ≤ √ ξ for 0 ≤ ξ ≤ 1 . Therefore , to show the accelerated rate of convergence , we want the following relation to hold : ( √ 2 + 1 ) (cid:112) ξ ≤ 1 − (cid:113) 1 − δ 2 r 1 + δ 2 r ⇐⇒ (cid:112) ξ ≤ √ 1 + δ 2 r − √ 1 − δ 2 r ( √ 2 + 1 ) √ 1 + δ 2 r . ( 59 ) Recalling our deﬁnition of ξ = (cid:113) 1 − 4 ησ r ( ρ (cid:63) ) ( 1 − δ 2 r ) 10 , the problem boils down to choosing the right step size η such that the above inequality on ξ in Eq . ( 59 ) is satisﬁed . With simple algebra , we can show the following lower bound on η : (cid:34) 1 − (cid:18) √ 1 + δ 2 r − √ 1 − δ 2 r ( √ 2 + 1 ) √ 1 + δ 2 r (cid:19) 4 (cid:35) · 10 4 σ r ( ρ (cid:63) ) ( 1 − δ 2 r ) ≤ η Finally , the argument inside the √· term of ξ = (cid:113) 1 − 4 ησ r ( ρ (cid:63) ) ( 1 − δ 2 r ) 10 > 0 has to be non - negative , yielding the following upper bound on η : η ≤ 10 4 σ r ( ρ (cid:63) ) ( 1 − δ 2 r ) . Combining two inequalities , and noting that the term (cid:20) 1 − (cid:16) √ 1 + δ 2 r −√ 1 − δ 2 r ( √ 2 + 1 ) √ 1 + δ 2 r (cid:17) 4 (cid:21) is bounded above by 1 , we arrive at the following bound on η : (cid:34) 1 − (cid:18) √ 1 + δ 2 r − √ 1 − δ 2 r ( √ 2 + 1 ) √ 1 + δ 2 r (cid:19) 4 (cid:35) · 10 4 σ r ( ρ (cid:63) ) ( 1 − δ 2 r ) ≤ η ≤ 10 4 σ r ( ρ (cid:63) ) ( 1 − δ 2 r ) . ( 60 ) In sum , for the speciﬁc η satisfying the above bound , we have shown that λ 1 = ξ · | 1 + µ | 2 + (cid:114) ξ 2 ( 1 + µ ) 2 4 + ξ · | µ | ≤ 1 − (cid:114) 1 − δ 2 r 1 + δ 2 r Above translates our original recursion in ( 58 ) as : (cid:13)(cid:13) (cid:13)(cid:13) (cid:20) x i + 1 x i (cid:21) (cid:13)(cid:13) (cid:13)(cid:13) 2 ≤ (cid:107) A (cid:107) 2 · (cid:13)(cid:13) (cid:13)(cid:13)(cid:20) x i x i − 1 (cid:21)(cid:13)(cid:13) (cid:13)(cid:13) 2 + (cid:13)(cid:13) (cid:13)(cid:13)(cid:20) 10 (cid:21) · ξ · | µ | · σ 1 ( ρ (cid:63) ) 1 / 2 · r (cid:13)(cid:13) (cid:13)(cid:13) 2 ≤ (cid:18) 1 − (cid:113) 1 − δ 2 r 1 + δ 2 r (cid:19) · (cid:13)(cid:13)(cid:13)(cid:13)(cid:20) x i x i − 1 (cid:21)(cid:13)(cid:13)(cid:13)(cid:13) 2 + (cid:13)(cid:13)(cid:13)(cid:13)(cid:20) 1 0 (cid:21) · ξ · | µ | · σ 1 ( ρ (cid:63) ) 1 / 2 · r (cid:13)(cid:13)(cid:13)(cid:13) 2 = (cid:18) 1 − (cid:113) 1 − δ 2 r 1 + δ 2 r (cid:19) · (cid:13)(cid:13)(cid:13)(cid:13)(cid:20) x i x i − 1 (cid:21)(cid:13)(cid:13)(cid:13)(cid:13) 2 + ξ · | µ | · σ 1 ( ρ (cid:63) ) 1 / 2 · r , ( 61 ) where the last equality is by the deﬁnition of (cid:96) 2 - norm . 37 Unrolling the recursion in Eq . ( 61 ) for J iterations , we get (cid:13)(cid:13)(cid:13)(cid:13)(cid:20) x J + 1 x J (cid:21)(cid:13)(cid:13)(cid:13)(cid:13) 2 ≤ (cid:18) 1 − (cid:113) 1 − δ 2 r 1 + δ 2 r (cid:19) J + 1 (cid:13)(cid:13)(cid:13)(cid:13)(cid:20) x 0 x − 1 (cid:21)(cid:13)(cid:13)(cid:13)(cid:13) 2 + ξ · | µ | · σ 1 ( ρ (cid:63) ) 1 / 2 · r · J (cid:88) i = 0 (cid:18) 1 − (cid:113) 1 − δ 2 r 1 + δ 2 r (cid:19) i = (cid:18) 1 − (cid:113) 1 − δ 2 r 1 + δ 2 r (cid:19) J + 1 (cid:13)(cid:13)(cid:13)(cid:13)(cid:20) x 0 x − 1 (cid:21)(cid:13)(cid:13)(cid:13)(cid:13) 2 + ξ · | µ | · σ 1 ( ρ (cid:63) ) 1 / 2 · r · (cid:32) 1 − (cid:18) 1 − (cid:113) 1 − δ 2 r 1 + δ 2 r (cid:19) J + 1 (cid:33) (cid:18) 1 − (cid:113) 1 − δ 2 r 1 + δ 2 r (cid:19) − 1 = (cid:18) 1 − (cid:113) 1 − δ 2 r 1 + δ 2 r (cid:19) J + 1 (cid:13)(cid:13)(cid:13)(cid:13)(cid:20) x 0 x − 1 (cid:21)(cid:13)(cid:13)(cid:13)(cid:13) 2 + O ( µ ) Finally , computing the (cid:96) 2 - norm explicitly and resubstituting x j = min R ∈ O (cid:107) U j − U (cid:63) R (cid:107) F , we get min R ∈O (cid:107) U J + 1 − U (cid:63) R (cid:107) F ≤ (cid:18) 1 − (cid:113) 1 − δ 2 r 1 + δ 2 r (cid:19) J + 1 (cid:18) min R ∈O (cid:107) U 0 − U (cid:63) R (cid:107) 2 F + min R ∈O (cid:107) U − 1 − U (cid:63) R (cid:107) 2 F (cid:19) 1 / 2 + O ( µ ) . Supporting lemmata In this section , we present a series of lemmata , used for the main result of the paper . Lemma 2 . Let U ∈ C d × r and U (cid:63) ∈ C d × r , such that (cid:107) U − U (cid:63) R (cid:107) F ≤ σ r ( ρ (cid:63) ) 1 / 2 10 3 √ κτ ( ρ (cid:63) ) for some R ∈ O , where ρ (cid:63) = U (cid:63) U (cid:63) † , κ : = 1 + δ 2 r 1 − δ 2 r > 1 , for δ 2 r ≤ 110 , and τ ( ρ (cid:63) ) : = σ 1 ( ρ (cid:63) ) σ r ( ρ (cid:63) ) > 1 . Then : σ 1 ( ρ (cid:63) ) 1 / 2 (cid:0) 1 − 110 3 (cid:1) ≤ σ 1 ( U ) ≤ σ 1 ( ρ (cid:63) ) 1 / 2 (cid:0) 1 + 110 3 (cid:1) ( 62 ) σ r ( ρ (cid:63) ) 1 / 2 (cid:0) 1 − 110 3 (cid:1) ≤ σ r ( U ) ≤ σ r ( ρ (cid:63) ) 1 / 2 (cid:0) 1 + 110 3 (cid:1) ( 63 ) Proof . By the fact (cid:107)·(cid:107) 2 ≤ (cid:107)·(cid:107) F and using Weyl’s inequality for perturbation of singular values [ 41 , Theorem 3 . 3 . 16 ] , we have : | σ i ( U ) − σ i ( U (cid:63) ) | ≤ σ r ( ρ (cid:63) ) 1 / 2 10 3 √ κτ ( ρ (cid:63) ) ≤ σ r ( ρ (cid:63) ) 1 / 2 10 3 , 1 ≤ i ≤ r . ( 64 ) Then , − σ r ( ρ (cid:63) ) 1 / 2 10 3 ≤ σ 1 ( U ) − σ 1 ( U (cid:63) ) ≤ σ r ( ρ (cid:63) ) 1 / 2 10 3 ⇒ ( 65 ) σ 1 ( ρ (cid:63) ) 1 / 2 − σ r ( ρ (cid:63) ) 1 / 2 10 3 ≤ σ 1 ( U ) ≤ σ 1 ( ρ (cid:63) ) 1 / 2 + σ r ( ρ (cid:63) ) 1 / 2 10 3 ⇒ ( 66 ) σ 1 ( ρ (cid:63) ) 1 / 2 (cid:0) 1 − 110 3 (cid:1) ≤ σ 1 ( U ) ≤ σ 1 ( ρ (cid:63) ) 1 / 2 (cid:0) 1 + 110 3 (cid:1) . ( 67 ) Similarly : − σ r ( ρ (cid:63) ) 1 / 2 10 3 ≤ σ r ( U ) − σ r ( U (cid:63) ) ≤ σ r ( ρ (cid:63) ) 1 / 2 10 3 ⇒ ( 68 ) σ r ( ρ (cid:63) ) 1 / 2 − σ r ( ρ (cid:63) ) 1 / 2 10 3 ≤ σ r ( U ) ≤ σ r ( ρ (cid:63) ) 1 / 2 + σ r ( ρ (cid:63) ) 1 / 2 10 3 ⇒ ( 69 ) σ r ( ρ (cid:63) ) 1 / 2 (cid:0) 1 − 110 3 (cid:1) ≤ σ r ( U ) ≤ σ r ( ρ (cid:63) ) 1 / 2 (cid:0) 1 + 110 3 (cid:1) . ( 70 ) In the above , we used the fact that σ i ( U (cid:63) ) = σ i ( ρ (cid:63) ) 1 / 2 , for all i , and the fact that σ i ( ρ (cid:63) ) 1 / 2 ≥ σ j ( ρ (cid:63) ) 1 / 2 , for i ≤ j . Lemma 3 . Let U ∈ C d × r , U − ∈ C d × r , and U (cid:63) ∈ C d × r , such that min R ∈O (cid:107) U − U (cid:63) R (cid:107) F ≤ σ r ( ρ (cid:63) ) 1 / 2 10 3 √ κτ ( ρ (cid:63) ) and min R ∈O (cid:107) U − − U (cid:63) R (cid:107) F ≤ σ r ( ρ (cid:63) ) 1 / 2 10 3 √ κτ ( ρ (cid:63) ) , where ρ (cid:63) = U (cid:63) U (cid:63) † , and κ : = 1 + δ 2 r 1 − δ 2 r > 1 , for δ 2 r ≤ 110 , and τ ( ρ (cid:63) ) : = σ 1 ( ρ (cid:63) ) σ r ( ρ (cid:63) ) > 1 . Set the momen - tum parameter as µ = σ r ( ρ (cid:63) ) 1 / 2 10 3 √ κτ ( ρ (cid:63) ) · ε 4 · σ 1 ( ρ (cid:63) ) 1 / 2 · r , for ε ∈ ( 0 , 1 ) user - deﬁned . Then , (cid:107) Z − U (cid:63) R Z (cid:107) F ≤ (cid:0) 32 + 2 | µ | (cid:1) · σ r ( ρ (cid:63) ) 1 / 2 10 3 √ κτ ( ρ (cid:63) ) . ( 71 ) 38 Proof . Let R U ∈ arg min R ∈O (cid:107) U − U (cid:63) (cid:107) F and R U − ∈ arg min R ∈O (cid:107) U − − U (cid:63) R (cid:107) F . By the deﬁnition of the distance function : (cid:107) Z − U (cid:63) R Z (cid:107) F = min R ∈O (cid:107) Z − U (cid:63) R (cid:107) F = min R ∈O (cid:107) U + µ ( U − U − ) − U (cid:63) R (cid:107) F ( 72 ) = min R ∈O (cid:107) U + µ ( U − U − ) − ( 1 − µ + µ ) U (cid:63) R (cid:107) F ( 73 ) ≤ | 1 + µ | · (cid:107) U − U ∗ R U (cid:107) F + | µ | · | | U − − U ∗ R U − | | F ( 74 ) = | 1 + µ | · (cid:107) U − U ∗ R U (cid:107) F + | µ | · (cid:107) U − − U ∗ R U − U ∗ R U − + U ∗ R U − (cid:107) F ( 75 ) = | 1 + µ | · (cid:107) U − U ∗ R U (cid:107) F + | µ | · (cid:107) ( U − − U ∗ R U − ) + U ∗ ( R U − − R U ) (cid:107) F ( 76 ) ≤ | 1 + µ | · min R ∈O (cid:107) U − U (cid:63) R (cid:107) F + | µ | · min R ∈O (cid:107) U − − U (cid:63) R (cid:107) F + | µ | · (cid:107) U (cid:63) ( R U − R U − ) (cid:107) F ( 77 ) ≤ | 1 + µ | · min R ∈O (cid:107) U − U (cid:63) R (cid:107) F + | µ | · min R ∈O (cid:107) U − − U (cid:63) R (cid:107) F + 2 | µ | · σ 1 ( ρ (cid:63) ) 1 / 2 r ( 78 ) ( i ) ≤ (cid:0) 32 + 2 | µ | (cid:1) · σ r ( ρ (cid:63) ) 1 / 2 10 3 √ κτ ( ρ (cid:63) ) ( 79 ) where ( i ) is due to the fact that µ ≤ σ r ( ρ (cid:63) ) 1 / 2 10 3 √ κτ ( ρ (cid:63) ) · 1 4 · σ 1 ( ρ (cid:63) ) 1 / 2 · r . We keep µ in the expression , but we use it for clarity for the rest of the proof . Corollary 1 . Let Z ∈ C d × r and U (cid:63) ∈ C d × r , such that (cid:107) Z − U (cid:63) R (cid:107) F ≤ (cid:0) 32 + 2 | µ | (cid:1) · σ r ( ρ (cid:63) ) 1 / 2 10 3 √ κτ ( ρ (cid:63) ) for some R ∈ O , and ρ (cid:63) = U (cid:63) U (cid:63) † . Then : σ 1 ( ρ (cid:63) ) 1 / 2 (cid:0) 1 − (cid:0) 32 + 2 | µ | (cid:1) 110 3 (cid:1) ≤ σ 1 ( Z ) ≤ σ 1 ( ρ (cid:63) ) 1 / 2 (cid:0) 1 + (cid:0) 32 + 2 | µ | (cid:1) 110 3 (cid:1) ( 80 ) σ r ( ρ (cid:63) ) 1 / 2 (cid:0) 1 − (cid:0) 32 + 2 | µ | (cid:1) 110 3 (cid:1) ≤ σ r ( Z ) ≤ σ r ( ρ (cid:63) ) 1 / 2 (cid:0) 1 + (cid:0) 32 + 2 | µ | (cid:1) 110 3 (cid:1) . ( 81 ) Given that µ = σ r ( ρ (cid:63) ) 1 / 2 10 3 √ κτ ( ρ (cid:63) ) · ε 4 · σ 1 ( ρ (cid:63) ) 1 / 2 · r ≤ 110 3 , we get : 0 . 998 · σ 1 ( ρ (cid:63) ) 1 / 2 ≤ σ 1 ( Z ) ≤ 1 . 0015 · σ 1 ( ρ (cid:63) ) 1 / 2 ( 82 ) 0 . 998 · σ r ( ρ (cid:63) ) 1 / 2 ≤ σ r ( Z ) ≤ 1 . 0015 · σ r ( ρ (cid:63) ) 1 / 2 . ( 83 ) Proof . The proof follows similar motions as in Lemma 2 . Corollary 2 . Under the same assumptions of Lemma 2 and Corollary 1 , and given the assumptions on µ , we have : 99100 · (cid:107) ρ (cid:63) (cid:107) 2 ≤ (cid:107) ZZ † (cid:107) 2 ≤ 101100 · (cid:107) ρ (cid:63) (cid:107) 2 ( 84 ) 99100 · (cid:107) ρ (cid:63) (cid:107) 2 ≤ (cid:107) Z 0 Z † 0 (cid:107) 2 ≤ 101100 · (cid:107) ρ (cid:63) (cid:107) 2 ( 85 ) and 99101 · (cid:107) Z 0 Z † 0 (cid:107) 2 ≤ (cid:107) ZZ † (cid:107) 2 ≤ 10199 · (cid:107) Z 0 Z † 0 (cid:107) 2 ( 86 ) Proof . The proof is easily derived based on the quantities from Lemma 2 and Corollary 1 . Corollary 3 . Let Z ∈ C d × r and U (cid:63) ∈ C d × r , such that (cid:107) Z − U (cid:63) R (cid:107) F ≤ (cid:0) 32 + 2 | µ | (cid:1) · σ r ( ρ (cid:63) ) 1 / 2 10 3 √ κτ ( ρ (cid:63) ) for some R ∈ O , and ρ (cid:63) = U (cid:63) U (cid:63) † . Deﬁne τ ( W ) = σ 1 ( W ) σ r ( W ) . Then : τ ( ZZ † ) ≤ β 2 τ ( ρ (cid:63) ) , ( 87 ) where β : = 1 + (cid:16) 32 + 2 | µ | (cid:17) · 110 3 1 − (cid:16) 32 + 2 | µ | (cid:17) · 110 3 > 1 . for µ ≤ σ r ( ρ (cid:63) ) 1 / 2 10 3 √ κτ ( ρ (cid:63) ) · 1 4 · σ 1 ( ρ (cid:63) ) 1 / 2 · r . Proof . The proof uses the deﬁnition of the condition number τ ( · ) and the results from Lemma 2 and and Corollary 1 . 39 Lemma 4 . Consider the following three step sizes : η = 1 4 (cid:16) ( 1 + δ 2 r ) (cid:107) Z 0 Z † 0 (cid:107) 2 + (cid:107)A † (cid:16) A ( Z 0 Z † 0 ) − y (cid:17) (cid:107) 2 (cid:17) ( 88 ) (cid:98) η = 1 4 (cid:16) ( 1 + δ 2 r ) (cid:107) ZZ † (cid:107) 2 + (cid:107)A † ( A ( ZZ † ) − y ) Q Z Q † Z (cid:107) 2 (cid:17) ( 89 ) η (cid:63) = 1 4 ( ( 1 + δ 2 r ) (cid:107) ρ (cid:63) (cid:62) (cid:107) 2 + (cid:107)A † ( A ( ρ (cid:63) ) − y ) (cid:107) 2 ) . ( 90 ) Here , Z 0 ∈ C d × r is the initial point , Z ∈ C d × r is the current point , ρ (cid:63) ∈ C d × d is the optimal solution , and Q Z denotes a basis of the column space of Z . Then , under the assumptions that min R ∈O (cid:107) U − U (cid:63) R (cid:107) F ≤ σ r ( ρ (cid:63) ) 1 / 2 10 3 √ κτ ( ρ (cid:63) ) , and min R ∈O (cid:107) Z − U (cid:63) R (cid:107) F ≤ (cid:0) 32 + 2 | µ | (cid:1) · σ r ( ρ (cid:63) ) 1 / 2 10 3 √ κτ ( ρ (cid:63) ) , and assuming µ = σ r ( ρ (cid:63) ) 1 / 2 10 3 √ κτ ( ρ (cid:63) ) · ε 4 · σ 1 ( ρ (cid:63) ) 1 / 2 · r , for the user - deﬁned parameter ε ∈ ( 0 , 1 ) , we have : 109 η ≥ (cid:98) η ≥ 1010 . 5 η , and 100102 η (cid:63) ≤ η ≤ 102100 η (cid:63) ( 91 ) Proof . The assumptions of the lemma are identical to that of Corollary 2 . Thus , we have : 99100 · (cid:107) U (cid:63) (cid:107) 22 ≤ (cid:107) Z (cid:107) 22 ≤ 101100 · (cid:107) U (cid:63) (cid:107) 22 , 99100 · (cid:107) U (cid:63) (cid:107) 22 ≤ (cid:107) Z 0 (cid:107) 22 ≤ 101100 · (cid:107) U (cid:63) (cid:107) 22 , and 99101 · (cid:107) Z 0 (cid:107) 22 ≤ (cid:107) Z (cid:107) 22 ≤ 10199 · (cid:107) Z 0 (cid:107) 22 . We focus on the inequality (cid:98) η ≥ 1010 . 5 η . Observe that : (cid:13)(cid:13)(cid:13) A † (cid:16) A ( ZZ † ) − y (cid:17) Q Z Q † Z (cid:13)(cid:13)(cid:13) 2 ≤ (cid:13)(cid:13)(cid:13) A † (cid:16) A ( ZZ † ) − y (cid:17)(cid:13)(cid:13)(cid:13) 2 ( 92 ) = (cid:13)(cid:13)(cid:13) A † (cid:16) A ( ZZ † ) − y (cid:17) − A † (cid:16) A ( Z 0 Z † 0 ) − y (cid:17) + A † (cid:16) A ( Z 0 Z † 0 ) − y (cid:17)(cid:13)(cid:13)(cid:13) 2 ( 93 ) ( i ) ≤ ( 1 + δ 2 r ) (cid:13)(cid:13)(cid:13) ZZ † − Z 0 Z † 0 (cid:13)(cid:13)(cid:13) F + (cid:13)(cid:13)(cid:13) A † (cid:16) A ( Z 0 Z † 0 ) − y (cid:17)(cid:13)(cid:13)(cid:13) 2 ( 94 ) ≤ ( 1 + δ 2 r ) (cid:13)(cid:13)(cid:13) ZZ † − U (cid:63) U (cid:63) † (cid:13)(cid:13)(cid:13) F + ( 1 + δ 2 r ) (cid:13)(cid:13)(cid:13) Z 0 Z † 0 − U (cid:63) U (cid:63) † (cid:13)(cid:13)(cid:13) F ( 95 ) + (cid:13)(cid:13)(cid:13) A † (cid:16) A ( Z 0 Z † 0 ) − y (cid:17)(cid:13)(cid:13)(cid:13) 2 ( 96 ) where ( i ) is due to smoothness via RIP constants of the objective and the fact (cid:107) · (cid:107) 2 ≤ (cid:107) · (cid:107) F . For the ﬁrst two terms on the right - hand side , where R Z is the minimizing rotation matrix for Z , we obtain : (cid:107) ZZ † − U (cid:63) U (cid:63) † (cid:107) F = (cid:107) ZZ † − U (cid:63) R Z Z † + U (cid:63) R Z Z † − U (cid:63) U (cid:63) † (cid:107) F ( 97 ) = (cid:107) ( Z − U (cid:63) R Z ) Z † + U (cid:63) R Z ( Z − U (cid:63) R Z ) † (cid:107) F ( 98 ) ≤ (cid:107) Z (cid:107) 2 · (cid:107) Z − U (cid:63) R Z (cid:107) F + (cid:107) U (cid:63) (cid:107) 2 · (cid:107) Z − U (cid:63) R Z (cid:107) F ( 99 ) ≤ ( (cid:107) Z (cid:107) 2 + (cid:107) U (cid:63) (cid:107) 2 ) · (cid:107) Z − U (cid:63) R Z (cid:107) F ( 100 ) ( i ) ≤ (cid:18) (cid:113) 10199 + (cid:113) 10099 (cid:19) (cid:107) Z 0 (cid:107) 2 · (cid:107) Z − U (cid:63) R Z (cid:107) F ( 101 ) ( ii ) ≤ (cid:18) (cid:113) 10199 + (cid:113) 10099 (cid:19) (cid:107) Z 0 (cid:107) 2 · 0 . 001 σ r ( ρ (cid:63) ) 1 / 2 ( 102 ) ≤ (cid:18) (cid:113) 10199 + (cid:113) 10099 (cid:19) · 0 . 001 · (cid:113) 10099 · (cid:107) Z 0 (cid:107) 22 ( 103 ) where ( i ) is due to the relation of (cid:107) Z (cid:107) 2 and (cid:107) U (cid:63) (cid:107) 2 derived above , ( ii ) is due to Lemma 3 . Similarly : (cid:107) Z 0 Z † 0 − U (cid:63) U (cid:63) † (cid:107) F ≤ (cid:18)(cid:113) 101 99 + (cid:113) 100 99 (cid:19) · 0 . 001 · (cid:113) 100 99 · (cid:107) Z 0 (cid:107) 2 2 ( 104 ) Using these above , we obtain : (cid:13)(cid:13)(cid:13) A † (cid:16) A ( ZZ † ) − y (cid:17) Q Z Q † Z (cid:13)(cid:13)(cid:13) 2 ≤ 4 . 1 ( 1 + δ 2 r ) 10 3 (cid:107) Z 0 Z † 0 (cid:107) 2 + (cid:13)(cid:13)(cid:13) A † (cid:16) A ( Z 0 Z † 0 ) − y (cid:17)(cid:13)(cid:13)(cid:13) 2 ( 105 ) 40 Thus : (cid:98) η = 1 4 (cid:16) ( 1 + δ 2 r ) (cid:107) ZZ † (cid:107) 2 + (cid:107)A † ( A ( ZZ † ) − y ) Q Z Q † Z (cid:107) 2 (cid:17) ( 106 ) ≥ 1 4 (cid:0) ( 1 + δ 2 r ) 10199 (cid:107) Z 0 Z 0 (cid:107) 2 + (cid:1) + 4 . 1 ( 1 + δ 2 r ) 10 3 (cid:107) Z 0 Z † 0 (cid:107) 2 + (cid:13)(cid:13)(cid:13) A † (cid:16) A ( Z 0 Z † 0 ) − y (cid:17)(cid:13)(cid:13)(cid:13) 2 ( 107 ) ≥ 1 4 (cid:16) 10 . 5 10 · ( 1 + δ 2 r ) (cid:107) Z 0 Z † 0 (cid:107) 2 + (cid:107)A † (cid:16) A ( Z 0 Z † 0 ) − y (cid:17) (cid:107) 2 (cid:17) ( 108 ) ≥ 1010 . 5 η ( 109 ) Similarly , one gets (cid:98) η ≤ 109 η . For the relation between η and η (cid:63) , we will prove here the lower bound ; similar motions lead to the upper bound also . By deﬁnition , and using the relations in Corollary 2 , we get : η = 1 4 (cid:16) ( 1 + δ 2 r ) (cid:107) Z 0 Z † 0 (cid:107) 2 + (cid:107)A † (cid:16) A ( Z 0 Z † 0 ) − y (cid:17) (cid:107) 2 (cid:17) ( 110 ) ≥ 1 4 (cid:16) ( 1 + δ 2 r ) 101100 (cid:107) ρ (cid:63) (cid:62) (cid:107) 2 + (cid:107)A † (cid:16) A ( Z 0 Z † 0 ) − y (cid:17) (cid:107) 2 (cid:17) ( 111 ) For the gradient term , we observe : (cid:13)(cid:13)(cid:13) A † (cid:16) A ( Z 0 Z † 0 ) − y (cid:17)(cid:13)(cid:13)(cid:13) 2 ≤ (cid:13)(cid:13)(cid:13) A † (cid:16) A ( Z 0 Z † 0 ) − y (cid:17) − A † ( A ( ρ (cid:63) ) − y ) (cid:13)(cid:13)(cid:13) 2 + (cid:13)(cid:13) A † ( A ( ρ (cid:63) ) − y ) (cid:13)(cid:13) 2 ( 112 ) ( i ) = (cid:13)(cid:13)(cid:13) A † (cid:16) A ( Z 0 Z † 0 ) − y (cid:17) − A † ( A ( ρ (cid:63) ) − y ) (cid:13)(cid:13)(cid:13) 2 ( 113 ) ( ii ) ≤ ( 1 + δ 2 r ) (cid:13)(cid:13)(cid:13) Z 0 Z † 0 − U (cid:63) U (cid:63) † (cid:13)(cid:13)(cid:13) F ( 114 ) ( iii ) ≤ ( 1 + δ 2 r ) ( (cid:107) Z 0 (cid:107) 2 + (cid:107) U (cid:63) (cid:107) 2 ) · (cid:107) Z − U (cid:63) R Z (cid:107) F ( 115 ) ( iv ) ≤ ( 1 + δ 2 r ) (cid:18)(cid:113) 101100 + 1 (cid:19) (cid:107) U (cid:63) (cid:107) 2 · 0 . 001 · (cid:107) U (cid:63) (cid:107) 22 ( 116 ) ≤ 0 . 002 · ( 1 + δ 2 r ) (cid:107) ρ (cid:63) (cid:107) 2 ( 117 ) where ( i ) is due to (cid:13) (cid:13) A † ( A ( ρ (cid:63) ) − y ) (cid:13) (cid:13) 2 = 0 , ( ii ) is due to the restricted smoothness assumption and the RIP , ( iii ) is due to the bounds above on (cid:13)(cid:13)(cid:13) Z 0 Z † 0 − U (cid:63) U (cid:63) † (cid:13)(cid:13)(cid:13) F , ( iv ) is due to the bounds on (cid:107) Z 0 (cid:107) 2 , w . r . t . (cid:107) U (cid:63) (cid:107) 2 , as well as the bound on (cid:107) Z − U (cid:63) R (cid:107) F . Thus , in the inequality above , we get : η ≥ 1 4 (cid:16) ( 1 + δ 2 r ) 101100 (cid:107) ρ (cid:63) (cid:62) (cid:107) 2 + (cid:107)A † (cid:16) A ( Z 0 Z † 0 ) − y (cid:17) (cid:107) 2 (cid:17) ( 118 ) ≥ 1 4 (cid:0) ( 1 + δ 2 r ) 101100 (cid:107) ρ (cid:63) (cid:62) (cid:107) 2 + 0 . 001 · ( 1 + δ 2 r ) (cid:107) ρ (cid:63) (cid:107) 2 + (cid:107)A † ( A ( ρ (cid:63) ) − y ) (cid:107) 2 (cid:1) ( 119 ) ≥ 1 4 (cid:0) ( 1 + δ 2 r ) 102100 (cid:107) ρ (cid:63) (cid:62) (cid:107) 2 + (cid:107)A † ( A ( ρ (cid:63) ) − y ) (cid:107) 2 (cid:1) ≥ 100102 η (cid:63) ( 120 ) Similarly , one can show that 102100 η (cid:63) ≥ η . Lemma 5 . Let U ∈ C d × r , U − ∈ C d × r , and U (cid:63) ∈ C d × r , such that min R ∈O (cid:107) U − U (cid:63) R (cid:107) F ≤ σ r ( ρ (cid:63) ) 1 / 2 10 3 √ κτ ( ρ (cid:63) ) and min R ∈O (cid:107) U − − U (cid:63) R (cid:107) F ≤ σ r ( ρ (cid:63) ) 1 / 2 10 3 √ κτ ( ρ (cid:63) ) , where ρ (cid:63) = U (cid:63) U (cid:63) † , and κ : = 1 + δ 2 r 1 − δ 2 r > 1 , for δ 2 r ≤ 110 , and τ ( ρ (cid:63) ) : = σ 1 ( ρ (cid:63) ) σ r ( ρ (cid:63) ) > 1 . By Lemma 41 3 , the above imply also that : (cid:107) Z − U (cid:63) R Z (cid:107) F ≤ (cid:0) 32 + 2 | µ | (cid:1) · σ r ( ρ (cid:63) ) 1 / 2 10 3 √ κτ ( ρ (cid:63) ) . Then , under RIP assumptions of the mapping A , we have : (cid:68) A † ( A ( ZZ † ) − y ) , ( Z − U (cid:63) R Z ) ( Z − U (cid:63) R Z ) † (cid:69) ≥ − (cid:32) θσ r ( ρ (cid:63) ) · (cid:107) Z − U (cid:63) R Z (cid:107) 2 F + 10 . 1 100 β 2 · (cid:98) η · ( 1 + 2 | µ | ) 2 (cid:18) 1 − ( 1 + 2 | µ | ) 1200 (cid:19) 2 · (cid:107)A † ( A ( ZZ † ) − y ) · Z (cid:107) 2 F (cid:33) ( 121 ) where θ = ( 1 − δ 2 r ) (cid:16) 1 + ( 1 + 2 | µ | ) 1200 (cid:17) 2 10 3 + ( 1 + δ 2 r ) (cid:0) 2 + ( 1 + 2 | µ | ) · 1200 (cid:1) ( 1 + 2 | µ | ) · 1200 , and (cid:98) η = 1 4 ( ( 1 + δ r ) (cid:107) ZZ † (cid:107) 2 + (cid:107)A † ( A ( ZZ † ) − y ) Q Z Q † Z (cid:107) 2 ) . Proof . First , denote ∆ : = Z − U (cid:63) R Z . Then : (cid:68) A † ( A ( ZZ † ) − y ) , ( Z − U (cid:63) R Z ) ( Z − U (cid:63) R Z ) † (cid:69) ( i ) = (cid:68) A † ( A ( ZZ † ) − y ) · Q ∆ Q † ∆ , ∆ Z ∆ † Z (cid:69) ≥ − (cid:12)(cid:12)(cid:12) Tr (cid:16) A † ( A ( ZZ † ) − y ) · Q ∆ Q † ∆ · ∆ Z ∆ † Z (cid:17)(cid:12)(cid:12)(cid:12) ( ii ) ≥ −(cid:107)A † ( A ( ZZ † ) − y ) · Q ∆ Q † ∆ (cid:107) 2 · Tr ( ∆ Z ∆ † Z ) ( iii ) ≥ − (cid:16) (cid:107)A † ( A ( ZZ † ) − y ) · Q Z Q † Z (cid:107) 2 + (cid:107)A † ( A ( ZZ † ) − y ) · Q U (cid:63) Q † U (cid:63) (cid:107) 2 (cid:17) (cid:107) Z − U (cid:63) R Z (cid:107) 2 F ( 122 ) Note that ( i ) follows from the fact ∆ Z = ∆ Z Q ∆ Q † ∆ , for a matrix Q that spans the row space of ∆ Z , and ( ii ) follows from | Tr ( AB ) | ≤ (cid:107) A (cid:107) 2 T R ( B ) , for PSD matrix B ( Von Neumann’s trace inequality [ 65 ] ) . For the transformation in ( iii ) , we use that fact that the row space of ∆ Z , S PAN ( ∆ Z ) , is a subset of S PAN ( Z ∪ U (cid:63) ) , as ∆ Z is a linear combination of U and U (cid:63) . To bound the ﬁrst term in equation ( 122 ) , we observe : (cid:107)A † ( A ( ZZ † ) − y ) · Q Z Q † Z (cid:107) 2 · (cid:107) Z − U (cid:63) R Z (cid:107) 2 F ( i ) = (cid:98) η · 4 (cid:16) ( 1 + δ 2 r ) (cid:107) ZZ † (cid:107) 2 + (cid:107)A † ( A ( ZZ † ) − y ) · Q Z Q † Z (cid:107) 2 (cid:17) · (cid:107)A † ( A ( ZZ † ) − y ) · Q Z Q † Z (cid:107) 2 · (cid:107) Z − U (cid:63) R Z (cid:107) 2 F = 4 (cid:98) η ( 1 + δ 2 r ) (cid:107) ZZ † (cid:107) 2 (cid:107)A † ( A ( ZZ † ) − y ) · Q Z Q † Z (cid:107) 2 · (cid:107) Z − U (cid:63) R Z (cid:107) 2 F (cid:124) (cid:123)(cid:122) (cid:125) : = A + 4 (cid:98) η (cid:107)A † ( A ( ZZ † ) − y ) · Q Z Q † Z (cid:107) 22 · (cid:107) Z − U (cid:63) R Z (cid:107) 2 F where ( i ) is due to the deﬁnition of (cid:98) η . To bound term A , we observe that (cid:107)A † ( A ( ZZ † ) − y ) · Q Z Q † Z (cid:107) 2 ≤ ( 1 − δ 2 r ) σ r ( ZZ † ) 10 3 or (cid:107)A † ( A ( ZZ † ) − y ) · Q Z Q † Z (cid:107) 2 ≥ ( 1 − δ 2 r ) σ r ( ZZ † ) 10 3 . This results into bounding A as follows : 4 (cid:98) η ( 1 + δ 2 r ) (cid:107) ZZ † (cid:107) 2 (cid:107)A † ( A ( ZZ † ) − y ) · Q Z Q † Z (cid:107) 2 · (cid:107) Z − U (cid:63) R Z (cid:107) 2 F ( 123 ) ≤ max (cid:110) 4 · (cid:98) η · ( 1 + δ 2 r ) (cid:107) ZZ † (cid:107) 2 · ( 1 − δ 2 r ) σ r ( ZZ † ) 10 3 · (cid:107) Z − U (cid:63) R Z (cid:107) 2 F , ( 124 ) (cid:98) η · 4 · 10 3 κτ ( ZZ † ) (cid:107)A † ( A ( ZZ † ) − y ) · Q Z Q † Z (cid:107) 22 · (cid:107) Z − U (cid:63) R Z (cid:107) 2 F (cid:111) ( 125 ) ≤ 4 · (cid:98) η · ( 1 − δ 22 r ) (cid:107) ZZ † (cid:107) 2 · σ r ( ZZ † ) 10 3 · (cid:107) Z − U (cid:63) R Z (cid:107) 2 F ( 126 ) + (cid:98) η · 4 · 10 3 κτ ( ZZ † ) (cid:107)A † ( A ( ZZ † ) − y ) · Q Z Q † Z (cid:107) 2 2 · (cid:107) Z − U (cid:63) R Z (cid:107) 2 F . ( 127 ) 42 Combining the above inequalities , we obtain : (cid:107)A † ( A ( ZZ † ) − y ) · Q Z Q † Z (cid:107) 2 · (cid:107) Z − U (cid:63) R Z (cid:107) 2 F ( i ) ≤ ( 1 − δ 2 r ) σ r ( ZZ † ) 10 3 · (cid:107) Z − U (cid:63) R Z (cid:107) 2 F + ( 10 3 κτ ( ZZ † ) + 1 ) · 4 · (cid:98) η (cid:107)A † ( A ( ZZ † ) − y ) · Q Z Q † Z (cid:107) 22 · (cid:107) Z − U (cid:63) R Z (cid:107) 2 F ( ii ) ≤ ( 1 − δ 2 r ) σ r ( ZZ † ) 10 3 · (cid:107) Z − U (cid:63) R Z (cid:107) 2 F + ( 10 3 β 2 κτ ( ρ (cid:63) ) + 1 ) · 4 · (cid:98) η (cid:107)A † ( A ( ZZ † ) − y ) · Q Z Q † Z (cid:107) 22 · (cid:18) 32 + 2 | µ | (cid:19) 2 κτ ( ρ (cid:63) ) 110 6 σ r ( ρ (cid:63) ) ( iii ) ≤ ( 1 − δ 2 r ) σ r ( ZZ † ) 10 3 · (cid:107) Z − U (cid:63) R Z (cid:107) 2 F + 4 · 1001 β 2 · (cid:98) η · (cid:107)A † ( A ( ZZ † ) − y ) · Q Z Q † Z (cid:107) 22 · (cid:18) 32 + 2 | µ | (cid:19) 2 10 6 (cid:18) 1 − (cid:18) 32 + 2 | µ | (cid:19) 110 3 (cid:19) 2 σ r ( ZZ † ) ( iv ) ≤ ( 1 − δ 2 r ) σ r ( ZZ † ) 10 3 · (cid:107) Z − U (cid:63) R Z (cid:107) 2 F + 4 · 1001 β 2 · (cid:98) η · (cid:18) 32 + 2 | µ | (cid:19) 2 10 6 (cid:18) 1 − (cid:18) 32 + 2 | µ | (cid:19) 110 3 (cid:19) 2 · (cid:107)A † ( A ( ZZ † ) − y ) · Z (cid:107) 2 F ( v ) ≤ ( 1 − δ 2 r ) (cid:18) 1 + ( 32 + 2 | µ | ) 110 3 (cid:19) 2 σ r ( ρ (cid:63) ) 10 3 · (cid:107) Z − U (cid:63) R Z (cid:107) 2 F + 1200 β 2 · (cid:98) η · (cid:18) 32 + 2 | µ | (cid:19) 2 (cid:18) 1 − (cid:18) 32 + 2 | µ | (cid:19) 110 3 (cid:19) 2 · (cid:107)A † ( A ( ZZ † ) − y ) · Z (cid:107) 2 F where ( i ) follows from (cid:98) η ≤ 1 4 ( 1 + δ 2 r ) (cid:107) ZZ † (cid:107) 2 , ( ii ) is due to Corollary 3 , bounding (cid:107) Z − U (cid:63) R Z (cid:107) F ≤ ρσ r ( ρ (cid:63) ) 1 / 2 , where ρ : = (cid:0) 32 + 2 | µ | (cid:1) 1 10 3 √ κτ ( ρ (cid:63) ) by Lemma 3 , ( iii ) is due to ( 10 3 β 2 κτ ( ρ (cid:63) ) + 1 ) ≤ 1001 β 2 κτ ( ρ (cid:63) ) , and by Corollary 1 , ( iv ) is due to the fact σ r ( ZZ † ) (cid:107)A † ( A ( ZZ † ) − y ) · Q Z Q † Z (cid:107) 22 ≤ (cid:107)A † ( A ( ZZ † ) − y ) Z (cid:107) 2 F , and ( v ) is due to Corollary 1 . Next , we bound the second term in equation ( 122 ) : (cid:107)A † ( A ( ZZ † ) − y ) · Q U (cid:63) Q † U (cid:63) (cid:107) 2 · (cid:107) Z − U (cid:63) R Z (cid:107) 2 F ( i ) ≤ (cid:107)A † ( A ( ZZ † ) − y ) − A † ( A ( ρ (cid:63) ) − y ) (cid:107) 2 · (cid:107) Z − U (cid:63) R Z (cid:107) 2 F ( ii ) ≤ ( 1 + δ 2 r ) · (cid:107) ZZ † − U (cid:63) U (cid:63) † (cid:107) F · (cid:107) Z − U (cid:63) R Z (cid:107) 2 F ( iii ) ≤ ( 1 + δ 2 r ) ( 2 + ρ ) · ρ · σ 1 ( U (cid:63) ) · σ r ( U (cid:63) ) · (cid:107) Z − U (cid:63) R Z (cid:107) 2 F ( iv ) ≤ ( 1 + δ 2 r ) ( 2 + ρ ) (cid:0) 32 + 2 | µ | (cid:1) · 110 3 σ r ( ρ (cid:63) ) · (cid:107) Z − U (cid:63) R Z (cid:107) 2 F ≤ ( 1 + δ 2 r ) (cid:0) 2 + (cid:0) 32 + 2 | µ | (cid:1) · 110 3 (cid:1) (cid:0) 32 + 2 | µ | (cid:1) · 110 3 σ r ( ρ (cid:63) ) · (cid:107) Z − U (cid:63) R Z (cid:107) 2 F , where ( i ) follows from (cid:107)A † ( A ( ZZ † ) − y ) · Q U (cid:63) Q † U (cid:63) (cid:107) 2 ≤ (cid:107)A † ( A ( ZZ † ) − y ) (cid:107) 2 and A † ( A ( ρ (cid:63) ) − y ) = 0 , ( ii ) is due to smoothness of f and the RIP constants , ( iii ) follows from [ 14 , Lemma 18 ] , for ρ = (cid:0) 32 + 2 | µ | (cid:1) · 1 10 3 √ κτ ( ρ (cid:63) ) , ( iv ) follows from substituting ρ above , and observing that τ ( ρ (cid:63) ) = σ 1 ( U (cid:63) ) 2 / σ r ( U (cid:63) ) 2 > 1 and κ = ( 1 + δ 2 r ) / ( 1 − δ 2 r ) > 1 . Combining the above we get : (cid:68) A † ( A ( ZZ † ) − y ) , ( Z − U (cid:63) R Z ) ( Z − U (cid:63) R Z ) † (cid:69) ≥ − (cid:32) θσ r ( ρ (cid:63) ) · (cid:107) Z − U (cid:63) R Z (cid:107) 2 F + 1200 β 2 · (cid:98) η · (cid:18) 32 + 2 | µ | (cid:19) 2 (cid:18) 1 − (cid:18) 32 + 2 | µ | (cid:19) 110 3 (cid:19) 2 · (cid:107)A † ( A ( ZZ † ) − y ) · Z (cid:107) 2 F (cid:33) ( 128 ) where θ = ( 1 − δ 2 r ) (cid:16) 1 + (cid:16) 32 + 2 | µ | (cid:17) 110 3 (cid:17) 2 10 3 + ( 1 + δ 2 r ) (cid:0) 2 + (cid:0) 32 + 2 | µ | (cid:1) · 110 3 (cid:1) (cid:0) 32 + 2 | µ | (cid:1) · 110 3 . 43 Lemma 6 . Under identical assumptions with Lemma 5 , the following inequality holds : (cid:68) A † ( A ( ZZ † ) − y ) , ZZ † − U (cid:63) U (cid:63) † (cid:69) ≥ 1 . 1172 η (cid:13)(cid:13)(cid:13) A † ( A ( ZZ † ) − y ) Z (cid:13)(cid:13)(cid:13) 2 F + 1 − δ 2 r 2 (cid:107) U (cid:63) U (cid:63) † − ZZ † (cid:107) 2 F ( 129 ) Proof . By smoothness assumption of the objective , based on the RIP assumption , we have : 12 (cid:107)A ( ZZ † ) − y (cid:107) 22 ≥ 12 (cid:107)A ( U + U † + ) − y (cid:107) 22 ( 130 ) − (cid:68) A † ( A ( ZZ † ) − y ) , U + U † + − ZZ † (cid:69) − 1 + δ 2 r 2 (cid:107) U + U † + − ZZ † (cid:107) 2 F ⇒ ( 131 ) 12 (cid:107)A ( ZZ † ) − y (cid:107) 22 ≥ 12 (cid:107)A ( U (cid:63) U (cid:63) † ) − y (cid:107) 22 ( 132 ) − (cid:68) A † ( A ( ZZ † ) − y ) , U + U † + − ZZ † (cid:69) − 1 + δ 2 r 2 (cid:107) U + U † + − ZZ † (cid:107) 2 F ( 133 ) due to the optimality (cid:107)A ( U (cid:63) U (cid:63) † ) − y (cid:107) 22 = 0 ≤ (cid:107)A ( V V † ) − y (cid:107) 22 , for any V ∈ C d × r . Also , by the restricted strong convexity with RIP , we get : 12 (cid:107)A ( U (cid:63) U (cid:63) † ) − y (cid:107) 22 ≥ 12 (cid:107)A ( ZZ † ) − y (cid:107) 22 ( 134 ) + (cid:68) A † ( A ( ZZ † ) − y ) , U (cid:63) U (cid:63) † − ZZ † (cid:69) + 1 − δ 2 r 2 (cid:107) U (cid:63) U (cid:63) † − ZZ † (cid:107) 2 F ( 135 ) Adding the two inequalities , we obtain : (cid:68) A † ( A ( ZZ † ) − y ) , ZZ † − U (cid:63) U (cid:63) † (cid:69) ≥ (cid:68) A † ( A ( ZZ † ) − y ) , ZZ † − U + U † + (cid:69) ( 136 ) − 1 + δ 2 r 2 (cid:107) U + U † + − ZZ † (cid:107) 2 F + 1 − δ 2 r 2 (cid:107) U (cid:63) U (cid:63) † − ZZ † (cid:107) 2 F ( 137 ) To proceed we observe : U + U † + = (cid:16) Z − η A † (cid:16) A ( ZZ † ) − y (cid:17) Z (cid:17) · (cid:16) Z − η A † (cid:16) A ( ZZ † ) − y (cid:17) Z (cid:17) † ( 138 ) = ZZ † − ηZZ † · A † (cid:16) A ( ZZ † ) − y (cid:17) − η A † (cid:16) A ( ZZ † ) − y (cid:17) · ZZ † ( 139 ) + η 2 A † (cid:16) A ( ZZ † ) − y (cid:17) · ZZ † · A † (cid:16) A ( ZZ † ) − y (cid:17) ( 140 ) ( i ) = ZZ † − (cid:16) I − η 2 Q Z Q † Z A † (cid:16) A ( ZZ † ) − y (cid:17)(cid:17) · ηZZ † · A † (cid:16) A ( ZZ † ) − y (cid:17) ( 141 ) − η A † (cid:16) A ( ZZ † ) − y (cid:17) · ZZ † · (cid:16) I − η 2 Q Z Q † Z A † (cid:16) A ( ZZ † ) − y (cid:17)(cid:17) ( 142 ) where ( i ) is due to the fact A † (cid:0) A ( ZZ † ) − y (cid:1) · ZZ † · A † (cid:0) A ( ZZ † ) − y (cid:1) = A † (cid:0) A ( ZZ † ) − y (cid:1) · Q Z Q † Z · ZZ † · Q Z Q † Z · A † (cid:0) A ( ZZ † ) − y (cid:1) , for Q Z a basis matrix whose columns span the column space of Z ; also , I is the identity matrix whose dimension is apparent from the context . Thus : η 2 Q Z Q † Z A † (cid:16) A ( ZZ † ) − y (cid:17) (cid:22) 10 . 5 10 (cid:98) η 2 Q Z Q † Z A † (cid:16) A ( ZZ † ) − y (cid:17) , ( 143 ) and , hence , I − η 2 Q Z Q † Z A † (cid:16) A ( ZZ † ) − y (cid:17) (cid:23) I − 10 . 5 10 (cid:98) η 2 Q Z Q † Z A † (cid:16) A ( ZZ † ) − y (cid:17) . ( 144 ) Deﬁne Ψ = I − η 2 Q Z Q † Z A † (cid:0) A ( ZZ † ) − y (cid:1) . Then , using the deﬁnition of (cid:98) η , we know that (cid:98) η ≤ 1 4 (cid:107) Q Z Q † Z A † ( A ( ZZ † ) − y ) (cid:107) 2 , and thus : Ψ (cid:31) 0 , σ 1 ( Ψ ) ≤ 1 + 21160 , and σ n ( Ψ ) ≥ 1 − 21160 . ( 145 ) 44 Going back to the main recursion and using the above expression for U + U † + , we have : (cid:68) A † ( A ( ZZ † ) − y ) , ZZ † − U (cid:63) U (cid:63) † (cid:69) − 1 − δ 2 r 2 (cid:107) U (cid:63) U (cid:63) † − ZZ † (cid:107) 2 F ( 146 ) ≥ (cid:68) A † ( A ( ZZ † ) − y ) , ZZ † − U + U † + (cid:69) − 1 + δ 2 r 2 (cid:107) U + U † + − ZZ † (cid:107) 2 F ( 147 ) ( i ) ≥ 2 η (cid:68) A † ( A ( ZZ † ) − y ) , A † ( A ( ZZ † ) − y ) · ZZ † · Ψ (cid:69) ( 148 ) − 1 + δ 2 r 2 (cid:107) 2 η A † ( A ( ZZ † ) − y ) · ZZ † · Ψ (cid:107) 2 F ( 149 ) ( ii ) ≥ 2 (cid:0) 1 − 21160 (cid:1) η (cid:13)(cid:13)(cid:13) A † ( A ( ZZ † ) − y ) Z (cid:13)(cid:13)(cid:13) 2 F ( 150 ) − 2 ( 1 + δ 2 r ) η 2 (cid:13)(cid:13)(cid:13) A † ( A ( ZZ † ) − y ) Z (cid:13)(cid:13)(cid:13) 2 F · (cid:107) Z (cid:107) 22 · (cid:107) Ψ (cid:107) 22 ( 151 ) ( iii ) ≥ 2 (cid:0) 1 − 21160 (cid:1) η (cid:13)(cid:13)(cid:13) A † ( A ( ZZ † ) − y ) Z (cid:13)(cid:13)(cid:13) 2 F ( 152 ) − 2 ( 1 + δ 2 r ) η 2 (cid:13)(cid:13)(cid:13) A † ( A ( ZZ † ) − y ) Z (cid:13)(cid:13)(cid:13) 2 F · (cid:107) Z (cid:107) 22 · (cid:0) 1 + 21160 (cid:1) 2 ( 153 ) = 2 (cid:0) 1 − 21160 (cid:1) η (cid:13) (cid:13)(cid:13) A † ( A ( ZZ † ) − y ) Z (cid:13) (cid:13)(cid:13) 2 F · (cid:18) 1 − 2 ( 1 + δ 2 r ) η · (cid:107) Z (cid:107) 22 · (cid:0) 1 + 21160 (cid:1) 2 · 1 2 ( 1 − 21160 ) (cid:19) ( 154 ) ( iv ) ≥ 2 (cid:0) 1 − 21160 (cid:1) η (cid:13)(cid:13)(cid:13) A † ( A ( ZZ † ) − y ) Z (cid:13)(cid:13)(cid:13) 2 F · (cid:18) 1 − 2 ( 1 + δ 2 r ) 10 . 5 10 (cid:98) η · (cid:107) Z (cid:107) 22 · (cid:0) 1 + 21160 (cid:1) 2 · 1 2 ( 1 − 21160 ) (cid:19) ( 155 ) ( v ) ≥ 2 (cid:0) 1 − 21160 (cid:1) η (cid:13)(cid:13)(cid:13) A † ( A ( ZZ † ) − y ) Z (cid:13)(cid:13)(cid:13) 2 F ·   1 − 10 . 5 10 (cid:18) 1 + 21160 (cid:19) 2 4 ( 1 − 21160 )   ( 156 ) = 1 . 0656 η (cid:13)(cid:13)(cid:13) A † ( A ( ZZ † ) − y ) Z (cid:13)(cid:13)(cid:13) 2 F ( 157 ) where ( i ) is due to the symmetry of the objective ; ( ii ) is due to Cauchy - Schwarz inequality and the fact : (cid:68) A † ( A ( ZZ † ) − y ) , A † ( A ( ZZ † ) − y ) · ZZ † · Ψ (cid:69) ( 158 ) = (cid:68) A † ( A ( ZZ † ) − y ) , A † ( A ( ZZ † ) − y ) · ZZ † (cid:69) ( 159 ) − η 2 (cid:68) A † ( A ( ZZ † ) − y ) , A † ( A ( ZZ † ) − y ) · ZZ † · A † ( A ( ZZ † ) − y ) (cid:69) ( 160 ) ( i ) ≥ (cid:68) A † ( A ( ZZ † ) − y ) , A † ( A ( ZZ † ) − y ) · ZZ † (cid:69) ( 161 ) − 10 . 5 10 (cid:98) η 2 (cid:68) A † ( A ( ZZ † ) − y ) , A † ( A ( ZZ † ) − y ) · ZZ † · A † ( A ( ZZ † ) − y ) (cid:69) ( 162 ) ≥ (cid:16) 1 − 10 . 5 10 (cid:98) η 2 (cid:107) Q Z Q † Z A † ( A ( ZZ † ) − y ) (cid:107) 22 (cid:17) · (cid:13)(cid:13)(cid:13) A † ( A ( ZZ † ) − y ) Z (cid:13)(cid:13)(cid:13) 2 F ( 163 ) ≥ (cid:0) 1 − 21160 (cid:1) (cid:13)(cid:13)(cid:13) A † ( A ( ZZ † ) − y ) Z (cid:13)(cid:13)(cid:13) 2 F ( 164 ) where ( i ) is due to η ≤ 10 . 5 10 (cid:98) η , and the last inequality comes from the deﬁnition of the (cid:98) η and its upper bound ; ( iii ) is due to the upper bound on (cid:107) Ψ (cid:107) 2 above ; ( iv ) is due to η ≤ 10 . 5 10 (cid:98) η ; ( v ) is due to (cid:98) η ≤ 1 4 ( 1 + δ 2 r ) (cid:107) ZZ † (cid:107) 2 . The above lead to the desiderata : (cid:68) A † ( A ( ZZ † ) − y ) , ZZ † − U (cid:63) U (cid:63) † (cid:69) ≥ 1 . 0656 η (cid:13)(cid:13)(cid:13) A † ( A ( ZZ † ) − y ) Z (cid:13)(cid:13)(cid:13) 2 F + 1 − δ 2 r 2 (cid:107) U (cid:63) U (cid:63) † − ZZ † (cid:107) 2 F ( 165 ) 45