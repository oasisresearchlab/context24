© 2022 IEEE . This is the author’s version of the article that has been published in IEEE Transactions on Visualization and Computer Graphics . The ﬁnal version of this record is available at : xx . xxxx / TVCG . 201x . xxxxxxx / No Grammar to Rule Them All : A Survey of JSON - style DSLs for Visualization Andrew M . McNutt Abstract — There has been substantial growth in the use of JSON - based grammars , as well as other standard data serialization languages , to create visualizations . Each of these grammars serves a purpose : some focus on particular computational tasks ( such as animation ) , some are concerned with certain chart types ( such as maps ) , and some target speciﬁc data domains ( such as ML ) . Despite the prominence of this interface form , there has been little detailed analysis of the characteristics of these languages . In this study , we survey and analyze the design and implementation of 57 JSON - style DSLs for visualization . We analyze these languages supported by a collected corpus of examples for each DSL ( consisting of 4395 instances ) across a variety of axes organized into concerns related to domain , conceptual model , language relationships , affordances , and general practicalities . We identify tensions throughout these areas , such as between formal and colloquial speciﬁcations , among types of users , and within the composition of languages . Through this work , we seek to support language implementers by elucidating the choices , opportunities , and tradeoffs in visualization DSL design . Index Terms —Visualization grammar , Survey , Declarative speciﬁcation , Domain - Speciﬁc Languages 1 I NTRODUCTION Domain - speciﬁc languages ( DSLs ) represented in standard data seri - alization formats , such as JSON or YAML , are an increasingly com - mon [ 89 ] interface for the speciﬁcation of visualizations across an array of contexts and tasks . These restricted textual languages allow for the declarative speciﬁcation of both static and interactive graphics in a systematic manner that can be manipulated both by humans , making them attractive for end - user programming , and computational agents , making them appealing for artiﬁcial intelligence applications [ 123 ] . This language style appears in a surprisingly large variety of tools and systems but is well exempliﬁed by Vega [ 97 ] and Vega - Lite [ 95 ] . While it is sometimes derided for usability issues [ 24 , 53 , 65 ] , this language style has a variety of beneﬁts . DSLs which employ it can be expressive , allowing for the concise manipulation of complex speciﬁca - tions with minimal textual modiﬁcation [ 97 ] . Many of these languages enhance the explorability of a space of possible programs by simple and ﬂuid movement between instances . Their limited scope enables some speciﬁcations to be used portably , such that charts created in one platform ( such as a GUI like Voyager [ 120 ] ) can be used in another environment ( such as in the Python - based Altair [ 109 ] ) . Despite the popularity ( Fig . 2 ) of this approach , there has been little detailed analysis of the characteristics of these systems . Pu et al . [ 89 ] highlight the need for additional study of visualization grammars , while Wongsuphasawat [ 117 ] surveyed the more general space of JavaScript ( JS ) visualization libraries . Although they are insightful , these works leave critical questions about these DSLs open : What problems do they seek to solve ? Who are they designed to serve ? or more generally What design and implementation patterns are used in JSON - style DSLs ? In this paper we answer these questions by surveying visualization DSLs represented in standard data serialization languages covering academic , industrial , and open source language efforts , yielding 57 distinct languages ( Fig . 3 ) . We analyze each of these DSLs across a variety of dimensions including the motivations for their design , relationships with other languages , and the conceptual models which are utilized . We identify ﬁve sets of concerns ( Fig . 1 ) which are critical to JSON - style DSL design and highlight a corresponding set of tensions to be navigated , such as the tension between formal and colloquial Andrew M . McNutt is with University of Chicago . E - mail : mcnutt @ uchicago . edu . Manuscript received xx xxx . 201x ; accepted xx xxx . 201x . Date of Publication xx xxx . 201x ; date of current version xx xxx . 201x . For information on obtaining reprints of this article , please send e - mail to : reprints @ ieee . org . Digital Object Identiﬁer : xx . xxxx / TVCG . 201x . xxxxxxx models or the effect on the DSL caused by the interplay of different intended users . In doing so we note opportunities , tradeoffs , and open challenges . To aid this analysis we collected examples of each DSL , yielding 4395 programs , available in our interactive supplement . While JSON - style DSLs have been usefully employed in a variety of visual analytics systems [ 73 , 94 , 120 , 129 ] , we believe that a ﬁrmer grasp of the design space of this language form will help future languages better address the highlighted design questions . Moreover , a language’s affordances , abstractions , and models guide the types of expression that are made using it [ 81 , 111 ] . Thus , a stronger foundation may open the door to new forms of analysis and expression . 2 R ELATED W ORK We will now locate our study within prior work on DSLs in general ( and review relevant terminology ) and visualization DSLs speciﬁcally . 2 . 1 Domain Speciﬁc Languages DSLs are a type of programming language designed to facilitate par - ticular tasks within a chosen domain . While this term is variably deﬁned , DSLs are usually ( but not always [ 24 ] ) deﬁned as languages that are unable to execute general computations , in exchange for spe - ciﬁc declarative notation related to a domain of interest—properties that differentiate them from General Purpose Languages ( GPLs ) . The database query language SQL , the browser - styling language CSS , and the markup language L A TEX are all familiar examples of this design approach . Van Deursen et al . [ 108 ] argue that DSLs are useful because they allow domain experts to operate within the notation of a given domain , and assert that they are typically concise , reusable , and self - documenting . They also note that DSLs carry a host of disadvantages including maintenance costs , learnability issues , and the danger of language cacophony [ 24 ] resulting from a preponderance of languages . DSLs are often thought of as solely declarative , as the user speciﬁes intent relative to the domain rather than through low - level details of how that action is executed . However , some DSLs use imperative syntax ( e . g . shaders or Atlas [ 65 ] ) , but all DSLs in our study are declarative and the closest exceptions are pipeline models . A common decomposition of DSLs [ 24 , 76 ] describes them as ex - ternal or internal . External languages deﬁne their syntax outside of their host language , such that they typically require separate parsing to execute . Some utilize custom syntax ( e . g . SQL or CSS ) , while others elect to use standard data serialization grammars ( e . g . XML or JSON ) . This raises questions about what qualiﬁes as a language as opposed to an API . Highlighting this ambiguity , Fowler [ 24 ] argues for a heuristic related to a ﬂuent , composable , or language - like nature . This refers to the concept that “expressiveness comes not just from individual 1 a r X i v : 2207 . 07998v1 [ c s . H C ] 16 J u l 2022 Affordances Question : Who is the end user ? Tension : Competing interests vie for conveniences Domain : Question : Why is this DSL necessary ? Tension : Design for general vs speciﬁc use cases Models : Question : What is this DSL ? Tension : Formal / Colloquial models and Low / High abstraction Relationships Question : How does it relate to other DSLs ? Tension : Language customization vs reuse Practicalities Question : Where is work done ? Tension : Locate features among competing incentives ? Fig . 1 . An overview of the analysis of our survey . expressions , but also from the way they can be composed together” [ 24 ] . That is , there is a systemic way that the language operates , without needing special cases for every expression form . We use this heuristic to identify languages in our survey . The complement to external DSLs are internal DSLs , which are em - bedded ( as a library or through syntax extensions ) into a host language— e . g . dplyr , d3 , or RSpec . These languages provide expressivity similar to external languages , but do so in a way that confers the beneﬁts and limitations of their host . Tobin - Hochstadt et al . [ 105 ] highlight the permeable border between languages and libraries in Racket , where libraries are distributed as language extensions—an ambiguity that is increasingly relevant as more visualization libraries adopt language - style interfaces . This architectural choice allows for the straightforward creation of richly expressive languages that are easy to integrate into a host , but can force constraints and notation which are inappropriate to the DSL domain . In contrast , Diderot [ 14 ] explicitly resists embedding so as to maintain the domain speciﬁcity of its type system . Prior studies have sought to understand and typify DSL usage [ 6 , 24 , 87 , 108 ] . Mernik et al . [ 76 ] describe design patterns exhibited at each stage of the DSL design process . Van Deursen et al . [ 108 ] characterize 75 DSLs by purpose . The analysis of our survey draws on these works but is designed to complement these considerations made by others by focusing on a particular domain . Erdweg et al . [ 23 ] identify a set of language composition mechanisms , which guides our discussion of the topic ( although ours is adapted to a less - general domain ) . Several studies consider DSLs in speciﬁc domains , such as declarative data analytics [ 70 ] , conﬁguration languages [ 30 ] , and visual computing [ 99 ] . Our work is related to these but is centered on visualization . The use of standard serialization languages as carrier languages for DSLs is not new . XML and other hierarchical serialization languages have long been used as a way to conﬁgure applications [ 24 , 30 ] and even specify visualizations ( as in VizML [ 115 ] ) . Similarly , visualization is not unique in its use of JSON - DSLs . Beyond familiar uses such as conﬁguration or NoSQL languages ( e . g . MongoDB ) , they are used in domains as varied as statistical analysis [ 45 ] , web development [ 5 ] , narrative [ 15 ] and game generation [ 20 ] , chatbots [ 52 ] , dance [ 83 ] , and fabrication [ 106 ] . We are interested in building a better understanding of JSON - style DSLs precisely because they are so prevalent—although their sudden prominence ( Fig . 2 ) may indicate that they are a fad . Despite their popularity , JSON - based languages are no panacea . They are sometimes maligned for their lack of programming usability features [ 53 ] , rendering them hard to learn , debug , and extend [ 65 ] . These criticisms can be extended through the Cognitive Dimensions of Notations ( CDN ) [ 4 ] , which are a suite of lightweight heuristics ( highlighted throughout ) that characterize the usability of notational interfaces . For instance , viscosity refers to the effort required to alter a program to a desired state , while diffuseness describes how terse the lan - guage is . This style of evaluation is especially useful for programming languages as it provides an external reference from which to critically reﬂect and a common grammar for usability issues . Thus , we can add to the criticisms of JSON DSLs by noting that they are subject to 2005 2010 2015 2020 6 1 13 1 4 2 2 7 2 1 1 1 1 Vega Survey DSL Paper Year Nb : systems without papers describing them are not represented here Fig . 2 . Since Vega ’s publication JSON - style DSLs have become popular . errors related to premature commitment ( choices that make movement between states difﬁcult ) , hard mental operations ( the work required outside of the coding environment ) , and progressive evaluation ( how incomplete programs are examined ) . Some serialization formats ( e . g . YAML or JSON5 ) or languages ( e . g . dhall [ 19 ] ) seek to address us - ability issues—such as diffuse syntax and lack of a secondary notation . Yet , a consensus replacement has not materialized . This may be due to JSON’s ubiquity in modern systems , which impart rich error handling and parsing , as well as typings via projects like JSON Schema [ 85 ] . 2 . 2 Visualization DSLs Visualization features a rich space in which a DSL can usefully abstract away unnecessary details in favor of domain - appropriate notation . The most prominent visualization DSL is Wilkinson’s Grammar of Graphics ( GoG ) [ 115 ] , which describes the visualization process as a series of stages that results in a mapping of data attributes to visual - encoding channels ( e . g . a penguin’s ﬂipper length mapped to spatial position ) . This approach allows the construction of myriad chart forms , in contrast to “chart templates” which map data attributes to aspects of a given chart type . GoG has inﬂuenced the development of many contemporary visualization language systems [ 7 , 97 , 114 ] . Friendly [ 26 ] reviews the model and its history . Despite its prevalent use , the term “visualization grammar” is not well deﬁned and is used in a variety of ways [ 89 ] . This term is some - times used in the generative syntactic sense [ 82 ] , referring to a system of rules that can be repeatedly applied to create particular shades of meaning . It may also be used to refer to composable systems of ex - pression [ 61 , 73 ] , akin to Fowler’s language deﬁnition . Further , it may speciﬁcally refer to variants of Wilkinson’s [ 115 ] GoG . Still others use it to refer to any visualization system [ 122 ] . We do not strive to provide a conclusive deﬁnition of visualization grammars here , instead electing to use the slightly more general framing of DSLs—although we sometimes use the term to refer to a space of allowed syntax . There are a wide variety of DSLs for visualization that fall outside of our language form of interest . The dot graph language and the mermaid diagramming language feature custom syntax for graph - based tasks . APT [ 69 ] is a DSL used to describe charts in a manner amenable to automated recommendations . Idyll [ 16 ] is a DSL for visualization - mediated explorable explanations . ViSlang [ 91 ] provides a system for making and coordinating small DSLs in SciVis , while Diderot [ 14 ] uses notation speciﬁcally aligned with the tensor - calculus operations which arise in that setting . Although the design patterns these DSLs manifest are valuable , they are beyond the scope of our study . Several prior works study visualization languages . Wongsupha - sawat [ 117 , 118 ] sketched a taxonomy based on the level of abstraction covering graphics languages , low - level languages , grammars , high - level languages , and templating systems . Qin et al . [ 90 ] sketch a similar taxonomy based on an expressiveness - accessibility axis . We expand upon these studies through a more in - depth survey of narrower scope . Pu et al . [ 89 ] highlight the pressing need for more formal study of these entities . We seek to explore and address the questions they raise , as well as support future work by developing a richer understanding of the state of the art of this language form . Satyanarayan et al . [ 94 ] reﬂect on the design of visualization authoring systems , the results of which overlap with our study , although tuned to a slightly different domain . 3 S URVEY M ETHODOLOGY We conducted a survey of visualization languages represented fully or partially in standard serialization languages ( e . g . JSON , YAML , XML ) . This yielded 57 languages , which are displayed in Fig . 3 . We searched relevant academic search engines ( Google Scholar , ACM Digital Library , IEEE Xplore ) and code repositories ( GitHub ) for 2 © 2022 IEEE . This is the author’s version of the article that has been published in IEEE Transactions on Visualization and Computer Graphics . The ﬁnal version of this record is available at : xx . xxxx / TVCG . 201x . xxxxxxx / A n i V i s A n i m a t i o n A n t V S p e c R e c o mm e n d a t i o n A p e x C h a r t s C h a r t i n g A rr a y V i s G r a m F u n c t i o n v i s u a li z a t i o n A t o m U n i t V i s u a li z a t i o n s B e r t i n M a p s C a n i s A n i m a t i o n C F G C o n f C o n t r o l F l o w G r a p h s C h a r t . j s C h a r t i n g C h a r t M L C h a r t i n g C i c e r o R e s p o n s i v e V i s C o m i c S c r i p t D a t a C o m i c s C o m p a ss Q L R e c o mm e n d a t i o n D a t a T h e a t e r E x p l o r a b l e E x p l a n a t i o n s d e c k . g l / j s o n M a p s D G M L G r a p h s D o t M L G r a p h s D X R X R E C h a r t s C h a r t i n g E n c o d a b l e C h a r t i n g F l e x - E R X R F r a pp e C h a r t i n g F u s i o n C h a r t s C h a r t i n g G e m i n i 1 A n i m a t i o n G e m i n i 2 A n i m a t i o n G e n o m e S p y G e n o m i c s gg C h a r t i n g G li n d a D a t a s c i e n c e G o s li n g G e n o m i c s G o T r ee T r ee V i s u a li z a t i o n G r a p h M L G r a p h s G X L G r a p h s H i g h c h a r t s C h a r t i n g I vy C h a r t i n g J S O L C h a r t i n g K y r i x - S Z oo m a b l e b i g d a t a M u l t i c l a ss - D e n s i t y D e n s i t y m a p s N E O C o n f u s i o n m a t r i c e s P 4 B i g d a t a P 5 P r o g r e ss i v e V i s P 6 M L P a p A R V i s X R P l o t l y J S O N C h a r t i n g S c h o l z 3 D V i s L a n g S c i V i s S e t C o L a G r a p h s S h i h V o l V i s L a n g S c i V i s S t r u c t G r a p h i c s C h a r t i n g S V L C o ll a b o r a t i o n V e g a C h a r t i n g V e g a - L i t e C h a r t i n g V i z G r a mm a r C h a r t i n g V i z M L C h a r t i n g V i z Q L C h a r t i n g V R - V i z X R V R I A X R X M L C h a r t s C h a r t i n g Z i n g C h a r t R e s p o n s i v e V i s Charting Standard Statistical Graphics Chart Type A particular chart type Interaction A particular interaction Medium A particular task or context Low Level Close to the renderer Formal Model Pervasive Logical Structure Academic Originating in academic work Internal DSL Roughly a library style Compiled Code is generated Interpreted Code is executed Has Abstraction Variables , Loops , or Control - Flow In GUI Part of an application Data manip . Can use filters or more Extensible Externally D o m a i n M o d e l s A ff o r d a n c e s P r a c t i c a l i t i e s The surveyed DSLs were analyzed across various axes , a subset of which are shown here . See supplement for details . Fig . 3 . DSLs select different feature combinations to achieve their goals . No one language , or feature combination , will suit all situations . the following keywords : DSL , domain - specific language , JSON , XML , YAML , visualization , map , grammar , language , chart , and graph . Given the inﬂuence of the works on Vega and Vega - Lite on this type of DSL , we also reviewed all papers citing the papers document - ing those systems [ 95 – 97 ] . We utilized snowball sampling whenever possible . We refer to systems in our survey like Vega , while we cite the works documenting them . See the appendix for a survey bibliography . Our survey criterion included any human - usable language that uses a standard serialization language to produce visualizations . We follow Fowler’s deﬁnition of a language [ 24 ] as being a system with a concept of composition or a sense of ﬂuency . This language nature can manifest in a variety of ways , such as mark or series composition , as well as data or view algebras . We follow our prior deﬁnition [ 71 ] of a visualization as being a transformation of data meant to be interpreted by a human . This criterion excludes some system types . SVG , HTML , and other high - level markup languages ( as well as general - purpose JSON - based DSLs , such as Varv [ 5 ] ) were excluded because they are capable of pro - ducing far more than visualizations . Also excluded were those merely subsetting another language—for instance , GraphScape [ 50 ] uses a non - interactive subset of Vega - Lite to explore sequence recommenda - tion . These systems are excluded because they simply make use of a visualization DSL rather than constructing one . Systems that possess systematically described languages ( e . g . Visception [ 54 ] ) but either do not utilize a standard serialization language for its description or do not expose that language to the end - user were excluded . We focus on computer - based languages , which precludes natural language spec - iﬁcations such as in NL4DV [ 79 ] . While many libraries excluded by our criterion ( e . g . ggplot ) could be recast into JSON , we exclude them because we strive only to understand the patterns of those DSLs that have explicitly opted to use this representation—although the design of visualization APIs more generally is intriguing future work . Examples . To facilitate comparison between the DSLs in our survey we collected representative samples of each language . For some DSLs this involved collecting every single example available ( such as Atom and Cicero ) . For those with thriving communities ( such as Highcharts and Vega - Lite ) , we only gathered examples from documentation or test repositories which provided sufﬁcient examples for analysis . In some cases ( e . g . GoTree ) the only examples available were those found in the publications documenting those languages . While additional examples would always be useful , the samples collected were sufﬁciently rep - resentative to allow us to consider each of the axes of analysis . This yielded 4395 examples , although a small number of DSLs dominate this total . We present these materials as a DSL zoo [ 127 ] in our supplement at vis - json - dsls . netlify . app and for download at osf . io / e9v8y . Analysis Process . We conducted an analysis seeking to answer : What are the design and implementation patterns in visualization DSLs rep - resented in standard serialization formats ? To do so , we analyzed each surveyed language across a set of topics . Our initial selection of topics was motivated by discussions of DSLs in general [ 24 , 65 , 76 , 108 ] , visualization DSLs [ 65 , 117 ] , as well as related work on visualization authoring systems [ 94 ] . We iteratively added and removed axes of analysis ( analogous to codes ) until a theoretical saturation was reached . Each axis was evaluated based on available documentation ( such as a paper describing the DSL ) , the found examples for the language , or sometimes by reviewing the code itself . These results were grouped into categories ( Fig . 1 ) . See the supplement for details . Our observations and analysis are descriptive , and not evaluative . Thus analyses such as locating DSLs within Satyanarayan et al . ’s [ 94 ] expressiveness - learnability spectrum are beyond the scope of this work , as such comparisons would require experimental evaluation . We focus on patterns relevant to visualization DSLs and refer to exterior sources for those related to general DSL patterns [ 24 , 46 ] . We forgo analysis of living sources ( such as interviews ) because these artifacts are suf - ﬁciently rich to conduct our analysis , although future work could be augmented by such explorations . 4 A NALYSIS We organize our discussion following our ﬁve concerns ( Fig . 1 ) guided by the information - gathering interrogatives for each DSL . 4 . 1 Domain : Why is it necessary ? We begin by considering the aims of our DSLs in order to identify the problems they seek to solve and therein identify why they are necessary . We found four purposes or domains for designing visualization DSLs : creating standard charts , creating a particular chart , enabling a speciﬁc interaction , and serving a certain task— as in Fig . 3 . These various purposes highlight a critical tension : why not just use something that already exists ? Indeed , many of the graphic types and domains can be addressed using Vega or GoG [ 26 ] with enough manipulation . This issue can be seen as a Turing tar pit [ 84 ] in which everything is possible , but nothing is easy . The value of using DSLs is exactly to avoid this pitfall : allowing some things to be easy by making some things ( that are not relevant to the domain ) impossible . Standard charts . Most DSLs focused on standard charts , such as bar charts or scatter plots . Among these , the ostensible purpose varied , fea - turing different levels of abstraction , contexts , means of expression , or implementation affordances—each of which we discuss in subsequent sections . For instance , Vega - Lite enables standard charting tasks using a formal GoG - inspired approach , while ECharts employs a colloquial chart - type model that uses its close connection to the browser to provide responsive and progressive analytics features [ 59 ] . The purpose of such languages is then the additional affordances brought to the design . Chart Forms . Some DSLs focus on enabling a particular chart form or genre . For instance , several languages support maps ( such as Bertin and deck . gl / json ) , while others focus on graphs ( GraphML , GXL , CFGConf , and SetCoLa ) . NEO enables confusion matrices . By focusing on a 3 speciﬁc chart form a DSL can tailor its notation to the concerns of that graphic . To wit , graphs specify node position as relationships between entities and not in terms of spatial attributes . This allows languages like GraphML to focus on only high - level attributes—although adding notions of axial direction can be useful ( which SetCoLa achieves by encoding directional and relative properties as constraints ) . Some chart families—like Gantt charts , Sunbursts , HOP Plots , or Euler diagrams—can be constructed through visualization DSLs whose notations are not well aligned with those charts . For instance , while Gantt charts can be produced using general charting tools like Vega - Lite ( Fig . 4 ) , they do so in a fashion that is not well matched with the data . Gantt charts show the relationship between projects over time in a DAG structure , sometimes featuring graph - based computations such as critical path ( maximum path length ) , neither of which are well supported in the tabular data model used in many DSLs . The result is that the user potentially needs to make tedious layout re - computations and round - trips to the data . While this data type and associated transformations could be embedded into Vega - Lite , doing so would add to the growing complexity of that language . We suggest that the creation of task - speciﬁc DSLs ( or what Guzdial and Shreiner [ 31 ] would call Teaspoon languages ) that allow end - users to author charts in the vernacular of a particular chart or data form to be an important opportunity . Encodable addresses this problem through a Vega - Lite - inspired component abstraction over arbitrary chart forms—although this is done in such a way that binds the charts to the JS - implementation ( precluding portability ) and requires a tabular data structure ( which can be at odds with the domain , as in Gantt charts ) . Interactions . Most languages in our survey produced interactive vi - sualizations that supported at least some simple interactions , such as tooltips . However , some languages speciﬁcally focus on nuanced or uncommon interactions . Some DSLs center animation , such as AniVis , Gemini 1 / 2 , and Canis . Cicero , ECharts , and ZingChart emphasize creat - ing responsive visualizations . SVL supports some collaborative visual analytics interactions . Focusing on a particular interaction allows the language to surface attributes that are speciﬁc to that interaction , such as Gemini 2 ’s use of keyframes as a ﬁrst - class element of the language . Careful balancing of novel and expected features is essential , as having too many options can dilute the speciﬁcity of the DSL , however , missing anticipated features can ruin its domain utility . For instance , zooming is an interesting addition to abstract visualizations in Gosling , while in map - focused DSLs it is all but required . A number of DSLs focus only on the interaction of concern and ofﬂoad the remainder of the work to another DSL through compilation ( Sec . 4 . 3 ) . This style of interaction injection is a valuable component of some JSON - style DSLs . The restricted grammars allow simple language composition , allowing each DSL to do one thing well . Sim - ilar effects can be achieved with plugin architectures , however such methods are usually inaccessible to end - users . Nearly all interactions in these DSLs are transient , with only one DSL ( Glinda ) supporting updates from their state into their speciﬁca - tion . While some interfaces ( e . g . B2 [ 125 ] ) provide mechanisms to reify interactions into code , it is a missed opportunity that such bidirec - tional interactions are relegated to external tools given JSON - like DSLs computational malleability . For instance , tasks like annotation may be easier to complete using direct manipulation as it does not require repeated round trips to code [ 110 ] . We suggest that such tasks may be well - supported by DSLs that allow alteration of their speciﬁcation from their output in addition to from the code , such that changes to the output are reﬂected in the input and vice - versa . Similar techniques have been employed to allow bidirectional updates to SVG drawings formed through functional programming languages [ 34 , 36 ] . As JSON - style DSLs can be manipulated more easily than most GPLs , we suggest that future systems should explore this intriguing feature domain . Mediums . The purpose of a number of systems is to enable use of a particular medium , form of data , or set of tasks . As noted in Fig . 3 , these DSLs address a wide range of domains including SciVis , big data , and data science / ML . This broad purpose highlights that visualization tasks occur outside of the tidy small - data abstract - charting sandbox that V e g a - L i t e H y p o t h e t i c a l G a n tt G r a mm a r { data : { values : [ { task : " A " , start : 1 , end : 3 } , { task : " B " , start : 3 , end : 8 } , { task : " C " , start : 8 , end : 10 } ] } , mark : " bar " , encoding : { y : { field : " task " , type : " ordinal " } , x : { field : " start " , type : " quantitative " } , x2 : { field : " end " } } } { data : { values : [ { id : " A " , deps : [ ] , dur : 2 } , { id : " B " , deps : [ " A " ] , dur : 5 } , { id : " C " , deps : [ " B " ] , dur : 2 } ] } , encoding : { time : { field : " dur " , offset : 1 } , deps : " deps " , id : " id " } } t a s k time 0 2 4 6 8 10 A B C Nb : While windowing functions can ease recomputation for simple charts such as this one , more complex graphs can not be repeatably adjusted without substantial difﬁculty . Fig . 4 . While these Gantt chart speciﬁcations are similar in length and complexity , the task - speciﬁc DSL does not require the user to manually update the positions after a data update . visualization DSLs ( and systems [ 94 ] ) often target , and moreover , that conceptual adaptations can be usefully made to serve other use cases . Focusing on domain allows selection of appropriate notation . For instance , some domains use their own coordinate systems either by convention or necessity . Genome Spy and Gosling include an idea of genomic coordinates . ComicScript has a comic - speciﬁc notion of panels . While generic approaches could achieve similar ends , they would not match the expressivity found by localizing the syntax to the domain . ComicScript has limited support for data exploration but enables interac - tive data comics in a way that would otherwise be unmanageable [ 113 ] . As with DSLs in any domain , this may come at the cost of generality . Surfacing domain - speciﬁc concepts allows the user to avoid the Turing tarpit and directly address aspects relevant to the domain . How - ever , JSON - style DSLs are most useful for tasks that speciﬁcally ﬁt the medium or that an end - user would wish to accomplish as a DSL ( or through a facade for one ) . For instance , several virtual or extended re - ality systems ( XR ) —such as DXR , VR - Viz —use JSON - based grammars as the basis of their syntax . We suggest the prevalence of this approach may be because of XR’s need to pass between mediums ( e . g . between JS and Unity ) is well matched with the portability of JSON - style DSLs . Tasks with less structure may be better matched with free - text DSLs ( e . g . ViSlang [ 91 ] ) as these allow for greater ﬂexibility at the expense of automation ( e . g . GUIs or recommenders ) . 4 . 2 Models : What is it ? All languages are predicated on a model of what computation is exe - cuted based on the commands written by the programmer . DSLs in our survey used models that fell along axes of low to high abstraction , and formal to colloquial . Drawing on prior work [ 117 ] , abstraction level refers to DSLs that are close to the data domain as “high - level” ( e . g . VizML or Highcharts ) and those near the rendering context as “low - level” ( e . g . Vega or deck . gl / json ) . Model formality denotes a pervasive logical structure in the DSL’s design . Formal Models . Languages backed by overarching frameworks are an important approach to visualization system design and are successful in tools like Tableau and ggplot . These formal models can simplify the expression of intent ( within their scope ) and aid potentially difﬁcult analyses , although possibly impeding ﬂexibility . We observed a variety of models whose purpose and intent varied . The most prominent of these is Wilkinson’s GoG [ 115 ] model in which data attributes are mapped to encoding channels and combined through marks . These forms allow for expressive construction and combination of visualizations allowing for the ﬂuid creation of novel forms without concern for chart type . Examples of this form include Vega - Lite , Vega , VizML , JSOL , and Flex - ER . We suggest that this form is a safe default model for many visualization systems , as it “expose ( s ) the mechanics of good practice” [ 35 ] . Wilkinson has argued [ 89 , 115 ] that his Grammar of Graphics is the only grammar of graphics . While this framing has been enormously successful in the development of visualization systems and languages , it is far from the only conceivable systematic model for creating visualizations . Others can be more tightly tuned to support particular tasks . For instance , VizQL emphasizes data exploration through the language of a data cube . 4 © 2022 IEEE . This is the author’s version of the article that has been published in IEEE Transactions on Visualization and Computer Graphics . The ﬁnal version of this record is available at : xx . xxxx / TVCG . 201x . xxxxxxx / G o s li n g { tracks : [ { layout : " linear " , width : 600 , height : 400 , data : { url : " < URL > " , type : " multivec " , row : " sample " , column : " position " , value : " peak " , categories : [ " sample 1 " ] } , mark : " point " , x : { field : " position " , type : " genomic " , axis : " bottom " } , y : { field : " peak " , type : " quantitative " , axis : " right " } , size : { field : " peak " , type : " quantitative " } } ] } GoG - style languages can be augmented with domain speciﬁc content and abstractions , such as in the notion of tracks and genomic coordinates shown here . P l o t l y J S O N [ { x : [ 1 , 2 , 3 , 4 ] , y : [ 10 , 11 , 12 , 13 ] , mode : " markers " , marker : { color : [ " rgb ( 93 , 164 , 214 ) " , " rgb ( 255 , 144 , 14 ) " , " rgb ( 44 , 160 , 101 ) " , " rgb ( 255 , 65 , 54 ) " ] , opacity : [ 1 , 0 . 8 , 0 . 6 , 0 . 4 ] , size : [ 40 , 60 , 80 , 100 ] } } ] Properties ( such as color ) in series - models can be applied directly to the relevant component , giving a good closeness of mapping . { data : { url : " data / cars . json " } , mark : " point " , encoding : { x : { field : " Horsepower " , type : " quantitative " } , y : { field : " Miles _ per _ Gallon " , type : " quantitative " } } } V e g a - L i t e A t o m GoG - style mappings ( as here ) provide a fast - ﬂexible control over the chart design space allowing smooth exploration and clear documentation of intent . Alternative formal models ( such as the L - System inspired framing used here ) can motivate alternative analyses and creation of novel chart forms . { data : { url : " data / titanic3 . csv " } , layouts : [ { type : " gridxy " , aspect _ ratio : " fillX " , subgroup : { type : " groupby " , key : " pclass " } } , { type : " gridxy " , aspect _ ratio : " maxfill " , subgroup : { type : " flatten " } , size : { type : " uniform " , isShared : false } } ] , mark : { shape : " circle " , color : { key : " survived " } } } Fig . 5 . A DSL’s domain and model manifest themselves in its syntax . While many DSLs expressively use a declarative mapping of data to visual properties , other formulations can also be effective . For instance , Atom uses an L - system - inspired model to describe unit visualizations ( see Fig . 5 ) , whose graphical forms carry pivot sequences that are well matched with the iterative stages of an L - system . CompassQL and SetCoLa use constraints to generate programs that can act as a facade for complex systems whose interface might not be easy to understand or write ( such as recommendation systems ) . Scholz 3D Vis Language , Shih Volume Vis Language , and P4 - 6 use a sequential pipeline model . Pipeline models seem to be especially suited to low - level graphics tasks ( as in Shih Volume Vis Language or shaders ) or data manipulation ( as in P5 or Vega ’s data model ) as they may involve iterated stages whose results must be produced sequentially . We highlight these alternative framings because they may yield new approaches to various problems and enable chart types or analyses which are impossible ( or needlessly difﬁcult ) in other framings . Alternative conceptual models are not unique to our survey . For instance , the HiVE notation [ 102 ] eases exploration of hierarchical orderings in treemaps . The development of DSLs for particular chart types or aspects is an intriguing opportunity for this genre of work , as are DSLs that surface novel semantic models as a way to expose new framings for analysis . While our survey criterion requires that every DSL have algebraic qualities , several DSLs introduced explicit algebraic structures . Both VizML and VizQL use table algebras to describe the way data is manipu - lated prior to graphical display . Vega - Lite uses a simple data table model but provides a view algebra that provides affordances for viewing per - mutations and combinations . These algebras allow for rich expression within their domains . Similar systematic models might be established to serve other tasks or simply to surface alternate analysis approaches . For instance , NEO uses an algebra speciﬁc to confusion matrices . The visualization process has many interrelated steps , many of which might be enriched through formal modeling . Colloquial Models . The complement to formal models are those mod - els that do not impose a framework over the structure of the interface . These colloquial models are sometimes overlooked despite their ability to adapt and accommodate real - world situations and problems . These less structured DSLs typically utilize series - based models in which data is mapped to aspects of particular chart forms ( as in templates ) , such as the x - axis of a scatterplot or the angles of a pie chart ( e . g . Plotly JSON in Fig . 5 ) . Systems whose speciﬁcation unit is a layer ( such as deck . gl / json and Bertin ) can be seen as using a series model in which the series are superimposed . They can be used at any level { series : [ { type : " treemap " , data : [ … ] , layoutAlgorithm : " stripes " , alternateStartingDirection : true , levels : [ … , { level : 1 , layoutAlgorithm : " sliceAndDice " , dataLabels : { enabled : true , align : " left " } } , … ] } ] } H i g h c h a r t s Fig . 6 . Colloquial DSLs can enable speciﬁcation of chart attributes without modeling those attributes through the entire system . of abstraction , such as high - level DSLs like AniVis ( which focuses on high - level chart templates ) or low - level DSLs as in deck . gl / json ( which can give access to shader - level manipulations ) . While these approaches are sometimes denigrated for their perceived lack of expressivity [ 26 , 115 ] , the close connection between their inputs and outputs forms a closeness of mapping that can make them simple to understand and easy to verbally describe ( aspects which formal ap - proaches may fall short on ) . This closeness can make the process of switching to a conceptually related ( but visually distinct ) chart form more viscous , as the two syntaxes may be highly different . They are more likely to allow unusual graphics as they can be created without respect to a formal model , such as Bertin ’s multiple forms of cartograms or ZingChart ’s funnel charts . These interfaces can be tuned to speciﬁ - cally support the domain , as in Highcharts ’s treemaps ( Fig . 6 ) . However , their design is often ad hoc and may be inconsistent with other parts of the system , rendering them harder to learn or understand . This ap - proach allows for simple local styles to be applied without needing to map those properties through top - level language concerns , as well as hierarchical styling which can be difﬁcult to apply in systems whose data model requires tabular normalization for rendering ( as in Vega ) . Colloquial models can support particular features without forming themselves around that concept . For instance , only a handful of DSLs have top - level annotation support ( e . g . Plotly JSON , Highcharts , and ApexCharts ) , however most of these are industry - driven efforts that do not use a formal model— P4 and Cicero excepted , as they explicitly model annotation . Similarly , only a small set of mostly industry - led DSLs provide their own accessibility features ( Highcharts , Vega - Lite , ECharts , and FusionCharts ) . This dearth may be due to the fact that such practicalities are often viewed as mere implementation details rather than being central to usability [ 82 , 107 ] , which may be compounded by a lack of research incentives to provide usable artifacts . Beyond explicitly modeling features , formal models can pro - vide these model - breaking behaviors through escape hatches to non - declarative programming or other points of extension ( Sec . 4 . 5 ) . How - ever , doing so requires that such hatches be pre - placed in a manner relevant to the new feature—which is difﬁcult to predict . Exploration of DSL malleability in a manner that allows for undesigned features without becoming unapproachably complex for end - users ( a concern for the deeply malleable Varv [ 5 ] ) is a valuable opportunity . Formal models may have colloquial components . These are often found at interfaces with other systems . Styling is one such common leaky abstraction . The manner in which a chart is rendered may leak into the formalism without being modeled . For example , Vega - Lite ’s concept of styling is guided by its downstream SVG and canvas render - ers . Colloquial DSL components are not inherently detrimental . If the leaked feature is large or complex , it may be appropriate to embed that language rather than model it , although this can lead to inconsistent interfaces that are hard to adapt to new forms . Consideration of these properties in DSL design may be valuable , such as by designing with leaking in mind or by separating external concerns into separate DSLs . Despite their academic stigma , we suggest that colloquial models may be valuable to consider . Among series - based DSLs we observed 306 distinctly named series types , although there was signiﬁcant overlap in this list due to synonyms or simple modiﬁers ( e . g . “3D” or “drag - able” ) . The design space of name and modiﬁer - based speciﬁcation appears to be a rich one , although an analysis of which is beyond the scope of this work . Developing a better understanding of these forms and the way they are used by system designers and domain experts is intriguing work—especially in light of the decades - long popularity of this speciﬁcation style ( cf . SpotFire , ChartML , XML Charts ) . As researchers and tool - smiths [ 9 ] , we suggest that we should meet people where they are , which may mean working to enrich colloquial models . 5 I vy V e g a - L i t e V e g a V R I A { data : { … } , mark : " bar " , y : 0 . 2 , z : - 0 . 5 , yrotation : 45 , encoding : { x : { field : " keyword " , type : “ordinal " } , y : { field : " count " , type : " quantitative " , axis : { face : " back " } } , z : { timeUnit : " year " , field : " Year " , type : " temporal " } } } { data : [ { name : " table " , values : [ … ] } ] , scales : [ { name : " xscale " , type : " band " , domain : { data : " table " , field : " keyword " } , range : " width " , padding : 0 . 05 , round : true } , { name : " yscale " , nice : true , range : " height " , domain : { data : " table " , field : " amount " } } ] , axes : [ { orient : " bottom " , scale : " x " } , { orient : " left " , scale : " y " } ] , marks : [ { type : " rect " , from : { data : " table " } , encode : { enter : { x : { scale : " x " , field : " keyword " } , width : { scale : " x " , band : 1 } , y : { scale : " y " , field : " count " } , y2 : { scale : " y " , value : 0 } , fill : { value : " steelblue " } } } } ] } Extends Compiles to Wraps { data : { name : " myData " } , transform : [ { filter : " datum . year = = [ filter ] " } ] , mark : { type : " bar " , color : " [ color ] " } , encoding : { x : { aggregate : " sum " , field : " [ xDim ] " } y : { field : " [ yDim ] " , type : " ordinal " , sort : { if : " sort . includes ( ' true ' ) " , true : " - x " } } } } { data : { … } , transform : [ { filter : " datum . year = = 2009 " } ] , mark : { type : " bar " , color : " purple " } , encoding : { y : { field : " keyword " , type : " ordinal " } , x : { aggregate : " sum " , field : " count " } } Adds variables related to GUI via compilation Extends the syntax to address 3D concerns Compiles the syntax into a low - level rendering syntax Vega Expression language embedded into the syntax Vega - Lite syntax is literally presented ( and augmented ) Extensions can allow for domain speciﬁc additions , such as XR additions Ivy allows embedding JS snippets as conditionals , which typically lose syntax highlighting in the process Fig . 7 . Annotated examples of the relationships between several DSLs . 4 . 3 Relationships : How does it relate to other DSLs ? Languages rarely exist in a language vacuum . For instance , many languages support regular expressions in a syntax unrelated to their own . We found that our DSLs are related to each other by Compiling , Wrapping / Embedding , or Extending / Contracting . The way a language relates to others determines numerous details about its implementation ( particularly its execution model ) , although each relation has tradeoffs— the main tension residing between language customization and reuse . Language composition can allow DSLs to be developed without requiring re - implementation or invention of abstractions . Yet , this comes at a cost as the new system is limited by the design choices of the old . For instance , compiling into Vega - Lite ensures that Cicero does not require the design of a visual encoding system , however , doing so means that it is restrained to the mark types available in Vega - Lite ( and by a similar composition , Vega ) ; impeding forms such as cartograms or treemaps . While such tradeoffs can be navigated , compositions that surface nested DSLs to the end user , as in Scholz 3D Vis Language use of Vega speciﬁcations , may diminish the value of a language style API , As they may necessitate frequent reference to documentation of the nested - DSLs rather than providing a single coherent expression language—yielding language cacophony . Compile . Among external DSLs , there are two evaluation mechanisms : compilation and interpretation [ 24 ] . We refer to compilation as a process that generates code , while interpretation evaluates it directly . Internal languages are embedded into their host which carries with them all of the beneﬁts and drawbacks associated with the more generic DSL design decision of internal vs external . Compiled languages allow the language to gain all the strengths— and weaknesses—of its compile - target ( often an interpreted or internal DSL ) , such as with Cicero . Compilation does not require a direct translation but can be used to embed computations into the resulting system . SetCoLa uses this strategy to create circular layouts which are not present in its compile - target WebCoLa [ 21 ] . In addition to ofﬂoading rendering , this gives access to potentially hard - to - achieve functionality , such as accessibility features . Compilations may be chained together in a compile tower in a man - ner supported by targeted languages that do one thing well ( akin to the Unix credo ) . For instance , our Gantt chart example in Fig . 4 might use - fully target Vega - Lite to gain features such as tooltips without requiring implementation of nuanced details . As the ecosystem of JSON - style DSLs continues to grow it may be advantageous to select designs that re - use as much work of the previous DSLs as possible . These beneﬁts do not come for free . While Vega - Lite provides ARIA - accessibility features , it currently cannot provide some accessibility - enhancing encodings ( e . g . texture ) because its compile target , Vega , does not support them . More generally , errors may be harder for the end - user to understand if they are generated by the target’s interpreter , whose concerns and conceptual model may be different from the source language . Ivy , which is a wrapping language that uses compilation , exempliﬁes this duality . It is language - agnostic and can be used over any JSON language , however , doing so precludes the surrounding application from providing contextual hints because it is unaware of the languages over which it is executed . Despite this , we argue that while compile towers are not always applicable , they should be employed more often . They can simplify implementation , improve usability , and D e p e n d e n c i e s g o u p w a r d s D e p e n d e n c i e s g o u p w a r d s Cicero CompassQL Multiclass Density MapsScholz 3D Vis Language Ivy Gemini 2 Genome Spy Gosling SVL VRIA P6 P4 Vega Atom Gemini 1 PapARVis Vega - Lite P5 VizGrammar G e m i n i 2 W r a p s V e g a P 5 C o m p il e s t o P 4 P 6 E x t e n d s P 5 Compiles to Extends Wraps Explicit Language Relations Some languages were inspired by other DSLs ( as in ComicScript with Vega - Lite and DataTheater ) without a speciﬁc relationship and so are not shown here . Others had no connection . Fig . 8 . DSLs can hold a variety of relationships with one another that allow them to reuse implementations , syntax , or concepts . reduce reinvention . They are well suited to research systems ( whose contribution is not based on implementation ) as they can rely on another system for repeatability and defense against bit - rot . In contrast , interpretation allows for rich customization that can be helpful in specialized contexts . Kyrix - S supports large data sets for zooming visualizations . Data Theater uses an unusual data model ( the output of an end - user speciﬁed Python script ) to create explorable ex - planations . This approach can enable construction of contextual error messages ( and other usability features ) that are relevant to the local do - main as they are not predicated on layers of indirection . However , this approach pushes rendering , data manipulation , and usability features onto the language implementer . Medium - focused DSLs tend to use this approach , possibly because their value is related to their customization to that medium ( the main exceptions to this are XR - focused DSLs ) . Wrap / Embed . Wrapping or embedding languages provides function - ality extensions by literally containing other languages . For instance , Gemini 2 , allows users to describe keyframes of an animation by explic - itly including Vega and Vega - Lite speciﬁcations . Scholz 3D Vis Language allows the inclusion of entire Vega and Vega - Lite charts in a 3D context . There is overlap with compilation ( as it can be used as a wrapping mechanism , as with Ivy ) , however we delineate this as a separate pat - tern to highlight the particular form of re - use . This approach allows for language - level separation of concerns as well as the use of the imported DSL’s externalities ( e . g . documentation or community support ) . This approach’s main risk ( beyond language cacophony ) is that the embed - ded language might not match the domain and lead to inconsistencies . A less extreme example of this approach is to embed language snippets—such as in the manner that SQL snippets are represented as strings in GPLs . These snippets address common tasks , such as control - ﬂow or formatting ( often via the d3 - format language ) as well as model - speciﬁc issues . Vega has a purpose - built JS subset for interacting with event streams . FusionCharts permits HTML snippets in tooltips . This common DSL pattern [ 24 ] allows for rich expression of intent , but may come at the cost of tooling , yielding some usability features ( e . g . syntax highlighting ) unavailable . There may be hidden dependencies within the snippet , as in the often numerous signals in Vega expressions [ 39 ] . Extend / Contract . An associated relationship is extension , in which a DSL is contracted or extended to form a new DSL . This usually comes in conjunction with syntactic extensions or modiﬁcations to the execution strategy . Genome Spy and VRIA contract the syntax of Vega - Lite behind custom renderers , and extend it with some genome and XR - speciﬁc affordances , respectively . PapARVis wraps and extends Vega with augmented reality enhancements . This approach can be useful as it allows for porting of ideas to new domains ( e . g . Genome Spy ’s reuse of Vega - Lite syntax in genomics ) . However , it does so at the expense of creating a new backend for that system . Given the variety of functionality developed across these DSLs , enabling their composition to allow greater reuse and increase their long - term impact . Language elements are sometimes extended or reused in an ad hoc manner , a pattern which is more closely aligned with inﬂu - ence than extension . Some languages ( such as Encodable , Flex - ER , or DXR ) explicitly mold themselves on the thin mapping style of Vega - Lite or Vega without actually reusing the speciﬁc syntax or rendering systems . Other DSLs include only minor syntactic ele - ments , such as P4 and Ivy ’s use of MongoDB - style operators ( e . g . { ﬁeld : { $ not : { OPERATOR - EXPRESSION } } } ) . At other times this inﬂuence 6 © 2022 IEEE . This is the author’s version of the article that has been published in IEEE Transactions on Visualization and Computer Graphics . The ﬁnal version of this record is available at : xx . xxxx / TVCG . 201x . xxxxxxx / is conceptual . GoTree includes a spacing system related to the CSS box model , while ZingChart and Cicero include responsive - design features inspired by CSS media queries . Familiar syntax and concepts may aid learnability—possibly reducing the negative effects of language cacophony —however not every domain will ﬁt every imported idea . For instance , CSS - style declarative rules are unlikely to handle the iterative stages of a data transformation pipeline well . 4 . 4 Language Affordances : Who is the end - user ? Each language has at least a general idea of its users , which motivates what features to include . We saw three user types based on the way they are expected to use the DSL , whose interests are naturally in tension . Some users simply use the DSL ( end - users ) , others can mod - ify the system which houses the DSL ( system - builders ) , while others automatically manipulate and analyze the DSL ( automated agents ) . Syntax . A common ﬁrst choice is whether to create an internal or exter - nal DSL . This is covered at length in other venues [ 24 , 76 ] but in essence , it can be seen as a question of language invention or embedding . The languages in our survey do not demonstrate any substantial divergences from the common beneﬁts and limitations of each of these patterns . External DSLs offer richer expressivity but can be harder to construct and learn . Internal DSLs are easier to use within a host language but can force a notation that is poorly matched with the domain . Internal languages seem to be most useful to interface - builders [ 117 ] as opposed to end - users . For instance , they do not by default facilitate automated analysis , and as such analysis can require dedicated high - complexity tools ( such as AST - analyzers ) . These components are often beyond the design goals of tools meant only to support web - based presentations ( e . g . Chart . js ) . Notebook - based analysis is a notable exception as it blurs end - user and system - builder . Internal bindings to external DSLs ( e . g . Altair [ 109 ] ) seem well matched to such hybrid users . However , such an analysis is beyond the scope of our study . Among external languages , JSON is sometimes chosen for being end - user friendly . Scholz [ 98 ] notes that JSON was selected because it is human - readable and easy to transfer on the web . DeLine valued “YAML’s declarative , hierarchical syntax” [ 17 ] . In contrast , a common criticism of XML as a carrier language is that it is verbose , which is seen as poorly matched with human usage [ 24 , 115 ] . JSON’s syntax , which is terse , appears to overcome this hurdle and may account for this style of DSL’s growing popularity ( Fig . 2 ) . Several end - user - focused systems expose their syntax to the end - user in applications . StructGraphics uses a custom GUI , whereas others ( e . g . Ivy and Glinda ) use plain text extended by modern editor affordances ( e . g . autocomplete ) . Other DSLs have editors that support their use ( without being required ) , such as Gemini 1 - 2 or Vega . Constructing an environment around a DSL allows debugging tools and other end - user supportive features , however , this can ( and has [ 124 ] ) led to a constellation of small applications that repeatedly reimplement similar functionality . We suggest that it may be beneﬁcial to consider how these efforts may be consolidated for this language style more generically . Shih et al . ’s [ 100 ] rationale for selecting JSON for their scientiﬁc visualization grammar was more focused on machine usability , noting that they selected “JSON because it is a widely used standard , is easy to parse , and it has sufﬁcient expressiveness for hierarchical structures” , an attitude shared in the design of GoTree [ 60 ] . Wu et al . [ 123 ] note that this interface style allows for manipulation by humans and autonomous users . While true for any executable language , manipulations are easier in serialization formats due to their restricted form . The limited grammar allows for exhaustive design space exploration , enabling recommendation ( as in CompassQL and Cicero [ 47 ] ) and enumeration of novel chart forms ( as in Atom [ 82 ] and GoTree [ 60 ] ) . An often discussed beneﬁt of external DSLs [ 76 ] is that they expose a notation local to a domain—as in Diderot’s [ 14 ] explicit use of tensor operators ( e . g . ∇ and (cid:126) ) . While JSON - like languages can abstract over various domains , few domains use it as their primary notation ( API design and data deﬁnition are clear exceptions ) . The selection of these carrier languages as syntax is then a compromise . In exchange for beneﬁts like portability and simple machine operability , domain experts encounter a less familiar notation . C o m i c S c r i p t [ … , { trigger : " click " , condition : [ " total " , " > 0 " ] , operation : " loadLayout " , element : " day5 " , layout : [ [ " congrats " ] ] , after : " day4” , group : " g1 " } , … ] I vy { …sort : { $ if : " sort . includes ( ' true ' ) " , true : " - x " } … } P 4 { … { $ interact : { event : " brush " , condition : { x : true } , from : [ " c3 " ] , response : { c1 : { unselected : { color : " gray " } } , c2 : { unselected : { color : " gray” } } } } } … } S e t C o l a [ … , { name : " additional spacing " , forEach : [ { constraint : " padding " , amount : 18 } ] , sets : { partition : " type " , exclude : [ " unknown " , " dwnstream genes " ] } } , … ] Fig . 9 . Many languages feature logic or control ﬂow operators . Abstraction Mechanisms . Creating abstractions is an important part of any programming language . In GPLs features like variables , functions , if - else structures , loops , and a host of others serve this purpose . Some languages in our survey utilized these elements ( Fig . 8 ) allowing ab - straction on syntactic , data , output , or contextual levels . Those that did not , likely did so to limit scope , because their domain did not require it , or relied on their host for such features ( a beneﬁt of internal DSLs ) . The tendency to forgo abstraction in DSLs is well known [ 24 ] , but we highlight it to explore the particularities exempliﬁed in this context . Control ﬂow operators ( as in Fig . 9 ) were common . These condi - tionals can address a range of program aspects including the data ( as in Vega - Lite ’s conditional marks ) , the graphic ( as in the query selectors found in Canis ) , interactions ( as in ComicScript ) , or container state ( such as in languages rooted in GUIs like Ivy ) . Some focused on modifying graphics based on interactions ( as in P4 ) while others focused on syn - tactic transformations ( as in Ivy ) . Some languages , such as Vega , use another language to evaluate their condition ( via embedded snippets ) , while others , like ComicScript , construct the logic through explicit op - erators . While it is not necessary to be able to query or conditionalize every element , each of them can be beneﬁcial depending on the domain although not every situation necessitates such facilities . Cicero uses a powerful query language that gives access to data , graphic , and spec - iﬁcation , which is necessary for its responsive and annotation tasks , although it appropriately has no concept of its surrounding context ( be - sides aspect ratio ) . Embedding snippets offers greater expressivity [ 24 ] ( potentially at the price of portability and diminished usability features ) , while explicit operators allow the user and their tooling to keep a single consistent mental model ( potentially introducing unfamiliar syntax ) . A variety of other abstraction mechanisms were used . Some systems included notions of variables , although their purpose varied . Flex - ER and Vega use FRP - style signals as variables . Canis uses variables as a form of textual - macro replacement . Ivy and Vega - Lite use variables as a way to reference GUI controls exposed to the end - user ( although Vega - Lite ’s are a mask for Vega ’s signals ) . Variables can help reduce the cognitive load on the user by reducing diffuseness , but it can also increase it if the references become difﬁcult to follow . SetCoLa was the only language to include loops . While an appropriate syntactic choice for their domain ( simplifying constraint generation ) it is common for DSLs to not provide loops as this can cause DSLs to accidentally “slide into generality” [ 24 ] . None of the external DSLs had SQL - style end - user deﬁnable functions . Varv [ 5 ] takes extensibility to an extreme via a fully end - user editable application creation external DSL ( that includes simple macros ) ; demonstrating that this level of malleability is achievable in external DSLs . The selected abstraction gradient should cater to a designed audi - ence . Loops and variables can help readability , which supports humans but does not generally affect automations . Functions and control ﬂow operators can aid in reuse , but if programs are generated on the ﬂy in a GUI and not meant for reuse , their utility will be limited . If the intended user’s interests are not aligned with multiple such user types then a different interface may be preferential to a JSON - style DSL . For instance , a DSL solely focused on humans using notebooks will likely be better served by not imposing the grammatical limitations of a serialization language , while an automatically generated language for facilitating chart recommendations need not be human readable . 7 4 . 5 Practicalities : Where is work done ? There are a number of places within a DSL where a given feature can be implemented . As in Fig . 10 , these include explicit and implicit modeling as well as internal and external placement . This modeling describes where the user is expected to do work to use those features . Each strategy has advantages and disadvantages . Internal features give deep control over implementation . However , that entity must be clearly represented or risk visibility errors . Explicit modeling can allow the user to address a task directly , but it can require the development of new ( potentially inconsistent ) syntax . External features can push burdens to other systems , reducing portability and potentially inducing hidden dependencies . Implicit modeling can be deeply expressive , but carrying out such intentions can yield hard mental operations . Integration and State . Most DSLs manage state and interactivity through a runtime inside the system . This allows them exact con - trol over the way a feature is delivered , and is thus favored by internal and interpreted DSLs . Similarly , internal DSLs allow rich integration with web pages through affordances like callbacks—typically in ex - change for a lack of end - user control . Other systems manage state by integration with an external application . StructGraphics , for instance , provides a visualization builder interface that maps spreadsheet data to graphics . Embedding state into a housing application allows graphics to be synchronized with and used to control the UI , enabling deeply integrated experiences , although this may impede portability . Some sys - tems ( typically compiled DSLs ) pass control to an external system , as in Vega - Lite or SetCoLa . This simpliﬁes system construction , however , it may impede interactions outside the target’s model . These approaches only have value when appropriately coordinated with their purpose . For instance , Atom uses a custom interpreter in - tegrated into an application . While this approach allows Atom to be closely integrated with its editing environment , it makes it difﬁcult to portably reuse speciﬁcations in other contexts and precludes them from being integrated into other applications . Given its position as an academic artifact whose value is not related to its renderer , we suggest that DSLs like Atom may be well matched with a compile tower - style strategy to alleviate implementation burden and facilitate portability . Some DSLs provide mechanisms for interactions and integration with their environment , although this can require coupling with those systems ( as does binding to any external system ) . For instance , Encod - able explores creating Vega - Lite - style facades over arbitrary JS visual - izations . However , this causes those little languages to be inextricably linked to JS . We suggest that portability and contextual integration are opposing goals , as surfacing integrations as ﬁrst - class aspects of the language creates a context dependence . Both are reasonable design choices , but favoring integration may reduce some of JSON - style DSLs’ utility ( e . g . portability ) . Yet , language - level integration in these DSLs is unexplored , so it may be useful to consider visualizations as part of a system rather than singular units . Alternate language APIs . Some DSLs are used in host languages through internal bindings . This type of tool can enable work - arounds for DSL limitations by externalizing these needs to a host language , as in the Gos Python - wrapper for Gosling [ 68 ] or Altair [ 109 ] for Vega - Lite . For instance , some facet and layer combinations create data ambiguities that can prevent Vega - Lite from rendering . This can be resolved by manually pivoting data and combining Altair charts in Python . Beyond providing workarounds for language issues , this can sim - plify program speciﬁcation for users with limited familiarity with the DSL . For instance , it may be easier for an Elm programmer to use elm - vega [ 121 ] than to a write a corresponding Vega speciﬁcation . This is analogous to the value of object relational mappers for manipulation of SQL databases . Users can write and reason about their database in their chosen language rather than being required to utilize SQL’s sometimes idiosyncratic or unfamiliar form . We emphasize that con - sideration of the environments in which a language will be used is a valuable component of language design as it may surface components and strategies that guide the design , such as expecting faceting to be done outside of the DSL . Internal to system External to system Explicit modeling Implicit modeling C o n t a i n e r L a n g u a g e Ex : control state from within a runtime to give access to language level variables and data Ex : use features external to the DSL to address a task , such as using HTML for chart composition Ex : push a feature into the conceptual model , such as using XR’s spatial properties for composition Ex : surface a feature in the DSL , such as a domain - speciﬁc data transformation Fig . 10 . Features can be built in a variety of places across the DSL . Extensibility . Wilkinson notes that any closed system will have missing pieces [ 115 ] . For instance , his VizML has limited support for nested or data - driven layouts ( e . g . sets or cartograms ) or mixed data and aesthetic - driven tasks ( such as annotation ) . Some DSLs approach extensibility by designing places where external elements can be introduced into the system through an API . This can allow for the introduction of new transforms ( as in Vega - Lite ) , user - deﬁned marks ( as in DXR ) , renderers ( as in Vega ) , as well as chart types or events ( as in Chart . js ) . Extensions typically occur in explicitly modeled features within the system , pre - cluding end - user modiﬁcation of system concepts ( e . g . new coordinate systems ) . Open source software can allow for a slower but less limited form of extension . Yet this is not always the case . Some systems are no longer maintained , might be resistant to external changes , or might require too high a technical barrier to contribution from domain experts . A form of extension available in some formal model - based DSLs is the creation of ad hoc mark types within the language itself . Wong - suphasawat [ 118 ] explores how end - users of some systems can con - struct composite marks , such as candlesticks , although there are bound - aries to this imposed by the form of the language model . For instance , Vega - Lite allows some custom glyph creation ( via image marks ) , which enables unit isotypes but not aggregates—as such encodings fall outside its model . Some extensions are not possible without external modeling , as in our Gantt example ( Fig . 4 ) . This extension style is powerful but is limited by its model and so can be well paired with external extension . Combination and Data Strategy . A DSL’s approach to image compo - sition ( e . g . layering or juxtaposition ) and handling data exemplify the stratiﬁcation of where work is done . We observed a spectrum of strategies for image composition ranging from speciﬁcation above the language ( in the container ) , explicitly modeling within the language , to below it implicitly in the conceptual model . Many DSLs do not provide a mechanism for combination , either because it is not relevant to their domain ( as in graph DSLs ) or by making use of awareness of their medium as the implied context through which conjunction happens . For instance , ECharts relies on the browser for spatial arrangement and the user for data partitioning . This can be simple to construct but pushes implementation onto the user . Some formal models feature a composition algebra , as in Vega - Lite ’s layer , facet , and concat operations . These operators typically focus on data partitions ( to facilitate small multiples ) , however , Wu also describes an under - explored notion of parameter - based faceting [ 124 ] . Some languages include a combination mechanism unique to their domain , such as ComicScript ’s panels or Gosling ’s notion of tracks . These approaches are useful , but typically require explicit modeling in the language , which can take up limited conceptual real estate . Some DSLs push feature description into their conceptual model , such as by using spatial position for combination ( as in map and XR DSLs ) . While powerful , these should be used cautiously as implicit operations can yield hard mental operations . The selection of how and where data is handled is critical , as it determines how a DSL can interact with its environment and compose with other DSLs . Most DSLs hold all their data inside the system , a simplistic model which is adequate for many use cases , however some externalize that task . For instance , Kyrix - S uses a custom back - end that sits on top of a database to allow exploration of large datasets via zooming . While sometimes useful , a complex data strategy is unlikely to work with a system that does not share that strategy : Kyrix - S is unlikely to be interoperable with Multiclass - Density - Maps despite sharing a domain interest in aggregating heatmaps . Similarly , DSLs exhibit no manipulation strategy ( ignoring it or externalizing to the host ) , rudimentary language manipulations such as ﬁlters , or a richer domain - relevant expression or transformation system explicitly modeled within 8 © 2022 IEEE . This is the author’s version of the article that has been published in IEEE Transactions on Visualization and Computer Graphics . The ﬁnal version of this record is available at : xx . xxxx / TVCG . 201x . xxxxxxx / the language ( as in Genome Spy ’s genome - focused transformations ) . These carry similar tradeoffs as composition in placement stratiﬁcation . Unlike composition , there are well - implemented libraries that support this task . Yet , many DSLs implement their data processing features themselves [ 124 ] . These recreations may be motivated by domain . For example , most data libraries do not support the genomic coordinates required by Gosling —although this is more often done needlessly when more robust implementations are available . Consideration of how and where to place features such as these is critical for DSL usability . 5 D ISCUSSION In this study , we surveyed JSON - style DSLs for visualization from across academia , industry , and open source efforts spanning a period of more than 20 years . In doing so we examined both the state of the art for this domain ( such as the role of DSL compilation vs interpretation or abstraction in DSLs ) , and introduced new concerns ( including the tension between colloquial and formal visualization models ) , patterns ( like the role of composition ) , and practices ( e . g . supporting both computational and human users ) . We observed a wide variety of tasks and domains that this style of language seeks to serve , indicating its pliability to a large collection of concerns and highlighted many avenues for future work ( such as designing languages that can be bidirectionally updated ) . From our results , we are optimistic about this style’s future . However this is not without caveats nor enticing avenues of exploration . Study Limitations . We sought to understand the design and implemen - tation of JSON - style DSLs through analysis of artifacts , documentation , and scholarly works . While this revealed a number of intriguing pat - terns , it did not capture the entirety of visualization DSLs or APIs . For instance , we excluded a variety of visualization languages ( e . g . ggplot ) and JSON - based languages outside of visualization ( e . g . Varv ) . Exploration of design patterns and tradeoffs found in these and other languages , libraries , and APIs is warranted in future studies . Computer languages , like spoken languages , are often living entities whose design changes over time and can be driven by individuals’ undocumented ideas or inﬂuences . In future work , this analysis might be enriched through interviews with DSL authors to better understand language design choices and life cycles . Our survey was biased in several ways . Our survey was biased to - wards more recent open source and academic works , and away from older or privately - produced DSLs , as it is easier to ﬁnd public contem - porary systems . As such , there are likely additional DSLs that were not observed during our search . While additional data would be useful , we believe our sample sufﬁciently captures the tendencies of this language form , although sample size and biases are known issues [ 127 ] . Some codings were based on limited documentation as we were unable to locate some DSL artifacts ( e . g . due to URL - rot or closed - source ) . We intend to continue expanding the corpus of examples in our supplement to facilitate further empirical investigation of this language genre . This may reveal patterns hidden from our qualitative lens . Finally , our anal - ysis is limited by our own biases , which we sought to reduce through iterative theming and reﬂection . Language Design and Tooling . The design of an effective DSL for achieving any of the nuanced tasks that visualization DSLs seek to solve is a thorny problem . Novel languages and notations have the potential to serve as foundations on which to “think the unthinkable” [ 111 ] , but also can add needless complexity and cacophony . How to build powerful tools that do not result in confusion which can be applied to an ecosystem that has a competing set of users ? Per the tensions and tradeoffs we highlight throughout this study , there is no one answer . We suggest that developing mechanisms for design evaluation and improving the DSL tool ecosystem may fruitfully guide future DSLs . DSL evaluation is a long - running topic [ 6 , 87 ] . However , these methods are not extensively used for visualization DSLs [ 89 ] . Only two works [ 18 , 97 ] offered a formal CDN analysis , while others provided ad hoc reasoning [ 115 ] . Poltronieri et al . [ 87 ] suggest that DSL evaluation may be more effective if done in a contextual and non - generic manner ( as in Jakubovic et al . ’s [ 43 ] work on programming systems or Elavsky et al . ’s work on visualization accessibility [ 22 ] ) . Such a call might be answered with evaluatory heuristics , like “What tasks does this DSL address ? ” , “What form of model is it using ? ” , “How are non - data elements described ? ” , “Who is the intended user ? ” , or “What is meant by data ? ” A notable experiment in this regard is Pu et al . ’s [ 88 ] use of Algebraic Visualization [ 51 , 72 ] as a sibling to CDN , suggesting the applicability of visualization theory to DSL evaluation . JSON DSLs have been described as being intended for use by end - users [ 73 ] . However , there has been little formal usability analysis . Hoffswell et al . [ 39 ] studied debugging in Vega . Naimipour et al . [ 78 ] explore social science teachers’ perceived usability of Vega - Lite . These works demonstrate this approach’s utility . However , future work should investigate which language form is best matched with end - users . We believe that some of the usability issues found in JSON - style visualization DSLs [ 65 ] can be addressed through careful enhancements to end - user tooling . Merino et al . explore this in their system for creating notebooks tuned to individual DSLs [ 75 ] . Hoffswell et al . [ 39 ] augment textual representations of Vega programs with in - situ state visualizations . As JSON - style DSLs continue to be developed , it may be useful to explore language workbenches [ 24 ] , which are a form of tool for designing , composing , and using ( often domain - speciﬁc ) languages . Some work has been done in this direction by JSON Schema structure editors [ 5 ] . However , they focus on data validation and not language design . Some DSLs provide formal syntax deﬁnitions . However , none formalize their semantics , although this may be because a visualization semantics language does not exist . We suggest that a metalanguage for such descriptions would be valuable future work . JSON - style DSLs can be error prone through silent errors or over - rides , such as those caused by invalid or misspelled properties . This can be confusing to the end - user who then receives little feedback on why execution is not carried out as they expect . Tools like JSON Schema can be useful to reduce this type of error , but they are only able to capture syntactic errors . Analysis tools like linters [ 12 , 41 , 74 ] can help capture semantic errors , although the conﬁguration of which may present non - trivial complexities . Future designs should explore encoding invariants as syntax so that invalid expression is impossible . The Next 10k Visualization Grammars . If our survey prompts any prediction , it is that new visualization languages will continue to be developed —some of which may be in the JSON - style . There are many forms , shapes , and purposes these languages may take . Hogr¨afer et al . [ 40 ] argue for a map grammar . Lau et al . [ 56 ] call for a compu - tational notebook grammar that would enable task - speciﬁc notebook forms . Hullman and Gelman call for a grammar that enables statistical model checks [ 42 ] . Following the trend of developing DSLs to support complex data tasks in genomics [ 58 , 68 ] or ML [ 63 ] , other languages could be developed for other data - intensive contexts , such as multi - scale analysis , temporal data , or textual data . Tuning computation - heavy algorithms or processes involving randomness ( as in force direction ) can be clumsy and error - prone , suggesting that an end - user - centered DSL enhancing those operations might be valuable . The volume of XR DSLs suggests that JSON - style DSLs may be useful for other uncommon mediums . For instance , a soniﬁcation grammar ( such as brieﬂy explored by Highcharts and DXR ) might make non - visual data experiences easier and more accessible to produce . Park et al . [ 82 ] argue that efforts should be made to “ﬁnd a deﬁnitive grammar that can unify many of these existing grammars” . However , Greenspun’s tenth rule [ 29 ] quips that any sufﬁciently complicated program contains an ad hoc , informally speciﬁed , bug - ridden , slow implementation of half of Lisp . Less satirically Fowler notes that one of the biggest dangers in DSL design is “Sliding into generality . ” [ 24 ] While tools like Vega - Lite are probably not in danger of becoming Lisp , we suggest that consideration of small modular language components may be helpful in the continuation and extension of this ecosystem . There are many tasks , and no one DSL will be able to capture all of them without compromising essential parts of its domain design . That is , there is no grammar to rule them all . A CKNOWLEDGMENTS We thank our reviewers , as well as Ravi Chugh , Arvind Satyanarayan , Brian Hempel , Will Brackenbury , and Michael A . McNutt . 9 R EFERENCES [ 1 ] ApexCharts . https : / / apexcharts . com / , 2022 . Viewed 1 / 4 / 22 . [ 2 ] XML / SWF Charts . http : / / maani . us / xml _ charts / , 2022 . Viewed 1 / 4 / 22 . [ 3 ] AntV . Antv - spec . https : / / github . com / antvis / antv - spec , 2022 . Viewed 1 / 12 / 22 . [ 4 ] A . Blackwell and T . Green . Notational Systems – the Cognitive Dimen - sions of Notations Framework . HCI Models , Theories , And Frameworks : Toward An Interdisciplinary Science . Morgan Kaufmann , 2003 . [ 5 ] M . Borowski , L . Murray , J . B . Bagge , Rolf Kristensen , A . Satyanarayan , and C . N . Klokmose . Varv : Reprogrammable Interactive Software As a Declarative Data Structure . In Conference on Human Factors in Comput - ing Systems , pp . 492 : 1 – 492 : 20 , 2022 . doi : 10 . 1145 / 3491102 . 3502064 [ 6 ] H . S . Borum , H . Niss , and P . Sestoft . On Designing Applied DSLs for Non - programming Experts in Evolving Domains . In Conference on Model Driven Engineering Languages And Systems , pp . 227 – 238 , 2021 . [ 7 ] M . Bostock , V . Ogievetsky , and J . Heer . D 3 Data - driven Docu - ments . IEEE Transactions on Visualization and Computer Graphics , 17 ( 12 ) : 2301 – 2309 , 2011 . [ 8 ] U . Brandes , M . Eiglsperger , J . Lerner , and C . Pich . Graph Markup Language ( GraphML ) . 2013 . [ 9 ] F . P . Brooks Jr . The Computer Scientist As Toolsmith II . Communications of the ACM , 39 ( 3 ) : 61 – 68 , 1996 . [ 10 ] P . W . Butcher , N . W . John , and P . D . Ritsos . Vria : a Web - based Frame - work for Creating Immersive Analytics Experiences . IEEE Transactions on Visualization and Computer Graphics , 27 ( 7 ) : 3213 – 3225 , 2020 . [ 11 ] chartjs . Chart . js . https : / / www . chartjs . org / , 2022 . Viewed 1 / 4 / 22 . [ 12 ] Q . Chen , F . Sun , X . Xu , Z . Chen , J . Wang , and N . Cao . VizLinter : a Linter And Fixer Framework for Data Visualization . IEEE Transactions on Visualization and Computer Graphics , 2021 . [ 13 ] Z . Chen , W . Tong , Q . Wang , B . Bach , and H . Qu . Augmenting Static Vi - sualizations with PapARVis Designer . In Conference on Human Factors in Computing Systems , pp . 1 – 12 , 2020 . [ 14 ] C . Chiw , G . Kindlmann , J . Reppy , L . Samuels , and N . Seltzer . Diderot : a Parallel DSL for Image Analysis And Visualization . In Programming Language Design and Implementation , pp . 111 – 120 , 2012 . [ 15 ] K . Compton , B . Kybartas , and M . Mateas . Tracery : An Author - Focused Generative Text Tool . In International Conference on Interactive Digital Storytelling , pp . 154 – 161 . Springer , 2015 . [ 16 ] M . Conlen and J . Heer . Idyll : a Markup Language for Authoring And Publishing Interactive Articles on the Web . In Symposium on User Interface Software and Technology , pp . 977 – 989 , 2018 . [ 17 ] R . A . DeLine . Glinda : Supporting Data Science with Live Program - ming , GUIs And a Domain - speciﬁc Language . In Conference on Human Factors in Computing Systems , pp . 1 – 11 , 2021 . [ 18 ] S . Devkota , M . Legendre , A . Kunen , P . Aschwanden , and K . E . Isaacs . CFGConf : Supporting High Level Requirements for Visualizing Control Flow Graphs . arxiv , 2021 . [ 19 ] Dhall . Design Choices . https : / / docs . dhall - lang . org / discussions / Design - choices . html , 2021 . Viewed 1 / 3 / 21 . [ 20 ] T . Duplantis , I . Karth , M . Kreminski , A . M . Smith , and M . Mateas . A Genre - Speciﬁc Game Description Language for Game Boy RPGs . In IEEE Conference on Games , 2021 . [ 21 ] T . Dwyer . WebCola . https : / / github . com / tgdwyer / WebCola . Viewed 3 / 5 / 2022 . [ 22 ] F . Elavsky , C . Bennett , and D . Moritz . How Accessible Is My Visu - alization ? Evaluating Visualization Accessibility with Chartability . In Eurographics Conference on Visualization , p . 14 , 2022 . To Appear . [ 23 ] S . Erdweg , P . G . Giarrusso , and T . Rendel . Language Composition Untan - gled . In Workshop on Language Descriptions , Tools , And Applications , pp . 1 – 8 , 2012 . [ 24 ] M . Fowler . Domain - speciﬁc Languages . Pearson Education , 2010 . [ 25 ] Frappe . Modern , Open Source SVG Charts . https : / / frappe . io / charts , 2022 . Viewed 1 / 4 / 22 . [ 26 ] M . Friendly . Colorless Green Graphs Sleep Furiously : a Conversation with Leland Wilkinson . Nightingale , March 2022 . [ 27 ] fusioncharts . Fusioncharts . https : / / www . fusioncharts . com / fusionexport , 2019 . Viewed 1 / 4 / 22 . [ 28 ] T . Ge , Y . Zhao , B . Lee , D . Ren , B . Chen , and Y . Wang . Canis : a High - Level Language for Data - Driven Chart Animations . In Computer Graphics Forum , vol . 39 , pp . 607 – 617 . Wiley Online Library , 2020 . [ 29 ] P . Greenspun . 10th Rule of Programming . http : / / philip . greenspun . com / bboard / q - and - a - fetch - msg ? msg _ id = 000tgU , 2003 . Viewed 1 / 3 / 2022 . [ 30 ] S . G¨unther , T . Cleenewerck , and V . Jonckers . Software Variability : the Design Space of Conﬁguration Languages . In Workshop on Variability Modeling of Software - Intensive Systems , pp . 157 – 164 , 2012 . [ 31 ] M . Guzdial and T . Shreiner . Integrating Computing Through Task - speciﬁc Programming for Disciplinary Relevance : Considerations And Examples . In Computational Thinking in Education , pp . 172 – 190 . Rout - ledge , 2021 . [ 32 ] J . G¨ortler , F . Hohman , D . Moritz , K . Wongsuphasawat , D . Ren , R . Nair , M . Kirchner , and K . Patel . Neo : Generalizing Confusion Matrix Vi - sualization To Hierarchical And Multi - Output Labels . In Conference on Human Factors in Computing Systems . ACM , 2022 . doi : 10 . 1145 / 3491102 . 3501823 [ 33 ] P . Hanrahan . Vizql : a Language for Query , Analysis And Visualization . In ACM SIGMOD International Conference on Management of Data , pp . 721 – 721 , 2006 . [ 34 ] B . Hasimoto . Glisp . https : / / github . com / baku89 / glisp , 2021 . [ 35 ] K . Healy and J . Moody . Data Visualization in Sociology . Annual Review of Sociology , 40 : 105 – 128 , 2014 . [ 36 ] B . Hempel , J . Lubin , and R . Chugh . Sketch - n - Sketch : Output - Directed Programming for SVG . In Symposium on User Interface Software and Technology , pp . 281 – 292 , 2019 . doi : 10 . 1145 / 3332165 . 3347925 [ 37 ] HighCharts . HighCharts . https : / / www . highcharts . com / , 2022 . Viewed 1 / 4 / 22 . [ 38 ] J . Hoffswell , A . Borning , and J . Heer . SetCoLa : High - Level Constraints for Graph Layout . In Computer Graphics Forum , vol . 37 , pp . 537 – 548 . Wiley Online Library , 2018 . [ 39 ] J . Hoffswell , A . Satyanarayan , and J . Heer . Augmenting Code with in Situ Visualizations To Aid Program Understanding . In Conference on Human Factors in Computing Systems , pp . 1 – 12 , 2018 . [ 40 ] M . Hogr¨afer , M . Heitzler , and H . - J . Schulz . The State of the Art in Map - Like Visualization . In Computer Graphics Forum , vol . 39 , pp . 647 – 674 . Wiley Online Library , 2020 . [ 41 ] A . K . Hopkins , M . Correll , and A . Satyanarayan . VisuaLint : Sketchy in Situ Annotations of Chart Construction Errors . In Computer Graphics Forum , 2020 . doi : 10 . 1111 / cgf . 13975 [ 42 ] J . Hullman and A . Gelman . Designing for Interactive Exploratory Data Analysis Requires Theories of Graphical Inference . HDSR , 2021 . [ 43 ] J . Jakubovic , J . Edwards , and T . Petricek . Technical Dimensions of Programming Systems . 2022 . [ 44 ] J . Jo , F . Vernier , P . Dragicevic , and J . - D . Fekete . A Declarative Rendering Model for Multiclass Density Maps . IEEE Transactions on Visualization and Computer Graphics , 25 ( 1 ) : 470 – 480 , 2018 . [ 45 ] E . Jun , M . Daum , J . Roesch , S . Chasins , E . Berger , R . Just , and K . Rei - necke . Tea : a High - level Language And Runtime System for Automating Statistical Analysis . In Symposium on User Interface Software and Technology , pp . 591 – 603 , 2019 . [ 46 ] G . Karsai , H . Krahn , C . Pinkernell , B . Rumpe , M . Schindler , and S . V¨olkel . Design Guidelines for Domain Speciﬁc Languages . arxiv , 2014 . [ 47 ] H . Kim , R . Rossi , F . Du , E . Koh , S . Guo , J . Hullman , and J . Hoffswell . Cicero : a Declarative Grammar for Responsive Visualization . In Confer - ence on Human Factors in Computing Systems , pp . 600 : 1 – 600 : 15 , 2022 . doi : 10 . 1145 / 3491102 . 3517455 [ 48 ] Y . Kim and J . Heer . Gemini : a Grammar And Recommender System for Animated Transitions in Statistical Graphics . IEEE Transactions on Visualization and Computer Graphics , 27 ( 2 ) : 485 – 494 , 2020 . [ 49 ] Y . Kim and J . Heer . Gemini 2 : Generating Keyframe - Oriented Ani - mated Transitions Between Statistical Graphics . In IEEE Visualization Conference , pp . 201 – 205 . IEEE , 2021 . [ 50 ] Y . Kim , K . Wongsuphasawat , J . Hullman , and J . Heer . GraphScape : a Model for Automated Reasoning About Visualization Similarity And Sequencing . In Conference on Human Factors in Computing Systems , pp . 2628 – 2638 . ACM , 2017 . doi : 10 . 1145 / 3025453 . 3025866 [ 51 ] G . Kindlmann and C . Scheidegger . An Algebraic Process for Visualiza - tion Design . IEEE Transactions on Visualization and Computer Graphics , 20 ( 12 ) : 2181 – 2190 , 2014 . doi : 10 . 1109 / TVCG . 2014 . 2346325 [ 52 ] L . C . Klopfenstein , S . Delpriori , and A . Ricci . Adapting a Conversa - tional Text Generator for Online Chatbot Messaging . In International Conference on Internet Science , pp . 87 – 99 . Springer , 2018 . [ 53 ] A . Ko . Tweet , November 2021 . https : / / twitter . com / amyjko / status / 1458537839939895299 . 10 © 2022 IEEE . This is the author’s version of the article that has been published in IEEE Transactions on Visualization and Computer Graphics . The ﬁnal version of this record is available at : xx . xxxx / TVCG . 201x . xxxxxxx / [ 54 ] Y . S . Kristiansen and S . Bruckner . Visception : An Interactive Visual Framework for Nested Visualization Design . Computers & Graphics , 92 : 13 – 27 , 2020 . [ 55 ] N . Lambert . Bertin . https : / / github . com / neocarto / bertin , 2022 . Viewed 1 / 12 / 22 . [ 56 ] S . Lau , I . Drosos , J . M . Markel , and P . J . Guo . The Design Space of Computational Notebooks : An Analysis of 60 Systems in Academia And Industry . In Visual Languages And Human - Centric Computing , pp . 1 – 11 . IEEE , 2020 . [ 57 ] S . Lau and P . J . Guo . Data Theater : a Live Programming Environment for Prototyping Data - Driven Explorable Explanations . In Workshop on Live Programming , 2020 . [ 58 ] K . Lavikka . Grammar - Based Interactive Genome Visualization . Master’s thesis , Helsingin yliopisto , 2020 . [ 59 ] D . Li , H . Mei , Y . Shen , S . Su , W . Zhang , J . Wang , M . Zu , and W . Chen . ECharts : a Declarative Framework for Rapid Construction of Web - based Visualization . Visual Informatics , 2 ( 2 ) : 136 – 146 , 2018 . [ 60 ] G . Li , M . Tian , Q . Xu , M . J . McGufﬁn , and X . Yuan . Gotree : a Grammar of Tree Visualizations . In Conference on Human Factors in Computing Systems , pp . 1 – 13 , 2020 . [ 61 ] J . K . Li and K . - L . Ma . P4 : Portable Parallel Processing Pipelines for In - teractive Information Visualization . IEEE Transactions on Visualization and Computer Graphics , 26 ( 3 ) : 1548 – 1561 , 2018 . [ 62 ] J . K . Li and K . - L . Ma . P5 : Portable Progressive Parallel Processing Pipelines for Interactive Data Analysis And Visualization . IEEE Transac - tions on Visualization and Computer Graphics , 26 ( 1 ) : 1151 – 1160 , 2019 . [ 63 ] J . K . Li and K . - L . Ma . P6 : a Declarative Language for Integrating Ma - chine Learning in Visual Analytics . IEEE Transactions on Visualization and Computer Graphics , 27 ( 2 ) : 380 – 389 , 2020 . [ 64 ] W . Li , Y . Wang , H . Huang , W . Cui , H . Zhang , H . Qu , and D . Zhang . AniVis : Generating Animated Transitions Between Statistical Charts with a Tree Model . arxiv , 2021 . [ 65 ] Z . Liu , C . Chen , F . Morales , and Y . Zhao . Atlas : Grammar - based Procedural Generation of Data Visualizations . [ 66 ] M . J . Lobo , C . Hurter , and P . Irani . Flex - ER : a Platform To Evaluate Interaction Techniques for Immersive Visualizations . ACM on Human - Computer Interaction , 4 ( ISS ) : 1 – 20 , 2020 . [ 67 ] M . Loetzsch . The Dot Markup Language . http : / / www . martin - loetzsch . de / DOTML / , 2010 . Viewed 1 / 17 / 22 . [ 68 ] S . L’Yi , Q . Wang , F . Lekschas , and N . Gehlenborg . Gosling : a Grammar - based Toolkit for Scalable And Interactive Genomics Data Visualization . IEEE Transactions on Visualization and Computer Graphics , 2022 . [ 69 ] J . Mackinlay . Automating the Design of Graphical Presentations of Relational Information . Acm Transactions on Graphics , 5 ( 2 ) : 110 – 141 , 1986 . [ 70 ] N . Makrynioti and V . Vassalos . Declarative Data Analytics : a Survey . IEEE Transactions on Knowledge And Data Engineering , 2019 . [ 71 ] A . McNutt . On the Potential of Zines As a Medium for Visualization . In IEEE Visualization Conference , pp . 176 – 180 . IEEE , 2021 . [ 72 ] A . McNutt . What Are Table Cartograms Good for Anyway ? An Alge - braic Analysis . In Computer Graphics Forum , vol . 40 , pp . 61 – 73 . Wiley Online Library , 2021 . [ 73 ] A . McNutt and R . Chugh . Integrated Visualization Editing Via Param - eterized Declarative Templates . In Conference on Human Factors in Computing Systems , pp . 1 – 14 , 2021 . [ 74 ] A . McNutt , G . Kindlmann , and M . Correll . Surfacing Visualization Mirages . Conference on Human Factors in Computing Systems , 2020 . doi : 10 . 1145 / 3313831 . 3376420 [ 75 ] M . V . Merino , J . Vinju , and T . van der Storm . Bacat´a : Notebooks for DSLs , Almost for Free . In International Conference on Art , Science , And Engineering . ACM , 2020 . [ 76 ] M . Mernik , J . Heering , and A . M . Sloane . When And How To Develop Domain - speciﬁc Languages . ACM Computing Surveys , 37 ( 4 ) : 316 – 344 , 2005 . [ 77 ] Microsoft . Directed Graph Markup Language . https : / / docs . microsoft . com / en - us / visualstudio / modeling / directed - graph - markup - language - dgml - reference ? view = vs - 2022 , 2021 . Viewed 1 / 17 / 22 . [ 78 ] B . Naimipour , M . Guzdial , and T . Shreiner . Engaging Pre - service Teach - ers in Front - end Design : Developing Technology for a Social Studies Classroom . In Frontiers in Education Conference , pp . 1 – 9 . IEEE , 2020 . [ 79 ] A . Narechania , A . Srinivasan , and J . Stasko . NL4DV : a Toolkit for Generating Analytic Speciﬁcations for Data Visualization From Natural Language Queries . IEEE Transactions on Visualization and Computer Graphics , 27 ( 2 ) : 369 – 379 , 2020 . [ 80 ] R . Neogy , J . Zong , and A . Satyanarayan . Representing Real - Time Multi - User Collaboration in Visualizations . In IEEE Visualization Conference , pp . 146 – 150 . IEEE , 2020 . [ 81 ] D . Orchard . The Four Rs of Programming Language Design . In Proceed - ings of the 10th SIGPLAN Symposium on New Ideas , New Paradigms , And Reﬂections on Programming And Software , pp . 157 – 162 , 2011 . [ 82 ] D . Park , S . M . Drucker , R . Fernandez , and N . Elmqvist . Atom : a Grammar for Unit Visualizations . IEEE Transactions on Visualization and Computer Graphics , 24 ( 12 ) : 3032 – 3043 , 2017 . [ 83 ] W . C . Payne , Y . Bergner , M . E . West , C . Charp , R . B . B . Shapiro , D . A . Szaﬁr , E . V . Taylor , and K . DesPortes . DanceON : Culturally Responsive Creative Computing . In Conference on Human Factors in Computing Systems , pp . 1 – 16 , 2021 . [ 84 ] A . J . Perlis . Special Feature : Epigrams on Programming . ACM Sigplan Notices , 17 ( 9 ) : 7 – 13 , 1982 . [ 85 ] F . Pezoa , J . L . Reutter , F . Suarez , M . Ugarte , and D . Vrgoˇc . Foundations of JSON Schema . In Conference on World Wide Web , 2016 . doi : 10 . 1145 / 2872427 . 2883029 [ 86 ] Plotly . Plotly JSON Chart Schema . https : / / plotly . com / chart - studio - help / json - chart - schema / . Viewed 1 / 4 / 22 . [ 87 ] I . Poltronieri , A . C . Pedroso , A . F . Zorzo , M . Bernardino , and M . d . Borba Campos . Is Usability Evaluation of DSL Still a Trending Topic ? In International Conference on Human - Computer Interaction , pp . 299 – 317 . Springer , 2021 . [ 88 ] X . Pu and M . Kay . A Probabilistic Grammar of Graphics . In Conference on Human Factors in Computing Systems , 2020 . [ 89 ] X . Pu , M . Kay , S . M . Drucker , J . Heer , D . Moritz , and A . Satyanarayan . Special Interest Group on Visualization Grammars . In Conference on Human Factors in Computing Systems , pp . 1 – 3 , 2021 . [ 90 ] X . Qin , Y . Luo , N . Tang , and G . Li . Making Data Visualization More Efﬁcient And Effective : a Survey . VLDB , 29 ( 1 ) : 93 – 117 , 2020 . [ 91 ] P . Rautek , S . Bruckner , M . E . Gr¨oller , and M . Hadwiger . ViSlang : a System for Interpreted Domain - speciﬁc Languages for Scientiﬁc Visu - alization . IEEE Transactions on Visualization and Computer Graphics , 20 ( 12 ) : 2388 – 2396 , 2014 . [ 92 ] M . Saifee et al . VR - Viz : Visualization System for Data Visualization in VR . 2018 . Masters Thesis . [ 93 ] T . Saito and J . Ouyang . Client - side Data Visualization . In IEEE Inter - national Conference on Information Reuse & Integration , pp . 194 – 199 . IEEE , 2009 . [ 94 ] A . Satyanarayan , B . Lee , D . Ren , J . Heer , J . Stasko , J . Thompson , M . Brehmer , and Z . Liu . Critical Reﬂections on Visualization Authoring Systems . IEEE Transactions on Visualization and Computer Graphics , 26 ( 1 ) : 461 – 471 , 2020 . doi : 10 . 1109 / TVCG . 2019 . 2934281 [ 95 ] A . Satyanarayan , D . Moritz , K . Wongsuphasawat , and J . Heer . Vega - Lite : a Grammar of Interactive Graphics . IEEE Transactions on Visualization and Computer Graphics , 23 ( 1 ) : 341 – 350 , 2016 . [ 96 ] A . Satyanarayan , R . Russell , J . Hoffswell , and J . Heer . Reactive Vega : a Streaming Dataﬂow Architecture for Declarative Interactive Visual - ization . IEEE Transactions on Visualization and Computer Graphics , 22 ( 1 ) : 659 – 668 , 2016 . doi : 10 . 1109 / TVCG . 2015 . 2467091 [ 97 ] A . Satyanarayan , K . Wongsuphasawat , and J . Heer . Declarative Inter - action Design for Data Visualization . In Symposium on User Interface Software and Technology , pp . 669 – 678 , 2014 . [ 98 ] D . Scholz . A Modular Domain - Speciﬁc Language for Interactive 3D Visualization . Master’s thesis , TU Wien , May 2021 . [ 99 ] L . Shen , X . Chen , R . Liu , H . Wang , and G . Ji . Domain - Speciﬁc Language Techniques for Visual Computing : a Comprehensive Study . Archives of Computational Methods in Engineering , 28 ( 4 ) : 3113 – 3134 , 2021 . [ 100 ] M . Shih , C . Rozhon , and K . - L . Ma . A Declarative Grammar of Flexible Volume Visualization Pipelines . IEEE Transactions on Visualization and Computer Graphics , 25 ( 1 ) : 1050 – 1059 , 2018 . [ 101 ] R . Sicat , J . Li , J . Choi , M . Cordeil , W . - K . Jeong , B . Bach , and H . Pﬁs - ter . Dxr : a Toolkit for Building Immersive Data Visualizations . IEEE Transactions on Visualization and Computer Graphics , 25 ( 1 ) : 715 – 725 , 2018 . [ 102 ] A . Slingsby , J . Dykes , and J . Wood . Conﬁguring Hierarchical Layouts To Address Research Questions . IEEE Transactions on Visualization and Computer Graphics , 15 ( 6 ) : 977 – 984 , 2009 . [ 103 ] W . Tao , X . Hou , A . Sah , L . Battle , R . Chang , and M . Stonebraker . Kyrix - S : Authoring Scalable Scatterplot Visualizations of Big Data . IEEE 11 Transactions on Visualization and Computer Graphics , 2020 . [ 104 ] D . Tiwari . Array Visualization Grammar . https : / / github . com / clinckzone / array - visualization - grammar . Viewed 1 / 4 / 22 . [ 105 ] S . Tobin - Hochstadt , V . St - Amour , R . Culpepper , M . Flatt , and M . Felleisen . Languages As Libraries . In Programming Language Design and Implementation , pp . 132 – 141 , 2011 . [ 106 ] J . Tran O’Leary , K . Lee , and N . Peek . A Grammar of Digital Fabrication Machines . In Conference on Human Factors in Computing Systems , pp . 1 – 6 , 2021 . [ 107 ] T . Tsandilas . StructGraphics : Flexible Visualization Design Through Data - Agnostic And Reusable Graphical Structures . IEEE Transactions on Visualization and Computer Graphics , 27 ( 2 ) : 315 – 325 , 2021 . doi : 10 . 1109 / TVCG . 2020 . 3030476 [ 108 ] A . Van Deursen , P . Klint , and J . Visser . Domain - speciﬁc Languages : An Annotated Bibliography . ACM Sigplan Notices , 35 ( 6 ) : 26 – 36 , 2000 . [ 109 ] J . VanderPlas , B . E . Granger , J . Heer , D . Moritz , K . Wongsuphasawat , A . Satyanarayan , E . Lees , I . Timofeev , B . Welsh , and S . Sievert . Altair : Interactive Statistical Visualizations for Python . Journal of Open Source Software , 3 ( 32 ) : 1057 , 2018 . doi : 10 . 21105 / joss . 01057 [ 110 ] B . Victor . Drawing Dynamic Visualizations , May 2013 . [ 111 ] B . Victor . Media for Thinking the Unthinkable . http : / / worrydream . com / MediaForThinkingTheUnthinkable , April 2013 . [ 112 ] Y . Wang . Deck . gl : Large - scale Web - based Visual Analytics Made Easy . arxiv , 2019 . [ 113 ] Z . Wang , H . Romat , F . Chevalier , N . H . Riche , D . Murray - Rust , and B . Bach . Interactive Data Comics . IEEE Transactions on Visualization and Computer Graphics , 2022 . [ 114 ] H . Wickham . A Layered Grammar of Graphics . Journal of Computa - tional And Graphical Statistics , 19 ( 1 ) : 3 – 28 , 2010 . [ 115 ] L . Wilkinson . The Grammar of Graphics . In Handbook of Computational Statistics , pp . 375 – 414 . Springer , 2012 . [ 116 ] A . Winter , B . Kullbach , and V . Riediger . An Overview of the GXL Graph Exchange Language . Software Visualization , pp . 324 – 336 , 2002 . [ 117 ] K . Wongsuphasawat . Encodable : Conﬁgurable Grammar for Visualiza - tion Components . In IEEE Visualization Conference , pp . 131 – 135 . IEEE , 2020 . [ 118 ] K . Wongsuphasawat . Navigating the Wide World of Data Visualization Libraries . Nightingale , September 2020 . [ 119 ] K . Wongsuphasawat , D . Moritz , A . Anand , J . Mackinlay , B . Howe , and J . Heer . Towards a General - purpose Query Language for Visualization Recommendation . In Workshop on Human - In - the - Loop Data Analytics , pp . 1 – 6 , 2016 . [ 120 ] K . Wongsuphasawat , Z . Qu , D . Moritz , R . Chang , F . Ouk , A . Anand , J . Mackinlay , B . Howe , and J . Heer . Voyager 2 : Augmenting Visual Analysis with Partial View Speciﬁcations . In Conference on Human Factors in Computing Systems , pp . 2648 – 2659 . ACM , 2017 . doi : 10 . 1145 / 3025453 . 3025768 [ 121 ] J . Wood , A . Kachkaev , and J . Dykes . Design Exposition with Literate Vi - sualization . IEEE Transactions on Visualization and Computer Graphics , 25 ( 1 ) : 759 – 768 , 2019 . doi : 10 . 1109 / TVCG . 2018 . 2864836 [ 122 ] wso2 . VizGrammar . https : / / github . com / wso2 / VizGrammar , 2018 . Viewed 6 / 10 / 22 . [ 123 ] A . Wu , Y . Wang , X . Shu , D . Moritz , W . Cui , H . Zhang , D . Zhang , and H . Qu . AI4VIS : Survey on Artiﬁcial Intelligence Approaches for Data Visualization . IEEE Transactions on Visualization and Computer Graphics , 2021 . [ 124 ] E . Wu , L . Battle , and S . R . Madden . The Case for Data Visualization Management Systems : Vision Paper . VLDB , 7 ( 10 ) : 903 – 906 , 2014 . [ 125 ] Y . Wu , J . M . Hellerstein , and A . Satyanarayan . B2 : Bridging Code And Interactive Visualization in Computational Notebooks . In Symposium on User Interface Software and Technology , pp . 152 – 165 . ACM , 2020 . doi : 10 . 1145 / 3379337 . 3415851 [ 126 ] W . A . Yousef , H . E . Mohammed , A . A . Naguib , R . S . Eid , S . E . Emabrak , A . F . Hamed , Y . M . Khalifa , S . T . AbdElrheem , E . A . Awad , S . G . Gaafar , et al . JSOL : JavaScript Open - source Library for Grammar of Graphics . arxiv , 2022 . [ 127 ] V . Zaytsev . Grammar Zoo : a Corpus of Experimental Grammarware . Science of Computer Programming , 98 : 28 – 51 , 2015 . [ 128 ] zingchart . ZingChart . https : / / www . zingchart . com / , 2021 . Viewed 1 / 4 / 22 . [ 129 ] J . Zong , D . Barnwal , R . Neogy , and A . Satyanarayan . Lyra 2 : Designing Interactive Visualizations By Demonstration . IEEE Transactions on Visualization and Computer Graphics , 2021 . 12 © 2022 IEEE . This is the author’s version of the article that has been published in IEEE Transactions on Visualization and Computer Graphics . The ﬁnal version of this record is available at : xx . xxxx / TVCG . 201x . xxxxxxx / A A PPENDIX In this appendix we provide a complete bibliography for the languages in our survey , see Fig . 11 for an index . For further information about our survey we refer the reader to the archival location of our supplement : osf . io / e9v8y or the interactive version at vis - json - dsls . netlify . app , which include an interactive table showing the coding , summary charts , and an interactive example explorer . A . 1 Axes of analysis The following axes were used in our analysis : System : The name of the system . Abstraction Mechanism : Which simple abstraction mechanisms the language features , e . g . control ﬂow or variables Abstraction level : Whether the language has a high ( close to the domain ) or low ( close to the renderer ) level of abstraction Allowed Data Type : The type of input data transformed by the visualization , such as CSVs or domain - speciﬁc ﬁle formats Alt API Available : Whether the language can be used through a mechanism other than writing programs in the language Annotation Support : Whether there is explicit support for annotation Carrier : The language in which the DSL was embedded Conceptual Model : The conceptual model which is used to represent computations executed based on the program speciﬁcation Coordinate Systems : The way in which data is arranged within the graphic Data manipulation : The way in which language users can manipulate the input data , e . g . ﬁlters Data model : The conceptual model of data used by the system Dependent : Whether the language is dependent on another for its effects Domain : The self described purpose of that language , such as animation , XR , genomics , etc Execution Model : How the language is implemented , e . g . compiled , interpreted , composed Extensible : Whether and how the language can be extended , e . g . by end users , through an API , etc Formal Deﬁnition Available : Whether there was a formal deﬁnition of the language available ( including BNF Grammars or other formal descriptions , as well as living speciﬁcations such as JSON Schemas ) Interaction source : Where the state for the application is held such that interactions with the system can be executed in a dynamic environment Juxtaposition strategy : The way in which multiple graphics are combined , e . g . via operators Language Form : Whether the language was internal or external Language Relationship : The explicitly deﬁned relationship that some languages had with one another Mark Types : The mark types available in grammar of graphics style languages Model Formality : Whether the model has a pervasive logical structure ( high formality ) or an ad hoc one ( low formality ) governing the syntax and conceptual model Open Source : Whether or not the system is open source . Output Type : What the execution of the language produces , e . g . vector , raster , text , interactive websites Output Type : The result of executing the program Paper : The paper or papers describing the system . Provides Accessibility : Whether the language explicitly provides accessibility features . Series Types : The types of graphical series ( or chart forms ) available in series - based languages Source : Where the language arises from , e . g . Academic , Industry , Open Source Additional details about these axes , such as the mapping of each of the languages for each of the topics , can be found in the interactive supplement . Letter Languages A AniVis [ 64 ] , AntVSpec [ 3 ] , ApexCharts [ 1 ] , Array visu - alization grammar [ 104 ] , Atom [ 82 ] B Bertin [ 55 ] C Canis [ 28 ] , CFGConf [ 18 ] , Chart . js [ 11 ] , ChartML [ 93 ] , Cicero [ 47 ] , ComicScript [ 113 ] , CompassQL [ 119 ] D Data Theater [ 57 ] , deck . gl / json [ 112 ] , DGML [ 77 ] , DotML [ 67 ] , DXR [ 101 ] E ECharts [ 59 ] , Encodable [ 117 ] F Flex - ER [ 66 ] , Frappe [ 25 ] , FusionCharts [ 27 ] G Gemini 1 [ 48 ] , Gemini 2 [ 49 ] , Genome Spy [ 58 ] , gg [ 124 ] , Glinda [ 17 ] , Gosling [ 68 ] , GoTree [ 60 ] , GraphML [ 8 ] , GXL [ 116 ] H Highcharts [ 37 ] I Ivy [ 73 ] J JSOL [ 126 ] K Kyrix - S [ 103 ] M Multiclass - Density - Maps [ 44 ] N NEO [ 32 ] P P4 [ 61 ] , P5 [ 62 ] , P6 [ 63 ] , PapARVis [ 13 ] , Plotly JSON [ 86 ] S Scholz 3D Vis Language [ 98 ] , SetCoLa [ 38 ] , Shih Vol - ume Vis Language [ 100 ] , StructGraphics [ 107 ] , SVL [ 80 ] V Vega [ 96 ] , Vega - Lite [ 95 ] , VizGrammar [ 122 ] , VizML [ 115 ] , VizQL [ 33 ] , VR - Viz [ 92 ] , VRIA [ 10 ] X XML Charts [ 2 ] Z ZingChart [ 128 ] Fig . 11 . Bibliographic index of languages in our survey . 13