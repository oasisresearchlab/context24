Int . J . Man - Machine Studies ( 1990 ) 33 , 279 - 304 Knowledge exploited by experts during software system design RAYMONDE GutNoost Microelectronics and Computer Technology Corporation , Austin , Texas , USA ( Received August 1989 and accepted in revised form 28 February 1990 ) High - level software design is characterized by incompletely specified requirements , no predetermined solution path , and by the integration of multiple domains of knowledge at various levels of abstraction . The application of data - driven knowledge rules characterizes expertise . A verbal protocol study describes these domains of knowledge and how experts exploit their rich knowledge during design . It documents how designers heavily rely on problem domain scenario simulations throughout solution development . These simulations trigger the inferences of new requirements and complete the requirement specification . Designers recognize partial solutions at various levels of abstraction in the design decomposition through the application of data - driven rules . Designers also rely heavily on simulations of their design solutions , but these are shallow , that is , limited to one level of abstraction in the solution . The findings also illustrate how designers capitalize on design methods , notations , and specialized software design schemas . Finally , the study describes how designers exploit powerful heuristics and personalized evalua - tion criteria to constrain the design process and select a satisfactory solution . Studies , such as this one , help map the road to understanding expertise in complex tasks . 1 . Design : integration of multiple knowledge domains Many organizations divide the development of large software systems in the following phases : requirement analysis ; system design ( high - level and detailed ) ; implementation ( coding , debugging , unit testing ) ; and system testing , and main - tenance . During high - level system design , a designer has to transform an incomplete and ambiguous specification of the requirements into a high - level system design , expressed in a formal or semi - formal notation . A high - level design describes the main software functions and subfunctions , the information flow in the system , the conceptual data structures , and the interfaces between functions , subfunctions , and data structures ( Fairley , 1985 ) . The most expensive errors to correct in a software development project are those made during high - level system design , not those made during coding ( Dunn , 1984 ) . Yet , most empirical studies in software psychology have concentrated on the skills in debugging , memorizing , and coding short programs . Indeed , high - level system design has rarely been empirically studied and is currently poorly supported by software tools and environments . Thus this study concentrates on this important phase of a software development project . This section presents an analysis of design as a knowledge intensive ill - structured task . It briefly reviews findings on how experts represent and use their knowledge in t Author ' s present address : Computer Science Department . Stanford University , Stanford , CA 94305 , USA . 279 0020 - 7373 / 90 / 030279 + 26503 . 00 / 0 (cid:14)9 1990 Academic Press Limited 280 R . GUINDON complex tasks . Section 2 describes the method - - the participants , the l ~ roblem statement , the procedure , and protocol analysis scheme . Section 3 describes the various sources of knowledge brought to bear by experts and how they are exploited . Section 3 . 1 describes problem domain knowledge and the roles of scenario simulations throughout solution development . Section 3 . 2 describes how the requirements are represented and elaborated throughout the design process . Section 3 . 3 discusses how the design solution is represented and evaluated . It discusses how working memory limitations pose constraints on the simulations of complex systems and induce shallow simulations . Section 3 . 4 discusses how knowledge of design strategies , methods , and notations underlay goal - directed processing . Section 3 . 5 describes how designers exploit the knowledge of design schemas to develop a solution in a systematic way . Section 3 . 6 discusses how design heuristics are used in controlling the design process . Finally , section 3 . 7 presents a special case of inferred requirements - - preferred evaluation criteria - - and how they are used in guiding the search for a satisfactory solution . Readers may prefer reading section 3 in a different order , starting with the subsections on design schemas , design heuristics , solution representations and simulations , and preferred evaluation criteria . 1 . 1 . GUIDED SEARCH AND ILL - STRUCI ~ RED PROBLEMS Simon ( 1981 ) presents a theoretical and psychologically - oriented analysis of design tasks . This analysis is meant to apply to any design task - - architectural design , software design , high - level system design , code module design , and so on . Simon describes design as a guided search for a satisfactory solution , under scarce resources such as time , material , money , and so on . The space of possible designs is very large . The search is guided because only the most promising alternative search paths can be pursued . General and domain - specific heuristics are used in selecting the most promising path . Moreover , Simon points out that the search processes should not only be conceived as searches for a solution , but , more generally , as processes for gathering knowledge about the problem structure , that will ultimately be valuable in discovering a problem solution . Indeed , Simon ( 1973 ) characterizes design problems as ill - structured and contrasts them with well - structured problems in terms of four main characteristics given in Table I ( see also Newell , 1969 ; Rittel , 1972 ; Nii , 1986 ) . An analysis of software design tasks is presented in terms of Simon ' s characterization . System design involves the integration of multiple knowledge domains - - knowledge of the application domain , of software system architecture , of computer science , of software design methods , and so on . The design of an elevator control system , for example , requires integrating knowledge about asynchronous request handling , software and hardware interaction , control and communication schemes for multiple processors , concurrency , scheduling and routing optimizations , and so on . These knowledge domains have been associated with problem spaces ( Kant & Newell , 1984 ) . A problem space is composed of a description of the initial state and the goal state , a set of operators to transform a state into another state , a description of the intermediate states reached so far , including the current state , and search control knowledge which guides the selection of which operator to apply or which state to treat as the current state . EXPERT KNOWLEDGE USED IN SOFTWARE DESIGN 281 TABLE 1 Some contrasting features between well - structured and ill - structured problems Well - structured problems Ill - structured problems ( 1 ) Complete and unambiguous specification ( 1 ) Incomplete and ambiguous specification of problem of the problem ( 2 ) Definite criteria to evaluate the solution ( 2 ) No stopping rule - - - no definite criteria and mechanizable process for evaluating to evaluate whether a solution is if the solution is reached reached ( 3 ) Any knowledge necdcd by the problem ( 3 ) Many sources of knowledge ( problem solver can be represented in one or more spaces ) that cannot be determined in problem spaces advance and need to be integrated ( 4 ) Enumerable set of operators that can ( 4 ) No exhaustive , enumerable list of change the initial state into another state operators to reach a solution and and there is at least one problem space absence of predetermined solution in v , ' hich can be represented initial state , path from initial state to goal state goal state , and all intermediate states considered Examples Checkers , Tower of llano ~ Chess , Theorem proving Examples Design ( software , architectural ) Planning , Management , Document and music composition Incomplete and ambiguous system requirements ( or goals ) are intrinsic to system design ( e . g . Swartout & Balzer , 1982 ; Meyer , 1985 ; Parnas & Clements , 1986 ) . As a consequence , system design has two features of ill - structured problems : poorly defined goals and no well - defined criteria to evaluate the solution ( Newell , 1969 ; Simon , 1973 ) . Design tasks involve extensive problem structuring . Problem struc - turing is the process of uncovering missing information and using it to define a problem space . Therefore , the design process should encompass the discovery of new knowledge , in particular , discovery of unstated goals and evaluation criteria . Moreover , system design frequently involves novelty ; ranging from a novel combination of requirements for a familiar type of system to an unfamiliar type of system in an unfamiliar domain . In other words , system design tasks often have no predetermined solution path ( Newell , 1969 ; Simon , 1973 ) . The frequent novelty in design tasks forces a reconsideration of the notion of expertise . Designers have to combine the application of already known plans , with the creation of new plans to handle the novelty in design problems . Designers may have to integrate multiple knowledge domains they had never previously integrated together . In design , even the most expert is always somewhat of a novice . But experts , as opposed to the true novices , bring a great deal of specialized knowledge to structure the design problem and tame the complexity of design tasks . This study concentrates on describing these various sources of knowledge and how experts exploit them . 1 . 2 . EXPERTISE AND ILL - STRUCTURED PROBLEMS Newell ( 1969 ) and Nii ( 1986 ) have hypothesized that the human abilities to solve ill - structured problems , such as design , arise from the data - driven application of knowledge in the forms of empirical associations or rules derived from past experience . In fact , expertise in many problem domains has been attributed to the 282 R . GUINDON development of such data - driven rules ( Larkin , 1981 ; Anderson , 1982 ) . The application of these data - driven rules is considered to be automatic and to impose little cognitive cost , in contrast to goal - directed behaviours ( Anderson , 1983 ) . Expertise is also associated with the development of knowledge schemas - - - knowledge structures abstracted from previous attempts at understanding and solving similar problems ( Rumelhart & Norman , 1981 ; Soloway , Adelson & Ehrlich , 1988 ) . But more important , these knowledge structures become organized more efficiently with expertise . Experts organize their knowledge in terms of functional categories in their domains of expertise , whereas novices organize their knowledge in terms of surface features of the problem ( Egan & Schwartz , 1979 ; Larkin , McDermott , Simon & Simon , 1980 ; McKeithen , Reitman , Rueter & Hirtle , 1981 ) . So , experts are expected to retrieve knowledge rules and the more complex design schemas in a data - driven manner . However , because design problems are ill - structured , the design process cannot be just the retrieval of known solutions , even in experts . The novelty in design and the incompletely specified requirements force even expert designers to punctuate the retrieval of known solutions with the inferences of new requirements , the recognition of partial solutions at various levels of abstraction , and the creation of new solutions . The complexity of the design process also forces designers to use design methods and heuristics in a goal - directed manner to constrain the search for a design solution . This analysis of design tasks as ill - structured problems and the studies on expert - novice differences underscore the ubiquity and criticality of specialized knowledge during design . This study describes some of the specialized knowledge exploited by experts during design . It examines how the discovery of new knowledge - - - unstated goals and evaluation criteria in the requirements - - impacts the design process . It describes the specialized design schemas experts abstract from past experience and apply to new designs . It also documents the powerful heuristics exploited in searching for and selecting a satisfying solution . This paper describes what knowledge is used by experts . A companion paper describes how experts plan and control the application of that knowledge ( Guindon , 1990 ) Some of the breakdowns , or difficulties , resulting from a lack of relevant specialized knowledge have been described in Guindon , Curtis and Krasner ( 1987 ) . 2 . Method 2 . 1 . PARTICIPANTS Three designers were selected because they were considered by their peers and managers to be very experienced and competent designers . They all had advanced degrees and many years of professional experience . Designer 1 had a master ' s degree in software engineering , was the top student of his class , and had five years of professional experience in designing real - time systems . Designer 2 had a doctoral degree in electrical engineering and had ten years of professional experience with concurrent systems and communication systems . He was a weU - seasoned software designer experienced in a wide variety of systems . Designer 3 had temporarily suspended his doctoral training in computer science to work in an industrial setting for three years . He had experience with logic : . XPERT KNOWLEDGE USED IN SOFTWARE DESIGN 283 ~ rogramming and rapid prototyping . He had produced more working systems than my other member of his organization and was considered by managers and peers as ; xtremely productive and competent . All designers had learned structured program - ning and top - down design as part of their formal education or their job training . l ' he protocols of Designers 1 and 2 were fully analysed , the protocol of Designer 3 vas analysed to a lesser extent . L2 . PROBLEM STATEMENT l ' he Lift Control Problem is a standard problem in the areas of software ; pecification and software requirements research . The problem statement is given in . : igure 1 . The goal is to design the control to move N lifts elevators between M loots , given the constraints expressed in the problem statement . None of the three : lesigners had solved this problem before our study . How representative is the Lift problem of typical design problems ? The Lift ~ roblem has the ecologically - valid features identified in the ill - structured problem malysis . Its specification is informal and , therefore , incomplete and ambiguous . It is dso a knowledge - rich problem requiring the integration of many knowledge : lomains . There is also novelty , since none of our designers had designed an dentical system ( although Designers 1 and 2 had worked on related systems ) . A LIFT CONTROL SYSTEM An N - Lift system is to be installed in a building with M floors . The lifts and the control mechanism are supplied by a manufacturer . The internal mechanisms of these are assumed ( given ) in this problem . DESIGN THE LOGIC TO MOVE LIFTS BETWEEN FLOORS BUILDING ACCORDING TO THE FOLLOWING RULES : IN THE ( 1 ) Each lift has a set of buttons , one button for each floor . These illuminate when pressed and cause the lift to visit the corresponding floor . The illumination is cancelled when the corresponding floor is visited ( i . e . stopped at ) by the lift . ( 2 ) Each floor has two buttons ( except ground and top ) , one to request an up - lift and one to request a down - lift . These buttons illuminate when pressed . The buttons are cancelled when a lift visits the floor and is either travelling in the desired direction , or visiting the floor with no rcquests outstanding . In the latter case , if both floor request buttons are illuminated , only 1 should be cancelled . The algorithm used to decide which to service first should minimize the waiting time for both requests . ( 3 ) When a lift has no requests to service , it should remain at its final destination with its doors closed and await further requests ( or model a " holding " floor ) . ( 4 ) All requests for lifts from floors must be serviced eventually , with all floors given equal priority ( can this be proved or demonstrated ? ) . ( 5 ) All requests for floors within lifts must be serviced eventually , with floors being serviced sequentially in the direction of travel ( can this be proved or demonstrated ? ) . ( 6 ) Each lift has an emergency button which , when pressed causes a warning signal to be sent to the site manager . The lift is then deemed " out of service " . Each lift has a mechanism to cancel its " out of service " status . FIGURE 1 . The N - Lift problem statement . 284 R . OUINDO ! 2 . 3 . PROCEDURE An experimenter collected thinking - aloud reports from the designers as the i designed the control for the N - lift problem . The designers easily verbalized thei thoughts , with few moments of silence . This natural ease may be attributed to th ~ fact that since design often ocurs in teams designers are comfortable expressing thei : thoughts aloud . When the designers fell silent , the experimenter gently prompte ~ them to resume talking . The designers were given up to two hours to produce a very high level desigr solution in a form and level of detail that could be handed off to a competent systerr programmer to implement . The participants were videotaped and supplied witl paper and pencils to work their solution . Their notes and diagrams were regularl ~ time - stamped by the experimenter . Also time - stamped was the transcript of eacl ' participant , which included the designer ' s written notes and diagrams . Since thi ~ procedure is comparable to other design studies ' procedure , its results can bd compared with those of these studies ( Jeffries , Turner , Poison & Atwood , 1981 Adelson & Soloway , 1984 , 1985 ; Kant & Newell , 1984 ; Adelson , 1988 . ) In debriefing sessions following the protocol collection , the designers were asked to assess the naturalness of the experimental situation . They reported that the problem was not unlike the type of design problems they had been given in th ~ . I past - - sketchy , incomplete , and ambiguous . They also commented that during high - level design , they typically use only paper and pencil to jot down ideas , notes i design sketches , and they also constantly have to operate under severe time constraints . They added that in the field , however , they are freer to interrupt design to seek information from colleagues and customers . On the other hand , the designers asserted that they felt more constrained in the experimental session than in the field , to go by the book and to follow accepted design methods and practices . 2 . 4 . PROTOCOL ANALYSTS SCHEME AND PROCEDURE The procedure for the protocol analysis was divided into the following major steps . First , in a preliminary analysis , each designer ' s videotape and transcript were viewed and read by four researchers in different domains of expertise . One of the researchers was a cognitive psychologist , two had a background in artificial intelligence with an interest in software tools to support designers , and the last one had a background in software engineering and in large system development . The researchers were free to note whatever they felt was significant about the design process of an individual designer . The notes were then shared and discussed at length among the researchers . This brainstorming analysis helped ensure that the findings were shared very rapidly with those involved in building tools . The analysis also helped ensure that design activities that could be considered as noise or as uninteresting within one domain of expertise could reveal their significance when viewed from another domain of expertise . This is particularly important since design tasks are knowledge - intensive and involve the integration of multiple knowledge domains . Second , following this preliminary analysis , and about one month after protocol collection , each participant ' s videotape was then viewed with the participant in a prompted review session . The participant designer was free to stop the videotape and note whatever was significant from his perspective . The researchers could also EXPERT KNOWLEDGE USED IN SOFTWARE DESIGN 285 stop the videotape at any point and question the designer . These questions were particularly useful in probing for the specialized knowledge that the designer brought into the design sessions but that he only alluded to in the verbalizations . The questions were also useful in uncovering the unverbalized rationale underlying design decisions . Third , an analysis scheme was developed iteratively as additional and more detailed analyses of the protocols were performed . For each episode that cor - responded to a distinct design activity , a template of attribute - value pairs was filled out . It described the type of design process activity and its associated knowledge domain : Lift domain scenarios , requirement understanding or elaboration , develop - ment of solutions , software design schemas , design methods and heuristics , and design process management . Then , each designer ' s protocol was analysed by two people in depth . Finally , the analyses were compared and conflicts resolved . 3 . Results and observations Software system design is knowledge - intensive . There is little hope of understanding this process without identifying the domains of knowledge designers bring to bear , and how designers exploit that knowledge in searching for a satisfactory solution . Several recurrent observations arose from the protocols regarding these issues . Each of the following subsections describes a knowledge domain observed in the protocols , gives examples , documents how designers used and represented that knowledge , and compares the findings with those of previous studies . 3 . 1 . PROBLEM DOMAIN One of the designers ' activities was the retrieval or the simulation of scenarios in the problem domain ( called the Lift domain ) . By problem domain we mean a subset of the real world with which a computer system is concerned ( but not the design solution describing the computer system itself ) . A lift system is concerned with lifts , floors , passengers , waiting time of passengers on the floors , safety of passengers , and so on . Kant and Newell ( 1984 ) called this the task domain . Others call this the application domain . Figure 2 presents an example of a scenario in the Lift domain with external representation . Bold font capitalized material indicates the type of design activity . Five main uses for the retrieval and the simulation of scenarios in the Lift domain were observed in the protocols : ( 1 ) Understand the given requirements with Lift scenarios : At the beginning of the session , before any solution components have been elaborated , designers perform Lift domain simulations to support their understanding of the requirements . ( 2 ) Understand the inferred requirements with Lift scenarios : Throughout the session , the designers infer new requirements ( see the next section ) . They often follow such discoveries by Lift scenarios to confirm the relevance of these inferred requirements . ( 3 ) Solution deoelopment with Lift scenarios : At times , designers are not making any progress toward a solution . They will sometimes simulate scenarios in the Lift domain to get new ideas about which operators to apply . Participants in this study 286 R . GUINDON 4 3 2 1 Floors GD GD ( : 312 ) GD ( 3D 0 Lifts I ' m not sure 1 understand about scheduling . { LIFr SCENARIO } I ' ll draw two elevators with a few floors . (cid:12)9 (cid:12)9 (cid:12)9 For each lift , ! have , say , four buttons that are illuminated or not . And for each lift 1 also have to know the floor and the direction . Say Lift I is at floor 4 and there are requests to go down to floors 3 and 2 . (cid:12)9 (cid:12)9 (cid:12)9 The floors don ' t move , the lifts move . { INFERRED CONSTRAINT } It strikes me that 1 haven ' t considered enough this idea of having lifts between floors . { NEW DESIGN GOAL SET } I ' m going to handle that . FtGURE 2 . A Lift scenario with external representation , an inferred constraint , and the induced shift in designer ' s goals . rarely use Lift scenarios for this purpose . These simulations also act as a mechanism for problem understanding and structuring as they can lead to the inference of new constraints or requirements . Figure 2 shows an example where a Lift scenario triggers the inference of a new requirement . At other times , designers suddenly discover a partial solution which seems relevant , but which does not have a corresponding requirement in the problem statement . Designers simulate a Lift scenario to test the relevance of the newly discovered solution . Figure 3 shows an example of such use . ( 4 ) Unplanned discovery of new requirements : Lift scenarios frequently trigger the unplanned discovery of new requirements ( Figure 2 ) . Instances of new requirements are test cases - - possible input values based on possible operating conditions . The test cases are used in simulating and evaluating the solution . Figure 4 shows an example . ( 5 ) Unplanned discovery of partial solutions : Lift scenarios often trigger the immediate recognition of partial solutions at various points and abstraction levels in the design solution . Figure 3 shows an example . The simulations of problem domain scenarios are not found in a monolithic block preceding design as would be prescribed by a waterfall model of software { DISCOVERED PARTIAL SOLUTION } In fact that insight suggests that the door control could be done by a completely separate system from the handling of the service requests , but I ' m not sure yet . { LIFT SCENARIO } Yes , in fact , usuaUy in elevators first the doors open , then they stay open for a fixed amount of time , and then they close . { IMMEDIATE RECOGNITION OF PARTIAL SOLUTION } hz fact , ! shouM bzclude a timer in the system controlling the opening and closing of the doors . FtGURE 3 . A discovered partial solution confirmed with a Lift scenario v , hich triggers the recognition of a new partial solution . EXPERT KNOWLEDGE USED IN SOFTWARE DESIGN 287 { LIFT SCENARIO } I ' m going to imagine one elevator and a few scenarios . Say there ' s request from floor 2to 4 . If there is a lift going to 2on its way up , then stop the lift at 2 , open the doors , . . . If there is a lift going down from 5 to 1 , the lift does not stop at 2 . . (cid:12)9 { INFERRED TEST CASE } What if you press up at the floor , but once in the lift , you press a down button . . . . { NEW PARTIAL SOLUTION } So there ' s definitively the need for a queue of lift requests for each lift , separate from the floor requests . . . . Maybe the floor requests could be handled by a completely separate system from the lift requests . FIGURE 4 . A Lift scenario which triggers the inference of a test case which triggers the recognition of a new partial solution . development . Rather , they are found interleaved with solution development throughout the design session ( Guindon et al . , 1987 ; Guindon , 1990 ) . Although Kant and Newell ( 1984 ) do not report that their designers simulated scenarios in the geometry problem space , their designers retrieved knowledge from geometry to identify test cases for the evaluations of the solution . Kant and Newell argue that the interplay between knowledge about algorithms and geometry play a critical role in the discovery of new solution knowledge . The next section will describe our related finding - - simulations of scenarios in the Lift domain can lead to the discovery of critical knowledge , not only about the solution but also about the problem goals and evaluation criteria . In a similar vein , Jeffries et al . ( 1981 ) do not report the occurrence of simulation of scenarios in the problem domain . They report , however , a strategy they call problem solving by understanding . In problem solving by understanding , problem domain and computer science knowledge help the designer refine his or her understanding of the problem before attempting to find a solution . Jeffries and her co - workers claim that problem solving by understanding occurs when some aspect of the problem is not well enough understood to attempt a solution , and that it can occur at any point during the solution , even during the refinement of a subproblem . Jeffries and her co - workers do not report , however , the discovery of new requirements . All three designers in this study supported the simulations of Lift scenarios by using external representations . Anecdotally , all three designers produced external representations for the Lift scenarios similar to the one shown in Figure 2 . The scenario simulations were cognitively very taxing due to multiple lifts , lift requests and floor requests . Indeed , Larkin and Simon ( 1987 ) have shown that diagrams can display important information that is only implicit in sentential representations and which is very taxing cognitively to compute . In Figure 2 , the designer is trying to understand the problem of scheduling between lifts - - the relationships between requests made at the floors and those originating from within the lifts ; the relationships between lifts going up , going down , and being idle ; the outstanding requests from different floors ; and so on . Diagrams are particularly well suited to express directly spatial relationships , such as the location of one lift in relation to other lifts , the floors to be serviced by a particular lift in relation to the lift ' s current location and to the floors to be serviced by the other lifts . The diagram helps the designer make the inference that lifts are moving continuously between floors as opposed to discretely , and this is a critical point for the scheduling algorithm . Designers also annotated the diagrams . These annotations mainly described 288 R . GUINDON constraints from the requirements that could not be easily represented spatially or graphically ( e . g . the notion that all floor requests have equal priority ) . To summarize , designers interleave problem domain scenarios with solution development throughout the design process . These problem domain scenarios lead to the unplanned discovery of new requirements and of partial solutions in various points and abstraction levels in the solution decomposition . 3 . 2 . REOUIREMENTS AND TIIEIR ELABORATIONS The requirements define goals of the system : the external , functional , and performance criteria , as well as exception handling and acceptance criteria . Unfortunately , incomplete and ambiguous software requirement specifications are intrinsic to system design ( Swartout & Balzer , 1982 ; Meyer , 1985 ; Parnas & Clements , 1986 ) . A design activity observed in this study is the understanding and elaboration of the requirements given in the problem statement . By elaboration of the requirements , we mean any activity whose purpose is to decrease the incompleteness and ambiguity of the informal requirements specification . In particular , this includes the inferences of constraints which necessarily or possibly follow from the informal specification and the additions of new , desirable but optional , requirements . An hzferred constrahlt is not explicitly given in the requirements but can be deduced as a logically necessary or possible inference ( abduction ) from the informal specification and from one ' s knowledge of the problem domain . Inferred constraints include inferred objects , inferred relationships between objects , inferred properties of an object , inferred actions of an object , and inferred test cases . An example of an inferred constraint is given in Figure 2 . This designer infers that lifts are moving in a continuous manner between floors , as opposed to discretely . In other words , he infers a property of an action associated with an object . This has an impact on the solution , since the designer must now include a mechanism to detect the location of lifts between floors in time to allocate requests from floors the lifts are about to visit . Inferred constraints act to reduce the incompleteness and ambiguity inherent in the requirements specification . A particularly interesting type of inferred requirement is the inference of test cases , illustrated in Figure 4 . By simulating a Lift scenario , the designer realizes that a user may press a floor button to go in one direction , but once inside the lift , may press a lift button to go in another direction . This test case was not mentioned in the problem statement , yet it is critical for the design of a good control algorithm . The inference seems to arise from the confluence of knowledge from the Lift domain and the design of algorithms where one seeks to find extreme cases where the algorithm will fail . The most important observation , though , is that in most cases of inferred requirements , the designers elected to change their current goals and immediately handled the inferred rcquircmtnts ( Guindon , 1990 ) . The designers could have updated thc Instead they requirements discovered a evaluate the requirements list of requirements and continued working on their previous tasks . preferred to immediately develop a partial solution for the new ( Figures 4 and 5 ) . A possible interpretation is that until a designer had design solution demomposition , it is advantageous to immediately impact of new inferred constraints on the solution . First , the new change the design goals , and as a consequence , the design plans to EXPERT KNOWLEDGE USED IN SOFTWARE DESIGN 289 fulfill the requirements . Second , the new inferred constraints may provide early insights critical in reducing the space of design possibilities and in discovering a design decomposition . The inference of new requirements and their immediate handling by the designers contribute to the observed opportunistic character of design ( Guindon , 1990 ) . t Added requirements are desirable requirements , missing from the specification , but ones which do not logically follow from the informal specification and from one ' s knowledge of the problem domain . An example is given in Figure 5 . The designer recognizes from past knowledge with similar systems that " no single point of failure " would be a highly desirable requirement . However , other designers might have considered low cost or high speed to be more desirable than no single point of failure . The addition of this desirable requirement reduces the space of design possibilities - - - - only those designs that ensure high levels of reliability are considered from now on . Added requirements may also play a critical role as preferred evaluation criteria or stopping rule ( see section 3 . 7 ) . Two other activities relate to the understanding of requirements . Designers disambiguate requirements by simulating related scenarios in the Lift domain and comparing with their knowledge . Designers also identify and abstract the critical points from the requirements and give them priority . Designers also relied on external representations to keep track of the require - ments , but in this case , under the form of a list of notes . The notes were also used to highlight the requirements they felt were most critical . Designers also used notes to ensure that all the critical or inferred requirements were met . In particular , Designer 2 was very careful to write down all the inferred and desirable requirements as he assumed them . Moreover , he used these notes in two ways during the final review of the solution : first , he simulated his design solution and compared the simulation behaviours with what was demanded by the requirements ; second , he systematically revisited every requirement to ensure they were satisfied by his solution . Nevertheless , the observed design process was , behaviourally , more opportunistic than systematic and balanced ( Guindon , 1990 ) . Although the use of notes helps support a systematic and balanced development , it is not a sufficient condition . Previous studies , such as Jeffries et al . ( 1981 ) or Adelson and Soloway ( 1984 ) , have not reported the inferences and elaborations of requirements during design . { TRADE - OFF ANALYSIS DURING SOLUTION EVALUATION } The good news about central control is it ' s an easier algorithm vs distributed control . The bad news is you have a single point of failure . { ADDED REQUIREMENT } You would rather not have a single point of failure because if it goes down all the elevators go down . { NEW DESIGN GOALS } So , rll start off thinking about a distributed control system ( because it is more reliable than centralized control ) . F Z G U R E 5 . A solution evaluation triggers an added requirement which is handled immediately . t The term opportunistic is borrowed from the work of Hayes - Roth and Hayes - Roth ( 1979 ) . They observed that their subjects planned errand tasks by mixing decisions at various levels of abstraction and by elaborating partial solutions at various points in the solution space . Opportunistic design behaviours , however , do not necessarily imply an opportunistic model of planning such as proposed by Hayes - Roth and Hayes - Roth . Anderson ' s ACT * ( 1983 ) can also simulate opportunistic like behaviours with a hierarchical goal structure , a flat data - driven structure , the forgetting of higher - level goals , and the execution of data - driven productions with intentions . 290 R . GUINDON The studies by Carroll , Thomas and Malhotra ( 1979 ) and Malhotra , Thomas , Carroll and Miller ( 1988 ) are exceptions , but not surprisingly , in the context of customer and designer dialogues . Inferences and elaborations of the requirements are , however , critical in reducing the incompleteness and ambiguity of the problem specification , which is inherent to design tasks . To summarize , inferred and added requirements mainly serve two purposes : ( 1 ) they lessen the incompleteness and ambiguity inherent in the specification of the requirements ; and ( 2 ) they decrease the range of possible design solutions by acting as simplifying assumptions . In particular , these inferences contribute to problem structuring . Moreover , they effectively guide the search of a solution by pruning a large set of possibilities . Finally , they also provide preferred evaluation criteria to be used in selecting a satisfactory solution ( section 3 . 7 ) . Of course , once the inferred and added requirements are accepted by the designers , they are used in the evaluation of the correctness and completeness of the partial and final solutions . As mentioned previously , these requirement inferences do not occur as a monolithic block preceding design , as would be prescribed by waterfall models of software design . These requirement inferences occur throughout the session , interleaved with solution development . The use of problem domain knowledge was similarly observed to be interleaved with solution development . But more impor - tantly , designers tend to develop the partial solutions for these inferred require - ments immediately , leading to drastic shifts in the course of design activities . Thus problem understanding and structuring are interleaved with solution development throughout the design session . 3 . 3 . DESIGN SOLUTIONS , THEIR REPRESENTATIONS , SIMULATIONS AND EVALUATIONS Another part of the designer ' s knowledge is the evolving design solution - - the designer ' s mental model of the solution and its external representations . Activities related to this knowledge include the representation , development , mental or external simulations , and evaluations . Our designers had multiple uses for the external representations of their design solutions . The main use , of course , was to express the design solution ; that is , as the product and goal of the design process . Another important use was to support mental simulations of the solution , which would otherwise be too taxing cognitively and lead to breakdowns ( Guindon et al . , 1987 ) . Additionally , the designers used external representations to uncover missing information and to ensure completeness of the solution . This was particularly apparent with Designer 2 who , in seven different episodes , used his state transition diagrams for this purpose . However , these representations did not necessarily enforce a balanced and systematic development of the solution ( Guindon , 1990 ) . Regarding the design solution decomposition , the designers did differ in their solution decompositions . This contrasts with the findings of Jeffries et al . ( 1981 ) and is probably due to the greater complexity of the Lift problem compared with the book indexing problem . As Jeffries and her co - workers acknowledged , the book indexing problem required only upper undergraduate level computer science knowledge . The designers in the current study also differed in the design notations they used . EXPERT KNOWLEDGE USED IN SOFTWARE DESIGN 291 To illustrate the differences in design decompositions and notations , brief descriptions of two solutions are given . The solution of Designer 2 is a ring of independent elevators with sequential polling of floor request information which is kept locally on each floor . In this distributed control scheme , each elevator operates on its own ( using system state information ) and passes information around the ring to the others to coordinate the schedules of pickups that they had decided on independently . The coordination of the elevators is handled through a common circulating data structure , a baton . In each elevator there are two communicating finite state machines : one for local processing of the elevator as it decides which stops to make along its route , and the second for communicating with the next elevator in the ring . Figure 6 shows some of the state transition diagrams of Designer 2 , in the order in which they were generated . He first generated the state transition diagram for the main part of the scheduler , and then the diagram for the scheduler in case of failure by one or two consecutive lifts . Finally , he generated the diagram for the lift controller , which handles each individual lift ' s functions . On the other hand , the solution of Designer 1 is a star architecture in which the elevators communicate through a central process and database containing system state information . The central process handles requests from floors . For each lift , a lift handler is responsible for individual lift functions such as the opening and closing of the doors and servicing its own lift requests . Designer 1 represented his solution using Jackson System Development ( Jackson , 1983 ) ( JSD ) diagrams , dataflow diagrams , structure charts , and pseudocode . It is important to point out that design notations are amongst the operators that expert designers have at hand to produce a design solution , that is , to transform the informal specification of the requirements into a design solution . Design notations play the dual role of vehicle for expressing the design solution and of operators for developing the design solution . In fact , at the beginning of the design session , Designer 1 appeared to be searching for a good design solution representation by trying multiple alternative notations . So , search during design also encompasses search for a good design method and notation . This topic will be revisited in section 3 . 4 on design methods and notations . Regarding the simulations of design solutions , these helped uncover various types of bugs : ( 1 ) inconsistencies with other parts of the solutions ; ( 2 ) incompletness of the solution with respect to the rest of the design solution ; ( 3 ) inconsistencies with the given or inferred requirements ; and ( 4 ) incompleteness with respect to the rest of the design solution . All these simulations relied on external representations because , first , the external representation / s the artifact , and second , they are cognitively taxing . As mentioned previously , solution simulations were done in terms of test cases based on problem domain knowledge - - - possible scenarios of floor and lift requests and lift positions . As observed by Kant and Newell ( 1984 ) , there were two types of simulations : executions with specific test cases and symbolic executions using variables instead of specific cases . An interesting observation is that the mental simulations of the solutions were shallow , that is , most were restricted to one level of abstraction and one subsystem . They did not involve the simulations of subsystems embedded within the simulation of a higher - level subsystem . This is not surprising given the severe limitations that working memory poses on the processing of embedded structures ( see for example , 292 / n ~ w _ J 0 0 ( 3 _ J n ~ W J D 0 W I 0 a o , - ~ o R . GUINDON " ( 3 L . o ~ c - Q > - . 0 L E E " o c - O U r ( J ) EXPERT KNOWLEDGE USED IN SOFTWARE DESIGN 293 the work on parsing complex sentences by Frazier & Fodor , 1978 , and Hintikka , 1987 ) . The need to remember the values of the variables and the return locations in the higher - level system ( i . e . the context ) when simulating an embedded subsystem probably precludes simulations of solutions at more than one level of abstraction . This is related to the forgetting of higher - level goals , documented by Anderson ( 1983 ) , in the performance of a complex task with many levels of subgoals . Of course , this limitation was partly alleviated by the use of external representations , but not completely . The constraints posed by working memory on the processing of embedded structures and the ensuing shallow solution simulations are fundamental difficulties for humans during high - level design . As a consequence , designers may incorrectly evaluate the correctness or completeness of their design solutions . In fact , the difficulty in performing simulations of high - level design solutions has been identified as one of the breakdowns in the design process in need of support from software tools ( Guindon et al . , 1987 ) . As reported earlier , the Lift domain simulations often triggered the inferences of new requirements and the discovery of partial solutions . Likewise , the solution simulations often triggered the inferences of new requirements and the discovery of partial solutions at arbitrary points and levels of abstraction in the solution . These greatly contributed to the observed opportunistic character of the design process ( Guindon , 1990 ) . Regarding the evaluations of alternative solutions , designers rarely retrieved more than one alternative solution for a problem . But if the designers retrieved more than one solution to a subproblem ( e . g . centralized vs distributed algorithms for the control subsystem ) , they very rapidly selected one of them . The rejections of alternative solutions were made very rapidly , without developing them in depth . In a study of mechanical engineering , Ullman , Stauffer and Dietterich ( 1987 ) observed that designers elaborated only one main design idea , usually selected quite early in the design process , with few considerations of major changes to the basic design idea . They seldom saw parallel development of more than one idea , and if several alternatives were initially developed , all but one would be eliminated very rapidly . Kant and Newell ( 1984 ) made a similar observation . This finding can be attributed to the too heavy load on working memory that parallel development of alternative solutions would impose . Moreover , a designer working under limited time and other resources ( whether in the field or in the lab ) will naturally focus , as early as possible , on a familiar solution which has worked in the past and will avoid considering unfamiliar alternative solutions . In the current study , for example , Designer 2 did not develop at . any depth the alternative centralized and distributed control solutions to compare their conse - quences . Instead , Designer 2 rapidly rejected one of the alternatives through a trade - off analysis against preferred evaluation criteria ( see Figure 5 and section 3 . 7 ) . He immediately recognized which of the two solutions was more desirable with respect to the preferred evaluation criterion . He selected the solution that scored highest on the preferred evaluation criterion . 3 . 4 . DESIGN STRATEGIES , METHODS , AND NOTATIONS A critical source of knowledge pertains to the design process itself , that is , the knowledge of design strategies , methods , and notations . A design method , by 294 R . GUINDON definition , dictates or suggests a sequence of activities to be performed , and therefore is a prime influence on the planning and control of the design process . A design method provides a sequence of operators and associated tests to apply these operators , for the transformation from an informal specification of the requirements to a design solution . Therefore , design methods provide operator sequence knowledge and control knowledge for the application of these operators . This knowledge is specific to software design tasks , but independent of the problem domain ( though different design methods are best suited to different classes of problems ; see Fairley , 1985 , p . 181 ) . Previous empirical studies of design have mainly focused on the top - down strategy and its associated stepwise refinement method . However , top - down design strategies are only one of the many design strategies advocated in software design . Other design strategies exist , such as data structure - oriented and object - oriented strat - egies . Identifying such strategies from the protocols is not difficult because participants often verbalize the names of these strategies during the think aloud protocol or in the prompted review ( see Figure 7 ) . Moreover , these strategies have distinctive behavioural manifestations ( e . g . notations , steps ) which are easily recog - nizable . An example of a design method that embodies a data structure - oriented strategy is the Jackson System Development Method . Figure 7 illustrates the application of the first step of JSD , the entity action step . Designer 1 identifies the entities in the problem ( e . g . lifts , floor buttons ) and the actions that these entities can perform or suffer ( e . g . press button , lift going up ) . Designer 1 used two main design strategies during the design process , an object - oriented strategy and a data - structure oriented strategy . He also used multiple notations - - JSD diagrams , data flow diagrams , structure charts , and pseudocode . In fact , at the beginning of the session he appeared to search for a good design method and associated notation to develop his solution . Design methods and design notations can be part of the knowledge searched during design . This behaviour is consistent with his formal training in software engineering , providing him with a rich set of strategies , methods , and notations from which to select . Once he had selected a design method and notation , he used it to guide his search for a good design decomposition . Designer 2 , on the other hand , rapidly discovered the proper high - level design decomposition based on a retrieved software system design schema ( see section 3 . 5 ) . He also rapidly selected state transition Entity Action Lift ( Close doors , open doors ) moves up , moves down , breakdown , sends emergency notification , requests floors Floor Request lift Manager Receive emergency notification 1 ' 11 use the first step hz JSD . So I ask certah ~ questions : Does it exist in the real world ? Does it perform actions ? Does it have thne dependencies between its actions ? . . . To find entities , l ' m looking for nouns in the specification . A lift seems a possibility . . . . A lift closes doors , opens doors , actually doors might be a separate object , a lift moves ltp , moves down , . . . FIGURE 7 . Application of the JSD Entity Action Step . EXPERT KNOWLEDGE USED IN SOFTWARE DESIGN 295 diagrams as his design notation . This behaviour is consistent with his training in electrical engineering and his past experience with problems similar to the Lift problem . 3 . 5 . PROBLEM SOLVING AND SOFTWARE DESIGN SCHEMAS Jeffries et al . ( 1981 ) and Kant and Newell ( 1984 ) observe that their designers use domain - independent , problem solving schemas such as divide - and - conquer and generate - and - test . Jeffries et al . ( 1981 ) defines a schema as a higher - order knowledge structure which governs behaviour in a particular domain of activity . This knowledge structure specifies principal elements in a domain , includes mechanisms which drive the comprehension and generation processes , and is used to organize complex material into constituents . In the current study , we have also observed the use of the divide - and - conquer schema . For example , Designer 1 divided the problem into servicing the lift requests and servicing the floor requests . Jeffries et al . ( 1981 ) also mention that as designers develop more expertise , they learn more and more domain - specific and specialized schemas which allow them to decompose a design problem into subproblems more effectively . Jeffries and her co - workers do not give examples of these specialized schemas from their study . Given the critical and ubiquitous nature of specialized knowledge in design , examples of software system design schemas that were observed in the current study are presented . As observed in our protocols , the specialized design schemas can vary in complexity and granularity . Some of the specialized schemas can be simple rules such as : If the input requests are asynchronous , use an interrupt structure . Other specialized design schemas observed in the protocols are far more complex : they provide overall high - level decompositions for the Lift problem and the class of software systems to which it belongs . For example , early in the session , Designer 2 retrieved a design schema which specifies a high - level solution decomposition for the Lift problem , alternative solutions for each subsystem in the decomposition , and evaluation criteria for these alternative solutions . Indeed , he very quickly identified the main design sub - problems ( i . e . control , communication between lifts , and scheduling ) , knew alternative solutions to consider ( e . g . central vs distributed solutions for control ; centralized posting of requests vs broadcasting of requests ) , and knew evaluation criteria for these solutions ( e . g . ease of implementation vs reliability - - not repre - sented in Figure 8 for sake of clarity ) . The schema appears to have been abstracted from his previous designs of a cab dispatcher and of a film controller system - - systems with similar architectures , but in different problem domains . Designer 2 commented : " I have done algorithms for multiple processors like this problem for fixed applications . . . I ' ve thought about polling schemes and centralized memory schemes and distributed memory schemes . . , like the taxi cab dispatchers and police dispatchers . . . I remember doing a film controller . . . All these are the same states , what makes it move out of this state , what makes it start " . Scrutinizing the structure of these different systems , it becomes clear that they are all instances of resource allocation systems . They all have in common a set of general 296 R . GUINDON constraints to satisfy multiple clients , multiple servers , limited resources , asynchro - nous service requests , and routing or scheduling optimizations - - and they all share a similar design solution decomposition . On the basis of the information provided in the protocol and the prompted review , part of the schematic knowledge retrieved by Designer 2 has been derived . It is depicted in a graphical fashion in Figure 8 . Note how the schema is organized in terms of functional categories in the designers ' domains of expertise , instead of in terms of surface features of the problem ( see also Egan & Schwartz , 1979 ; Larkin et aL , 1980 ; Mckeithen , Reitman , Rueter & Hurtle , 1981 ) . Of course , the actual knowledge structure retrieved and used by the designer may contain more knowledge than shown in Figure 8 . The verbal protocols and prompted review did not permit to extract all the knowledge that the designers relied on during design . The schema is a complex rule composed of a pattern which specifies the similarities in requirements between different instances of a class of systems ( e . g . resource allocation systems ) . On the basis of these similarities the design schema is retrieved , in a data - driven fashion . The design schema also specifies a high - level decomposition of the software system into subsystems . In this case , the high - level decomposition includes a subsystem for control between lift processors , a subsystem for communication between processors , and a subsystem for scheduling , each with alternative solutions and their evaluation criteria . Likewise , each of these sub - systems might have a corresponding design schema . Once the design schema is retrieved , it sets up a goal - directed , top - down processing ( in the sense of building the system following a known structure ) to design each of these subsystems - - control , communication between processors , and scheduling . However , applying a design schema does not necessarily imply a single order in which to design each of the subsystems , since each of them should tend to be relatively independent . If an appropriate design schema is retrieved early in the session , the designer can then proceed in a systematic and balanced way by following its solution decomposi - tion . However , as noted in the introduction , novelty is not an exception in design . MULTIPLE CLIENTS MULTIPLE SERVERS LIMITED RESOURCES ASYNCHRONOUS SERVICE REQUESTS ROUTINGI SCHEDULING OPTIMIZATION CONTROL : r Distributed OR ~ ( Ring of processors with c2oZS " COMMUNICATION BETWEEN PROCESSORS : r Sequential baton passing OR ~ Broadcast to all / L SCHEDULING : Polling of requests Route selection OR ~ Closest request LMost requests FIGURE 8 . Part of a high - level design decomposition specified in a design schema . EXPERT KNOWLEDGE USED IN SOFTWARE DESIGN 297 Only in rare cases will the designer immediately retrieve and apply a design schema which provides the overall and complete design decomposition . Instead , as witnessed in this study , part of the design process will be spent in discovering what is the proper design decomposition for parts of the system and in creating the appropriate design plans . The mixture of applying retrieved software system design schemas and discovering parts of the design decompositions , compounded with the inference of new requirements and evaluation criteria resulting in problem restructuring , contribute to the opportunistic design behaviours observed in this study and in Guindon ( 1990 ) . Critical differences between novices and experts are likely to be found in the breadth and depth of the design schemas they bring to bear . Nevertheless , the iil ~ of problems in the early stages of designs will require structuring - - inferences of new goals and evaluation criteria - - making the application of a top - down approach difficult even for experts . Design schemas are one source of knowledge that can powerfully constrain the search for a solution . Presumably , a designer working under limited time and other resources ( whether in the field or in the lab ) will naturally prefer reusing a solution that is familiar and has worked in the past . Designers tend to reuse the same successful solutions over and over in their career . In fact , this is an engineering design principle : reuse existing tested designs instead of creating new ones . Once a promising design schema is retrieved , the designer is not likely to consider alternative overall solutions , especially if he has to develop them from first principles . This may contribute to a ubiquitous behaviour observed in this study : designers tend to elaborate only one main design idea , usually selected quite early in the design process , with few major changes to the basic design idea , and very little substantial development of alternative solutions ( Kant & Newell , 1984 ; Darke , 1984 ; Ullman et al . , 1987 ) . 3 . 6 . PROBLEM SOLVING AND DESIGN HEURISTICS Design has been described as a guided search - - - only the most promising search paths can be pursued . Design solutions are satisfactory , as opposed to optimal , because it is too expensive or impractical to generate all the alternative design solutions and because no objective metrics usually exist to evaluate the alternative solutions ( Simon , 1981 ) . Designers relied on various heuristics to guide the search for information about the problem structure and for a design solution . The most frequent heuristics observed in the protocols are given below , with examples . The heuristics are presented roughly in order of increasing specificity of software design : ( 1 ) Consider a Simpler Problem - - Assume Smaller Number of Objects , Relation - ships , Behaviours , Constraints , and Then Later Expand the Solution ( e . g . Consider the problem of one lift , then of N lifts ) . ( 2 ) Simulate Scenarios in the Problem Domain To Acquire More Information About the Problem Structure ( e . g . Seek insights about the relationships between floor and lift requests by simulating Lift scenarios ) . ( 3 ) Identify System Functions That Can Be Performed Nearly Independently and Divide the System into Corresponding Subsystems ( e . g . Divide the problem into 298 R . GUINDON two independent systems , one for handling the lift requests and another for handling floor requests ) . ( 4 ) Concentrate on Avoiding Serious Mistakes or Catastrophes ( e . g . Concentrate on avoiding the situation where all lifts break down at the same time ) . ( 5 ) Concentrate on Satisfying the Most Important Constraints or Requirements First ( e . g . concentrate on satisfying first the desired requirement of high level of reliability ) . ( 6 ) Keep the Design Solution as Simple as Possible ( e . g . Other things being equal , move as much of the control to the overall lift system controller rather than to the individual lifts ) . ( 7 ) Make Reasonable Simplifying Assumptions About the Requirements ( e . g . Assume that the emergency button can only be cleared by a maintenance person , so clearing the emergency button need not be included in the algorithm ) . ( 8 ) Keep the Solution Parts as Consistent as Possible ( e . g . The solution of Designer 1 for sending floor requests to lifts in motion differed from his solution for sending floor requests to stationary lifts . He noted the inconsistency as undesirable and revised his partial solutions to make them consistent ) . ( 9 ) Delay Firm Commitment To a Design Decision When There Is Insufficient Information and Re - Examine Tentative Decisions as Information Is Later Acquired . An aspect of the control of the design process is delaying firm commitment to a design decision and re - evaluating tentative commitments as additional information is acquired . For instance , new requirements may be inferred which affect an earlier tentative decision , inducing the designer to revisit this tentative decision . The next section presents a converse to this heuristic . Previous cognitive studies of design have not detailed the various heuristics used by designers , and this study has only described a few of them . The nature and impact of these heuristics , however , seem to be an important area of future research . Critical differences between experts and novices are likely to be found in the heuristics they use . 3 . 7 . PREFERRED EVALUATION CRITERIA As mentioned earlier , ill - structured problems , such as design problems , are characterized by the lack ofa stopping rule and by an incomplete specification of the goals . The designers in this study circumvented this problem by adopting , very early in the session , a small set of personalized criteria that guided the search for a solution and the selection of a satisfactory solution . We call this small set of criteria their preferred evaluation criteria . Designer 2 adopted as a preferred evaluation criterion , high reliability . This criterion was not stated in the requirements and constitutes an added requirement ( Figure 5 ) . He used this preferred criterion to select , very early on , distributed control and communication schemes and to reject a centralized scheme . He continued using this criterion throughout the session when he retrieved alternative solutions for further subproblems . His preferred evaluation criterion very effectively reduced the set of possible designs to consider and was a primary guide in searching for a satisfactory design solution . Designer 1 stressed simplicity of solution when selecting from alternative solutions . Designer 3 emphasized simplicity of the design EXPERT KNOWLEDGE USED IN SOFTWARE DESIGN 299 process . Darke ( 1984 ) found similar results in a study of architectural design and labelled these criteria the " primary generator " . The term " primary position " has been used in earlier papers to refer to the preferred evaluation criteria ( Guindon et ~ l , 1987 ; Guindon & Curtis , 1988 ) . Preferred evaluation criteria , if wisely selected , can effectively reduce the daunting complexity of the design process , without imposing constraints that are too binding on the design solution . However , the need to reduce the complexity of a problem may also mean that designers commit themselves early to wrong choices that . are difficult to recover from later on . Delaying commitment until more constraints on the design have been uncovered might be more desirable ( see Pearl , 1984 ; Thimbleby , 1988 ) . In fact , immediately following a top - down approach is an instance of an early commitment since it presupposes that an overall solution decomposition has already been adopted . However , this early commitment may not be suited for ill - struc : ared problems , with incompletely specified goals and with novelty . Instead , as was argued by Mills ( 1986 ) and other practitioners , the benefits of the top - down approach can only be gained after some exploration and backtracking , Indeed , expert designers working with an ill - structured problem have exhibited frequent deviations from the top - down approach ( Guindon , 1990 ) . Thus , further studies should investigate whether a critical difference between experts and novices is in the selection of good , preferred evaluation criteria . Another difference might be in the balance between early adoption of a design schema and its solution decomposition and delayed commitments to permit problem exploration and restructuring . 4 . Discussion This study addressed the process of system design and focused on high - level design , as opposed to detailed design . The designers ' process was characterized by the integration and coordination of multiple domains of knowledge . The main findings from this study are now summarized . Designers used their problem domain knowledge by retrieving or simulating scenarios in the Lift domain . These scenario simulations were interleaved with solution development throughout the design session . The simulations were exploited to understand the requirements , to infer new requirements leading to problem restructuring , and to develop the design solution by discovering partial solutions at various levels of abstraction in the solution decomposition . All designers inferred new requirements , whether necessary consequences from the information given or simply plausible ones . These inferred requirements led to problem restructuring , in particular , the inferences of new goals and of new evaluation criteria . These inferences occurred throughout the design session , inter - leaved with solution development . These inferences constitute an inherent aspect of high - level design consequent to the incompleteness and ambiguity of its problem specification . A special case of added requirements is the inference of preferred evaluation criteria . The designers in this study produced widely different design solution decomposi - tions , in contrast with the findings of Jeffries et al . ( 1981 ) . The greater complexity of the Lift problem compared with the book indexing problem is probably responsible 300 R . GLIINDON for this difference . As found in previous studies , designers adopted a kernel solution very early in the session and did not elaborate any alternative solutions in . depth . If designers retrieved alternative solutions for a subproblem , they quickly rejected all but one alternative by a trade - off analysis using a preferred evaluation criterion . Moreover , solution development was best characterized as opportunistic . The interaction between the ill - structuredness of problems in the early stage of design and data - driven processing in experts likely contributes to the opportunistic character of the observed process . Mental simulations of the design solutions were shallow , that is , mostly restricted to one le - . cl of abstraction and one subsystem . This phenomenon was attributed to working memory limitations which prevent keeping in memory the values in the context of a subsystem calling another subsystem at a lower level of abstraction . A similar phenomenon is well - known in the processing of sentences with embedded subsentences . Therefore , mental simulations of the overall solution could not be performed , rather partial solutions within the overall solution . Software tools are needed to alleviate this problem . We observed that a critical source of knowledge used to guide the search for a solution is a repertoire of design strategies , methods , and notations . These are not restricted to top - down design , and also include data - structured and object - oriented design . The strategies , methods , and associated notations provide the designers the knowledge of sequences of operators and associated control knowledge for the transformation from an informal specification to a design solution . In fact , search was observed not only for the design solution but also for which design method to apply . Designers not only used general problem - solving schemas such as divide - and - conquer , but also used more powerful and specialized software design schemas . These schemas provided the designers with sets or sequences of operators to produce the design solution . The specialized design schemas varied in level of granularity , from simple rules to complex schemas that defined the overall high - level decomposition for a class of systems . These complex software system schemas appeared to be abstracted from previously developed software systems with similar structures but in different problem domains . The software system schemas did not necessarily impose a strict order in which to develop each of the subsystems , since they tended to be independent of each others . The software design schemas induced top - down processing , and as a consequence , contributed to a systematic design process . However , because of the novelty intrinsic in design problems , the design process was also a combination of applying retrieved software schemas and creating new schemas to handle the novelty . This contributed to the observed opportunistic character of the design process . Designers exhibited the use of a large set of general problem solving and software design heuristics in guiding the search for a design solution and the selection of a satisfactory solution . For instance , the designers postponed firm commitment to design decisions when necessary information was lacking . Since design is a guided search under conditions of scarce resources , critical differences between experts and novices are likely to be found in the heuristics they use . Design problems are characterized by the lack of a stopping rule and by an incomplete specification of the goals . Designers circumvented this problem by EXPERT KNOWLEDGE USED IN SOFTWARE DESIGN 301 adopting very early in the session , a small set of personalized criteria which guided the search for a solution and the selection of a satisfactory solution . We called this small set of criteria their preferred evaluation criteria . If they are wisely selected they act as a powerful mechanism to tame the complexity of the design process . The selection of effective preferred evaluation criteria is likely to differentiate experts from novices . This study has only scratched the surface in describing the knowledge domains designers bring to bear , and how they exploit them . However , individual differences between experts and differences between experts and novices are likely to be caused , in great part , by differences in specialized knowledge . Thus , for instance , studies Of the design heuristics , software design schemas , and preferred evaluation criteria used by experts and novices are promising areas of future research . Studies such as this one will help map the road to understanding the development of expertise . 4 . 1 . IMPLICATIONS FOR DESIGN ENVIRONMENTS The results and observations in this study suggest the following general implications for computational environments to support the design process . Designers ' access to problem domain knowledge should not be restricted to a phase preceding design activities . Rather , it should be continuous throughout the design process , possibly through greater and closer contacts with the customers and the users . Scenarios of operations of the software system seem to be the preferred form of expression of this knowledge . Problem domain knowledge could also be stored in libraries of scenarios easily accessible to the designers . The representation languages in the design environment should support a smooth progression from requirements usually expressed informally , to design decisions expressed formally or semi - formally . The environment should support easy editing and reorganization of the requirements , design issues , and design decisions as the incompleteness and ambiguity of the problem specification get reduced through the design process . Designers experience great difficulties in simulating their high - level design solutions . Design solution simulations are most often restricted to one level of abstraction and one subsystem . Design languages and graphical visualization tools should be provided to the designers to alleviate these difficulties and permit better evaluation of the correctness and completeness of their designs . A library of reusable software design schemas , which could easily be retrieved by giving high - level descriptions of the problems may help bridge the gap between novices and experts . It may also provide experts with a richer repertoire of alternative designs to alleviate early commitments to a particular solution . The software design schemas provide a well - motivated decomposition of design problems into subproblems . The schemas would be for classes of problems like communica - tion systems , inventory control systems , scheduling , distributed systems , tracking systems . Lubars ( 1987 ) and Lubars and Harandi ( 1987 ) have provided examples of such design schemas and libraries . The design schemas could be accompanied with examples of their use in terms of application domains . The library of reusable design schemas could also be used as a training tool . 302 R . GUINDON To combat the ubiquitous early commitments to design solutions , tools should be provided to encourage the designer to explore and compare alternative solutions . A tool such as glBIS is promising in this regard ( Conklin & Begeman , 1988 ) . It provides facilities to represent design issues or problems , their alternative solutions , their pros and cons , and their interrelationships . These facilities support exploration of alternative design solutions and their consequences . The design environment may also embody the design process heuristics observed in experts , such as " allocate more resources to the most critical requirements " . The environment might monitor , at some level , the design process to critique and provide suggestions to the designers . Detailed studies and descriptions of the specialized knowledge brought to bear by experts are needed to map the road to understanding expertise and to build better tools to support experts and novices . This study has provided observations on how experts exploit their specialized knowledge during design . These observations have helped understand better what is expertise in design and helped make recommenda - tions for better design tools . Joyce Conner has performed a thorough and insightful analysis of the protocols . I thank Herb Krasner for collecting the protocols . Jeff Conklin , David Bridgeland , Mitch Lubars , and Herb Krasner all participated in the preliminary analyses of the protocols , bringing the different viewpoints from their respective areas of expertise . Ruven Brooks , Glenn Bruns , Jeff Conklin , Bill Curtis , Jonathan Grudin , Frank Italasz , Clayton Lewis , Patrick Lincoln , Mitch Lubars , and Judith Olson provided many useful comments on an earlier version of this paper . Patrick Lincoln also provided special help in text formatting using LATEX . Noreen Garrison and Nancy Gore helped the editing for syntax , style , clarity , and structure . References ADELSON , B . ( 1988 ) . A model of software design . In M . T . H . Cm , R . GLASER & M . FARR , Eds . , The Nature Of Expertise , pp . 185 - 208 . IJillsdale , N . J . : Erlbaum . ADDFt . SON , B . & SOLOWAY , E . ( 1984 ) . A Cognitive Model of Software Design ( Technical Report 342 ) . Department of Computer Science , Yale University . ADEt . SON , B . & SOLOWAY , E . ( 1985 ) . The role of domain experience in software design . IEEE Transactions on Software Engineering , 11 , 1351 - 1360 . ANDERSON , J . R . ( 1982 ) . Acquisition of cognitive skill . Psychological Review , 89 , 369 - 406 . ANDERSON , J . R . ( 1983 ) . The Architecture of Cognition . Cambridge , MA : Harvard University Press . CARROLL , J . M . , TIIOMAS , J . C . & MALttOTRA , A . ( 1979 ) . Clinical - experimental analysis of design problem solving . Design Studies , 1 , 84 - 92 . CONKLIN , J . & BEGEMAN , M . ( 1988 ) . gIBIS : A tool for exploratory policy discussion . Proceedings of Computer - Supported Cooperative Work 88 , 140 - 152 , New York : ACM . DARKF , J . ( 1984 ) . The primary generator and the design process . In NmEL CROSS , Ed . , Developments in Design Methodology . New York : Wiley & Sons . DuNN , R . ( 1984 ) . Software Defect Removal . New York : McGraw - Hill . EGAN , D . E . & SCHWARTZ , B . J . ( 1979 ) . Chunking in recall of symbolic drawings . Memory & Cognition , 7 , 149 - 158 . FAmLEY , R . E . ( 1985 ) . Software Engineering Concepts . New York : McGraw - Hill . FRAZmR , L . & FODOR , J . D . ( 1978 ) . The sausage machine : A new two - stage parsing model . Cognition , 6 , 291 - 325 . GmNDON , R . ( 1989 ) . The process of knowledge discovery in design . Proceedings of HCI ' 89 International . Amsterdam : Elsevier Science Publishers . EXPERT KNOWLEDGE USED IN SOFTWARE DESIGN 303 GUINDON , R . ( 1990 ) . Designing the design process : Exploiting opportunistic thoughts . Human - Computer Interaction , 5 . GUINDON , R . & CURTm , B . ( 1988 ) . Control of cognitive processes during software design : What tools would support software designers ? Proceedings of the CH ! ' 88 Conference on Human Factors in Computer Systems , pp . 263 - 286 . New York : ACM . GUINDON , R . , KR ^ SNER , H . & CUR ' nS , B . ( 1987 ) . Breakdowns and processes during the early activities of software design by professionals . In G . OLsoN , E . SOLOWAV & S . SHEPPARD , Eds . , Empirical Studies of Programmers , Second Workshop . Norwood , N . J . : Ablex Publi - ~ fing . HAVF . s - RoTH , B . & HAVES - RoTH , F . ( 1979 ) . A cognitive model of planning . Cognitive Science , 3 , 275 - 310 . HIN ' nKKA , J . ( 1987 ) . A note on anaphoric pronouns and information processing by humans . Linguistic Inquiry , 18 , 111 - 119 . JACKSON , M . ( 1983 ) . System Development . Englewood Cliffs , N . J . : Prentice ltall . JEi - ' FP , IES , R . , TURNER , A . A . , POLSON , P . & ATWOOD , M . E . ( 1981 ) . The processes involved in designing software . In J . R . ANDERSON , Ed . , Cognitive Skills and Their Acquisition , pp . 225 - 283 . Hillsdale , N . J . : Erlbaum . KANT , E . & NEWELL , A . ( 1984 ) . Problem solving techniques for the design of algorithms . Information Processing and Management , 28 , 97 - 118 . LARKIN , J . It . ( 1981 ) . Enriching formal knowledge : a model for learning to solve textbook problems . In R . R . ANDERSON , Ed . , Cognitive Skills And Their Acquisition . Hillsdale , N . J . : Erlbaum . LARKIN , J . H . , McDERMOT ' i ' ) J . , SIMON , D . P . & SIMON , It . A . ( 1980 ) . Expert and novice performance solving physics problems . Science , 208 , 1335 - 1342 . LARKIN , J . H . & SIMON , H . A . ( 1987 ) . Why a diagram is ( sometimes ) worth ten thousand words . Cognitive Science , 11 ) 65 - 100 . LUBARS , M . T . ( 1987 ) . Schematic techniques for high level support of software specification and design . Proceedings of the Fourth International Workshop on Software Specification and Design , pp . 68 - 75 . Los Angeles , CA : Computer Society , Press of IEEE . LUBARS , M . T . & HARANDI , M . T . ( 1987 ) . Knowledge - based software design using design schemas . Proceedings of the Ninth International Conference on Software Engineering , pp . 253 - 262 . New York : ACM . MALIIOTRA , A . , THOMAS , J . C . , CARt ~ OLL , J . M . MILLER , & L . A . ( 1980 ) . Cognitive processes in design . International Journal of Man - Machine Studies , 12 , 119 - 140 . McKEmmN , K . B . , RErrMAN , J . S . , RUETER , H . H . & HmTLE , S . ( 1981 ) . Knowledge organi - zation and skill differences in computer programmers . Cognitive Psychology , 13 , 307 - 325 . MEYER , B . ( 1985 ) . On formalism in specifications . IEEE Software , 2 , 6 - 26 . MILLS , It . D . ( 1986 ) . Structured programming : Retrospect and prospect . IEEE Software , November , 58 - 66 . NEWELL , A . ( 1969 ) . Heuristic programming : Ill - structured problems . In J . ARONOFSKV , Ed . , Progress in Operations Research , pp . 362 - 414 . New York : John Wiley & Sons , Inc . Nit , H . P . ( 1986 ) . Blackboard systems : Blackboard applications systems , blackboard systems from a knowledge engineering perspective . The A ! Magazine , August , 82 - 106 . PARNAS , D . L . & CLEMENTS , P . C . ( 1986 ) . a rational design process : How and why to fake it . IEEE Transactions on Software Engineering , 12 , 251 - 257 . PEARL , J . ( 1984 ) . Heuristics . Reading , MA : Addison - Wesley . RtH ) . L , H . ( 1972 ) . On the planning crisis : Systems analysis of the first and second generations . Beprifts Konomen , NR 8 , 390 - 396 . RUMELHART , D . E . & NORMAN , D . A . ( 1981 ) . Analogical process in learning . In J . R . ANDERSON , Ed . , Cognitive Skills And Their Acquisition . Hillsdale , N . J . : Erlbaum . SACERDO ' n , E . D . ( 1975 ) . A Structure for Plans and Behavior . ( Technical Report 109 ) . Menlo Park , CA : Stanford Research Institute . Sn ~ , ON , H . A . ( 1973 ) . The structure of ill structured problems . Artificial Intelligence , 4 , 145 - 180 . Sn , tON , It . A . ( 2nd Ed . ) . ( 1981 ) . Sciences of the Artificial . Cambridge , MA : MIT Press . ( Originally published , 1969 ) . 304 R . GUINDON SOLOWAY , E . , ADELSON , B . & EHRLICH , K . ( 1988 ) . Knowledge and processes in the comprehension of computer programs . In M . T . H . CIH , R . GLASER & M . FARR , Eds , The Nature Of Expertise , pp . 129 - 152 . Hillsdale , N . J . : Erlbaum . SWARTOLri , " ~ Jr & BALZER , R . ( 1982 ) . On the inevitable interwining of specification and implementation . Communications of the A CM , 25 , 438 - 440 . TIHMBLEBY , H . ( 1988 ) . Delaying commitment . IEEE Software , 78 - 86 . ULLMAN , D . G . , STAUFFER , L . A . ~ DIETTERICII , T . G . ( 1987 ) . Toward Expert CAD . Computers in Mechanical Engineering . Nov . - Dec . 32 - 45 .