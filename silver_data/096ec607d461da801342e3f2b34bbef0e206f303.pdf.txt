Session 12c6 0 - 7803 - 5643 - 8 / 99 / $ 10 . 00 © 1999 IEEE November 10 - 13 , 1999 San Juan , Puerto Rico 29 th ASEE / IEEE Frontiers in Education Conference 12c6 - 11 Integrated Development Environment for a Microcontroller Systems Laboratory Manuel A . Pérez - Quiñones and José L . Cruz - Rivera Department of Electrical and Computer Engineering University of Puerto Rico - Mayagüez Mayagüez , Puerto Rico Email : mperez | jcruz @ ece . uprm . edu Abstract - The MC68HC11 is one of the most popular mi - crocontroller families in existence . Software simulators and development boards are routinely used in undergraduate education in order to familiarize students with MC68HC11 applications development . Simulators offer graphical user interfaces that allow students to visualize all the inner workings of the MC68HC11 . Development boards provide all the necessary tools to write code for the MC68HC11 and to interface physical devices to the chip . Unfortu - nately , development boards used in academia ( e . g . , MC68HC11 EVB ) rely on command - line driven interfaces that result in steep learning curves that must be overcome in the course of an academic quarter or semester . This situation has led many academic institutions to opt for the use of simulators rather than development boards in their courses . The problem with this approach is that software simulators do not allow students to experience the issues that arise in the software - hardware integration step of mi - crocontroller - based system implementations . In order to address this situation , we have designed an integrated de - velopment environment ( IDE ) for MC68HC11 that uses a Graphical User Interface to interact with a low - level devel - opment board debugger ( Buffalo Monitor ) . The IDE seeks to improve on the drawbacks of the simulator and com - mand - line interfaces by implementing an easy to use graphical user interface to the most common commands used by the students in our Microprocessors course . This paper presents the design and implementation of the first prototype of this IDE . Also the paper presents the results of a preliminary evaluation of the IDE and plans for future extensions . Introduction The MC68HC11 family includes a wide range of chips with various types of on - chip peripheral units . A typical chip has an 8 - channel , 8 - bit ADC , 16 - bit timer unit with input capture , output compare , overflow interrupt , COP watch - dog , real time interrupt , and pulse accumulator functions , a serial communications interface , and a serial peripheral interface . The 68HC11’s simple instruction set architecture makes it ideal for undergraduate instruction . Software simulators and development boards are rou - tinely used in undergraduate education in order to familiar - ize students with MC68HC11 applications development . Simulators allow the user to write code for the microcon - troller system and to step through the code for debugging purposes . Simulators typically provide a graphical user interface that shows the contents of all major registers and memory locations of the system . Typical debugging opera - tions , such as dynamically changing the contents of particu - lar memory locations or registers are also supported . Sin - gle - instruction trace operations are typically provided as well as continuos operation with breakpoint assignments . A screen - shot of an excellent 68HC11 simulator available through the Internet is presented in Figure 1 . David Jones of RMIT supports this simulator ( http : / / dj . cse . rmit . edu . au / Simulator / ) . Figure 1 Screenshot of a 68HC11 simulator program . While simulators are very useful for debugging code , they are limited in terms of system debugging . That is , simulators do not allow issues such as real time interrupts to be modeled reliably . Hence , code that is deemed to be fully operational during simulation may fail during the software - hardware integration phase . Evaluation boards provide a very useful environment for software - hardware integration testing and evaluation . The evaluation board environment provides the user the ability to debug microcontroller code Session 12c6 0 - 7803 - 5643 - 8 / 99 / $ 10 . 00 © 1999 IEEE November 10 - 13 , 1999 San Juan , Puerto Rico 29 th ASEE / IEEE Frontiers in Education Conference 12c6 - 12 while the microcontroller is connected to the system under test . The programmer writes code for the target system us - ing a host computer . The code is then compiled or assem - bled and downloaded to the evaluation board . All the I / O lines of the microcontroller on the evaluation board are brought out to the periphery via a set of pins on a header connector . These lines are physically connected to the tar - get peripherals . The MC68HC11 EVB ( Evaluation Board ) is one of the most popular boards in existence . The EVB is used exten - sively in undergraduate courses throughout the world . The EVB includes a 68HC11 chip , 8K of EPROM , 8K of RAM , serial and parallel ports , download capability from a host computer , and an on - board monitor / debugger program called Bit User Fast Friendly Aid to Logical Operations ( BUFFALO ) . BUFFALO The BUFFALO monitor provides commands that allow the user to write programs , check the contents of memory , reg - isters , and I / O ports and to modify them as needed . A screenshot of the BUFFALO Memory Display command ( MD ) is shown in Figure 2 . The MD command takes two hexadecimal memory addresses as its arguments and dis - plays the contents of these locations on the screen . A sample of other Buffalo commands is presented in Table 1 . Clearly , simulators allow a more direct path towards learn - ing in the classroom . While development boards provide a more meaningful design experience . What is currently lack - ing is a hybrid approach where a development board system would be used with a simulator - like graphical user interface ( GUI ) for the monitor / debugging program . Figure 2 Memory Display command in BUFFALO . Some of the interactions with BUFFALO can be very cumbersome . For example , the LOAD command requires several steps that give new students a lot of trouble in the early stages of the semester . The sequence of steps to load a program to the MC68HC11 board using BUFFALO in - cludes running Kermit to establish the connection to BUF - FALO , issuing the LOAD command , then “escaping” back to local mode to send the contents of the compiled file via the serial port , and finally activating Kermit again . The previous sequence has to be done every time the program is compiled and needs to be downloaded to the board . This is a source of errors for students , and these er - rors usually take the student away from the edit - compile - run cycle that is part of the development task . Table 1 Sample Buffalo Commands . COMMAND DESCRIPTION BF < Addrress1 > < Address2 > < data > Block fill memory with data BR [ - ] [ < Address > ] … Breakpoint Set BULK Bulk erase EEPROM G [ < address > ] Execute program LOAD < T > Download ( S - records ) via terminal port MD [ < address1 > ] [ < address2 > ] Dump memory to ter - minal MM [ < address > ] Memory Modify P Proceed / continue from breakpoint RM [ p , y , x , a , b , c , s ] Register modify T [ < n > ] Trace $ 1 - $ FF instruc - tions IDE for BUFFALO In order to bridge the gap between the simulator and low - level monitor functionality , we have developed an inte - grated Development Environment ( IDE ) for BUFFALO . Our IDE provides a graphical user interface to the function - ality provided by BUFFALO . This was a conscious design decision on our part to save us the detailed ( and somewhat tedious ) work of defining a low - level monitor when one already exists . But it also allows us to have a simple console like window where students can interact with BUFFALO directly . Thus our system provides both , a GUI with the characteristic advantages of such a system and the low - level control of BUFFALO . Table 2 BUFFALO Most Used Commands . COMMAND VOTES LOAD < T > 19 MD 18 MM 18 BR 17 G 17 T 15 ASM 9 Others Less than 3 votes each Session 12c6 0 - 7803 - 5643 - 8 / 99 / $ 10 . 00 © 1999 IEEE November 10 - 13 , 1999 San Juan , Puerto Rico 29 th ASEE / IEEE Frontiers in Education Conference 12c6 - 13 The IDE was designed to cover the most commonly used commands by our students as they solved their pro - gramming assignments in the Microcomputer Interfacing course . The initial set of commands was determined by in - formal interviews with the students working in this project and with the class professors . Recently we conducted a sur - vey among students enrolled in this course during the Spring semester of 1999 to validate our initial set . Nineteen students identified the most commonly used BUFFALO commands from a table of all the commands available . Ta - ble 2 shows the most commonly used commands . The students were also asked to select which of memory modify , setting breakpoints , and downloading programs gave the students the most trouble , 10 responded break - points , 3 memory modify and 2 program download . Only 2 responded none of the above . The results confirm our initial intuition , the most often used commands were loading the object file to the board ( LOAD < T > ) , setting breakpoints ( BR ) , executing the pro - gram ( G ) , and commands associated with memory manipu - lation ( MM , MD , and RM ) . Curiously enough , some of these were also the most troublesome commands ( e . g . breakpoints ) . Finally , the design of the IDE is based on similar graphical user interfaces previously designed by one of the co - authors for other educational - oriented development envi - ronment [ 1 , 2 ] The previous IDEs have been well received and used in many university laboratories . Graphical User Interface The IDE for BUFFALO translates user actions into the appropriate sequences of BUFFALO commands . For exam - ple , in RIDE Buffalo double - clicking in a line of code within the source listing window sends BUFFALO the command for setting a Breakpoint at the line ( see below for more details ) . This approach of providing a graphical user interface that produces text commands for an underlying system is typical of this type of debugger [ 5 ] . Figure 3 Graphical User Interface with Internal Windows The IDE for BUFFALO is implemented in Java . It uses a class with Java Native Interface ( JNI ) to communicate via the serial port with the Buffalo monitor on the lab work - station 1 . JNI is a technology in Java that allows Java classes to call native code , usually written in C or C + + . This makes the project less portable than if it were written entirely in Java , but it does allow a Java application to have access to the hardware of a machine in a somewhat portable way . An extra layer of object oriented software around the low - level communication classes allows the Java program to be divided into two layers . The low - level layer communi - cates with the Buffalo monitor . The higher level layer com - municates with this lower layer via Java ' s Remote Method Invocation ( RMI ) . This allows the possibility for the IDE to be a remote program run from any Java - compatible platform ( more details about this in the Future Work section ) . RMI is another technology supported by Java that allows objects in one executable environment to send messages to objects in a separate executable environment . These two environments could exist in the same computer or across the network . In Java’s implementation , RMI allows to objects to send messages to each other across the Internet , with all communication processing handled inside of the Java RMI implementation . The IDE includes several internal windows , each of which shows the source listing , memory ( RAM ) , processor registers and status of ports . Internal windows are new in Java’s Graphical User Interface v1 . 2 , but are standard in MS Windows . A screenshot of the whole interface can be seen in Figure 3 . The next sections describe the different windows with the BUFFALO commands implemented in each of them . 1 This class was downloaded from the web . Session 12c6 0 - 7803 - 5643 - 8 / 99 / $ 10 . 00 © 1999 IEEE November 10 - 13 , 1999 San Juan , Puerto Rico 29 th ASEE / IEEE Frontiers in Education Conference 12c6 - 14 Display of source listing The source listing display shows the output of the assem - bler ( Figure 4 on the next page ) . This is done when the user loads a compiled program into the board . This listing is also functional , as it allows the user to step through the program , it shows the next instruction to be executed ( i . e . the instruction identified by the program counter ) . It also contains at the top the controls to allow the student to trace through their program . The trace controls allow the student to provide the number of instructions to be “stepped” in each trace command ; this implements the TR command of Buffalo . The Go bottom allows the student to beginning execu - tion from a set address , specified in the field box next to the button . This has the functionality of the G command in Buffalo . Double clicking in a source line sets a breakpoint at the address associated with the instruction . The currently - set breakpoints are shown at the bottom of the window . This implementation extends the BR command in Buffalo by continuously showing the current set of breakpoints . Finally , this window contains the functionality to allow students to download compiled code to the MC68HC11 board . The IDE remembers the last file downloaded , thus after each compilation all the student needs to do is click the Upload button at the bottom of the window and the IDE will initiate the download . Figure 4 Source Listing Window Display of the MC68HC11 Memory The Memory window ( Figure 5 ) allows the student to look into memory 256 words at a time . This memory view can be updated at any time by the student by clicking the “Update” button , but it is also automatically updated after a Trace or Go command . The student can select the starting address of memory from where to show the 256 words . Figure 5 Memory Window The memory contents are shown in hexadecimal , bi - nary and decimal . Double clicking in a memory position allows the student to change the value of the memory loca - tion . This is done by sending the memory modify ( MM ) to Buffalo . Display of the Processor Registers The processor registers give a view into the internals of the MC68HC11 . Most students programs will manipulate these registers . The Processor Registers window ( Figure 6 ) shows the value of the registers as well as it allows the student to modify those registers that the Buffalo monitor allows change ( e . g . p , y , x , a , b , c , s ) . Modifying the registers is done with a double - click , much like in the memory display . The “Udpate” allows the user to query the Buffalo monitor to get the latest values of the processor registers . Session 12c6 0 - 7803 - 5643 - 8 / 99 / $ 10 . 00 © 1999 IEEE November 10 - 13 , 1999 San Juan , Puerto Rico 29 th ASEE / IEEE Frontiers in Education Conference 12c6 - 15 Figure 6 Processor Register Window Preliminary Evaluation With this first version completed , we carried out a simple preliminary evaluation of our design and implementation . During the last week of the Spring 1999 semester , the IDE was installed in all the laboratory computers in our Micro - processor Interfacing lab . The students were asked to use with the new IDE for a week , as they completed their final projects . They were given a questionnaire to obtain their impressions and comments about the new IDE . Results from this preliminary evaluation show that the IDE will be beneficial to the students in the Microprocessor Interfacing course . Of 15 students asked , all agreed that the IDE is a vast improvement over the use of BUFFALO for their class work . Nine of 15 thought they should have been able to complete their projects faster using the IDE . Their overall comments on the IDE were very positive . One student liked the ease of loading the program into BUFFALO . Two students liked the new way of interacting with the breakpoints . Almost all of them ( 14 ) liked the new way of displaying the registers and memory . Many liked the automated display of values after the execution of a trace . Many liked the display of the registers in hex and binary , and many like the easy way of editing memory values . One area that we still have not addressed is the display of and interaction with the status ports of the MC68HC11 . Many students requested this feature for future releases . Future Work There are several areas that we will like to expand this IDE . We are currently designing three major updates to the IDE . The udpates will address the status ports window , the re - mote accessibility of the IDE , and the integration of running the compiler or assembler from the IDE . This section de - scribes these briefly . Display of Port Registers The MC68HC11 has 5 major ports named Port A , Port B , Port C , Port D , and Port E . These ports have data registers and a number of control registers associated with them . The Ports window will allow the student to see the different settings of these port registers . The information of the ports will be displayed in binary , hex and decimal formats . A brief map of the ports will be provided to help the students decipher the meaning of each bit in the ports . Remote Accessibility of the IDE Originally , the IDE for Buffalo was designed to allow a Lab PC connected to a MC68HC11 EVB to be accessed via a graphical user interface from a remote PC ( see Figure 7 ) . The user was to be able to establish a connection through the Internet to the Lab PC and to the EVB connected to it . The EVB is in turn connected to various typical peripherals that form part of various experiments outlined in a home - brewed laboratory manual . This situation was considered ideal for students in one of our earlier courses , that might not have the experience with connecting devices to the EVB . A predefined set of kits would be connected on this PC ( see Figure 8 ) and the students would only have to write the software to interface with these devices . Remote PC Remote PC Lab PC Lab PC WWW MC68HC11 EVB MC68HC11 EVB WebCAM System Under Test Figure 7 Web - based Virtual Lab Setup A typical lab session would take place as follows . The user schedules time on the lab station via a calendar man - ager and a webcam allows the user to monitor the system under test , as shown schematically in Figure 7 . For exam - ple , a lab assignment may involve the development of an assembly program that will interface the MC68HC11 to a LCD display . The student would develop and debug the program remotely and use the visual feedback to determine whether the software - hardware integration has worked . The currently implemented lab station is shown in Figure 4 . This station consists of a 4 x 40 Liquid Crystal Display , a 4 digit LED display , an LM 135 temperature sensor , and a stepper motor . Session 12c6 0 - 7803 - 5643 - 8 / 99 / $ 10 . 00 © 1999 IEEE November 10 - 13 , 1999 San Juan , Puerto Rico 29 th ASEE / IEEE Frontiers in Education Conference 12c6 - 16 Figure 8 System Virtual Lab Setup An issue that must be dealt with is the possibility that the remote system will “hang” . In order to address this is - sue a small RS232 - based circuit will be designed that will be able to listen in to the commands being sent to the EVB . If the user notices that the remote system hangs , a reset but - ton in the GUI will be used to send a special control se - quence that will prompt the circuit to give a hardware reset to the EVB . Integration of Compilation and / or Assembly We have begun studying how to integrate running the com - piler and / or assembler into the IDE . Currently , the student compiles his / her program with either the C compiler or with an assembler . The resulting program in s - records is what is downloaded to BUFFALO . Our IDE picks up from this point . The ideal situation would be to have our IDE call the compiler or assembler by issuing a system call to MSDOS . Once the compilation / assembly is completed , our IDE could automatically download the s - records to BUF - FALO , if no errors were found . Conclusions The IDE for BUFFALO provides students a complete low - level development environment with a nice graphical user interface . This system helps students visualize the inner workings of the MC68HC11 under real operating conditions ( non - simulated ) . Furthermore , the system is designed to allow for remote evaluation of the system under test . It should be pointed out that this project was under - taken with the help of students who had previous experience with the BUFFALO environment and the MC68HC11 EVB . Thus , the developed system takes into consideration many factors that lead to increased software - hardware integration productivity using this microcontroller technology . As part of the project the students gained valuable skills in the de - velopment of JAVA applications ( client , servlet , GUI ) , se - rial communications between computers ( servlet serial communication with BUFFALO ) , remote integrated systems ( Client / Server computing ) , Graphical User Interface Development ( Client / server , front end ) , and technical writing and oral presentation skills . The IDE for BUFFALO is available as freeware to all interested parties from the web page for the Microprocessor Interfacing course at www . ece . uprm . edu / ~ micro2 , follow the link Tools & Links . Acknowledgments The authors would like to acknowledge the University of Puerto Rico’s Industrial Affiliates Program for sponsoring this project , the Motorola Semiconductor Division for pro - viding the MC68HC11 EVBs , the Intel Foundation for pro - viding the development stations and Mr . Juan Ortiz Rodríguez , Mr . Eisen Montalvo and Mr . Joel Viera for de - velping the hardware and software aspects of this project . References [ 1 ] M . B . Feldman , A . Vargas - Lopes and M . A . Pérez ( 1990 ) " Small - Ada : Personal Computer Courseware for Studying Concurrent Programming " , SIGCSE ` 90 Proceed - ings , Washington , DC . [ 2 ] M . B . Feldman , C . W . Kann , A . Vargas - Lopes , M . A . Pérez ( 1994 ) " GW - Ada / Ed : Free Ada 83 Development En - vironments for IBM PC - compatible and Apple Macintosh Computers " , Technical Report , Department of Electrical Engineering and Computer Science , School of Engineering and Applied Science , The George Washington University . [ 3 ] T . Milligan and S . Coffin , “Building intelligence , web - based control systems” Dr . Dobb’s Journal , pp . 56 - 68 , March 1998 . [ 4 ] Motorola , MC68HC11 EVB Evaluation Board User’s Manual , September 1986 . [ 5 ] S . Mukherjea and J . T . Stasko , " Toward Visual debug - ging : Integrating Algorithm Animation Capabilities within a Source - Level Debugger " ACM Transactions on Com - puter - Human Interaction , v 1 , n3 , 1994 , pp . 215 - 244 . [ 6 ] J . C . Skroder , Using the M68HC11 Microcontroller . Prentice Hall . 1997 .