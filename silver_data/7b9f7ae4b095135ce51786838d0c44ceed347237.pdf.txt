HAL Id : tel - 01889927 https : / / tel . archives - ouvertes . fr / tel - 01889927 Submitted on 8 Oct 2018 HAL is a multi - disciplinary open access archive for the deposit and dissemination of sci - entific research documents , whether they are pub - lished or not . The documents may come from teaching and research institutions in France or abroad , or from public or private research centers . L’archive ouverte pluridisciplinaire HAL , est destinée au dépôt et à la diffusion de documents scientifiques de niveau recherche , publiés ou non , émanant des établissements d’enseignement et de recherche français ou étrangers , des laboratoires publics ou privés . Système de Mesure Mobile Adaptif Qualifié Florent Bourgeois To cite this version : Florent Bourgeois . Système de Mesure Mobile Adaptif Qualifié . Modélisation et simulation . Université de Haute Alsace - Mulhouse , 2018 . Français . ￿NNT : 2018MULH8953￿ . ￿tel - 01889927￿ École doctorale pluridisciplinaire Jean - Henri Lambert , n o 494 THÈSE pour obtenir le grade de docteur délivré par l’Université de Haute Alsace Spécialité doctorale : “Informatique” présentée et soutenue publiquement par Florent BOURGEOIS le 21 mars 2018 Système de Mesure Mobile Adaptif Qualiﬁé Directeur de thèse : Jean - Marc PERRONNE Co - encadrant de thèse : Philippe STUDER Jury M . Fabrice Bouquet , Professeur ; Université de Bourgogne Franche comté Rapporteur M . Amir Hajjam El Hassani , Maitre de conférence HDR ; Université de Belfort - Montbéliard Rapporteur M . Jean - Pierre Bourey , Professeur ; Université des Sciences et Technologies de Lille Examinateur M . Philippe Studer , Maitre de conférence ; Universitée de Haute Alsace Examinateur M . Jean - Marc Perronne , Professeur ; Universitée de Haute Alsace Directeur de thèse M . Olivier Grzelak , Chef de Projet ; Actimage GmbH Invité Laboratoire Modélisation Intelligence Processus et Systèmes ( MIPS ) – EA2332 12 rue des Frères Lumière , F - 68093 Mulhouse ( France ) ii Remerciements Avec ce manuscrit se clôt un travail de cinq années . Ce sont cinq années d’expériences scientiﬁques , professionnelles , d’enseignements et person - nelles . J’y ai découvert les métiers de chercheur , d’ingénieur , d’enseignant , d’oncle et de conjoint . J’aime maintenant à dire que la thèse est une aven - ture de la vie professionnelle ; entrecoupée de hauts et de bas intenses . L’enfer s’ouvre sous vos pieds pendant les phases de rédactions ou lors - qu’un verrou technique est abordé . Mais le paradis ouvre ses portes lors de l’acceptation d’un papier ou quand la solution au verrou est trouvée . Plu - sieurs personnes m’ont accompagné durant cette aventure et je tiens à les remercier . Je remercie chaleureusement toutes les personnes qui m’ont aidé pen - dant l’élaboration de ma thèse et notamment mes encadrants . Jean - Marc Perronne , pour ses conseils et sa patience concernant mes travaux de re - cherche , mais aussi pour la conﬁance qu’il a placé en moi en me permettant de rejoindre l’équipe d’enseignement de l’ENSISA . Philippe Studer , pour ses réponses concises toujours judicieuses , sa disponibilité et son accompa - gnement lors de chaque étape de ma thèse . Bernard Thirion , qui m’a donné envie de réaliser une thèse pour devenir enseignant , pour avoir accepté de m’assister tout au long de mes travaux , pour le temps qu’il y a passé et pour nos discussions toujours passionnées . Merci aux doctorants et sta - giaires ( Mariem , Houda , Trung , Heng , Baptiste , Paul , Oleg ) avec qui j’ai découvert de nouvelles cultures , et survécu à de longues journées , aux tem - pératures parfois alarmantes , interrompues par une fermeture venant trop tôt les soirs de deadline . J’ai également une pensée pour tous les collègues de l’ENSISA qui ont su me guider , m’encourager et me vider la tête . Je remercie également Actimage GmbH qui a accepté de me donner la chance de réaliser ces travaux en me guidant vers ce projet . J’ai une pen - sée particulière pour : Olivier , Alexandra et Ashley qui ont pris le temps de m’orienter de répondre à mes questions et calmer mes incertitudes ; Félicien , mon mentor sur les technologies de la pomme vers qui je me tour - nerais , encore aujourd’hui pour résoudre un conﬂit git ; Pierre Arlaud qui a rendu les journées de travail bien plus agréables à l’aide de Bernie Noël , de musiques de tout genre et d’Ecco ; chacun des autres membres de l’équipe qui ont apporté leurs pierres à l’édiﬁce . À tous mes amis , merci d’avoir accepté ces années d’indisponibilité . Mal - gré tout , j’ai vécu de sacrées aventures avec vous . Thibaut , vous m’avez fait découvrir la magie de Nice et le rôle de témoin , une des meilleures signa - tures de ma vie . Bruno , tu n’imagines pas le nombre de repas " taktaktak " que j’ai mangé depuis Besançon ; sans compter nos multiples débats sur iii l’enseignement . Les Haskulls , des WE à Gray , des vacances dans le sud , des scorpions , des Shaka Ponk et des Nightwish . Les GEII ; paradoxalement à la faible distance ; vous êtes ceux qui m’ont le moins vu . Mais je me soigne et nous avons partagé pas mal de grandes nouvelles en septembre . Brendan , que dire de mon ami et coéquipier de l’IUT , de la JMU et de l’ENSISA ? Tu as sûrement été , malgré toi , la personne à m’avoir le plus dirigé vers ce succès . Antoine et Antoine , merci l’un d’avoir été le meilleur coloc’ , l’autre mon partenaire de soirées , de musique et de re - modélisation du monde . Je me tourne maintenant du côté de ma famille . À toute la famille Zucho - wicz , mon second exploit de ces 5 années a été de savoir écrire votre nom . Avec vous tous , j’ai découvert ce qu’étaient les rôles de beau - frère , d’oncle et de gendre . Je ne sais pas si je les joue bien . En tous cas , c’est un plaisir de tous vous compter dans ma famille . Un grand merci à mes oncles , tantes et grands - parents , pour toutes les leçons de vie qu’ils ont pu m’enseigner au cours des nombreux repas , jeux , balades , week - ends et vacances que j’ai pu passer avec chacun d’entre vous . Ainsi qu’à mes cousins et cousines ( et je compte les pièces rapportées , moi ) avec lesquels , on commence à prendre le relais . On a déjà eu un paquet d’aventures ensemble et j’espère bien d’autres à venir . Maman , papa , vous m’avez montré la voie pour que je grandisse . Vous avez su m’accompagner lorsque j’ai commencé à déployer mes ailes et maintenant vous m’accompagnez ﬁèrement vers l’horizon . Merci de m’avoir offert toutes les opportunités qui s’offraient à moi . Je vous en serai toujours reconnaissant . N’oubliez pas que vous aussi vous pouvez compter sur moi maintenant . Paul , qu’est - ce qu’on a pu se chamailler plus jeunes . Mais on est et on reste le meilleur duo de 101 % qui n’a jamais existé ! En plus , tu ne m’as jamais demandé si j’avais bientôt terminé ma thèse . . . Le mot bro n’aura jamais eu autant de sens que là . Maintenant que j’ai terminé ma thèse , ça te tente un petit Borderland ? Enﬁn , jamais cette montagne n’aurait été franchie sans l’aide incondi - tionnelle et les nombreux sacriﬁces de ma petite ﬁancée . Je vais enﬁn deve - nir ton Docteur . Et surtout . . . papa . À tous ceux que j’ai cités , c’est grâce à vous tous que j’ai su devenir la personne que je suis aujourd’hui et que j’ai réussi à aller au bout de ce projet complètement fou qu’est la thèse . Je dédie ce manuscrit à mon grand - père . Il m’aurait certainement dit avec justesse , le regard plein de ﬁerté , cette phrase qui m’a toujours poussé plus loin : Tu as vu là , tu aurais pu faire mieux . iv Résumé Les dispositifs matériels mobiles proposent des capacités de mesure à l’aide de capteurs soit embarqués , soit connectés . Ils ont vocation à être de plus en plus utilisés dans des processus de prises de mesures . Ils présentent un caractère critique dans le sens où ces informations doivent être ﬁables , car potentiellement utilisées dans un contexte exigeant . Malgré une grande demande , peu d’applications proposent d’assister les utilisateurs lors de relevés exploitant ces capacités . Idéalement , ces appli - cations devraient proposer des méthodes de visualisation , de calcul , des procédures de mesure et des fonctions de communications permettant la prise en charge de capteurs connectés ou encore la génération de rapports . La rareté de ces applications se justiﬁe par les connaissances nécessaires pour permettre la déﬁnition de procédures de mesure correctes . Ces élé - ments sont apportés par la métrologie et la théorie de la mesure et sont rarement présents dans les équipes de développement logiciel . De plus , chaque utilisateur effectue des activités de mesure spéciﬁques au domaine de son champ d’activités , ce qui implique le développement d’applications spéciﬁques de qualité pouvant être certiﬁées par des experts . Ce postulat apporte la question de recherche à laquelle les travaux pré - sentés répondent : Comment proposer une approche pour la conception d’applications adaptées à des procédures de mesures spéciﬁques . Les pro - cédures de mesure pouvant être conﬁgurées par un utilisateur ﬁnal . La réponse développée est une " plateforme " de conception d’applica - tions d’assistance à la mesure . Elle permet d’assurer la conformité des pro - cédures de mesures sans l’intervention d’expert de la métrologie . Pour cela elle est construite en utilisant des concepts issus de la métrologie , de l’In - génierie Dirigée par les Modèles et de la logique du premier ordre . Une étude du domaine de la métrologie permet de mettre en évidence la nécessité d’une expertise des procédures de mesure impliquées dans les applications . Cette expertise comprend des termes et des règles assurant l’intégrité et la cohérence d’une procédure de mesure . Un modèle concep - tuel du domaine de la métrologie est proposé . Ce modèle conceptuel est ensuite intégré au processus de développement d’une application . Cette in - tégration se fait par un encodage de ce modèle conceptuel sous la forme d’un schéma des connaissances de la métrologie en logique du premier ordre . Il permet , la vériﬁcation du respect des contraintes inhérentes à la métrologie dans une procédure de mesure . Cette vériﬁcation est réalisée en confrontant les procédures de mesures au schéma sous forme de requêtes . Ces requêtes sont décrites à l’aide d’un langage proposé par le schéma . v Les applications d’assistance à la mesure nécessitent d’exposer à l’utili - sateur un processus de mesure impliquant relevés et afﬁchages de mesures étape par étape . Cela implique de pouvoir décrire un processus de mesure et d’en déﬁnir les interfaces et le schéma d’évolution . Pour cela , un éditeur d’application est proposé . Cet éditeur propose un langage spéciﬁque dé - dié à la description d’applications d’assistance à la mesure . Ce langage est construit à partir des concepts , formalismes et outils proposés par l’environ - nement de méta - modélisation Diagrammatic Predicate Framework ( DPF ) . Le langage comporte des contraintes syntaxiques prévenant les erreurs de construction au niveau logiciel tout en réduisant l’écart sémantique entre l’architecte logiciel l’utilisant et un potentiel expert de la métrologie . Enﬁn , les mobiles doivent pouvoir exécuter un comportement conforme à celui décrit avec l’éditeur . Pour cela , un langage de modélisation d’im - plantations est proposé . Il permet de décrire les procédures de mesures sous la forme de séquences d’activités impliquant des relevés , des calculs et des présentations de valeurs . Les grandeurs sont abstraites par des valeurs numériques , simpliﬁant leurs manipulations et l’utilisation des différents capteurs du marché . Le modèle d’implantation est constitué d’agents . Une application mobile est également proposée . Elle est construite autour d’un framework d’agents , d’un constructeur de réseaux d’agents et d’un moteur d’exécution . Elle prend en entrée un modèle d’implantation , construit le réseau d’agents correspondants et ainsi propose un comportement qui ré - pondra aux besoins de l’utilisateur . Ce qui permet de répondre aux besoins de tout utilisateur , du moment qu’il ait accès au modèle d’implantation , sans pour autant nécessiter de télécharger de nombreuses applications . Les trois outils présentés , l’éditeur de modèles , le schéma de connais - sance de la métrologie et l’application mobile manipulent des modèles dif - férents . Chaque modèle représente un point de vue spéciﬁque sur l’appli - cation . Les concepts de ( méta ) modélisation et de transformation de mo - dèles proposés par l’Ingénierie Dirigée par les Modèles , et plus particuliè - rement DPF , rendent possible l’interopérabilité automatisée des trois outils . La métamodélisation permet l’emploi du modèle conceptuel de la métrolo - gie comme noyau architectural commun aux trois outils . Les transforma - tions de modèles permettent de transposer les concepts d’un modèle vers ceux d’un autre , aﬁn de naviguer entre les différentes vues de l’applica - tion employées par les outils . Cela permet la création d’une " plateforme " de conception d’application simpliﬁant le travail de développement tout en assurant la qualité des applications générée . La valorisation de ces concepts au sein d’un projet industriel est illus - trée par le projet Actinote 4 . 0 d’Actimage GmbH , le partenaire industriel initiateur de ces travaux . vi Abstract Mobile devices offer measuring capabilities using embedded or connec - ted sensors . They are more and more used in measuring processes . They are critical because the performed measurements must be reliable because possibly used in rigorous context . Despite a real demand , there are relatively few applications assisting users with their measuring processes that use those sensors . Such assis - tant should propose methods to visualise and to compute measuring proce - dures while using communication functions to handle connected sensors or to generate reports . Such rarity of applications arises because of the know - ledges required to deﬁne correct measuring procedures . Those knowledges are brought by metrology and measurement theory and are rarely found in software development teams . Moreover , every user has speciﬁc measuring activities depending on his ﬁeld of work . That implies many quality applica - tions developments which could request expert certiﬁcation . This premises bring the research question the presented works answer : What approach enables the conception of applications suitable to speci - ﬁc measurement procedures considering that the measurement procedures could be conﬁgured by the ﬁnal user . The presented works propose a platform for the development of measu - ring assistant applications . The platform ensure the conformity of measu - ring processes without involving metrology experts . It is build upon metro - logy , model driven engineering and ﬁrst order logic concepts . A study of metrology enables to show the need of applications measu - ring process expert evaluation . This evaluation encompasses termes and rules that ensure the process integrity and coherence . A conceptual mo - del of the metrology domain is proposed . That model is then employed in the development process of applications . It is encoded into a ﬁrst order lo - gic knowledge scheme of the metrology concepts . That scheme enables to verify that metrology constraints holds in a given measuring process . The veriﬁcation is performed by confronting measuring processes to the know - ledge scheme in the form of requests . Those requests are described with a request language proposed by the scheme . Measuring assistant applications require to propose to the user a mea - suring process that sequences measuring activities . This implies to des - cribe a measuring process , and also to deﬁne interactive interfaces and sequencing mecanism . An application editor is proposed . That editor uses a domain speciﬁc language dedicated to the description of measuring as - sistant applications . The language est build upon concepts , formalisms and tools proposed by the metamodeling environment : Diagrammatic Predicat vii Framework ( DPF ) . The language encompasses syntactical constraints that prevent construction errors on the software level while reducing the seman - tical gap between the software architect using it and a potential metrology expert . Then , mobile platforms need to execute a behaviour conforming to the editor described one . An implementation modelling language is proposed . This language enables to describe measuring procedures as sequences of activities . Activities imply to measure , compute and present values . Quan - tities are all abstracted by numerical values . This eases their computation and the use of sensors . The implementation model is made up of software agents . A mobile application is also proposed . The application is build upon a framework of agents , an agent network composer and a runtime system . The application is able to consider an implementation model and to build the corresponding agent network in order to propose a behaviour matching the end users needs . This enables to answer to any user needs , considering he can access to the implementation model , without requiring to download several applications . The three tools presented : the application editor , the metrology know - ledge scheme and the mobile application handle different models . Every model represent a speciﬁc point of view on the application . Concepts of ( meta ) modelling and model transformations proposed by Model Driven En - gineering , especially those of DPF , enables automated interoperability of those three tools . Metamodelling enable to use the metrology conceptual model as a common architectural core . Model transformations enable to transpose concepts of a model toward those of another , in order to navigate between the different point of view of the application employed by each tool . This enables the creation of a platform for the development of applica - tions dedicated to assist software development while ensuring the quality of created applications . Those concepts have been promoted through an industrial project : Ac - tinote 4 . 0 from Actimage GmbH , these works industrial partner . viii Table des matières Table des matières ix Liste des ﬁgures xi Liste des tableaux xiii 1 Introduction 1 1 . 1 Motivations et enjeux . . . . . . . . . . . . . . . . . . . . . . . . . . 2 1 . 2 Contribution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6 1 . 3 Plan . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 I État de l’art 13 2 La science de la mesure 15 2 . 1 Abstraire le monde réel , normalisations et conséquences . . . . 16 2 . 2 Interpréter les grandeurs . . . . . . . . . . . . . . . . . . . . . . . . 22 2 . 3 La métrologie et l’informatique . . . . . . . . . . . . . . . . . . . . 27 2 . 4 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31 3 Génie Logiciel 33 3 . 1 Représentation des connaissances et mécanismes de raisonne - ment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34 3 . 2 Paradigmes logiciels et production de systèmes . . . . . . . . . . 46 3 . 3 Modélisation et représentations de systèmes . . . . . . . . . . . . 51 3 . 4 Ingénierie Dirigée par les Modèles . . . . . . . . . . . . . . . . . . 56 II Contribution 65 4 Représentation des Connaissances de la Métrologie 67 4 . 1 Modèle conceptuel et approche proposée . . . . . . . . . . . . . . 70 4 . 2 Encodage des termes de la métrologie . . . . . . . . . . . . . . . . 73 ix TABLE DES MATIÈRES 4 . 3 Encodage des règles d’analyses . . . . . . . . . . . . . . . . . . . . 78 4 . 4 Vériﬁcation de procédures de mesures et langage de requêtes . 87 4 . 5 Encodage des règles de conversion entre grandeurs . . . . . . . 93 4 . 6 Utilisation de ProLog et conclusion . . . . . . . . . . . . . . . . . . 99 5 Génie Logiciel pour le développement d’applications d’assis - tance à la mesure 107 5 . 1 Langage de description d’applications de mesure . . . . . . . . . 109 5 . 2 Application d’assistance à la mesure . . . . . . . . . . . . . . . . . 115 5 . 3 Intégration des outils dans la plateforme MEASURE . . . . . . . 124 III Validation et Perspectives 131 6 Illustration de l’utilisation de la plateforme 133 6 . 1 Spéciﬁcation de l’application . . . . . . . . . . . . . . . . . . . . . . 134 6 . 2 Vériﬁcation du modèle . . . . . . . . . . . . . . . . . . . . . . . . . . 138 6 . 3 Implantation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140 6 . 4 Utilisation dans un contexte industriel . . . . . . . . . . . . . . . . 143 7 Conclusion et perspectives 147 7 . 1 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 148 7 . 2 Perspectives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150 A Liste des contributions scientiﬁques I B Liste des acronymes V C Glossaire VII x Liste des ﬁgures 1 . 1 Acteurs et produits . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6 1 . 2 Structure de la plateforme MEASURE . . . . . . . . . . . . . . . . 9 2 . 1 Relations induites par la métrologie . . . . . . . . . . . . . . . . . 18 2 . 2 Rafﬁnement du cadre de la métrologie . . . . . . . . . . . . . . . 20 2 . 3 Rapport erroné entre deux températures . . . . . . . . . . . . . . 21 2 . 4 Moyenne erronée entre deux vitesses . . . . . . . . . . . . . . . . 22 3 . 1 Inférence de solution à une requête . . . . . . . . . . . . . . . . . 36 3 . 2 Architecture des systèmes experts . . . . . . . . . . . . . . . . . . 37 3 . 3 Syntaxe de la FOL sous forme de diagramme de classes . . . . . 40 3 . 4 Interprétation d’un domaine en FOL . . . . . . . . . . . . . . . . . 41 3 . 5 Représentation des connaissances en généalogie . . . . . . . . . 42 3 . 6 Représentation objet d’un système logiciel . . . . . . . . . . . . . 47 3 . 7 Représentation composants d’un système logiciel . . . . . . . . . 49 3 . 8 Conception logicielle correspondant à un modèle . . . . . . . . . 53 3 . 9 Différents points de vue d’un système . . . . . . . . . . . . . . . . 57 3 . 10Architecture de l’approche MDA . . . . . . . . . . . . . . . . . . . 58 3 . 11Métamodélisation du langage S + . . . . . . . . . . . . . . . . . . . 60 3 . 12Déﬁnition et instance d’une transformation de modèles . . . . . 62 4 . 1 Modèle Conceptuel de la Métrologie . . . . . . . . . . . . . . . . . 72 4 . 2 Classiﬁcation des unités par dimensions . . . . . . . . . . . . . . . 77 4 . 3 Modèle d’agents décrivant la requête de la procédure P . . . . 82 4 . 4 Modèle de vériﬁcation complexe . . . . . . . . . . . . . . . . . . . 93 5 . 1 Métamodèle pour les processus intéractifs . . . . . . . . . . . . . 113 5 . 2 Extrait du métamodèle du MAML . . . . . . . . . . . . . . . . . . . 113 5 . 3 Extrait d’un modèle décrit avec le MAML . . . . . . . . . . . . . . 114 5 . 4 Agents continus issus de PI . . . . . . . . . . . . . . . . . . . . . . . 117 5 . 5 Agents d’activités et transitions . . . . . . . . . . . . . . . . . . . . 118 5 . 6 Structure d’une vue de l’application . . . . . . . . . . . . . . . . . 119 xi LISTE DES FIGURES 5 . 7 Vue externe de l’application . . . . . . . . . . . . . . . . . . . . . . 120 5 . 8 Métamodèle du langage EMAML . . . . . . . . . . . . . . . . . . . 121 5 . 9 Transformation du modèle d’application à la requête de vériﬁ - cation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126 6 . 1 Modèle de l’activité de mesure simple . . . . . . . . . . . . . . . . 136 6 . 2 Modèle de l’activité de mesure simple . . . . . . . . . . . . . . . . 137 6 . 3 Visuel de l’application générée . . . . . . . . . . . . . . . . . . . . 142 xii Liste des tableaux 2 . 1 Les quatre échelles de mesure de base . . . . . . . . . . . . . . . 25 2 . 2 Comparaison des approches existantes . . . . . . . . . . . . . . . 30 3 . 1 Exemple de représentation de connaissances . . . . . . . . . . . 35 3 . 2 Variables liées et libres . . . . . . . . . . . . . . . . . . . . . . . . . 39 3 . 3 Formules FOL pour la généalogie . . . . . . . . . . . . . . . . . . . 42 3 . 4 Description OWL pour la généalogie . . . . . . . . . . . . . . . . . 43 3 . 5 Règles Prolog pour la généalogie . . . . . . . . . . . . . . . . . . . 45 4 . 1 Termes et règles pour les systèmes d’unités . . . . . . . . . . . . 75 4 . 2 Instance d’un petit système d’unités . . . . . . . . . . . . . . . . . 75 4 . 3 Règles d’inférences pour la description d’unitées . . . . . . . . . 76 4 . 4 Prédicats pour inférer l’analyse dimensionnelle . . . . . . . . . . 79 4 . 5 Faits et règles de l’analyse dimensionnelle . . . . . . . . . . . . . 80 4 . 6 Prédicats essentiels pour les échelles de mesure . . . . . . . . . 84 4 . 7 Règles associées aux échellees de mesure . . . . . . . . . . . . . 85 4 . 8 Prédicats pour abstraire les procédures de mesure . . . . . . . . 88 4 . 9 Règles décrivant les contraintes métrologiques . . . . . . . . . . 88 4 . 10Prédicats pour la trace de la vériﬁcation . . . . . . . . . . . . . . 89 4 . 11Règles pour vériﬁer et tracer les procédures . . . . . . . . . . . . 90 4 . 12Prédicats pour l’inférence de conversion . . . . . . . . . . . . . . 94 4 . 13Règles pour la conversion de grandeurs . . . . . . . . . . . . . . . 97 4 . 14Erreurs d’uniﬁcations du MKS . . . . . . . . . . . . . . . . . . . . . 101 xiii LISTE DES TABLEAUX xiv Liste des codes 3 . 1 Syntaxe du langage S + . . . . . . . . . . . . . . . . . . . . . . . . . 52 3 . 2 Transformation de modèles S + vers le code d’implémentation . 63 4 . 1 Equations de la procédure de mesure P à analyser . . . . . . . . 81 4 . 2 Requête pour l’application de l’analyse dimensionnelle à P . . . 82 4 . 3 Example of a scale analysis query . . . . . . . . . . . . . . . . . . . 86 4 . 4 Utilisation du MKQL pour décrire les analyse de la procédure P 91 4 . 5 Equations de la procédure de mesure complexe P2 . . . . . . . . 92 4 . 6 Vériﬁcation de procédure de mesure complexe . . . . . . . . . . 92 4 . 7 Exemple d’utilisation du cut de Prolog . . . . . . . . . . . . . . . . 104 5 . 1 Syntaxe du langage EMAML en EBNF . . . . . . . . . . . . . . . . 122 5 . 2 Exemple d’utilisation du EMAML . . . . . . . . . . . . . . . . . . . 123 5 . 3 Déﬁnition de transformation d’un instrument de mesure à une requête . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128 5 . 4 Déﬁnition de transformation d’instruments de mesure à une conﬁguration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129 6 . 1 Requête de vériﬁcation extraite du modèle d’application . . . . 139 6 . 2 Source de conﬁguration issue de la transformation M2APP . . . 141 xv LISTE DES CODES xvi Chapitre 1 Introduction « Il n’est que de tout mesurer pour perdre le sens de la mesure . » Robert Sabatier Sommaire 1 . 1 Motivations et enjeux . . . . . . . . . . . . . . . . . . . . . . 2 1 . 1 . 1 Contexte . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2 1 . 1 . 2 Analyse des besoins . . . . . . . . . . . . . . . . . . . . . 3 1 . 1 . 3 Questions de recherche . . . . . . . . . . . . . . . . . . . 5 1 . 2 Contribution . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6 1 . 3 Plan . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 1 CHAPITRE 1 . INTRODUCTION 1 . 1 Motivations et enjeux 1 . 1 . 1 Contexte La collecte de données est une problématique présente dans la plupart des domaines ( métier du bâtiment , cartographie , assistance au diagnostic , design intérieur , . . . ) . L’acquisition peut être faite en une fois ( métré ) ou être périodique , aﬁn d’acquérir une évolution , une tendance . Le contexte socio - économique ( services , disponibilité de réponses en vis à vis ) et la démocra - tisation des interventions à domicile ( soins , devis ) font que la mobilité est de plus en plus demandée . Pour répondre à cette demande , des systèmes lé - gers , portables , minimisant l’équipement nécessaire et capable de collecter les données de manière sufﬁsamment efﬁcace sont demandés . Le marché répond à cette situation en proposant des systèmes portables ( smartphones , tablettes ) construits autour de dispositifs dédiés à la mesure ( boussole , accéléromètre , . . . ) . La collecte de mesures est rendue possible par un nombre croissant d’applications . Ces applications exploitent globa - lement de manière satisfaisante les capacités offertes par les systèmes . En complément , aﬁn d’étendre les capacités de ces systèmes , des dispositifs matériels communicants spécialisés apparaissent . Cependant , les solutions existantes sont souvent inadéquates et insuf - ﬁsantes . Elles sont souvent limitées en ne proposant de réaliser que des mesures très spéciﬁques à un domaine ( mesurer un angle , un volume , . . . ) . Un utilisateur doit donc continuellement passer d’une application à l’autre comme s’il changeait d’instrument de mesure . Il est dans l’obligation de faire un traitement à postériori pour calculer le résultat désiré . D’autres solutions sont trop spéciﬁques car proposant une réponse à un processus de mesure complexe ; elles demandent de suivre un protocole rigide aﬁn d’accomplir une tâche spéciﬁque . Cet état de fait s’explique par l’écart existant entre l’expertise requise pour la déﬁnition d’une procédure de mesure et sa vulgarisation induite par l’actuelle généralisation de l’accès à des capteurs complexes pour tout utilisateur . Ceci s’exprime au travers de deux points principaux : — Obtenir un résultat de mesure correct implique l’utilisation d’une pro - cédure de mesure spéciﬁquement adaptée . Cependant , dans la pensée commune , ce résultat est une simple valeur numérique manipulable par toutes opérations algébriques , — La documentation d’un instrument de mesure est complexe . Elle pré - cise ses limites d’utilisation et les protocoles d’étalonnages pour en garantir l’utilisation . En revanche , la plupart de ces instruments pré - 2 CHAPITRE 1 . INTRODUCTION sentent à l’utilisateur une interface simple permettant de relever des valeurs , souvent numériques . Les résultats de mesurage ( action de mesurer ) interviennent dans plu - sieurs domaines ( production , santé , économie , . . . ) . Ce qui implique que cette vulgarisation du mesurage peut être un danger . En effet , un résul - tat erroné peut impliquer des conséquences [ 118 ] ﬁnancières ou même hu - maines . C’est pourquoi les travaux présentés visent à démontrer l’impor - tance de la métrologie dans des contextes de développement logiciels et proposent une solution permettant de vériﬁer la cohérence des procédures de mesures . Cette solution est développée dans un contexte de génération d’applications d’assistance à la mesure conﬁgurées pour répondre spéciﬁ - quement aux besoins de chaque utilisateur . Ainsi , l’application vise à offrir à l’utilisateur professionnel , comme au particulier , un ensemble d’outils lui permettant d’atteindre ses objectifs tout en prenant en compte le contexte de la mesure . Le travail de thèse s’inscrit dans le contexte industriel de la société Acti - mage GmbH 1 . Actimage GmbH est un éditeur de logiciels proposant des so - lutions de prise d’information en situation de mobilité aﬁn que les données collectées soient " poussées " dans les systèmes d’informations des clients . La préoccupation étant d’établir en fonction des domaines d’activité , des diagnostics , les documents préparant une production , une commande , . . . Les travaux ont dû prendre en compte en plus de la dimension recherche les aspects de faisabilité et de mise en oeuvre aﬁn d’aboutir à des mé - thodes et solutions valorisables par la société . Cet aspect concret implique de prendre en compte les limitations liées aux systèmes , existants ou à ve - nir , le monde des plateformes mobiles évoluant rapidement . 1 . 1 . 2 Analyse des besoins Le contexte spéciﬁque des travaux est décrit au travers d’une descrip - tion des besoins de chacune des quatre parties prenantes impliquées : l’or - ganisme de développement , l’utilisateur ﬁnal , le spécialiste de la métrologie et l’architecte logiciel . L’organisme de développement Actimage GmbH cherche à produire un ensemble d’applications dédiées à l’assistance d’opérateurs dans des contextes de mobilité . Elles peuvent servir , par exemple , à estimer le coût d’installation de panneaux solaires , 1 . http : / / www . actimage . de 3 CHAPITRE 1 . INTRODUCTION ou encore à établir des diagnostics sur l’état d’une installation industrielle . Après étude de leurs besoins , ils nécessitent que l’application proposée à un utilisateur instrumentalise une procédure de mesure qui : — produit les grandeurs requises par l’utilisateur , — prend en charge les instruments et les méthodes spéciﬁques de l’uti - lisateur , — propose de relever plus que de simples mesures traditionnelles ( infor - mations client , style d’intérieur , couleurs , . . . ) . Ces applications présentent des caractéristiques similaires ( e . g . construc - tion autour d’une procédure de mesure , hautement conﬁgurable , conforme à la métrologie ) . Actimage GmbH a besoin d’un processus de conception et de création d’applications qui soit rapide , assurant ces qualités et caracté - ristiques . L’utilisateur ﬁnal L’utilisateur ﬁnal est un habitué de la prise de mesure . Il emploie des procédures de mesures quotidiennement lors de ses activités . Il possède un ensemble d’instruments spécialisés , utilise un vocabulaire propre à son secteur d’activité et son expérience de la mesure vient du terrain . L’utilisateur est celui qui exprimera les besoins spéciﬁques de l’applica - tion . C’est avec ses mots qu’il énoncera une description de la ou les pro - cédure ( s ) de mesure qu’il espère voir assistée ( s ) par un système logiciel mobile . La description formulée contient des informations sur le matériel à dis - position . Cela comprend le système mobile , les instruments de mesure et les systèmes de visualisation que l’utilisateur envisage d’utiliser . La des - cription présente également des prescriptions concernant les grandeurs et unités impliquées aux entrées et sorties de la procédure de mesure . En - ﬁn , il est possible que l’utilisateur demande de respecter des contraintes d’incertitude de mesure sur les résultats obtenus . L’aspect mobile prend tout son sens pour une telle application . En effet , l’utilisateur pourrait facilement l’avoir à portée de main comme un outil supplémentaire , ou même à la place d’autres outils . Pour être valide aux yeux de l’utilisateur ﬁnal , l’application doit pouvoir : — Produire les résultats requis , — employer des méthodes et des instruments spéciﬁques maîtrisés par l’utilisateur , — proposer un résultat conforme aux contraintes exprimées , — être adaptée à la plateforme mobile ciblée . 4 CHAPITRE 1 . INTRODUCTION L’expert de la métrologie Les différents concepts de la métrologie impliqués dans ce projet sont : la description de procédures de mesure , leurs vériﬁcations , l’évaluation des incertitudes de mesures et également la prise en charge de relevés non physiques . En effet , les grandeurs non physiques sont indissociables des domaines des utilisateurs ( e . g . type de tuiles sur un toit ) . Ni l’utilisateur ﬁnal ni l’architecte logiciel ne sont experts en métrologie . Il faut donc proposer une approche accessible par des néophytes capables de garantir la qualité de l’application générée . C’est donc l’approche qui devra prendre en charge le rôle de l’expert de la métrologie . Cela implique des capacités de validation d’une procédure de mesure en fonction des dif - férentes entrées , instruments , opérations et sorties impliquées , quel que soit le domaine spéciﬁque adressé . L’architecte logiciel L’architecte logiciel spéciﬁe l’application à partir de la description des besoins de l’utilisateur . Ses connaissances en métrologie sont considérées faibles et il communique avec le vocabulaire du domaine logiciel . Il y a donc un écart sémantique entre les termes qu’il maîtrise et ceux composant la description . De plus , la description spéciﬁe les activités de mesure ainsi que leurs ordonnancements . L’architecte doit être capable de comprendre les différents éléments constituant la description aﬁn d’ensuite les inclure dans une spéciﬁcation de l’application . Pour cela , il faut que l’approche : — réduise l’écart sémantique entre les vocabulaires de l’utilisateur et de l’architecte , — propose de composer des séquences d’activités . La ﬁgure 1 . 1 illustre les différentes parties prenantes et les produits impliqués dans le développement d’une application dans le contexte des travaux réalisés . 1 . 1 . 3 Questions de recherche Le postulat décrit par l’analyse des besoins permet de déﬁnir le cadre dans lequel nos travaux ont été réalisés . La problématique fondamentale à laquelle ces travaux tendent à trouver une réponse est la suivante : Comment proposer une approche pour la conception d’applica - tions adaptées à des procédures de mesures spéciﬁques ? Les procé - dures de mesure pouvant être conﬁgurées par un utilisateur ﬁnal . 5 CHAPITRE 1 . INTRODUCTION Procédure de mesure définit le comportement process model application fondé sur satisfait définit Utilisateur Architecte lit SOLUTION modélise avec génère Actimage emploie répond aux besoins remplacé par utilise Spécialiste Figure 1 . 1 – Acteurs et produits interagissant dans la solution proposée Celle - ci peut être décomposée en trois problématiques : — Qu’est - ce qu’une procédure de mesure et comment en garantir la co - hérence ? — Comment intégrer des procédures de mesure dans un logiciel ? — Quelle approche permettrait de faciliter la conception de logiciel dans ce domaine ? 1 . 2 Contribution Nos travaux cherchent à répondre à ces questions . Pour cela , la science de la mesure , appelée métrologie , est étudiée . Les fondements de cette science , ces standards , le vocabulaire ainsi que les règles qu’elle décrit sont abordés . De plus , la théorie représentationnelle du mesurage ( repre - sentational theory of measurement : RTM [ 70 ; 119 ] ) est présentée . C’est une approche , plus ouverte que les standards de la métrologie , qui per - met d’ajouter à la métrologie l’utilisation de grandeurs non physiques . Ces présentations aboutissent à la proposition d’un modèle conceptuel pour les mesurages . Le modèle conceptuel est ensuite utilisé comme base pour inférer un schéma des connaissances du domaine [ 32 ] dans l’espace de la logique du 6 CHAPITRE 1 . INTRODUCTION premier ordre [ 77 ] . En plus d’encoder les éléments de la métrologie , le schéma offre des capacités de raisonnement . Ce raisonnement permet de vériﬁer la conformité d’une procédure de mesure ou d’une opération de conversion par rapport aux règles inférées . Cette vériﬁcation permet d’as - surer la cohérence d’une procédure de mesure impliquant différents cap - teurs , types de grandeurs , unités résultats et manipulations de résultats de mesures . La vériﬁcation est réalisée en présentant au schéma une procé - dure de mesure sous la forme d’une requête qu’il réduira à l’aide d’un algo - rithme d’uniﬁcation . Ces requêtes ne peuvent être valides que si elles sont décrites en employant les termes proposés par le schéma de connaissance . Ce qui implique qu’un langage de requêtes de validation de procédures de mesure est induit par le schéma . Ce langage est nommé le Measurement Knowledge Query Language ( MKQL ) . Un langage dédié , ou Domain Speciﬁc Language ( DSL ) [ 45 ] pour la des - cription d’applications logicielles fondées sur des procédures de mesure est proposé . Il est nommé le langage de modélisation d’application d’as - sistance à la mesure , Measure Application Modelling Language ( MAML ) . L’utilisation d’un DSL permet de simpliﬁer la syntaxe disponible tout en augmentant la sémantique [ 56 ] associée au contexte . MAML propose des termes provenant des domaines des processus , des interfaces utilisateur et les mêle à des termes de la métrologie . Il permet ainsi de réduire l’écart sémantique entre un architecte logiciel et un professionnel réalisant des mesurages quotidiennement . Les modèles qui en sont issus décrivent une procédure de mesure sous la forme de séquences d’activités de mesurages , de manipulation de grandeurs et de présentation de résultats . D’un point de vue logiciel , une mesure est largement représentée sous la forme d’un simple nombre . Cette représentation fait écho à un manque d’uniformisation de la gestion des grandeurs dans les systèmes d’informa - tion ( capteurs , logiciels ) [ 42 ] . Une approche permettant d’assurer la prise en charge de grandeurs dans un logiciel est proposée . Elle propose d’uni - formiser les valeurs obtenues et ainsi de simpliﬁer leurs manipulations . Un second DSL , cette fois dédié au côté fonctionnel de la procédure de mesure est proposé . Ce langage est nommé le langage pour la description de conﬁ - guration d’application de mesure , ou Executable Measurement Application Model Language ( EMAML ) . L’EMAML permet de décrire un modèle à un niveau d’abstraction plus bas que le précédent . Les éléments propres à la métrologie ne sont pas présents , cependant il propose une syntaxe dont la sémantique est exécutable par un système logiciel . Les modèles qui en sont issus sont donc constitués de séquences de requêtes de données provenant de divers systèmes ( capteurs , bases de données , interfaces utilisateur , . . . ) , d’uniformisation des données , d’opérations algébriques sur ces données et 7 CHAPITRE 1 . INTRODUCTION de présentation des données . Une approche permettant l’aide la création d’application d’assistance à la mesure doit proposer les capacités de chacun des trois langages pro - posés . En effet , les trois activités majeures d’un cycle de développement sont : la spéciﬁcation , la vériﬁcation et l’ implantation [ 12 ] . Ces travaux proposent d’intégrer ces langages sous la forme de trois outils , l’ éditeur , le vériﬁcateur et l’application mobile , chacun prenant en charge l’une de ces activités . Seulement , les trois langages proposent un point de vue différent sur ce qu’est une procédure de mesure . L’intégration de ces outils au sein d’une plateforme est réalisée par les méthodes proposées par l’ Ingénierie Dirigée par les Modèles ( IDM ) , ou Mo - del Driven Engineering . L’IDM [ 17 ; 115 ] est un paradigme de développe - ment qui emploie les modèles comme entités de premier ordre . Elle propose également le concept de transformations de modèles permettant d’adapter un modèle en un nouveau . L’intérêt étant de proposer un modèle focalisé sur l’activité à réaliser par chaque outil de la plateforme . Ces transforma - tions permettent donc de traduire le modèle issu de la spéciﬁcation en une requête vériﬁable ou encore en un modèle exécutable . Ces deux transfor - mations sont respectivement nommées Model to Veriﬁcation Query ( M2VQ ) et Model to Application ( M2APP ) . La plateforme est nommée MEASURE et sa structure présentée dans la ﬁgure 1 . 2 . L’architecte logiciel utilise la plateforme MEASURE pour spéciﬁer l’ap - plication qui remplira les besoins déﬁnis par l’utilisateur ﬁnal . — l’ éditeur est utilisé par l’architecte logiciel pour décrire le modèle de spéciﬁcation d’une application . Le langage MAML , qu’il emploie , pro - pose des termes compris dans le vocabulaire de la métrologie , ce qui réduit l’écart sémantique entre l’utilisateur et l’architecte logiciel . — Le vériﬁcateur est employé pour identiﬁer les erreurs relatives à la métrologie dans une procédure de mesure . Il utilise pour cela les ca - pacités de raisonnement du schéma des connaissances de la métrolo - gie . — l’ application mobile est le système logiciel mis à disposition de l’uti - lisateur ﬁnal . Ce système utilise un modèle exécutable pour proposer un comportement sur mesure répondant aux besoins spéciﬁques de l’utilisateur ﬁnal . — l’ extracteur de requêtes nommé M2VQ permet de transposer un mo - dèle de spéciﬁcation en requête de vériﬁcation . Cela rend possible la vériﬁcation de la procédure de mesure au travers d’un raisonnement autour de la sémantique de la métrologie . 8 CHAPITRE 1 . INTRODUCTION Embarqué dans le système mobile Editeur Modèle de spécification ( MAML ) Requête de vérification ( MKQL ) Vérificateur de conformité ( MKS ) Modèle d’implantation ( EMAML ) Application mobile embarquée Utilise Utilise Générateur d’application ( M2APP ) Extracteur de requête ( M2VQ ) Architecte Utilisateur Consomme Génère Génère Vérifie Execute Génère Génère Erreurs dans la spécification outil modèle Figure 1 . 2 – Outils et modèles interagissant dans la plateforme MEASURE 9 CHAPITRE 1 . INTRODUCTION — le générateur d’application nommé M2APP permet de générer un mo - dèle exécutable de l’application à partir d’un modèle de spéciﬁcation . Cela permet d’ajouter une sémantique exécutive à la spéciﬁcation tout en retirant la sémantique liée à la métrologie , inutile dans le contexte fonctionnel . 1 . 3 Plan Le manuscrit de thèse est organisé en sept chapitres : Le chapitre 2 présente la métrologie en abordant les termes et les règles employés dans ce domaine . Il a pour but de démontrer l’apport in - dispensable que peut proposer une expertise en métrologie lors de la créa - tion de systèmes logiciels . Dans un premier temps il présente l’intérêt des efforts d’uniformisation qui ont été réalisés depuis plusieurs années pour simpliﬁer la prise de mesure . Cette simpliﬁcation a eu un effet pervers qui sera également illustré . Ensuite , il présente le contexte socio - économique actuel qui propose un nombre croissant de systèmes de mesures . Puis , le chapitre décrit les termes composant le langage du métrologue et les struc - tures imaginées pour simpliﬁer la représentation d’une procédure de me - sure . À ces termes et structures s’ajoutent ensuite les contraintes et règles permettant d’assurer que le résultat d’un mesurage est cohérent . Enﬁn , le chapitre se conclut en proposant une description des différentes solutions logicielles permettant d’augmenter la conﬁance que l’on peut avoir dans une procédure de mesure . Le chapitre 3 présente les différentes approches du génie logiciel qui sont employées pour réaliser ces travaux . Il décrit les différentes approches permettant l’inférence de connaissances dans des systèmes logiciels . En - suite , il présente les approches d’implantations sous forme d’entités lo - giques des trois paradigmes logiciels : objet , composant et agent . Et enﬁn , il aborde l’Ingénierie Dirigée par les Modèles , une approche de description de logiciel utilisant les modèles comme entités de description principales . Le chapitre 4 présente le Metrology Knowledge Schema ( MKS ) , un schéma des connaissances de la métrologie . Ce schéma encode les diffé - rentes règles et contraintes composant la science de la mesure en logique du premier ordre . Il permet de raisonner dans le domaine de la métrolo - gie et donc de vériﬁer la cohérence de procédures de mesure . Pour com - mencer , il propose un modèle conceptuel pour la représentation de procé - dures de mesures fondé sur les standards du domaine . Ensuite , il présente une inférence en logique du premier ordre des termes et relations de ce 10 CHAPITRE 1 . INTRODUCTION modèle . Après quoi , il montre l’ajout des contraintes et règles inhérentes à la métrologie . Celles - ci comprennent les règles et contraintes d’analyse pour valider des procédures de mesure et celles assurant des conversions entre références d’un même type de grandeur . Enﬁn , il décrit comment la combinaison de ces règles permet au schéma de connaissances de vériﬁer des procédures de mesure faisant interagir des grandeurs aux unités hé - térogènes . Cette vériﬁcation est réalisée en décrivant des procédures de mesures sous la forme de requêtes conformes au MKQL , le langage de re - quêtes induit par le schéma de connaissances . Le chapitre 5 présente la plateforme MEASURE . Cette plateforme pro - pose un cycle assisté de développement d’application d’assistance à la me - sure qualiﬁées . Le cycle présente trois activités : la spéciﬁcation , la véri - ﬁcation et l’ implantation . MEASURE propose un outil dédié à chacune de ces activités : l’ éditeur , le vériﬁcateur et l’application mobile . Ces outils sont construits autour des trois contributions présentées dans ce chapitre le MAML , et le EMAML , et dans le chapitre précédent le MKQL . Ce chapitre présente en premier lieu le MAML . C’est un langage permet - tant la spéciﬁcation de modèles d’applications par un architecte logiciel sans expertise dans la métrologie . Pour cela il propose un ensemble de termes permettant de modéliser une procédure de mesure sous la forme d’une séquence d’activités comprenant des opérations de relevé , de mani - pulation et de présentation de grandeurs . Ce langage est construit à partir des concepts , formalismes et outils proposés par l’environnement de méta - modélisation Diagrammatic Predicate Framework ( DPF ) . Le langage com - porte des contraintes syntaxiques prévenant les erreurs de construction . Dans un deuxième temps , l’application logicielle employée par l’utilisateur ﬁnal est présentée . Cette application est conﬁgurable et adapte son com - portement en fonction du modèle fonctionnel qui lui est donné . Le langage de description des modèles fonctionnels , le EMAML , est présenté . C’est un langage destiné à représenter une procédure de mesure d’un point de vue fonctionnel pour un système logiciel . Une procédure de mesure se re - trouve réduite à un ensemble d’opérations de collecte , de manipulation et d’afﬁchage de données séquencées . Cette dénaturation des grandeurs en simples données permet une gestion aisée des différentes opérations de ma - nipulation , tant qu’une uniformisation est effectuée aux entrées et sorties de l’application . L’application logicielle est construite avec un framework permettant de construire le comportement de l’application . Ce framework est fondé sur une architecture d’agents . Chaque agent a un rôle simple . C’est leur collaboration qui permet de prendre en charge la gestion d’une séquence d’activités composée de relevés , de manipulations et de présenta - 11 CHAPITRE 1 . INTRODUCTION tions de données . L’application contient également un constructeur permet - tant de générer la conﬁguration correspondant au modèle d’implantation . Enﬁn , le chapitre se conclut en proposant deux transformations de modèles permettant d’intégrer l’éditeur de modèle , le vériﬁcateur et l’application mobile dans la plateforme MEASURE . Cela permet d’automatiser les pro - cessus de vériﬁcation de la métrologie et d’implémentation de l’application mobile à partir du modèle de spéciﬁcation . Le chapitre 6 illustre l’utilisation de la plateforme MEASURE en pré - sentant le développement d’une application d’estimation du coût d’installa - tion de panneaux solaires sur une toiture . L’application a été pensée avec Actimage GmbH pour permettre de faire avancer la réﬂexion sur la thé - matique de nos travaux . Ensuite , le chapitre présente l’adaptation de l’ap - proche présentée dans ces travaux et son utilisation par Actimage GmbH sous la forme de la plateforme ActiNote 4 . 0 TM . Cette plateforme propose la description d’applications d’assistance aux interventions in situ . Le cha - pitre décrit les adaptations qui ont été apportées aux différents outils par Actimage pour proposer un système commercialisable . Le chapitre 7 conclut sur ces travaux et présente les différentes pistes à explorer pour rendre ses travaux plus accessibles à la communauté des développeurs . 12 Première partie État de l’art 13 Chapitre 2 La science de la mesure « The mole is a quantity of substance . The new preﬁx “guaca” is deﬁned such that one guacamole equals Avocado’s Number . » G . David Byrne Sommaire 2 . 1 Abstraire le monde réel , normalisations et conséquences 16 2 . 1 . 1 Historique . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 2 . 1 . 2 Normalisation . . . . . . . . . . . . . . . . . . . . . . . . . 17 2 . 1 . 3 Conséquences . . . . . . . . . . . . . . . . . . . . . . . . . 19 2 . 2 Interpréter les grandeurs . . . . . . . . . . . . . . . . . . . . 22 2 . 2 . 1 Systèmes de grandeurs et analyse dimensionnelle . . 23 2 . 2 . 2 Échelles de mesures et grandeurs non physiques . . . 24 2 . 2 . 3 Procédures et incertitudes de mesure . . . . . . . . . . 26 2 . 3 La métrologie et l’informatique . . . . . . . . . . . . . . . . 27 2 . 4 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31 15 CHAPITRE 2 . LA SCIENCE DE LA MESURE Aﬁn de comprendre , décrire et communiquer sur le monde , l’être hu - main a dû développer un vocabulaire adapté . La métrologie est employée dans toutes les disciplines , que ce soit les sciences dures ( i . e . mécanique , physique , électronique ) , mais également les sciences humaines ( i . e . intel - ligence , conscience ) pour quantiﬁer , jauger et raisonner . C’est elle qui ca - ractérise les outils pour représenter les phénomènes observables . Pour cela elle déﬁnit les représentations possibles pour des propriétés observées et les relations qui les régissent . Ce chapitre présente les concepts essentiels de la métrologie , la science de la mesure . Il met en avant l’utilisation de mesures pour communiquer et raisonner sur les phénomènes du monde observable . L’accent est mis sur l’importance de la métrologie et les règles employées par les experts pour certiﬁer des procédures de mesures . 2 . 1 Abstraire le monde réel , normalisations et conséquences Cette section présente un bref historique de la métrologie pour ensuite montrer les efforts réalisés pour normaliser le vocabulaire de la métrolo - gie . Ces normes visent à simpliﬁer la communication entre les experts du domaine . Leurs apparentes simplicités entraînent également un ensemble de conséquences négatives . En effet les résultats de mesures sont souvent manipulés comme de simples nombres . Les avantages et les inconvénients de ces normes sont détaillés ici . 2 . 1 . 1 Historique La mesure est employée depuis les temps anciens [ 16 ] . L’action de mesu - rer est nommée mesurage . C’est une activité qui a pour but d’encoder des évènements empiriques en représentations formelles , simpliﬁant la com - munication de ces évènements , nommées grandeurs [ 89 ] . Un mesurage im - plique des processus complexes et est par nature multidisciplinaire . Fondé sur des comparaisons et des décomptes , un mesurage permet de quantiﬁer la contenance , la taille ou encore le prix d’entités . Auparavant , les comparaisons étaient fondées sur des parties du corps humain ( pouce , coudée , pied ) et des objets du quotidien ( baril , amphore , graine de caroubier aussi appelée carat ) . Les références n’étant pas glo - bales , certaines portaient le même nom , mais ne représentaient pas la même valeur d’un lieu à un autre . De plus , les subdivisions des références 16 CHAPITRE 2 . LA SCIENCE DE LA MESURE étaient également basées sur des entités physiques . Ainsi il était rare que la conversion entre deux références soit une opération simple . Par exemple , une coudée est divisée en six palmes . Une palme étant dé - ﬁnie par quatre doigts . Il faudra 24 doigts pour une coudée . La conversion entre ces entités n’est donc pas aisée . De plus , une autre unité nommée cou - dée était employée : la coudée de maya . Elle était divisée en sept palmes , car utilisée pour les monuments religieux , sept étant un nombre sacré . En - ﬁn , le doigt n’était pas identique dans chaque lieu . Dans ces conditions , il est impossible de connaître la taille exprimée par une longueur en coudées sans précisions sur le contexte . Il faut garder à l’esprit que les grandeurs sont employées pour décrire les objets qui constituent le monde . Cette déﬁnition est importante pour pouvoir communiquer les propriétés caractéristiques de l’objet . Un plan d’architecte doit pouvoir être lu non seulement par son créateur , mais éga - lement par le maître d’oeuvre , son personnel et idéalement l’acheteur . Il faut donc que toutes ces personnes adoptent un vocabulaire commun et que les références employées soient partagées par tous . 2 . 1 . 2 Normalisation Depuis la Révolution française , un effort conséquent a été réalisé aﬁn d’uniformiser les notions de références . Pour garantir l’invariabilité des ré - férences , elles ont commencé à être déﬁnies à partir de phénomènes natu - rels ﬁxes et reproductibles . Le premier mètre a été déﬁni par rapport à la longueur du méridien terrestre . Cette déﬁnition est dite universelle puisque identique pour tous . Cet effort a mené à la création du Joint Committee for Guides in Metro - logy ( JCGM ) qui a publié un vocabulaire uniﬁé le Vocabulaire International de Métrologie ( VIM ) [ 89 ] ainsi que d’un ensemble de références internatio - nales nommé le Système International ( SI ) [ 10 ] . Ces deux documents sont les références majeures constituant la métrologie actuelle . La métrologie est la science des mesurages . Elle déﬁnit un ensemble de vocabulaires et de méthodes permettant d’encoder les évènements empi - riques en abstractions formelles simples à communiquer et à comprendre . De plus , la manipulation de ces abstractions formelles permet d’en déduire d’autres qui sont également associées à des évènements empiriques . Les relations induites par la métrologie entre les domaines empirique et formel sont illustrées dans la ﬁgure 2 . 1 . Cette ﬁgure met également en avant l’im - portance de la sémantique de la métrologie qui permet de contraindre les manipulations d’abstractions . Le VIM est la référence déﬁnissant le vocabulaire international de la 17 CHAPITRE 2 . LA SCIENCE DE LA MESURE Abstraction 1 Propriété physique 1 Propriété physique 2 E xp é r i m e n t a ti on Abstraction 2 Domaine formel Domaine empirique D éc od e E n c od e Contraint Fondé sur M a n i pu l a ti on s f o r m e ll e s Sémantique de la métrologie Figure 2 . 1 – Relations induites par la métrologie entre les domaines empirique et formel métrologie 1 . Il comprend tous les termes que toute personne réalisant des mesurages devrait utiliser . Le modèle conceptuel du domaine présenté dans le chapitre 4 est déduit de ces termes . Le VIM nomme l’abstraction formelle grandeur . Le but des grandeurs est de simpliﬁer la communication d’évènements observés . Une grandeur est composée d’une valeur numérique et d’une référence . Pour simpliﬁer le discours , nous utiliserons le terme valeur d’une grandeur pour parler de la valeur numérique d’une grandeur . La référence d’une grandeur représente une quantité connue et ﬁgée de l’évènement soumis au mesurage . Partager cette référence permet de quantiﬁer les évènements empiriques en déﬁnissant les relations entre la référence et l’évènement observé . Ainsi , pour que la grandeur soit facile - ment utilisable , il faut que la référence associée soit répandue et connue par tous ces utilisateurs . C’est pourquoi le SI a été proposé . Il déﬁnit un ensemble de références internationales nommées unités . Le SI assigne une référence pour chaque nature d’évènement quantiﬁable . Chacune des unités du SI est déﬁnie par un étalon international unique . Des versions dérivées sont partagées au travers du globe et utilisées pour étalonner les instruments de mesure . Cela permet de proposer un vocabu - laire unique pour identiﬁer et comparer les grandeurs universellement . Le SI propose des subdivisions décimales des unités construites à partir du nom de l’unité et d’un préﬁxe ( e . g . pico , centi , kilo ) qui permettent d’expri - 1 . Tous les termes propres à la métrologie abordés dans ce document sont déﬁnis par le VIM . 18 CHAPITRE 2 . LA SCIENCE DE LA MESURE mer toutes les valeurs d’une grandeur avec une seule unité , et ce malgré l’écart entre les échelles dans les différents domaines ( inﬁniment petit pour la physique des particules contre inﬁniment grand pour l’astrologie ) . La valeur d’une grandeur est déﬁnie en comparant la référence à l’évè - nement empirique observé en utilisant un instrument de mesure avec la valeur afﬁchée par un instrument indicateur . Généralement , il est possible d’appliquer des opérations de conversion à une grandeur pour changer sa référence en une autre compatible . Un mesurage est l’application d’une procédure de mesure pour collecter une ou plusieurs valeurs de grandeurs . Une procédure de mesure est dé - ﬁnie par l’association d’instruments de mesure , d’instruments indicateurs et de fonctions de mesure . Une fonction de mesure est une manipulation algorithmique de grandeurs qui implique une grandeur résultante en fonc - tion de grandeurs sources . L’utilisation de fonctions de mesure permet la création de nouvelles grandeurs qui représentent également des propriétés physiques ( ﬁgure 2 . 2 ) . Cela permet de projeter et valider des propriétés du monde réel sans réaliser des expérimentations plus délicates . Par exemple un simple calcul permet de déﬁnir si un meuble peut être placé dans un es - pace donné quand l’expérimentation nécessiterait d’avoir le meuble à dis - position . Un mesurage permet donc d’abstraire des évènements physiques pour en simpliﬁer la communication et , en manipulant les abstractions , de prévoir certains évènements . Le vocabulaire déﬁni jusqu’ici est utilisé pour décrire les mesurages , les outils pour les réaliser , les abstractions et les méthodes pour les manipuler . La ﬁgure 2 . 2 présente un rafﬁnement de la ﬁgure 2 . 1 utilisant les termes du VIM . 2 . 1 . 3 Conséquences Le SI et le VIM étant des références internationales , ils permettent de simpliﬁer la communication entre toutes personnes réalisant des mesu - rages . Un expert de la métrologie est capable de déﬁnir une procédure de me - sure , de spéciﬁer les outils et fonctions de mesure nécessaires aﬁn d’obte - nir une grandeur . Il est capable de transmettre aisément la grandeur aﬁn de l’utiliser dans d’autres traitements . De plus , puisque le vocabulaire est également uniﬁé , il peut aussi transmettre la procédure de mesure aﬁn de reproduire le mesurage dans des conditions différentes ou simplement de l’appliquer à une autre entité . Cependant , le VIM est un outil qui n’est réellement employé que par les experts de la métrologie . Ce vocabulaire est généralement inconnu des 19 CHAPITRE 2 . LA SCIENCE DE LA MESURE Abstraction 1 Propriété physique 1 Propriété physique 2 E xp e r i m e n t a ti on Abstraction 2 Connaissances de la métrologie Domaine formel Domaine empirique Contraint Fondé sur F on c ti on d e m e s u r e Génère Consumes I n s t r u m e n t i nd i ca t e u r I n s t r u m e n t d e m e s u r e Génère Observe Représente Affiche Figure 2 . 2 – Rafﬁnement du cadre impliqué par la métrologie en prenant en compte le vocabulaire international non experts qui utilisent un vocabulaire plus commun et plus ambigu . Par exemple , les termes de mesurage , grandeur et instrument de mesure sont communément appelés mesure , quantité et capteurs . Les bases du SI sont bien mieux maîtrisés et communément employées par l’ensemble des personnes susceptibles de réaliser des mesurages . Le point fort du SI est de proposer des références internationales uniques qui ont été rapidement adoptées . Cependant , des unités hors du SI sont tou - jours employées , voire même autorisées par le SI [ 10 ] . Leurs utilisations peuvent être justiﬁées par : — des raisons historiques , comme dans la navigation maritime ou aé - rienne avec les noeuds ou milles marins , — un ancrage fort dans le vocabulaire commun , comme c’est le cas des minutes , litres et les tonnes , — une commodité de notation , comme les unités atomiques , astrono - miques ou basées sur des constantes naturelles , — des équations simpliﬁées pour des domaines spéciﬁques , comme en électrodynamique avec l’utilisation d’un autre système d’unités , le Sys - tème d’unité Centimètre , Gramme , Seconde ( CGS ) . À cela s’ajoutent toutes les unités qu’emploient les pays anglo - saxons qui ont conservé le système impérial ( e . g . mile , inch , degré Fahrenheit ) . La présence mondiale de ces pays et leur puissance économique engendrent une grande utilisation de ces unités . Cette uniformisation incomplète implique que , naturellement les utili - sateurs ont tendance à penser que les unités qu’ils emploient sont celles 20 CHAPITRE 2 . LA SCIENCE DE LA MESURE employées par tous . Cela peut induire des erreurs dans des contextes in - ternationaux . Prenons l’exemple de deux personnes parlant de la vitesse moyenne d’un conducteur sur un trajet . Elles pourraient , en langage com - mun , dire " je pense qu’il était à 110 " . Omettre l’unité est commun puisque les deux personnes savent que la thématique est la vitesse moyenne d’un véhicule . Mais même si l’orateur français est respectueux des limitations sur autoroutes , l’auditeur anglais pensera qu’il ne l’est pas . En effet , il en - tendra que la vitesse est en mile par heure , l’unité de vitesse anglaise et 110 mile / h correspondent à 177 km / h . Bien qu’étant dans un contexte plus complexe , c’est une erreur d’unités équivalente qui est à l’origine du crash de la sonde Mars Climate Orbiter [ 118 ] . Outre les possibles problèmes de conversions , la représentation d’évène - ments empiriques en grandeurs a également tendance à être source d’er - reurs . En effet , une grandeur est l’association d’une valeur numérique et d’une référence . L’utilisation d’une valeur numérique est tellement com - mune que les non - experts ont tendance à penser qu’ils manipulent des nombres au lieu d’abstractions de propriétés du monde réel . Cependant , les grandeurs n’ont pas forcément toutes les propriétés algébriques d’une simple valeur numérique . Les ﬁgures 2 . 3 et 2 . 4 montrent deux de ces erreurs . 10 kilomètre 20 kilomètre 10 °Celsius 20 °Celsius Francais 6 . 2 mile 12 . 4 mile 50 °Fahrenheit 68 °Fahrenheit Anglais * 2 * 2 * 2 * 2 Distance Température * 1 . 36 Figure 2 . 3 – Limites algébriques impliquées par des températures en °C ou °F La ﬁgure 2 . 3 montre que la déclaration " il fait deux fois plus chaud en mars qu’en mai " est erronée . En effet , en fonction de l’unité employée le résultat n’est pas le même . Les zéros attribués aux degrés Celsius et Fah - renheit sont arbitraires ( ne représentent pas l’absence de température ) et différents . Le rapport entre deux températures ne représente donc pas une relation physique . La ﬁgure 2 . 4 illustre une erreur d’inattention qui apparaît lorsque les grandeurs sont considérées comme de simples valeurs . Un véhicule par - court deux trajets ( A ) et ( B ) . Chaque trajet est coupé en deux intervalles identiques ( A ) en longueur ou ( B ) en temps . Le véhicule roule à une vitesse 21 CHAPITRE 2 . LA SCIENCE DE LA MESURE vitesse moyenne ( B ) temps écoulé ( B ) 1 h à 4 km / h 1 h à 6 km / h 10 km à 4 km / h 10 km à 6 km / h vitesse moyenne ( A ) ( B ) ( A ) distance parcourue ( A ) 4 + 6 2 = 5 km / h 4 + 6 2 = 5 km / h 5 * 2 = 10 km 4 + 6 = 10 km 2 . 5 + 1 . 66 = 4 . 16 h 20 / 5 = 4 h moyenne erronée estimation erronée Figure 2 . 4 – Calcul et utilisation d’une vitesse moyenne correcte ( A ) et incorrecte ( B ) différente sur chaque intervalle . La ﬁgure montre que , sur trajet découpé en intervalles identiques , calculer la vitesse moyenne en appliquant une moyenne algébrique est ( A ) possible pour des intervalles de temps iden - tiques et ( B ) impossible pour des intervalles de longueurs identiques . Cela s’explique , car pour ces équations , la longueur et le temps sont respective - ment numérateur et dénominateur . La somme de deux ratios aux dénomi - nateurs différents n’est possible qu’en les uniformisant et c’est cette étape qui est oubliée dans le cas ( B ) . Cette limitation peut être généralisée à toute grandeur dont la référence est déﬁnie par un ratio d’unités ( e . g . vitesse , ﬂux magnétique , force ) . Cette section a présenté l’importance des travaux d’uniformisation qui ont été proposés aﬁn de simpliﬁer la communication dans des contextes de mesurages . Les limitations et erreurs communes induites par cette unifor - misation ont également été mises en avant . La section suivante va présenter les différentes méthodes que la métrologie propose pour assurer la cohé - rence des abstractions avec les propriétés physiques qu’elles représentent pour garantir les interprétations . 2 . 2 Interpréter les grandeurs Les instruments de mesure sont maintenant très répandus . Il est naturel d’employer des valeurs associées à des unités pour décrire des évènements empiriques . Cependant , nous avons vu que , cette description sous forme nu - 22 CHAPITRE 2 . LA SCIENCE DE LA MESURE mérique des valeurs de grandeurs tend à induire les non - experts en erreur . En effet , les grandeurs sont des abstractions de propriétés du monde réel . Il ne faudrait donc pas les manipuler sans connaître les conséquences que cela implique sur les propriétés abstraites . Cette section présente les diffé - rentes règles qui composent les connaissances de la métrologie de la ﬁgure 2 . 2 . Ces règles garantissent la cohérence des grandeurs issues de fonctions de mesure avec les propriétés physiques observées ou présumées . 2 . 2 . 1 Systèmes de grandeurs et analyse dimensionnelle La métrologie déﬁnit un ensemble de natures de grandeur ( e . g . énergie , ﬂux magnétique , pression ) pour catégoriser chaque type d’évènement em - pirique . Les systèmes de grandeurs déﬁnissent un ensemble de relations algébriques entre les natures de grandeurs pour répercuter les lois de la physique qui lient les évènements empiriques . Ces systèmes sont fondés sur un ensemble de grandeurs de base considérées indépendantes ainsi que sur un ensemble de grandeurs dérivées déﬁnies par des combinaisons algé - briques des grandeurs de base . Le système international de grandeurs , ou International System of Quantities ( ISQ ) [ 63 ] est le système de référence . Il propose sept types de grandeurs de base : longueur , masse , temps , courant électrique , température thermodynamique , quantité de matière et intensité lumineuse . Toutes les grandeurs dérivées sont déﬁnies par des opérations de multiplications ou des divisions de ces sept grandeurs . Le SI propose une unité pour chacune des grandeurs de base déﬁnies par l’ISQ et représente également toutes les autres unités par une combi - naison de ces unités . Les préﬁxes permettent une mise à l’échelle de l’unité par rapport à l’élément observé . En plus , certaines unités ont des noms spéciaux qui permettent de simpliﬁer leurs utilisations ( e . g . newton , joule , watt ) . Les différents diagrammes proposés par le National Institute of Stan - dards and Technology ( NIST ) 2 présentent les différents types de grandeurs de l’ISQ ainsi que les unités associées et les relations algébriques les liants . L’utilisation de systèmes de grandeurs différents permet généralement de simpliﬁer les équations et les unités les plus communes dans ces systèmes , comme le CGS pour l’électromagnétisme ou la chimie . Les systèmes de grandeurs sont utilisés , car ils simpliﬁent la communi - cation en réduisant le vocabulaire nécessaire pour représenter toutes les grandeurs et unités . Ce sont des modèles formels représentant des lois ré - gissant la physique . Ils permettent donc de reﬂéter les effets des lois de la physique sur les abstractions formelles au travers d’une algèbre simple . 2 . http : / / physics . nist . gov / cuu / Units / SIdiagram2 . html 23 CHAPITRE 2 . LA SCIENCE DE LA MESURE Cette algèbre est appelée analyse dimensionnelle et est décrite comme ca - pable de vériﬁer l’homogénéité d’équations impliquant des grandeurs ou encore de les simpliﬁer [ 4 ] . Chaque type de grandeur peut être représenté sous une forme canonique . Cette forme canonique est un vecteur dont la longueur est égale au nombre de grandeurs de base du système . Le vecteur est appelé vecteur aux dimensions puisque chacune des grandeurs de base est assimilée à une dimension du vecteur . Le vecteur aux dimensions asso - cié au SI a donc la forme : < longueur , masse , temps , courant électrique , température thermodynamique , quantité de matière , intensité lumineuse > généralement noté < L , M , T , I , Θ , N , J > . L’analyse dimensionnelle implique de prendre la forme canonique de toutes les grandeurs impliquées dans le mesurage et de vériﬁer que les dif - férentes manipulations sur ces grandeurs ne génèrent pas un résultat inco - hérent . Par exemple , dans un processus d’installation de panneaux solaires , il faudra pouvoir assurer que la toiture supportera le poids de l’installation . L’impact de l’installation sera sûrement donné en kg / m 2 . Pour trouver la masse appliquée par une installation spéciﬁque il faudra donc appliquer l’opération masse = surface * impact dont la représentation canonique est < 0 , 1 , 0 > = < 2 , 0 , 0 > * < - 2 , 1 , 0 > ce qui donne < 0 , 1 , 0 > = < 0 , 1 , 0 > . L’équa - tion est homogène , ce qui garantit que les calculs sont corrects vis - à - vis de l’analyse dimensionnelle . 2 . 2 . 2 Échelles de mesures et grandeurs non physiques L’analyse dimensionnelle empêche la combinaison de grandeurs sans re - lations physiques . La théorie représentationnelle de la mesure , ou Repre - sentational Theory of Measurement ( RTM ) propose de consolider les rela - tions entre les évènements empiriques et leurs abstractions formelles . L’en - semble des opérations qui peuvent être appliquées à une grandeur devrait être contraint en prenant en compte la nature empirique de l’évènement qu’elle abstrait [ 70 ; 119 ] . L’ensemble d’opérations qui peuvent être appli - quées à une grandeur est nommé échelle de mesure . L’échelle de mesure associée à une grandeur est déﬁnie par la connaissance de l’évènement empirique abstrait et de la procédure de mesure dont elle est issue [ 53 ] . En effet , l’ensemble des opérations est déduit de l’évènement observé aﬁn de garantir que l’abstraction formelle encode bien une propriété du monde réel . Le tableau 2 . 1 présente les quatre échelles de mesure de base . Ainsi , puisque les températures en degrés Celsius ou Fahrenheit sont associées à l’échelle intervalle , il est impossible de leur appliquer un ratio et l’erreur " il fait deux fois plus chaud " n’a plus lieu d’arriver . La RTM étend les capacités d’abstractions des mesurages aux grandeurs 24 CHAPITRE 2 . LA SCIENCE DE LA MESURE Échelle Relations Operations Exemple Nominale Catégorisées = ( est un ) Genre , Couleurs Ordinale Ordonnées = , < QI , Notes scolaires Intervalle Équidistantes = , < , + Températures ( ◦ F , ◦ C ) Ratio Équidistantes et Zéro absolu = , < , + , ∗ Masse , Longueur Tableau 2 . 1 – Les quatre échelles de mesure de base . ( inspiré de [ 119 ] ) non physiques alors que les références en métrologie ne considèrent que les propriétés physiques . De plus , elle déﬁnit un ensemble de contraintes qui assurent que les relations illustrées dans la ﬁgure 2 . 2 liant les domaines empirique et formel . Une propriété physique peut être abstraite par une grandeur et une grandeur abstrait une propriété physique . Le fait que ces relations soient des homomorphismes implique que la manipulation des grandeurs est soumise aux contraintes du domaine empirique . Il est donc proscrit d’appliquer une fonction de mesure à une grandeur si cette fonc - tion n’a pas de projection possible dans une expérimentation . Cependant , il n’est pas aisé d’assigner une échelle de mesure à un évè - nement empirique et cette assignation dépend fortement du but du mesu - rage [ 76 ] . Prenons l’exemple d’une course . Les coureurs peuvent être diffé - renciés par des mesures présentant des échelles de mesure différentes : — Nominale avec le nom ou numéro des brassards , — ordinale avec le classement à l’arrivée , — intervalle avec l’attribution de note par rapport à la performance , — ratio avec le temps à l’arrivée . Chacune de ces grandeurs peut être employée pour différencier un concur - rent spéciﬁque de l’ensemble . Néanmoins en considérant deux groupes de coureurs , seule la connaissance du temps à l’arrivé autorise de déﬁnir exac - tement quel groupe a été le plus rapide pour terminer le parcours à l’aide d’une moyenne du temps de parcours . Malgré cette difﬁculté , la RTM répond aux besoins de mesurages de grandeurs non physiques [ 40 ; 78 ] . 25 CHAPITRE 2 . LA SCIENCE DE LA MESURE 2 . 2 . 3 Procédures et incertitudes de mesure Tout mesurage implique une incertitude de mesure générée par la limite de précision des instruments et la combinaison des erreurs induites par la procédure de mesure [ 39 ] . Il est impossible de relever une grandeur par - faite . Bien que les incertitudes et leurs impacts sur l’évènement observé ne puissent pas être évités , elles peuvent être estimées et réduites [ 39 ; 88 ] . Le Guide pour l’expression de l’incertitude des mesurages ou Guide to the ex - pression of Uncertainty in Measurement ( GUM ) est la référence internatio - nale concernant l’estimation des incertitudes de mesures [ 88 ] . Il présente le vocabulaire et les méthodes pour les estimer et amoindrir leurs impacts . Il faut noter que c’est le contexte d’utilisation de la grandeur qui déﬁnit les valeurs d’incertitudes acceptables ou non . Une valeur d’incertitude de 1 mm sur la largeur d’un toit est rarement critique . La même incertitude sur l’épaisseur d’un cheveu n’est , par contre , pas acceptable . D’un autre côté , le prix d’un mètre ruban n’est pas comparable à celui d’un instrument capable de mesurer ﬁdèlement la largeur d’un cheveu . Une procédure de mesure spéciﬁquement déﬁnie est l’approche la plus ﬁable pour assurer de produire des grandeurs dont les valeurs d’incerti - tudes correspondent aux besoins du mesurage . Une telle procédure per - mettra d’assurer une valeur d’incertitude tout en optimisant les coûts im - pliqués par l’acquisition et l’utilisation des instruments de mesure néces - saires . Les diagrammes causes et effets , aussi appelés diagrammes d’Ishi - kawa [ 62 ] , utilisés en gestion de qualité pour représenter graphiquement les causes liées à un effet , permettent de simpliﬁer cette tâche en asso - ciant des branches d’entrées aux différentes sources d’incertitudes [ 9 ] . Ces sources sont généralement la méthode employée pour le mesurage , l’opé - rateur qui réalise le mesurage , les instruments de mesure , l’environnement dans lequel est réalisé le mesurage et l’entité soumise au mesurage [ 38 ] . Différentes solutions logicielles proposent d’estimer les valeurs d’incer - titudes . Elles emploient plusieurs approches . Par exemple , elles peuvent utiliser un modèle mathématique [ 37 ] ou encore appliquer la loi de la pro - pagation des incertitudes [ 52 ] . Ces solutions logicielles impliquent des connaissances approfondies de la métrologie et un ensemble précis de spéciﬁcations à respecter est préco - nisé [ 28 ] . L’estimation des incertitudes est de première importance , cepen - dant , ces travaux n’abordent pas cette thématique . L’accent est mis sur la création d’applications de mesures conforme à la sémantique de la métro - logie en considérant que le mesurage proposé par l’utilisateur permet de relever des grandeurs qui correspondent à ses besoins . Les connaissances de la métrologie présentées sur la ﬁgure 2 . 2 assurent 26 CHAPITRE 2 . LA SCIENCE DE LA MESURE que les grandeurs encodent bien des évènements du monde réel , et ce pour toutes étapes de la procédure de mesure . De ce fait , il est possible d’appe - ler l’ensemble de ces connaissances la sémantique de la métrologie . Cette sémantique englobe les deux approches de vériﬁcations présentées . Pre - mièrement , les systèmes de grandeurs et d’unités contraignent la manipu - lation des grandeurs en fonction des lois de la physique auxquelles elles sont sujettes . Deuxièmement , la RTM renforce ces contraintes en prenant en compte que la manipulation de grandeurs doit respecter les proprié - tés intrinsèques aux évènements observés . Grace à ces considérations , elle permet également de prendre en compte des grandeurs non physiques . Ces deux points sont vériﬁés par la combinaison de l’analyse dimensionnelle et l’analyse des échelles de mesure de la RTM . 2 . 3 La métrologie et l’informatique Cette section présente une vue d’ensemble des approches qui permettent la modélisation de grandeurs et de procédures de mesures dans les sys - tèmes logiciels . Différentes approches ont été employées pour encoder les concepts de la métrologie dans des systèmes logiciels : ontologies , modélisation , enco - dage des unités ou des dimensions , etc . Cependant , le problème majeur de ces implantations est le manque d’une normalisation des concepts propo - sés [ 42 ] . Ce manque a généré un écosystème de logiciels sans cohésions , chaque système proposant des interprétations et encodages différents des notions de la métrologie . L’ Open Geospatial Consortium propose la norme Observations and Mea - surements ( O & M ) [ 64 ] . Ce modèle propose d’employer des classiﬁcations pour déﬁnir l’ensemble des valeurs associé à une grandeur , physique ou non . O & M permet de modéliser les mesurages de n’importe quel domaine en décrivant des séquences d’observations . Un framework [ 14 ] est déve - loppé autour de O & M et ajoute les notions de procédure et un langage pour l’encodage de capteurs nommé SensorML . O & M est utilisé par le consor - tium pour la description de procédures de mesures précises impliquant tout type de protocoles de mesurage . Cependant , étant employée par des ex - perts , aucune approche pour vériﬁer la cohérence des procédures de me - sures n’est proposée . Le Uniﬁed Code For Units of Measure ( UCUM ) est un système d’enco - dage conçu pour inclure toutes les unités employées communément [ 111 ] . Son but est de proposer un encodage non ambigu pour la communication électronique de grandeurs . Cet encodage permet de représenter toutes 27 CHAPITRE 2 . LA SCIENCE DE LA MESURE unités physiques sous la forme d’une trame de sept caractères ASCII . Le UCUM est un langage capable d’exprimer toutes les unités , même pré - ﬁxées . De plus il ne présente pas de conﬂit dans les expressions d’unités du moment que les unités hors du SI ne sont pas préﬁxées . C’est donc une solution viable pour représenter les grandeurs comme des structures com - posées d’un nombre et d’une unité décrite par le UCUM . Malgré l’intérêt que présente l’encodage du UCUM pour la communication entre machines , il n’est dédié qu’à cette tâche et malheureusement n’est que rarement em - ployé par les instruments de mesure communicants . Le UCUM ne propose aucune sémantique de la métrologie . Ainsi il ne devrait être employé qu’au niveau des interfaces de communication des systèmes logiciels l’employant . Dans l’ingénierie des connaissances , une ontologie spéciﬁe l’ensemble des concepts et termes d’un domaine tout en explicitant les relations les liants [ 50 ] . Les grandeurs permettent d’encoder la connaissance que l’on a d’un objet . Cet encodage est réalisé à l’aide d’un vocabulaire et de règles normalisés . Il est donc logique de trouver des ontologies pour représenter les grandeurs et les unités . Quantities , Units , Dimensions and data Types ( QUDT ) [ 58 ] est une onto - logie dédiée à la représentation de systèmes de grandeurs et d’unités phy - siques . Elle est capable de déﬁnir la dimension de n’importe quelle unité et de déduire le type de grandeur résultant de manipulations de gran - deurs . QUDT propose une base réutilisable dans n’importe quel logiciel pour prendre en charge les grandeurs , les unités et leurs manipulations . Cependant , cette ontologie n’est pas capable de différencier des grandeurs de types différents mais présentant des dimensions identiques . Cela appa - raît par exemple entre un couple mécanique et une énergie ou encore entre une grandeur sans dimension et un angle . Ontology of units of Measure and related concepts ( OM ) est une ontolo - gie qui modélise les concepts de la métrologie [ 99 ] . Son but est l’ajout de sé - mantique issue de la métrologie à des systèmes employant des mesurages . OM propose un service web pour appliquer l’analyse dimensionnelle sur des équations . Elle propose également de prendre en compte les domaines d’application . En déﬁnissant les unités usuelles pour un domaine donné , elle réduit le champ lexical des unités employées et évite de confondre des uni - tés présentant des dimensions identiques et des sémantiques différentes . En effet , en sachant que le domaine d’application est le calcul de forces rotatives , OM peut retirer les unités concernant le domaine de l’énergie . OM propose d’étendre les capacités d’outils couramment employés par les chercheurs ( e . g . Microsoft Excel TM , Matlab TM ) , en y ajoutant les concepts de la métrologie . Cependant , l’implantation de OM est basée sur une inter - prétation des échelles qui est différente de celle de la RTM [ 99 ] . OM n’est 28 CHAPITRE 2 . LA SCIENCE DE LA MESURE donc pas capable de représenter des grandeurs non physiques . Des approches alternatives étendent les capacités des langages de pro - grammation classiques avec les notions de grandeur , d’unités et d’analyse dimensionnelles . Des travaux ont été réalisés pour employer les capacités du préprocesseur embarqué par le compilateur de C + + [ 23 ] et la librairie Boost propose une implantation relativement récente de ce concept [ 112 ] . L’idée est d’inclure les unités des grandeurs dans le code sous la forme de macros . La présence de grandeurs directement dans le code source faci - lite sa compréhension et responsabilise son rédacteur , car les entités ma - nipulées ne sont plus simplement des valeurs numériques , mais des gran - deurs . Cette approche évite la plupart des erreurs liées aux dimensions qui peuvent apparaître dans le code source d’une application de mesure . Ce - pendant elle est fondée sur l’analyse dimensionnelle proposée par le SI . Elle ne considère pas les systèmes de grandeurs différents . De plus elle ne prend pas en compte la RTM et les grandeurs non physiques . Enﬁn , des langages et outils spécialisés pour la modélisation de sys - tèmes physiques existent [ 1 ; 84 ] . Ils permettent une modélisation ﬁdèle des grandeurs et de leurs manipulations . Cependant , ils ne sont pas conçus pour être utilisés dans des processus de développement logiciels , mais pour la modélisation et la simulation de systèmes physiques . Le tableau 2 . 2 montre une comparaison des différentes approches . 29 CHAPITRE 2 . LA SCIENCE DE LA MESURE O & M U C U M Q U D T O M P r e p r o c e ss e u r s U n i t é s t o u t e s p h y s i q u e s p h y s i q u e s p h y s i q u e s p h y s i q u e s P r o c é d u r e d e m e s u r e c o m p l e x e a u c un e b a s i q u e b a s i q u e b a s i q u e A n a l y s e d i m e n s i o nn e ll e n o n n o n o u i o u i o u i A n a l y s e d e s é c h e ll e s n o n n o n n o n n o n n o n C o nn a i ss a n c e s r e q u i s e s e x p e r t b a s i q u e b a s i q u e b a s i q u e b a s i q u e U t ili s a t i o n s y s t è m e s e m p l o y a n t d e s c a p t e u r s c o m p l e x e s e n c o d a g e d ’ un i t é e t c o mm un i c a t i o n v é r i ﬁ c a t i o n v é r i ﬁ c a t i o n e t a i d e a u x e x p e r t s v é r i ﬁ c a t i o n d e c o d e s o u r c e T a b l e a u 2 . 2 – C o m p a r a i s o n d e s s y s t è m e s p e r m e tt a n t d e m o d é li s e r d e s g r a n d e u r s o u d e s p r o c é d u r e s d e m e s u r e s 30 CHAPITRE 2 . LA SCIENCE DE LA MESURE 2 . 4 Conclusion La métrologie est la science qui permet de déﬁnir les approches et les règles utilisées pour abstraire des évènements du monde réel en grandeurs , des abstractions formelles . Les grandeurs simpliﬁent la communication em - ployant des références connues de tous pour comparer les évènements de mêmes natures . La sémantique de la métrologie , en plus de proposer un vocabulaire in - ternational , déﬁnit un ensemble de contraintes assurant la cohérence entre les grandeurs et les évènements empiriques . Ces contraintes peuvent être vériﬁées en appliquant l’analyse dimensionnelle des systèmes de grandeurs et l’analyse des échelles de mesure de la RTM . Différents systèmes logiciels proposent de modéliser des grandeurs ou des procédures de mesure . À cause d’un manque de formalisme dans le domaine de l’informatique , aucune normalisation n’est proposée . Ainsi , les systèmes proposent des points de vue , des encodages et des formalismes différents et génèrent un écosystème sans cohésion . Les travaux présentés ultérieurement emploient trois points de vue dif - férents sur ce qu’est une procédure de mesure en fonction du contexte d’uti - lisation ( modélisation d’application , vériﬁcation de procédures de mesure , implantation d’application ) . Le chapitre suivant présente les différentes ap - proches et outils , issus du monde du logiciel , employés pour réaliser ces travaux . 31 CHAPITRE 2 . LA SCIENCE DE LA MESURE 32 Chapitre 3 Génie Logiciel « C’est seulement pour ceux qui persévèrent après que tout semble perdu , que l’espoir luit à nouveau . » Gilbert Keith Chesterton Sommaire 3 . 1 Représentation des connaissances et mécanismes de raisonnement . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34 3 . 1 . 1 Systèmes experts . . . . . . . . . . . . . . . . . . . . . . . 36 3 . 1 . 2 Syntaxes et sémantiques . . . . . . . . . . . . . . . . . . 37 3 . 1 . 3 Ontologies et Prolog . . . . . . . . . . . . . . . . . . . . . 42 3 . 2 Paradigmes logiciels et production de systèmes . . . . . 46 3 . 2 . 1 Paradigme objet . . . . . . . . . . . . . . . . . . . . . . . . 46 3 . 2 . 2 Paradigme composant . . . . . . . . . . . . . . . . . . . . 48 3 . 2 . 3 Paradigme agent . . . . . . . . . . . . . . . . . . . . . . . 50 3 . 3 Modélisation et représentations de systèmes . . . . . . . 51 3 . 3 . 1 Langages génériques et UML . . . . . . . . . . . . . . . 54 3 . 3 . 2 Langages Spéciﬁques de Domaines . . . . . . . . . . . . 55 3 . 4 Ingénierie Dirigée par les Modèles . . . . . . . . . . . . . . 56 3 . 4 . 1 Modélisation et métamodélisation . . . . . . . . . . . . 58 3 . 4 . 2 Transformations de modèles . . . . . . . . . . . . . . . . 62 33 CHAPITRE 3 . GÉNIE LOGICIEL Ce chapitre présente différentes approches du génie logiciel . Celles - ci répondent aux différents besoins d’un processus de développement dans le contexte de ces travaux . Cette présentation commence par une description des approches de représentations de connaissances employées pour créer des systèmes ca - pables de raisonner . Deux approches sont étudiées , les logiques descrip - tives et la programmation logique . Elles peuvent être utilisées aﬁn de mo - déliser et de raisonner sur un domaine pour générer un système expert . Ensuite ce sont trois paradigmes employés pour l’implémentation de systèmes logiciels qui sont présentés . Ces paradigmes sont les objets , les composants et les agents . Ils permettent de simpliﬁer l’implantation des systèmes logiciels qui seront développés dans ces travaux . La section suivante présente la modélisation de systèmes . Elle permet de décrire des descriptions , formelles ou non , des structures , comporte - ments et communications d’un système . Ces descriptions sont employées pour communiquer avec les différentes parties intervenant dans le dévelop - pement d’un logiciel . Les langages génériques et les langages dédiés sont présentés . Enﬁn , l’Ingénierie Dirigée par les Modèles , une approche qui permet d’utiliser les modèles comme unités descriptives d’implantation est abor - dée . Cette approche permet d’adapter les points de vue sur le système aﬁn de permettre l’interopérabilité des approches présentées tout en proﬁtant de leurs avantages . Les notions de métamodélisation , utilisées pour la créa - tion de langages de modélisation , et de transformation de modèles , utilisées pour l’adaptation du modèle en code d’implémentation , de vériﬁcation ou encore pour sa mise à jour sont décrites . 3 . 1 Représentation des connaissances et mé - canismes de raisonnement Une représentation des connaissances , ou Knowledge Representation ( KR ) permet d’encoder les connaissances propres à un domaine sous forme numérique . Cet encodage permet de partager ces connaissances et de rai - sonner dans le domaine comme le ferait un être humain [ 32 ] . L’approche la plus utilisée est la logique mathématique [ 25 ] . Les langages les plus usités ( Java , C + + , C # ) pour le développement de systèmes logiciels sont des langages impératifs [ 36 ; 121 ] . Cette désignation implique que le logiciel est décrit sous la forme d’instructions qui seront sui - vies à la lettre lors de l’exécution . Le développeur décrit donc les structures 34 CHAPITRE 3 . GÉNIE LOGICIEL 1 ensoleillé élément 2 juillet élément 3 sec élément 4 couleur ( soleil , jaune ) relation 5 mois ( juillet , 7 ) relation 6 si ensoleillé et juillet alors chaud relation complexe 7 si juillet et humide alors orageux relation complexe a le temps est - il ensoleillé ? requête b est ce qu’il fait chaud ? requête c le temps est - il orageux ? requête Tableau 3 . 1 – Exemple d’une représentation des connaissances basiques de météo . de contrôle et comment elles interagissent . Les langages employés pour dé - ﬁnir les KR sont généralement déﬁnis comme des langages déclaratifs [ 74 ] . Ces langages décrivent le système sans s’attarder sur l’utilisation qui en sera faite . Le développeur ne décrit plus une solution mais un problème . Une KR contient des éléments et des relations liant les éléments . De ce point de vue , elles sont identiques aux bases de données classiques ( re - lationnelles ) [ 101 ] . Elles contiennent également des relations complexes qui permettent de lier des éléments et des relations . Les langages de des - cription des KR sont liés à des sémantiques fortes dérivées de la logique . Cela permet à la KR de pouvoir répertorier les entités qui la composent mais également , une fois associée à un moteur d’inférence , de raisonner sur l’ensemble de ces entités en déduisant des relations qui ne sont pas expressément décrites [ 90 ] . Ces approches sont à l’origine de l’essor des premières Intelligences Artiﬁcielles utilisant les langages LISP ou Prolog [ 18 ; 32 ; 65 ] et continuent à être employées . Le tableau 3 . 1 montre un example d’une KR dans le domaine de la météo . Elle est composée de trois éléments , de deux relations et deux relations complexes . La réponse à la requête ( a ) est trouvée directement dans la KR avec l’élément ( 1 ) et est donc vraie . Les requêtes ( b ) et ( c ) nécessitent de pou - voir raisonner sur les connaissances pour répondre . La ﬁgure 3 . 1 montre le raisonnement qui permet de déduire qu’il fait chaud . Il est donc important de noter qu’une KR n’est pas une représentation parfaite des connaissances du domaine représenté . Une personne dévelop - pera une KR qui représente ses connaissances à l’aide de son vocabulaire et qui servira de support à ses raisonnements [ 32 ] . La représentation est donc une projection des connaissances spéciﬁques que le développeur possède sur le système original . 35 CHAPITRE 3 . GÉNIE LOGICIEL ( 5 ) ( 1 ) ( 2 ) ( 3 ) ( b ) ( 6 ) ( 4 ) chaud ? ensoleillé ? juillet ? vrai vrai vrai vrai ( 7 ) Figure 3 . 1 – Raisonnement permettant d’inférer qu’il fait chaud en utilisant la KR de météo . Ainsi , ce ne sont pas tous les éléments de l’original qui sont représentés . Un raisonnement issu d’une KR donc peut induire un résultat qui ne corres - pondra pas aux propriétés réelles . Il est donc important de connaitre non seulement les capacités de la représentation mais également ses limites . La requête ( c ) de la table 3 . 1 permet d’illustrer ces propos . Contraire - ment au raisonnement que ferait un humain , il n’est pas possible de ré - pondre avec certitude à la requête ( c ) . En effet , ensoleillé , juillet et sec sont des éléments de la base . Bien que la langue française implique que sec et humide soient deux contraires , rien ne le spéciﬁe dans la KR . Ne connaissant pas la valeur pour humide , il est impossible de déterminer une réponse pour ( 7 ) . De plus , le raisonnement pour la question ( b ) apporte une réponse inexacte s’il est effectué au pôle nord . 3 . 1 . 1 Systèmes experts Une KR ne contient pas l’ensemble des connaissances d’un domaine . Elle encode les connaissances sous la forme d’entités et de relations . Il est ensuite possible , à l’aide de mécanismes d’inférence , de raisonner sur l’ensemble des éléments la constituant . L’association d’une KR et d’un moteur d’inférence est souvent appelé système expert [ 65 ] . Les systèmes experts sont des systèmes d’intelligence artiﬁcielle . Le but de ces systèmes étant de déduire une réponse à une re - quête d’entrée , en raisonnant sur les connaissances d’un domaine . Ces sys - tèmes sont utilisés depuis les années 80 et sont encore utilisés aujourd’hui , particulièrement avec l’émergence des ontologies ( voir section 3 . 1 . 3 ) . Ces systèmes emploient deux types de connaissances [ 35 ] : — connaissances factuelles : Connaissances axiomatiques accessibles directement dans la KR . Ces connaissances sont communément parta - 36 CHAPITRE 3 . GÉNIE LOGICIEL gées et peuvent être trouvées dans des manuels ou journaux spéciali - sés , — connaissances heuristiques : Connaissances du domaine considé - rées comme bonnes pratiques , jugements ou encore raisonnement . Elles comprennent les décisions réﬂéchies dans le domaine . Un système expert est généralement constitué de deux parties : une représentation des connaissances et un moteur d’inférence . La ﬁgure 3 . 2 représente un système expert ainsi que les deux types de connaissances qui peuvent être employées pour déduire des réponses . Système expert Factuelle Euristique Base de connaissances KR Moteur d’inférence Symbolise Interroge Faits Solution Requêtes Figure 3 . 2 – Combinaison d’une représentation des connaissances et d’un moteur d’inférence dans un système expert . Différents algorithmes d’inférence sont utilisés dans les systèmes ex - perts . Les plus représentés et les plus simples sont les algorithmes de chai - nage avant ou arrière [ 22 ] . 3 . 1 . 2 Syntaxes et sémantiques La plupart des KR sont décrites en utilisant la syntaxe des calculs des prédicats aussi nommée logique du premier ordre , ou First Order Logic ( FOL ) [ 25 ; 97 ] . La FOL est une formalisation de la logique mathématique . Elle propose une syntaxe permettant de décrire le raisonnement hu - main proche de l’expression d’un raisonnement par le langage naturel . Une 37 CHAPITRE 3 . GÉNIE LOGICIEL phrase telle que " il existe un homme nommé Socrate " aura en équivalent FOL ; " il existe X tel que X se nomme Socrate et X est un homme " . En plus de son expressivité , ce formalisme est construit autour des no - tions de démonstration . Il permet donc de déﬁnir la véracité d’un énoncé à partir des éléments le constituant . On pourra donc vériﬁer que Socrate est bien un homme . Syntaxe La syntaxe de la FOL se compose de termes , de prédicats , de connec - teurs logiques et de quantiﬁcateurs . Les termes représentent des éléments du domaine décrit . Il en existe trois sortes 1 . une constante représente un élément spéciﬁque : jack , jaune , a , 13 , 2 . une variable représente un ou plusieurs éléments qui répondent au contexte : X , Jack , Value , 3 . une fonction déﬁnit un élément à partir des éléments utilisés en ar - guments . Elles peuvent être vue comme des constructeurs pour des éléments qui ont des attributs : bureau ( jack ) , + ( x , 1 ) . Dans ce document , les constantes seront représentées par un nom commen - çant par une minuscule et les variables par une majuscule . Les prédicats , également appelés atomes , représentent les relations entre des ensembles de termes . Ils sont constitués d’un symbole de prédicat et d’un ensemble de termes : mois ( juillet , 7 ) , > ( x , 10 ) , P , Q ( r ) . Les prédicats sont équivalents à des fonctions qui assignent la valeur vrai pour chaque vecteur de termes qui remplissent la relation ; et faux pour chaque vecteur de termes qui ne la satisfont pas . Par exemple , le prédicat Q ( r ) associera la valeur vrai à toute réponse r qui répond à la question Q . P est un prédicat sans paramètre . Il peut être vu comme une variable à laquelle la valeur vrai ou faux sera associée par le domaine . Les prédicats sont donc des formules logiques déﬁnissant les vecteurs d’éléments soumis ou non à une relation . En appliquant des connecteurs sur des formules il est possible de construire des formules dites complexes . Il existe cinq connecteurs , illustrés ci - après , avec A et B des formules : 1 . la négation logique ¬ A est vraie si A est fausse , 2 . la conjonction A ∧ B est vraie si A et B sont vraies , 3 . la disjonction A ∨ B est vraie si A ou B est vraie , 4 . l’équivalence A ⇔ B est vraie si A et B sont fausses ou sont vraies , 5 . l’implication A ⇒ B est vraie si A est fausse ou B est vraie . 38 CHAPITRE 3 . GÉNIE LOGICIEL Les deux derniers connecteurs permettent d’exprimer les règles qui ré - gissent le domaine décrit . Ce sont ces règles qui permettent de raisonner sur l’ensemble des éléments énoncés . La syntaxe propose deux quantiﬁcateurs illustrés ci - après avec X une variable : 1 . le quantiﬁcateur existentiel ∃ X f lorent ( X ) ∧ doctor ant ( X ) est " vrai " s’il existe un élément substituable à X qui se nomme Florent et qui est doctorant . 2 . le quantiﬁcateur universel ∀ X doctor ant ( X ) ⇒ é tudi ant ( X ) implique que si X est doctorant alors X est étudiant est " vrai " pour tout choix attri - buable à X Les quantiﬁcateurs permettent de restreindre l’ensemble des éléments qui peuvent être attribués à une variable . Une variable associée à un quanti - ﬁcateur est dite liée ; les autres variables sont dites libres . Si toutes les variables d’une formule sont quantiﬁées , alors elle est nommée phrase . Il est possible de déﬁnir la véracité d’une phrase . La table 3 . 2 montre trois formules utilisant le même prédicat et montre les différentes interprétations qui en sont déduites . 1 = ( 2X , X ) indéﬁnie , X peut être tout élément 2 ∀ X entier ( X ) ∧ = ( 2X , X ) faux , X peut être tout entier 3 ∃ X entier ( X ) ∧ = ( 2X , X ) vrai , X peut être 0 Tableau 3 . 2 – Différentes interprétations pour un prédicat avec des variables liées ou libres . La ﬁgure 3 . 3 représente la syntaxe de la FOL sous la forme d’un dia - gramme de classe . Toute formule exprimable à l’aide de ces éléments est une formule FOL correcte au niveau syntaxique . Sémantique La syntaxe de la FOL permettant de représenter les éléments et rela - tions d’un domaine à l’aide de formules logiques a été présentée . Il faut maintenant associer une sémantique , un sens , aux formules . L’ interprétation d’une formule permet d’associer des objets du domaine aux éléments syntaxiques ( termes et prédicats ) qui la composent . C’est l’in - terprétation qui déterminera la véracité des formules . Prenons la formule couleur ( soleil , ver t ) . Cette formule est fausse si l’interprétation associe le corps céleste nommé soleil à soleil et la couleur verte à ver t . Mais elle peut être vrai si l’interprétation associe le soleil dessiné par un enfant à soleil . 39 CHAPITRE 3 . GÉNIE LOGICIEL T up l e * T e r m e C on s t a n t e V a r i a b l e F on c ti on S y m b o l e * A t o m e F o r m u l e S y m bo l e d e p r é d i ca t S y m bo l e d e c on s t a n t e S y m bo l e d e v a r i a b l e S y m bo l e d e f on c ti on * B i n a i r e O u E t I m p li qu e U n a i r e U n i v e r s e l N on E x i s t e n ti e l 2 B a s e d e c onn a i ss a n ce s * C o m p l e x e F i g u r e 3 . 3 – D e s c r i p t i o n d e l a s y n t a x e d e l a l o g i q u e d u p r e m i e r o r d r e s o u s l a f o r m e d ’ un d i a g r a mm e d e c l a ss e s . 40 CHAPITRE 3 . GÉNIE LOGICIEL C’est donc le domaine et l’interprétation qui en est faite ( ﬁgure 3 . 4 ) qui permettent de déterminer la véracité d’une formule . Une interprétation qui assigne la valeur " vrai " d’une formule est appelée un modèle pour la formule . Terme objet objetN Tuple Logique du premier ordre Monde Encode * Décode Encode Décode relations Atome Encode Décode I n t e r p r é t a ti on Figure 3 . 4 – Relations impliquées par l’interprétation entre le domaine et la syntaxe de la FOL . Il est délicat de déﬁnir qu’une formule F est une conséquence logique d’un ensemble de formules E . En effet ce n’est le cas que si F est vraie , si toutes les interprétations satisfaisant toutes les formules E sont aussi des modèles pour F [ 41 ] . Ce qui implique d’étudier toutes les interprétations , qui peuvent être nombreuses . Une autre approche , plus efﬁcace à calculer , utilise des règles d’infé - rences ( modus ponens , modus tollens , généralisation ) [ 25 ] qui réécrivent les formules et contraignent leur analyse . Par exemple , en imposant que F est la dernière formule d’une séquence de formules S ; S étant la concaté - nation de l’ensemble de formule E et de F ; on pourra prouver que F est déductible de S en considérant que toute formule de la séquence satisfait une des trois conditions suivantes : 1 . la formule est toujours satisfaite , 2 . la formule est un axiome ( un fait avéré dans l’analyse ) , 3 . la formule est dérivée des formules qui la précèdent dans S en utilisant une règle d’inférence . Ces approches optimisent le calcul et sont donc particulièrement utiles pour permettre de créer des outils logiciels capables de raisonner . Il existe un grand nombre d’outils capables de raisonner sur la FOL [ 29 ] . La ﬁgure 3 . 5 présente une KR permettant de représenter une généalo - gie . Le tableau 3 . 3 montre l’ensemble des formules la constituant . 41 CHAPITRE 3 . GÉNIE LOGICIEL jacques pierre père paul pereDe descendantDe humain Figure 3 . 5 – Représentation des connaissances d’une généalogie . 1 pere ( pier re ) 2 pere D e ( pier re , paul ) 3 descendant D e ( paul , j acques ) 4 ∀ X ( descendant D e ( Y , X ) ∨ pere D e ( X , Y ) ⇒ pere ( X ) ) 5 ∀ X ( pere ( X ) ⇒ humain ( X ) ) 6 ∀ X ∀ Y ( pere D e ( X , Y ) ⇒ descendant D e ( X ) ) 7 ∀ X ∀ Y ∃ Z ( pere D e ( X , Z ) ∧ descendant D e ( Z , Y ) ⇒ descendant D e ( X , Y ) Tableau 3 . 3 – Formules FOL pour la représentation des connaissances d’une gé - néalogie . Cette KR permet de déﬁnir que Paul est le descendant de Jacques et de Pierre , que Pierre et Jacques sont des pères et que Pierre et Jacques sont des humains . 3 . 1 . 3 Ontologies et Prolog Nous avons étudié deux approches communément employées pour dé - crire des représentations des connaissances et raisonner . Ce sont la logique descriptive [ 5 ] employée dans les ontologies [ 79 ] avec l’ensemble de lan - gage OWL [ 90 ; 127 ] et la programmation logique [ 75 ; 132 ] utilisée dans les moteurs de règles d’intelligences artiﬁcielles [ 49 ] avec le langage Prolog [ 120 ; 133 ] . Logique descriptive Une ontologie est une représentation des connaissances d’un domaine . Depuis quelques années , l’avènement du web sémantique [ 8 ] a entrainé un nombre croissant de travaux mettant à disposition des ontologies représen - tant les connaissances de multiples domaines . Les logiques de description proposent trois types d’entités : les concepts qui sont des classes d’individus , les rôles qui sont des relations entre indi - vidus et les individus qui sont des instances des concepts . Une KR décrite avec les logiques de description est structurée en deux parties , la ABox qui exprime les axiomes auxquels sont soumis les individus 42 CHAPITRE 3 . GÉNIE LOGICIEL et la TBox qui déﬁnit la structure de l’ontologie à l’aide des concepts et rôles . Plusieurs familles de logiques de description existent . Elles proposent toutes un ensemble d’éléments nommés constructeurs . Les constructeurs permettent de décrire les entités d’un domaine avec une syntaxe plus ou moins proche de la FOL . OWL ou Web Semantic Langage est le standard proposé par le W3C pour représenter les ontologies . C’est un ensemble de langages dérivé du lan - gage de description de graphes Resource Description Framework Schema ( RDFS ) et les logiques descriptives [ 2 ] . RDFS déﬁnit un ensemble de classes de base pour décrire formellement et typer les ressources publiées sur le web et décrire leurs relations à l’aide de triplets de la forme < su jet , pr é dicat , ob jet > . Il permet donc la descrip - tion de termes et de prédicats des FOL OWL augmente d’un niveau les relations exprimables en ajoutant des constructeurs équivalents aux connecteurs et quantiﬁcateurs de la FOL ainsi que des constructeurs plus expressifs comme la restriction de car - dinalité ou des concepts globaux permettant d’adresser tous les individus ou aucun . Le tableau 3 . 4 montre la KR de la ﬁgure 3 . 5 décrite en logique de des - cription . 1 H uman i s A C lass 2 Pè re sub C lass O f H uman 3 p è re D e i s A P r oper t y 4 Pè re p è re D e H uman 5 descendant D e i s A T r ansi ti ve P r oper t y 6 descendant D e inver se O f p è re D e 7 H uman descendant D e Pè re a Pè re ( pier re ) b pier re p è re D e paul ) c paul descendant D e j acques Tableau 3 . 4 – Description OWL pour la représentation des connaissances d’une généalogie . La partie supérieure déﬁnit les classes et propriétés ( TBox ) . La partie inférieure déﬁnit les instances ( Abox ) Le langage est dérivé en plusieurs sous - langages aux capacités d’expres - sions et complexités d’inférences croissantes : OWL Lite , OWL DL et OWL Full [ 71 ] . OWL Lite propose un ensemble réduit de constructeurs assurant sa compatibilité avec RDFS et que toute démonstration est décidable . OWL 43 CHAPITRE 3 . GÉNIE LOGICIEL DL propose un ensemble syntaxique décidable . Il n’est cependant pas entiè - rement compatible avec RDFS . OWL Full offre une expressivité maximale , une compatibilité avec RDFS mais ne garantit pas la décidabilité des dé - monstrations . Le choix du langage est à faire en fonction de l’utilisation de l’ontologie . Il est à noter que le développement d’une ontologie implique d’employer plusieurs langages ( pour la description des ABox et TBox ) et impose des en - vironnements de développement ainsi que des formalismes contraignants . Les ontologies permettent un accès aux résultats d’un développement simplement au travers d’internet et permettent une grande expressivité . Les logiques descriptives imposent que le raisonnement soit monotone . La KR ne peut donc pas être modiﬁée par le raisonnement . Les raisonnements réalisés utilisent l’hypothèse du monde ouvert . Cette hypothèse implique que toute formule est considérée vraie tant que l’on ne peut pas prouver qu’elle est fausse . Programmation logique La programmation logique quant à elle propose de représenter l’en - semble d’une KR sous la forme de règles et de faits . Les faits représentent les axiomes du domaine et les règles , les règles logiques qui régissent le domaine . C’est le langage Prolog ( Programmation logique ) qui est le plus utilisé dans ce domaine . Pour simpliﬁer et accélérer la démonstration des expres - sions de la FOL , prolog propose de décrire les formules complexes sous la forme d’un ensemble de clauses de Horn [ 60 ] . Une clause de Horn est une conjonction de clauses qui est composée au plus d’un seul littéral positif et d’un nombre ﬁni de littéraux négatifs . Un littéral est un prédicat ou la négation d’un prédicat . Ainsi , la formule complexe A1 ∧ A2 ∧ A3 ⇒ B composée des formules A1 , A2 , A3 et B peut être réécrite sous la forme ( ¬ A1 ∨ ¬ A2 ∨ ¬ A3 ) ∨ B . B sera alors démontrée en démontrant consécutivement A1 , A2 et A3 . Pour Prolog , il existe trois sortes de clauses . 1 . les faits qui représentent les axiomes du domaine . Un fait est une clause ne contenant aucun littéral négatif . 2 . les règles qui représentent les relations logiques du domaine . Une règle est une clause avec un littéral positif et un nombre ﬁni de litté - raux négatifs , 3 . les buts qui représentent une requête de démonstration qui sont géné - ralement les entrées d’un système expert . Un but est une clause avec 44 CHAPITRE 3 . GÉNIE LOGICIEL uniquement des littéraux négatifs . Le tableau 3 . 5 montre la KR de la ﬁgure 3 . 5 décrite en Prolog . 1 pere ( pier re ) . 2 pere ( X ) : − pere D e ( X , _ ) . 3 pere ( X ) : − descendant D e ( _ , X ) . 4 pere D e ( pier re , paul ) . 5 humain ( X ) : − pere ( X ) . 6 descendant D e ( paul , j acques ) . 7 descendant D e ( X , Y ) : − pere D e ( Y , X ) . 8 descendant D e ( X , Z ) : − pere D e ( X , Y ) , descendant D e ( Y , Z ) . Tableau 3 . 5 – Règles Prolog pour la représentation des connaissances d’une généa - logie . La distribution la plus utilisée de Prolog est SWI - Prolog . C’est une dis - tribution qui a été construite dans l’optique de créer des systèmes experts impliquant des besoins d’interactions et de raisonnement élevés . La com - munauté d’utilisateurs contribue à l’élaboration de librairies de règles per - mettant d’augmenter les capacités du langage tout en simpliﬁant son utili - sation [ 133 ] . SWI - Prolog propose un raisonnement qui est partiellement non mono - tone . Il est donc possible de modiﬁer la KR pendant le raisonnement en ajoutant ou retirant des clauses temporaires . Les raisonnements réalisés utilisent l’hypothèse du monde fermé . Toute formule est considérée fausse à moins que le contraire ne soit démontré . SWI - Prolog permet de mélan - ger des approches déclaratives et impératives . Ce qui permet de manipuler la démonstration de requêtes en manipulant l’algorithme de raisonnement . Par exemple en réduisant le nombre de règles à analyser [ 86 ] . Ces travaux utilisent SWI - Prolog comme outil de développement plutôt que OWL pour sa simplicité de déploiement , sa vitesse de démonstration , sa librairie de fonctionnalités et pour l’hypothèse du monde fermé . Cette hypothèse permet de garantir qu’une requête est vraie , car démontrée ce qui est important dans le cas d’une validation de systèmes . Notez que plusieurs travaux proposent de combiner les logiques descrip - tives et la programmation logique pour proﬁter de la forte expressivité des ontologies et des capacités de raisonnement de Prolog . [ 3 ; 30 ; 109 ; 116 ] 45 CHAPITRE 3 . GÉNIE LOGICIEL 3 . 2 Paradigmes logiciels et production de sys - tèmes La section précédente a présenté des approches pour modéliser et rai - sonner sur les connaissances d’un domaine . C’est une de ces approches qui est employée dans ces travaux pour vériﬁer qu’une procédure de mesure est conforme aux règles de la métrologie . La procédure de mesure étant validée , il faut pouvoir créer des systèmes logiciels capables d’assister l’utilisateur lors de ses activités de mesure . Cette section présente trois paradigmes permettant l’implantation de sys - tèmes logiciels : les paradigmes objet , composant et agent . Les systèmes logiciels sont implantés en utilisant des langages de pro - grammation . Ces langages ont évolué et proposent des abstractions tou - jours plus puissantes pour simpliﬁer le travail des développeurs tout en augmentant la réutilisation et la maintenabilité des systèmes développés . 3 . 2 . 1 Paradigme objet Le paradigme objet est l’approche la plus employée actuellement pour représenter et implanter les systèmes logiciels . Les approches impératives ( pascal , assembleur , C ) représentent un système par une suite séquentielle d’actions ( fonctions ) qui permettent de manipuler l’état du système ( va - riables ) . Le paradigme objet propose d’ajouter de nouvelles entités nom - mées objets . Un objet est une structure logicielle qui encapsule un état et propose une interface permettant de le manipuler [ 13 ] . Un système logiciel se compose d’un ensemble d’objets qui communiquent entre eux . C’est l’in - teraction de l’ensemble des objets qui permet de réaliser le comportement global du système . Le paradigme objet permet de diminuer la complexité du développement d’un système logiciel en le décomposant en objets aux buts et portées plus limitées . Un système complexe se décompose donc en un ensemble de sous - systèmes simples et maîtrisés . Ce qui permet de rapprocher la forme du système logiciel du système réel [ 36 ] . La ﬁgure 3 . 6 montre la structure d’objets employée par une application permettant d’estimer le prix d’une installation de panneaux solaires simple . Il y a des objets pour représenter les différents éléments du système observé : toit , capteur de distance , pan - neau solaire , prix . Ces objets communiquent pour mesurer le toit , calculer le prix de l’installation et proposer une interface de pilotage . Les objets sont les éléments d’un système logiciel lors de son exécu - tion . Le développeur ne décrit pas tous les objets du système . Il déﬁnit des 46 CHAPITRE 3 . GÉNIE LOGICIEL toit : Rectangle prixInstalation : Valeur : CapteurLaser 1 . 1 : majLongueur ( ) : PanneauSolaire : Interface Système réel Systèmeobjet 2 . 1 : majLargeur ( ) : CalculePrix 3 . 3 : aire ( ) 3 . 1 : aire ( ) 3 . 2 : prix ( ) 3 . 4 : maj ( ) 4 : valeur ( ) 3 : calcule ( ) 1 : captureLongueur ( ) 2 : captureLargeur ( ) Figure 3 . 6 – Utilisation d’objets logiciels pour formaliser une application mobile d’estimation du prix de panneaux solaires pour un toit . classes , des modèles décrivant chaque type d’objet . La classe déﬁnit l’en - semble des capacités d’un type d’objet et il est possible de créer ( instancier ) autant d’objets que nécessaire à partir d’une classe donnée . L’autre méca - nisme présent est l’ héritage . Une classe héritant d’une autre en prend les caractéristiques aﬁn de la spécialiser . L’intérêt étant de créer des familles d’objets . Il est possible de manipuler les objets soit en tant qu’entités spé - cialisées soit en tant qu’entité appartenant à une famille ( généricité ) . Un objet instancié ne peut être adressé que par les fonctions et variables que le développeur a décidé de laisser accessibles . Cette encapsulation des mécanismes de fonctionnement est analogue à ce que proposent les sys - tèmes du quotidien . Une voiture est un objet très complexe , mais cette complexité est cachée pour ne présenter que quelques interactions à l’uti - lisateur . L’encapsulation des propriétés des objets simpliﬁe leur utilisation , leur vériﬁcation et leur réutilisation dans d’autres systèmes . De plus , il apparaît que les programmes fondés sur les concepts objets tendent à réutiliser les mêmes structures . Ces structures ont été identiﬁées depuis plusieurs années et diffusées pour permettre d’appréhender correc - tement les problèmes qu’elles permettent de résoudre [ 134 ] . Elles sont ap - pelées patrons de conception . Bien que génériques , ils peuvent présenter des spéciﬁcités en fonction du langage employé [ 11 ; 44 ; 54 ] . L’avantage principal du paradigme objet est la simplicité de développe - 47 CHAPITRE 3 . GÉNIE LOGICIEL ment et de compréhension du système de par la décomposition en entités simples qu’il propose . Cependant , la construction du système est fortement liée aux objets qui le composent . Il n’est possible de remplacer un objet dans une structure que par un objet qui propose au minimum la même interface . La réutilisation des objets est en réalité compliquée puisqu’ils sont souvent déﬁnis pour répondre à un besoin spéciﬁque du problème adressé . Il faudra donc souvent mettre en place des mécanismes d’adaptations pour faire cor - respondre l’interface d’un objet déjà implémentée et celle nécessaire pour le système [ 57 ; 73 ; 94 ; 98 ] . Les paradigmes composant et agent sont des alternatives développées pour pallier à ces limitations . 3 . 2 . 2 Paradigme composant L’approche composants est une évolution de l’approche objets qui pro - pose de développer des solutions logicielles sous la forme d’un ensemble de systèmes autonomes capables de répondre à des messages . Un système devient donc un ensemble de sous - systèmes interagissant en partageant des données et en demandant des traitements spéciﬁques à des systèmes spécialisés [ 128 ] . Un composant est donc un système entier . Les composants logiciels pré - sentent deux types d’interfaces , les interfaces fournies , qui permettent de proposer des services et les interfaces requises , qui servent à accéder à des services pour calculer les réponses fournies [ 43 ] . La métaphore correspon - dante est celle des composants électroniques . Il est possible d’acheter un composant avec des caractéristiques précises . Son fonctionnement interne est généralement secret , mais il fournit un service ( remplit un rôle ) , du moment que ses conditions d’utilisation ( alimentation , connexions ) soient respectées . Il est possible de créer des composants complexes à partir d’un assem - blage de composants existants . Ces composants sont dits composites . L’in - térêt étant de pouvoir fournir les services d’un ensemble de composants tout en simpliﬁant l’accès à ce service . Les interfaces présentées par ces composants agissent directement sur le composant , ou permettent d’inter - agir avec les composants internes [ 57 ] . Tant que ses conditions d’utilisation sont respectées , un composant peut être intégré soit au sein de la solution logicielle , soit indépendamment [ 21 ] . Cela permet de décentraliser l’exécution de tâches sur des systèmes dis - tants ce qui permet de limiter les ressources consommées par la machine de l’utilisateur , de diminuer les accès à des bases de données distantes en gérant des requêtes complexes dans un service au niveau de la base ou 48 CHAPITRE 3 . GÉNIE LOGICIEL encore de proposer des services en ligne . L’intérêt majeur de cette approche est que tout composant , ou assem - blage de composants du système peut être remplacé , à tout moment , par un autre composant , assemblage de composants , s’il propose un ensemble d’interfaces identiques ( à condition que l’état interne du composant ne soit pas une ressource unique et critique du système ) . Ainsi , les mises à jour d’un système sont simpliﬁées . Pour que le couplage entre les composants soit le plus faible possible , la communication entre les composants se fait généralement en passant par des intermédiaires de communications . Ceux - ci prennent plusieurs noms en fonction des frameworks ( port , connecteur , . . . ) . En plus de prendre en charge les communications entre les composants , ils peuvent assurer leurs cohérences en imposant qu’elles n’aient lieu qu’entre des interfaces compa - tibles . Ils peuvent également simpliﬁer la communication entre deux com - posants . Les connecteurs peuvent , communiquer des valeurs , des appels de fonctions , convertir les messages ( changer le format de données ) ou encore simpliﬁer la communication entre deux composants [ 81 ] . La ﬁgure 3 . 7 schématise un système de composants permettant de rem - plir le même rôle que l’application modélisée ﬁgure 3 . 6 . Estimateur Capteur laser Contrôleur bluetooth Calculateur valeur longueur largeur Contrôleur service web BDD panneaux prix ( type ) prix res estimation longueur largeur Figure 3 . 7 – Utilisation de composants logiciels pour formaliser une application mobile d’estimation du prix de panneaux solaires pour un toit . L’ Estimateur est un composant composite chargé de calculer le prix d’une installation de panneaux solaires . Il présente 3 interfaces permettant de récupérer les informations sur le monde extérieur et une interface qui fournit le résultat de l’estimation . Deux composants distants sont présents sur la ﬁgure , le Capteur laser qui est embarqué dans le capteur électro - nique et le BDD panneaux qui est un service web mis à disposition par le fournisseur de panneaux solaires . Les composants contrôleurs permettent de prendre en charge les communications avec les capteurs ou le service web . Habituellement , les composants communiquent de façon synchrone . C’est - 49 CHAPITRE 3 . GÉNIE LOGICIEL à - dire qu’ils présentent un comportement passif . Ils ne sont activés que par la réception d’un message ou par l’appel d’une fonction sur leurs in - terfaces ; ils traitent ce message et renvoient le résultat pour ensuite at - tendre le suivant . Ce qui rend leur utilisation délicate dans des contextes d’exécutions distribuées ou temps réel [ 94 ] . Malgré tout , certains travaux proposent l’emploi de connecteurs capables de stocker les messages , pour apporter une exécution asynchrone au système [ 94 ; 105 ] . 3 . 2 . 3 Paradigme agent Le paradigme agent est proche de celui des composants . La différence majeure étant que les agents sont des entités élémentaires , qui sont sou - mises à une évolution asynchrone et surtout sont coordonnées en sociétés . Ils sont généralement employés dans des systèmes impliquant des exécu - tions concurrentes [ 87 ] . Un agent évolue indépendamment des autres agents du système . L’in - térêt des agents est de simpliﬁer la gestion et la réactivité d’un système . Ils assurent l’exécution en parallèle de toutes les tâches du système . Ce qui permet la création d’applications réactives tout en masquant les spéciﬁcités des mécanismes d’implantation [ 26 ; 69 ; 98 ; 124 ] . Un agent est dédié à la prise en charge d’une tâche spéciﬁque . Pour réaliser cette tâche , il peut observer l’état de l’environnement dans lequel il évolue pour adapter son état interne . En fonction de ses observations , il sélectionne l’action à réaliser . Enﬁn , l’agent réalise l’action qui peut mettre à jour son état interne , son environnement pour les agents à effets de bord ( blackboard [ 48 ] ) ou communiquer avec les autres agents [ 98 ] . Les obser - vations et modiﬁcations qu’un agent peut réaliser sur son environnement sont limitées à ses besoins et passent par des interfaces , comme pour les composants . Le comportement global d’un système à agent est issu d’un effet dit d’émergence [ 93 ] . En effet , chaque agent dédié à la réalisation de tâches simples . C’est l’interaction des différents agents de la société qui permettra de faire émerger le comportement global du système . Placer des agents au sein d’un système n’est pas sufﬁsant pour que leurs comportements puissent réaliser des tâches complexes . Il faut organiser leurs interactions . Plusieurs types d’organisations existent comme les hié - rarchies , les équipes ou les coalitions [ 33 ] . La première impose un agent qui contrôle les agents sous ses ordres ; dans la seconde tous les agents travaillent pour maximiser les chances d’atteindre un but unique commun et dans la dernière , les agents s’allient pour optimiser leurs buts propres . La communication entre les agents n’est normalement réalisée que par 50 CHAPITRE 3 . GÉNIE LOGICIEL messages . Contrairement aux composants , étant autonomes , ils ne sont pas censés pouvoir répondre à des appels de fonctions qui modiﬁeraient leurs ﬂux d’activités . Les messages sont passés au travers d’interfaces qui per - mettent à l’agent d’observer ou d’éditer l’environnement dans lequel il évo - lue . Il est à noter que si l’agent peut modiﬁer son environnement , dans une société multi - agents , il faudra réguler l’accès aux espaces partagés par plusieurs agents . L’avantage des agents est leur capacité à construire des systèmes concur - rents complexes de par leur autonomie et l’effet d’émergence . Cela im - plique aussi un désavantage . Les agents sont des entités souvent trop au - tonomes pour prédire le comportement exact du système [ 66 ] . La priorité et l’ordre de traitement des taches , le temps alloué à l’évolution de chaque agent , l’accès aux données sont autant de paramètres qui rendent le com - portement du système indécidable . Plus le nombre d’agents augmente , plus le comportement est difﬁcile à prédire . Malgré tout , les sociétés d’agents et leurs contraintes d’exécutions per - mettent de maîtriser la portée du comportement du système . Ce qui permet de garantir son évolution globale . Par exemple , la structure hiérarchique est souvent proposée pour implanter le patron logiciel PAC ( présentation , abstraction , contrôle ) [ 69 ] . Elle implique une évolution en étages du sys - tème avec une entité Contrôle par agent PAC qui contrôle l’évolution des agents PAC de l’étage inférieur auxquels elle a accès . Le framework PI [ 98 ] propose un système à agents dont l’évolution est contrôlée . Il garantit que chaque agent actif évoluera au moins une fois dans un cycle d’horloge du système , cycle dont la durée est paramétrée . Les paradigmes composant et agent permettent la création de systèmes logiciels ﬂexibles et évolutifs . Ces systèmes peuvent être assemblés au mo - ment de l’exécution puisque les liaisons entre les entités sont plus ﬂexibles qu’avec des paradigmes objets . Chacun de ces paradigmes possède des avantages et des inconvénients . Plusieurs travaux tentent de marier ces deux approches pour en tirer parti [ 43 ; 57 ; 94 ; 98 ] . 3 . 3 Modélisation et représentations de systèmes Nous avons vu différentes approches pour implémenter un système lo - giciel . Un processus de développement logiciel implique une phase de des - cription avant la conception . La description d’un système permet de déﬁnir l’ensemble des caractéristiques auxquelles il devra correspondre . Elle sim - pliﬁe la communication entre les différentes parties d’un projet , le suivi de sa production , la cohérence des choix techniques ainsi que l’évolution du 51 CHAPITRE 3 . GÉNIE LOGICIEL système une fois produit . La description d’un système logiciel est généralement appelée modèle . Un modèle est une représentation abstraite d’un système ou d’un phéno - mène . Un modèle peut présenter un système existant , pour en simpliﬁer la compréhension ( description ) , ou spéciﬁer un système à concevoir ( prescrip - tion ) . Dans les deux cas , il se trouve à un niveau d’abstraction plus élevé que le système . L’abstraction simpliﬁe la compréhension du système en pré - sentant un point de vue spéciﬁque sur le modèle . Modéliser un système à développer permet de s’abstraire des contraintes liées à la conception système [ 17 ] . En effet , plutôt que de s’intéresser aux détails d’implantation ( code , contraintes système ) le modèle peut synthé - tiser la structure globale , les relations entre les entités ou encore l’ordon - nancement des communications entre les entités du système . Un modèle de prescription se place donc au même niveau que le plan d’un bâtiment . Il peut être employé pour implémenter , vériﬁer ou expliquer le système mo - délisé ( cf section 3 . 4 ) . Les ﬁgures 3 . 6 et 3 . 7 sont des modèles de systèmes logiciels construits respectivement à l’aide d’objets ou de composants . Ces diagrammes masquent le code permettant d’implanter le système pour en faire une description structurelle simple à communiquer . Un modèle est décrit en utilisant un langage de modélisation [ 55 ] . Un langage est un ensemble de termes qui sont liés par des règles syntaxiques et sémantiques . La syntaxe d’un langage décrit l’ensemble des phrases cor - rectes qui peuvent être rédigées à partir d’un ensemble de termes de base . La sémantique est l’interprétation d’une expression dans un domaine sé - mantique donné . Le code 3 . 1 décrit un langage de base nommé S + . S + permet de décrire des expressions qui représentent l’assignation d’une valeur ou du résultat de la somme de valeur à une variable . Code 3 . 1 Description de la syntaxe d’un langage simple ( S + ) . < expr > : : = < somme > ' = ' < var > < somme > : : = < nbr > [ + < nbr > ] * < var > : : = " X " < nbr > : : = " 0 " | " 1 " | " 2 " Un langage déﬁnit l’ensemble de tous les modèles qui peuvent être dé - crits en l’employant . S + permet de décrire l’ensemble de toutes les expres - sions de la forme (cid:80) n i = 1 V i = R es avec V i une valeur entre 0 et 2 et R es la variable x . 52 CHAPITRE 3 . GÉNIE LOGICIEL L’expression 1 + 1 = X ( e ) est donc syntaxiquement correcte pour S + . C’est la sémantique du langage qui déﬁnit ensuite le sens associé aux expressions autorisées par la syntaxe [ 56 ] . Ainsi , si le domaine sémantique implique que x est un entier , alors le résultat de la somme de ( e ) qui est assigné à X est 2 ( 1 + 1 ) . Par contre , si le domaine sémantique implique que x est une valeur booléenne , alors le résultat de la somme de ( e ) assigné à X est 1 . En effet , pour des booléens , la somme de ( e ) est équivalente à ’ tr ue or tr ue ‘ ; Le langage S + permet également de modéliser un système logiciel construit à partir de deux entités : des valeurs et des opérations . Par exemple la ﬁgure 3 . 8 représente un modèle du système logiciel correspondant à l’expression 0 + 1 + 2 = X . Ce système est construit à partir de ports contenant des valeurs ainsi que des agents qui exécutent les opérations . 2 somme 0 1 somme a b res a b res A B assignation a res X Figure 3 . 8 – Conception logicielle d’un système d’agents correspondant à l’expres - sion 0 + 1 + 2 = X . Notez qu’ici chaque opération est un agent spéciﬁque . Une autre struc - ture possible serait d’utiliser des agents Opérateur avec un port d’entrée de plus pour déﬁnir l’opération à effectuer . L’expression 0 + 1 + 2 = X est une abstraction de la ﬁgure 3 . 8 , qui est un modèle de conception ( représente l’architecture du système ) . C’est donc un modèle du système à agents . Le modèle exprimé par le langage S + est plus abstrait que le modèle de conception . En effet , S + ne demande pas à s’attarder sur des détails comme les ports de connexions . Notez que le modèle de conception , bien que plus proche du niveau d’abstraction du code ne lui est pas ﬁdèle non plus . Il ne représente pas du code , et ne s’attarde pas sur l’implémentation des comportements des agents ou des ports . La syntaxe d’un langage peut prendre n’importe quelle forme ( e . g . dia - grammes , textes ) [ 56 ] . La forme adéquate dépendra du système à modéli - ser et des afﬁnités de la personne qui décrira le modèle . Les modèles gra - phiques sont souvent utilisés pour modéliser des architectures . Les modèles textuels sont concis et généralement plus pratiques pour la modélisation d’algorithmes . L’expression textuelle 0 + 1 + 2 = X et la ﬁgure 3 . 8 illustre bien ces propos . L’expression est concise et claire et la ﬁgure montre une vue d’ensemble du système avec dix entités et 9 liens de communications iden - tiﬁés d’un seul coup d’oeil . 53 CHAPITRE 3 . GÉNIE LOGICIEL Les langages de modélisation sont séparés en deux catégories ; les lan - gages génériques , ou General Purpose Languages ( GPL ) et les DSLs [ 45 ] . 3 . 3 . 1 Langages génériques et UML Les GPL sont des langages spéciﬁés pour décrire des systèmes appar - tenant à des domaines divers . Ils proposent des capacités de description larges avec un niveau d’expressivité sufﬁsant pour permettre la description de toutes les entités qui peuvent se trouver dans un système . Le langage Uniﬁed Modeling Language ( UML ) entre dans cette catégorie . UML [ 106 ] est un langage graphique développé dans les années 90 pour uniﬁer les différents langages utilisés jusqu’alors pour décrire un système logiciel . Ces langages étaient dédiés à la description d’une des propriétés du modèle ( e . g . architecture , comportement ) . UML permet de modéliser tous systèmes logiciels . Il peut décrire la structure du système , les inter - actions entre les entités qui composent le système et le comportement du système ou de ses entités . Il a été conçu dans les années 90 , pour répondre au manque de forma - lismes pour la modélisation de systèmes logiciels , spéciﬁquement pour ceux construits avec le paradigme objet . Il est rapidement devenu une référence tellement répandue qu’il est délicat de citer un autre GPL 1 . La suite UML propose un ensemble de 14 types de diagrammes diffé - rents qui permettent de modéliser les différents aspects qui entrent en jeu dans le développement d’un système . Les diagrammes employés dans ces travaux sont les diagrammes d’objets ( ﬁgure 3 . 6 ) , les diagrammes de com - posants ( ﬁgure 3 . 7 ) et les diagrammes de séquences . UML est associé à une sémantique semi - formelle . En effet , le langage est décrit par une syntaxe formelle ; mais étant dédié à la description de tout système , il est associé à une sémantique modulaire . Elle est sufﬁsamment souple pour permettre à UML de représenter tout système . Ce qui est une des raisons de son fort taux d’adoption au sein de la communauté des déve - loppeurs . Mais c’est également une faiblesse ; un modèle UML étant sujet à interprétation , il n’est pas possible de vériﬁer la cohérence de tous les modèles exprimables par UML . En particulier ce sont les diagrammes d’in - teraction ou de séquence qui posent problème . Ainsi que l’interpretation des relations entre les différents diagrammes [ 7 ; 107 ] . Cette sémantique faible est un problème pour la description stricte de systèmes . Cependant c’est également une force du langage . Les contraintes d’utilisation du lan - 1 . La version la plus récente ( 2015 ) peut être trouvée sur le site de l’OMG http : / / www . omg . org / spec / UML / 54 CHAPITRE 3 . GÉNIE LOGICIEL gage étant faibles , il est plus accessible lors de son apprentissage qui est malgré tout complexe [ 7 ] . Charge aux différentes parties intervenant sur le développement de s’accorder sur une façon d’interpréter les diagrammes . Cette interprétation est souvent apportée par les outils employés lors du processus de développement . Étant un standard omniprésent sur le marché du développement logi - ciel , l’utilisation d’UML s’est vue assistée par des outils . Des assistants per - mettent de créer et partager des modèles UML de manière graphique ( En - treprise Architect [ 61 ] , ArgoUml [ 102 ] , MoDisco [ 19 ] ) ou textuelle ( plan - tUML [ 103 ] , TextUML [ 80 ] ) . Certains permettent la création de modèles correspondant au code d’un système [ 123 ] . Et certains ajoutent une séman - tique plus restrictive à UML pour permettre la génération de code depuis le modèle correspondant ( Entreprise Architect , MoDisco ) . UML est donc un langage très expressif qui est employé dans beaucoup de développements logiciels . Il permet de simpliﬁer la communication avec les personnes non experts logiciel en leur proposant des points de vue adap - tés sur le système . Cependant , la généricité du langage le rend complexe à maîtriser totalement et il faudra souvent spéciﬁer sa sémantique pour le contexte du projet . 3 . 3 . 2 Langages Spéciﬁques de Domaines Les DSL sont dédiés à la description d’un domaine spéciﬁque [ 45 ] . Cela leurs permet de proposer un vocabulaire proche de celui employé dans ce domaine , ce qui simpliﬁe la communication avec les personnes du métier . Dans le contexte d’un développement ancré dans un domaine spéciﬁque , une communication accrue simpliﬁe la compréhension du problème par les développeurs et simpliﬁe la vériﬁcation du modèle produit par les experts . Notez que la classiﬁcation d’un langage en tant que DSL est sujette à interprétation . En effet , UML pourrait être vu comme une suite de langages dédiés à la modélisation de systèmes logiciels impliquant des paradigmes objets ou composants . Néanmoins , l’intérêt et la force d’un DSL sont de proposer un vocabulaire le plus restreint et le plus ciblé possible pour le domaine . En effet , plus l’ensemble des expressions est réduit et proche du domaine plus il est simple à maîtriser . Le langage S + présenté précédemment ( cf . code 3 . 1 ) associé à une sé - mantique d’algèbre mathématique est un DSL pour la modélisation d’addi - tions . Sa syntaxe propose des termes du domaine ( + , = , valeur , variable ) et contraint à les assembler correctement . Toute personne avec des bases en mathématiques est capable de modéliser des opérations avec ce langage . La modélisation proposée par la ﬁgure 3 . 8 est déjà moins aisée à prendre 55 CHAPITRE 3 . GÉNIE LOGICIEL en main . Elle requiert de comprendre ce que sont les ronds , les boîtes , et les connecteurs , et ce , parce que le langage est plus proche du domaine du développement que de l’algèbre mathématique . Les outils pour créer des DSL sont variés . Il est possible d’employer des descriptions textuelles de la grammaire ( BNF [ 68 ] ) et des générateurs de compilateurs ( AntLR [ 92 ] ) . Il est également possible de restreindre les modèles UML en ajoutant une nouvelle sémantique à l’aide de contraintes ( OCL [ 130 ] ) . Les représentations des connaissances peuvent également servir à la création de langages . Les ontologies sont typiquement dédiées à la modéli - sation des connaissances d’un domaine . Elles permettent aisément d’allier syntaxe et sémantique avec les liens sémiotiques qu’elles permettent de dé - crire entre les entités [ 126 ; 127 ] . Prolog peut être employé pour l’analyse syntaxique de textes [ 27 ] . La sémantique peut également être analysée si elle est encodée sous forme de règles et que le texte peut être transformé en un ensemble de clauses . Des outils plus évolués pour la création de langages impliquent des ap - proches de métamodélisation ( cf section 3 . 4 ) . Ces outils proposent des lan - gages associés à des sémantiques formelles capables de modéliser des DSL pour les proposer ensuite au travers d’éditeurs dédiés . Il est à noter que , plusieurs approches permettent la déﬁnition de la syn - taxe de langage de modélisation ( cf . section 3 . 3 ) mais celles qui permettent d’en déﬁnir la sémantique sont rares [ 56 ] . Nos travaux visent à proposer des solutions pour la création d’applica - tions impliquant des procédures de mesures . L’utilisation d’un DSL dans ce contexte permet de modéliser des systèmes en employant un vocabu - laire proche de celui de la métrologie . Cela permet un cycle de développe - ment simpliﬁé puisque les clients pourront décrire leurs systèmes avec les termes de la métrologie qu’ils emploient quotidiennement et l’architecte lo - giciel n’aura qu’à employer des termes proches pour modéliser la solution correspondante . 3 . 4 Ingénierie Dirigée par les Modèles Les trois sections précédentes ont décrit des approches pour représen - ter des connaissances , pour concevoir des systèmes logiciels et pour les modéliser . Une KR d’un domaine produit une solution capable de répondre à des problèmes spéciﬁques à ces connaissances . La réponse est inférée par un raisonnement sur l’ensemble des connaissances . 56 CHAPITRE 3 . GÉNIE LOGICIEL Les paradigmes de conception logiciels sont spécialisés dans la réali - sation de logiciels aux portées plus ou moins larges . La conception im - plique de prendre en compte les contraintes spéciﬁques à l’implantation du système dans une plateforme logicielle . Ces paradigmes permettent de répondre à ces contraintes en proposant de réutiliser des structures qui y répondent . La modélisation d’un système permet de décrire et partager les entités et structure le composant . De plus il est possible de spécialiser la descrip - tion du système en fonction du point de vue ( client , spécialiste du domaine , codeur ) et du but du modèle ( structure , comportement , communication ) . Ces trois méthodes ( KR , paradigmes de conceptions et modélisation ) sont des solutions génériques qui permettent la représentation , le raison - nement et l’implantation de tous systèmes logiciels . Leur combinaison ré - pond aux besoins d’un cycle de développement complet comprenant la des - cription d’un système , sa vériﬁcation et son implantation . Cependant , de par leurs natures très différentes , ces approches imposent des points de vue , des syntaxes , des fonctionnements et des buts spéciﬁques et distincts ( ﬁgure 3 . 9 ) . Ces divergences de contextes d’utilisations font qu’elles ne peuvent pas cohabiter telles quelles . implantation besoin capteurs , activités , résultats métrologie S = L * l , m ^ 2 = m * m modèle gyro = new gyro ( ) ; toit = new Toit ( ) ; toit . setLargeur ( 10 ) ; gyro : Gyro angle : Q : theta Figure 3 . 9 – Prisme imposé par les différents points de vue et leurs contraintes sur un système . L’ Ingénierie Dirigée par les Modèles ( IDM ) , ou Model Driven Enginee - ring est un paradigme de développement qui propose des approches per - mettant de gérer ce prisme par lequel passe un système en fonction des besoins à chaque étape du cycle de vie d’un logiciel . En faisant des modèles des entités de premier ordre [ 17 ; 115 ] , l’IDM permet de modéliser les sys - tèmes et leurs comportements à un niveau d’abstraction plus élevé . Cette relation se retrouve , par exemple , entre les bâtiments et leurs plans dans 57 CHAPITRE 3 . GÉNIE LOGICIEL le génie civil . Cela simpliﬁe le développement de systèmes en proposant de focaliser la réﬂexion sur le but du système modélisé plutôt que sur les contraintes liées à l’implantation . Un système sera donc décrit par un en - semble de modèles . Chaque modèle représente un point de vue spéciﬁque sur le système étudié , qui expose les points d’intérêt du système pour les personnes ou outils qui l’emploieront . 3 . 4 . 1 Modélisation et métamodélisation L’idée de l’IDM est de considérer que tout système peut être modélisé . En considérant un langage de modélisation comme un système , il est éga - lement possible de le modéliser . Cette considération qui a mené à la création d’une architecture récur - sive qui permet de modéliser un système avec un langage , qui lui - même peut être modélisé par un langage . Cette architecture récursive est présen - tée par la ﬁgure 3 . 10 . Elle est répétée jusqu’à ce qu’un métamodèle soit auto représentatif , impliquant qu’il représente un langage capable de le modéliser . Métamodèle Méta - Métamodèle représente Langage de modélisation langage de méta - modélisation Modèle de système Système représente représente conforme à conforme à appartient à appartient à conforme à M0 M1 M2 M3 Figure 3 . 10 – Architecture récursive de métamodélisation proposée par la MDA pour modéliser les systèmes et les langages de modélisation . laarchitecture dirigée par les modèles , ou Model Driven Architecture 58 CHAPITRE 3 . GÉNIE LOGICIEL ( MDA ) est un framework conceptuel de référence pour l’approche IDM proposé par l’Object Management Group ( OMG ) [ 91 ] . La MDA est une ap - proche dédiée au développement de système qui propose trois niveaux de modélisation dont le niveau d’abstraction est de plus en plus proche de la solution : — un modèle représentant le contexte , les besoins et le but de la solution , — un modèle qui décrit le comportement et la structure de l’application , — un modèle qui contient l’ensemble des informations concernant le comportement et l’execution de l’application sur une plateforme spé - ciﬁque . Pour décrire ces modèles , l’OMG propose une hiérarchie de métamodé - lisation à quatre niveaux , identiﬁés sur la ﬁgure 3 . 10 : — M0 : implémentation du système ou instance du modèle , — M1 : modèle du système , — M2 : métamodèle déﬁnissant le langage de modélisation , — M3 : métamétamodèle auto - représentatif . L’OMG propose le Meta - Object Facility ( MOF ) [ 91 ] , un métamétamodèle qui permet de décrire UML au niveau M2 . D’autres architectures de méta - modélisation existent comme l’ Eclipse Modelling Framework ( EMF ) [ 117 ] qui emploie le métamétamodèle Ecore . Ou encore le Diagrammatic Predi - cate Framework ( DPF ) [ 72 ] qui lui propose une architecture récursive avec un nombre potentiellement inﬁni de niveaux . Ce qui augmente les capacités de séparation entre les concepts exprimés à chaque niveau de métamodé - lisation et donc dans chaque langage . La ﬁgure 3 . 11 montre l’architecture de métamodélisation correspondant au langage S + déﬁni à la section 3 . 3 . Le formalisme employé pour décrire ce modèle est celui proposé par DPF . Conformément à DPF , le métamodèle DPF est employé au niveau M4 . IlM4 ) est utilisé pour décrire un langage de modélisation LM4 . LM4 permet de décrire le modèle M3 . Ainsi il y a une relation entre chaque élément de M4 et l’un de ceux disponibles sur M3 . Ces relations apparaissent sur le dia - gramme comme : Node ou : arrow . Le même principe est appliqué pour les ( méta ) modèles des niveaux inférieurs , qui sont décrits ultérieurement . Pour tous les liens qui ne présentent pas de multiplicité ; c’est la multiplicité " ∗ " qui est sous entendue . Un lien avec plusieurs noms sous - entend l’existence de plusieurs liens identiques . Ils ne sont pas afﬁchés par souci de clarté du diagramme . Le langage décrit par le métamodèle M2 est S + . Le modèle de la ﬁgure 3 . 8 peut être décrit à l’aide de ce langage . La seule différence sera que les ports de connexion seront des instances de Variable ou de Valeur . 59 CHAPITRE 3 . GÉNIE LOGICIEL entrée : arrow2 . . 2 sortie : arrow1 . . 1 Node arrow M4 DPF metamodel M3 S + métamétamodèle Opération : Node Opérande : Node is a is a M2 métamodèle de S + a : entrée 1 . . 1 Assignation : Opération Valeur : Opérande Somme : Opération Variable : Opérande 1 . . 1 res : sortie a : entrée b : entrée 1 . . 1 1 . . 1 1 . . 1 res : sortie Figure 3 . 11 – Architecture de métamodélisation du langage S + décrite à l’aide du formalisme proposé par DPF . L’EMF est un framework de métamodélisation proposé par l’environne - ment de développement Eclipse . Il propose Ecore , un métamétamodèle , qui implémente le MOF et permet de modéliser le métamodèle d’un langage de modélisation . La suite d’outils proposés par le framework permet l’édition de ce métamodèle et la création d’un éditeur de modèles correspondant à ce métamodèle . L’EMF propose également des outils pour gérer la transfor - mation de modèles ( cf . section 3 . 4 . 2 ) avec pour sources des modèles issus d’Ecore . L’intégration du framework dans Eclipse implique que les outils orientent fortement vers une implantation logicielle en Java . EMF est une référence dans le domaine de la métamodélisation et l’écosystème outillé qu’il propose est conséquent . Les outils pour ajouter de la sémantique aux langages modélisés sont des plugins à ajouter au framework et emploient l’OCL [ 130 ] . OCL est un langage de contraintes qui permet de déﬁnir sous forme de texte des contraintes sur les entités constituant un métamodèle . Lorsqu’un modèle conforme au métamodèle est créé , sa conformité aux contraintes OCL peut être validée , ce qui permet d’effectuer une validation sémantique du modèle ou simplement de restreindre l’expressivité du langage créé . Le langage et ses contraintes se retrouvent donc déﬁnis à l’aide de deux langages dif - férents et sont stockés dans deux ﬁchiers séparés . Cela implique que lors de l’évolution du langage il faudra également penser à faire évoluer les 60 CHAPITRE 3 . GÉNIE LOGICIEL contraintes . Le DPF est également un framework de métamodélisation . Il est consti - tué de deux outils , le DPF workbench pour développer des DSL et des édi - teurs de modèles et un plugin XPAND pour créer des transformations de modèles issus du framework . Ce framework propose une architecture de métamodélisation sans limites dans le nombre de niveaux . Le métamodèle DPF est le langage auto représentatif qui est utilisé comme sommet de l’architecture . Ensuite l’utilisateur peut modéliser autant de niveaux que nécessaire . Cela permet d’encore plus fortement séparer les notions d’im - plantations et de modélisations [ 72 ] . Pour cela , le DPF workbench propose un éditeur de modèles graphiques qui propose un langage correspondant au métamodèle demandé . Le DPF emploie les transformations de graphes et la théorie des catégo - ries pour générer les différents éditeurs et assurer de la cohérence entre le langage et le modèle créé . Chaque modèle est représenté par une spéciﬁ - cation qui comprend un graphe associé à un ensemble de contraintes . Une contrainte est déﬁnie par un prédicat associé à un sous graphe . L’avan - tage de DPF est que le modèle est décrit sous forme de diagrammes qui contiennent et le modèle et les contraintes du modèle . Par exemple , la ﬁ - gure 3 . 11 montre un type de contraintes de DPF . Les multiplicités indiquent le nombre d’instances de la relation qui peuvent exister sur un modèle . Lors de la création d’un modèle , l’éditeur vériﬁe que le modèle correspond au métamodèle ( avec ses contraintes ) en vériﬁant que tout élément du modèle présente une relation homomorphique vers le métamodèle . La transformation de modèles issus des éditeurs du DPF workbench est possible à l’aide d’un plugin utilisant le métalangage XPAND agrémenté de méthodes d’accès aux différents éléments du métamodèle ( instance , rela - tion , contraintes ) [ 6 ; 125 ] . Bien que DPF soit beaucoup moins reconnu que EMF , il présente l’avan - tage de proposer un environnement épuré , simple à prendre en main . Le fait que les contraintes et la syntaxe d’un langage soient déﬁnies dans un seul et même diagramme simpliﬁe les évolutions potentielles des langages . De plus , tout élément non conforme au métamodèle est immédiatement identi - ﬁé au niveau de l’éditeur , ce qui garantit la création de modèles conformes et simpliﬁe l’utilisation de l’éditeur par des utilisateurs non habitués aux DSL ou à la modélisation . Ces prises en main et possibilités d’évolutions facilitées sont les arguments qui ont été décisifs pour l’utilisation de cet outil dans ces travaux . De plus , il a été employé avec succès dans plusieurs projets impliquant la modélisation de processus [ 95 ; 108 ; 129 ] . 61 CHAPITRE 3 . GÉNIE LOGICIEL 3 . 4 . 2 Transformations de modèles Les modèles jouent un rôle descriptif , ils servent à représenter les élé - ments signiﬁcatifs d’un système tout en omettant les autres ( cf . section 3 . 3 ) . L’IDM propose d’employer les modèles pour automatiser la création de sys - tèmes logiciels . Cette automatisation est réalisée à l’aide des transforma - tions de modèles [ 82 ; 114 ] . Une transformation de modèle est une entité qui , à partir d’un modèle d’entrée E , génère un modèle de sortie S . La transformation sera notée T E → S . Cette génération peut être vue comme une projection des éléments de E vers ceux de S . T E → S respecte une déﬁnition D M ( E ) → M ( S ) qui se trouve au niveau des métamodèles de E et g respectivement M ( E ) et M ( S ) ( cf . ﬁgure 3 . 12 . Définition entrée Métamodèle M ( E ) Métamodèle M ( S ) sortie Transformation entrée Modèle E ModèleS sortie conforme à conforme à applique Figure 3 . 12 – Modélisation d’une transformation de modèle entre deux modèles et de sa déﬁnition . Le fait que D M ( E ) → M ( S ) soit exprimé au niveau méta permet de la rendre applicable à l’ensemble des modèles conformes au métamodèle puisqu’un langage déﬁnit l’ensemble des modèles qu’il peut exprimer . Ainsi T n E n → S n n’est qu’une instance des multiples transformations résultantes de D M ( E ) → M ( S ) . Il existe différents types de transformations de modèles [ 17 ; 31 ; 82 ] , ca - tégorisés en fonction de leurs schémas d’exécutions , de degrés d’automa - tisation , de déﬁnitions ou encore de buts . Les trois premières catégories ne sont que des détails d’implantation . La catégorisation en buts sépare les transformations en deux groupes , les transformations verticales ou horizon - tales . Les transformations verticales impliquent que M ( E ) soit à un niveau d’abstraction supérieur à M ( S ) . Elles servent particulièrement à projeter les éléments constituant un modèle vers un modèle contenant des détails de l’implantation du système , voire vers le code qui implante le système [ 47 ] . Ces transformations sont généralement des transformations modèle vers texte , ou Model to Text ( M2T ) . Les transformations horizontales impliquent que les métamodèles M ( E ) et M ( S ) soient au même niveau d’abstraction . Elles permettent de changer le langage ( typiquement la syntaxe ) dans le - 62 CHAPITRE 3 . GÉNIE LOGICIEL quel est exprimé le modèle ou d’automatiser les mises à jour du modèle [ 83 ] . Ces transformations sont généralement des transformations modèle vers model , ou Model to Model ( M2M ) . Il existe cependant des transfor - mations verticales M2M ( e . g . apport des spéciﬁcité d’une plateforme à un modèle indépendant de toute plateforme ) ou des transformations horizon - tales M2T ( e . g . changement de syntaxe concrète ) . Notez que rien n’empêche M ( S ) et M ( E ) d’être le même métamodèle . Dans ce cas , la projection ne changerait pas l’ensemble dans lequel se trouvent les éléments de E . Une telle transformation peut avoir pour but de réorganiser les éléments pour simpliﬁer leurs lectures . Elles sont égale - ment utilisées pour la complétion automatique de modèles [ 96 ] . Le code 3 . 2 décrit le processus de la transformation du modèle ﬁgure 3 . 8 vers une implémentation sous forme d’agents logiciels . Code 3 . 2 Processus de transformation entre les modèles décrits avec S + et le code d’implémentation correspondant . soit ports une liste de vecteurs < Nom , Port > soit agents une liste de vecteurs < Nom , Agent > pour chaque instance de noeud n du modèle créer un objet o de type n . type ( ) ajouter < n . nom ( ) , o > dans la liste correspondant au type n . type ( ) pour chaque instance de relation r du modèle agent = agents . get ( r . source ( ) . nom ( ) ) port = ports . get ( r . destination ( ) . nom ( ) ) agent . connect ( r . type ( ) , port ) L’IDM permet donc , avec la métamodélisation , de modéliser des DSL et des systèmes logiciels à des niveaux d’abstractions sufﬁsamment élevés pour ne pas considérer les détails liés à l’implantation . Ces détails sont ajoutés au modèle par des transformations de modèles automatisées . Les transformations sont spéciﬁées en décrivant les déﬁnitions des projections entre les entités du métamodèle décrivant le modèle du système et celui du code d’implantation ciblé . Un compilateur de code peut être vu comme une transformation verticale d’un modèle ( code informatique ) correspon - dant à un métamodèle ( grammaire du langage de programmation ) vers un ensemble d’instructions compréhensible par la machine , correspondant à des instances spéciﬁques de l’ensemble des instructions . Rappelons que la section 3 . 3 décrivait que la sémantique d’un langage 63 CHAPITRE 3 . GÉNIE LOGICIEL est délicate à déﬁnir lors de la création d’un DSL . L’IDM permet d’adjoindre à la syntaxe d’un langage une sémantique forte au travers des transforma - tions de modèles . En effet , par manque de sémantique , c’est l’utilisation du modèle qui déﬁnira la sémantique qui lui est associée . Dans ce contexte , les transformations de modèles peuvent être vues comme des médias qui associent de la sémantique aux modèles [ 17 ] . Plusieurs outils permettent le développement de M2T automatiques [ 24 ; 67 ; 104 ] . Ils utilisent un métalangage qui permet de décrire la déﬁnition de la projection sous forme de templates . Le DPF workbench propose un plugin utilisant le langage XPAND . Ce plugin peut être utilisé avec pour source , n’importe quel métamodèle qui aura été déﬁni à l’aide d’un éditeur du DPF workbench [ 110 ] . 64 Deuxième partie Contribution 65 Chapitre 4 Représentation des Connaissances de la Métrologie « Une théorie est vraie si elle est énonçable selon les règles de la logique formelle , et si ses conséquences sont vériﬁables par tout observateur . » Jacques Attali Sommaire 4 . 1 Modèle conceptuel et approche proposée . . . . . . . . . 70 4 . 2 Encodage des termes de la métrologie . . . . . . . . . . . 73 4 . 2 . 1 Description des systèmes d’unités . . . . . . . . . . . . 74 4 . 2 . 2 Description des unités composées et schéma de conver - sions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76 4 . 3 Encodage des règles d’analyses . . . . . . . . . . . . . . . . 78 4 . 3 . 1 Analyse dimensionnelle . . . . . . . . . . . . . . . . . . . 78 4 . 3 . 2 Analyse des échelles . . . . . . . . . . . . . . . . . . . . . 83 4 . 4 Vériﬁcation de procédures de mesures et langage de requêtes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87 4 . 4 . 1 Abstraction des procédures de mesure . . . . . . . . . 87 4 . 4 . 2 Vériﬁcation des procédures de mesure . . . . . . . . . . 89 4 . 5 Encodage des règles de conversion entre grandeurs . . 93 4 . 5 . 1 Prédicats de conversion . . . . . . . . . . . . . . . . . . . 93 4 . 5 . 2 Règles de conversion . . . . . . . . . . . . . . . . . . . . 96 4 . 6 Utilisation de ProLog et conclusion . . . . . . . . . . . . . 99 67 CHAPITRE 4 . REPRÉSENTATION DES CONNAISSANCES DE LA MÉTROLOGIE 4 . 6 . 1 Utilisation de ProLog . . . . . . . . . . . . . . . . . . . . 99 4 . 6 . 2 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . 104 68 CHAPITRE 4 . REPRÉSENTATION DES CONNAISSANCES DE LA MÉTROLOGIE Ces travaux ont pour objectif la simpliﬁcation de la création de sys - tèmes logiciels impliquant des mesurages . Cette simpliﬁcation se fait sur trois axes : 1 . assurer la cohérence du mesurage avec les règles de la métrologie , 2 . diminuer l’écart sémantique entre l’architecte logiciel et le client lors de la modélisation des systèmes , 3 . assister la création du logiciel à partir de son modèle . Ce chapitre se focalise sur le premier des trois points . Il propose pre - mièrement un modèle conceptuel de la métrologie telle qu’elle a été décrite dans le chapitre 2 . Ce modèle sera employé comme modèle de référence dans les trois chapitres suivants . Il permet de déﬁnir l’ensemble des termes qui constituent la syntaxe de la métrologie employée dans ces travaux . Ensuite , une représentation des connaissances de la métrologie est pro - posée . Nommée Metrology Knowledge Schema ( MKS ) cette représentation des connaissances , ou Knowledge Representation ( KR ) est déﬁnie à l’aide d’un ensemble de clauses de Horns en language SWI - ProLog [ 133 ] . Elle per - met le raisonnement sur l’ensemble des connaissances que sont l’analyse dimensionnelle , l’analyse des échelles de mesures et la conversion d’unités . La présentation du MKS est séparée en quatre sections complémen - taires . La première présente comment les différents termes de bases consti - tuant les unités , les dimensions et les systèmes de grandeurs sont inférés . La seconde décrit les règles d’analyses qui permettent de réaliser l’analyse dimensionnelle et l’analyse des échelles de mesures . La troisième section étend les capacités expressives du MKS aﬁn de proposer un langage ca - pable de modéliser des procédure de mesures , le Measurement Knowledge Query Language ( MKQL ) . Le MKQL propose des termes proches de ceux employés dans la métrologie . Cette section illustre également les capacités de raisonnement du MKS qui permettent la vériﬁcation de la cohérence de procédures de mesures selon les règles de la métrologie . En effet , chaque modèle décrit par se langage est une requête de vériﬁcation , par le MKS , de la procédure modélisée . La quatrième section ajoute les règles qui per - mettent de raisonner sur l’ensemble des conversions entre les différentes unités d’un système . Enﬁn , la cinquième section présente les différents mé - canismes spéciﬁques à SWI - ProLog qui sont employés pour augmenter les capacités d’analyse du MKS , pour ﬁnalement conclure sur les capacités de mise à l’échelle de l’approche en décrivant la possibilité de créer une KR spécialisée pour les besoins d’une analyse dans un domaine spéciﬁque ou une KR pour l’analyse de tout type de procédure de mesures . 69 CHAPITRE 4 . REPRÉSENTATION DES CONNAISSANCES DE LA MÉTROLOGIE 4 . 1 Modèle conceptuel et approche proposée Les termes de la métrologie présentés dans le chapitre 2 sont employés pour , premièrement , décrire les mesurages et la transposition d’évènements empiriques en grandeurs et deuxièmement pour décrire la sémantique as - sociée à la manipulation de ces grandeurs . Cette sémantique contraint les fonctions de mesure pour reﬂéter dans le domaine abstrait les relations empiriques du domaine physique . La combinaison de ces éléments permet d’appliquer des fonctions sur des abstractions formelles et d’en déduire des relations physiques , plutôt que de les trouver en manipulant des objets du monde physique . De plus , la sémantique de la métrologie permet d’assu - rer la cohérence entre les abstractions et les relations physiques qu’elles représentent . L’utilisateur ﬁnal , qui décrit la procédure de mesure , et l’architecte logi - ciel , qui implante la procédure dans un logiciel , possèdent rarement une ex - pertise en métrologie . Cependant , cette expertise est très importante pour le développement de procédures correctes . L’utilisation des concepts de la métrologie dans un processus de développement permet de garantir la qua - lité des mesurages du système résultant . L’application de l’analyse dimensionnelle et de l’analyse des échelles de mesures permet de vériﬁer la procédure décrite par l’utilisateur ( cf cha - pitre 2 ) , ainsi que sa correspondance avec la procédure impliquée dans le système développé . Plusieurs propositions existent pour modéliser les procédures de me - sures [ 58 ; 64 ; 111 ] pour appliquer la sémantique de la métrologie [ 23 ; 100 ] ou pour prendre en charge des grandeurs non - physiques [ 51 ] . Cependant , nous l’avons indiqué dans le chapitre 2 , aucune de ces solutions n’est stan - dard ; elles proposent des interprétations différentes de la métrologie avec des implantations et des encodages différents [ 42 ] . Aucune solution ne ré - pond au besoin de l’intégration de la sémantique de la métrologie dans un processus de développement logiciel sans expertise du domaine . Nous proposons une approche IDM pour le développement de solutions logicielles impliquant des procédures de mesure . Une telle approche im - pose de déﬁnir la syntaxe et la sémantique de chaque langage impliqué , autrement , il n’est pas possible de décrire des déﬁnitions de transforma - tions . C’est pourquoi , aﬁn de pouvoir se focaliser sur l’ensemble des proprié - tés de la métrologie , qui sont importantes pour le contexte de ces travaux en assurant leurs maitrises , nous proposons un nouveau modèle conceptuel pour la description de procédure de mesure dérivé de la métrologie . Le mo - 70 CHAPITRE 4 . REPRÉSENTATION DES CONNAISSANCES DE LA MÉTROLOGIE dèle conceptuel de la métrologie , ou Metrology Conceptual Model ( MCM ) est présenté par la ﬁgure 4 . 1 . Ce modèle est fondé sur le Vocabulaire In - ternational de Métrologie ( VIM ) [ 89 ] et comprend les éléments conceptuels nécessaires à l’application de la sémantique présentée dans le chapitre 2 . Pour minimiser la charge graphique du modèle , les multiplicités associées aux relations sont déﬁnies par le nombre associé à chaque nom de relation . une relation au singulier implique une seule entité cible quand une relation au pluriel implique une ou des entités cibles . Les triangles noirs indiquent la navigabilité d’une relation quand il en existes plusieurs entre deux mêmes entités . Un instrument de mesure est un outil qui permet à un utilisateur d’ encoder une propriété physique en une grandeur . Un instrument indicateur est em - ployé pour décoder la grandeur et présenter à l’utilisateur la valeur résul - tante , et cohérente au monde physique , qu’il espère obtenir de la procédure ( cf ﬁgure 2 . 2 ) . Une fonction de mesure est une manipulation formelle utili - sée pour déduire des grandeurs mesurées , celles espérées en résultats . Une procédure de mesure est la combinaison de plusieurs instruments de mesure , indicateurs et fonctions de mesures . Ces éléments sont liés par les grandeurs produites et consommées ; comme le seraient des agents au travers de ports partagés . Ce qui produit une chaîne d’éléments . Une grandeur est l’association d’une valeur , d’une unité et d’une échelle de mesure de la RTM . Ces attributs permettent : — la manipulation algorithmique des valeurs , — l’application de l’analyse dimensionnelle , — l’application de l’analyse des échelles de mesure , — la gestion des unités à l’aide de conversions . Le VIM propose d’employer le terme référence , associé à une valeur , pour décrire une grandeur . Les unités sont normalement une spécialisa - tion des références associées aux grandeurs physiques déﬁnies par le SI . Cependant , nous cherchons à proposer un modèle accessible pour les non - experts . Le terme unité est entré dans le vocabulaire commun , quand celui de référence n’est que rarement associé aux mesures . C’est donc le terme unité est utilisé dans le modèle conceptuel . Une relation de conversion peut être déﬁnie entre deux unités . Cette re - lation implique une unité source ( de ) et une unité de destination ( à ) . L’en - semble de ces relations génère un graphe de conversions qui permet de convertir toute unité valide , vers une unité éligible , en suivant un chemin impliquant de multiples conversions . Le MCM décrit les connaissances nécessaires pour la description de pro - cédures de mesures spéciﬁques ainsi que pour l’application des méthodes 71 CHAPITRE 4 . REPRÉSENTATION DES CONNAISSANCES DE LA MÉTROLOGIE d i m e n s i on V a l e u r E c h e ll e G r a nd e u r U n it é un it é s d e b a s e S y s t è m e d ’ un it é s T yp e d e g r a nd e u r do m a i n e un it é s d é r i v ée s t yp e s d é r i v é s t yp e s d e b a s e D i m e n s i on ca non i qu e un it é s do m a i n e d é f i n iti on d e v ec t e u r C onv e r s i on à d e F on c ti on d e m e s u r e s o r ti e e n t r ée s P r o cé du r e d e m e s u r e I n s t r u m e n t d e m e s u r e P r op r i é t é phy s i qu e f on c ti on s m e s u r e u r s p r op r i é t é m é s u r ée I n s t r u m e n t i nd i ca t e u r i nd i ca t e u r s a ff i c h ée éc h e ll e v a l e u r F i g u r e 4 . 1 – M o d è l e C o n c e p t u e l d e l a M é t r o l o g i e . C e m o d è l e e s t c a p a b l e d e r e p r é s e n t e r d e s p r o c é d u r e s d e m e s u r e a i n s i q u e l e s s y s t è m e s p e r m e tt a n t l e s a n a l y s e s d i m e n s i o nn e ll e s e t d e s é c h e ll e s d e m e s u r e s . 72 CHAPITRE 4 . REPRÉSENTATION DES CONNAISSANCES DE LA MÉTROLOGIE d’analyse de la sémantique de la métrologie . De plus , le modèle inclut le vo - cabulaire employé par les futurs utilisateurs des systèmes logiciels produit avec ces travaux . Les entités présentes dans le MCM sont représentées dans le Metrology Knowledge Schema ( MKS ) , le langage de modélisation d’application d’as - sistance à la mesure , Measure Application Modelling Language ( MAML ) et l’application mobile de la plateforme de modélisation présentée dans ces travaux ( cf ﬁgure 1 . 2 ) . Le MKS est une KR qui encode en logique du pre - mier ordre , ou First Order Logic ( FOL ) les capacités descriptives du mo - dèle conceptuel , en y ajoutant les capacités de vériﬁcation des analyses dimensionnelles et des échelles de mesure . Le MAML est un langage de modélisation qui fusionne les entités du modèle conceptuel ainsi que celles provenant de la modélisation des processus et des interfaces utilisateur . L’application mobile est un système logiciel conﬁgurable qui accompagne un utilisateur dans la réalisation de ses procédures de mesure . Le MCM peut donc être vu comme un métamodèle partiel de ces trois entités . L’intérêt de cette approche est de simpliﬁer la coopération des ou - tils proposés par la plateforme , d’augmenter la cohérence des travaux et de proposer un vocabulaire relativement homogène lors de l’emploi d’entités liées à la métrologie dans ces travaux . 4 . 2 Encodage des termes de la métrologie Cette section et les suivantes présentent le Metrology Knowledge Schema ( MKS ) , une représentation des connaissances de la métrologie encodée en logique du premier ordre . Le but de cette représentation des connaissances , ou Knowledge Representation ( KR ) étant de pouvoir raisonner sur l’espace sémantique de la métrologie et de vériﬁer la cohérence de procédures de mesurer avec ce raisonnement . La KR comprend un système d’unités , une syntaxe pour exprimer les unités composées , deux analyses ( dimensionnelle et échelles de mesure ) , des relations de conversions et un langage de requêtes . Ces constructions sont représentées sous la forme de faits et de règles d’inférence , qui consti - tuent un métamodèle formel pour la représentation des connaissances de la métrologie en prédicats de la logique du premier ordre . La réalisation de la KR est écrite avec le langage ProLog ; ainsi , seules des clauses de Horn seront employées dans la description qui suit . L’implication de ProLog dans cette description est tenue à son minimum et il n’y sera fait allusion que dans la ﬁn de ce chapitre pour illustrer les mécanismes d’optimisation du raisonnement , de traçage des résultats et de prescriptions du MKS . 73 CHAPITRE 4 . REPRÉSENTATION DES CONNAISSANCES DE LA MÉTROLOGIE La KR proposée est conçue pour être hautement conﬁgurable . Sa créa - tion et ses extensions futures devraient être réalisées avec l’assistance d’un expert en métrologie . Cependant , une fois conﬁguré , le MKS est un système expert qui est spéciﬁé pour être utilisé par des non - experts pour soutenir la cohérence de leurs procédures de mesures . Les termes employés pour décrire la KR sont en anglais . Cela permet de proposer une description du MKS avec des notations plus courtes , non accentuées et donc qui sera directement implémentable . Les termes em - ployés sont ceux du VIM [ 89 ] pour toutes traductions , il faut s’y référer . Le document présente le vocabulaire anglais et français . 4 . 2 . 1 Description des systèmes d’unités Les systèmes d’unités simpliﬁent la spéciﬁcation d’unités en décrivant un ensemble réduit d’unités de bases et en décrivant les autres avec des combinaisons algébriques . Un système correctement déﬁni permet d’em - ployer l’analyse dimensionnelle . Le tableau 4 . 1 liste les termes et prédi - cats essentiels employés pour modéliser un système d’unités . Le tableau 4 . 2 illustre l’utilisation de ces constructions pour décrire une instance d’un système d’unités . Dans cet exemple tous les termes sont clos . La construction d’un système d’unités est faite à partir des notations du SI . Le SI utilise des facteurs de réduction et d’augmentation , appelés préﬁxes , pour mettre à l’échelle de la propriété observée l’unité employée . Ceux - ci permettent de simpliﬁer la notation des valeurs de grandeurs ( e . g . micro pour 10 − 6 ) . Le SI préconise l’utilisation des alias pour référer à des unités simplement ( e . g . newton pour l’unité kg ∗ m / s 2 ) . Pour le MCM , les alias sont aussi utilisés pour prendre en charge les traductions des unités . L’une des propriétés d’un système d’unités est la réduction d’unités vers des vecteurs aux dimensions . En fonction du domaine , les unités communé - ment employées ( unités de références ) peuvent varier . De plus , le but pre - mier d’un utilisateur est de mesurer des types de grandeurs ( longueur , sur - face , vitesse , etc ) . Les dimensions et l’analyse dimensionnelle permettent de s’abstraire des unités et de focaliser l’analyse sur les types de grandeurs impliqués dans une procédure de mesure . Ce sont donc les pierres angu - laires de tout outil métrologique . 74 CHAPITRE 4 . REPRÉSENTATION DES CONNAISSANCES DE LA MÉTROLOGIE Variables Description u , v , p , etc n’importe quelle variable fonctions Description preﬁxed _ unit ( p , u ) l’unité u est préﬁxée par p power ( u , n ) l’unité u est élevée à la puissance n product ( u , v ) décrit le produit des unités u et quotient ( u , v ) décrit le quotient des unités u et v Predicats Description is _ number ( n ) n est un nombre is _ atomic _ unit ( u ) une unité associée à une dimension de base is _ derived _ unit ( u ) une unité dérivée is _ preﬁx ( p , r ) p est un préﬁx de ratio r is _ alias ( a , u ) un alias accepté pour u is _ unit ( u ) une unité simple ou composée is _ base _ dim ( d ) une dimension de base is _ derived _ dim ( d ) une dimension dérivée is _ reference _ unit ( d , u ) une unité de référence pour la dimension is _ convertible ( u , c , v ) u est convertible en v à l’aide de c is _ convertible ( u , v ) u est convertible en v Tableau 4 . 1 – Termes et règles pour l’inférence d’unités , de dimensions et de sys - tèmes d’unités is _ base _ dim ( length ) is _ derived _ dim ( area ) is _ atomic _ unit ( meter ) is _ atomic _ unit ( mile ) is _ derived _ unit ( are ) is _ preﬁx ( kilo , 1000 ) is _ alias ( m , meter ) is _ preﬁx ( centi , 0 . 01 ) is _ alias ( mètre , meter ) is _ alias ( km , preﬁxed _ unit ( kilo , m ) ) is _ alias ( kilomètre , km ) is _ alias ( cm , preﬁxed _ unit ( centi , m ) ) is _ reference _ unit ( length , meter ) is _ reference _ unit ( area , power ( meter , 2 ) ) is _ convertible ( mile , 1 . 6 , preﬁxed _ unit ( kilo , m ) ) is _ convertible ( are , 100 , power ( meter , 2 ) ) Tableau 4 . 2 – Instance d’un petit système d’unités 75 CHAPITRE 4 . REPRÉSENTATION DES CONNAISSANCES DE LA MÉTROLOGIE Tête Corps is _ unit ( u ) is _ atomic _ unit ( u ) is _ unit ( a ) is _ alias ( a , u ) is _ unit ( u ) is _ derived _ unit ( u ) is _ unit ( preﬁxed _ unit ( p , u ) ) is _ preﬁx ( p , n ) ∧ is _ unit ( u ) is _ unit ( power ( u , n ) ) is _ number ( n ) ∧ is _ unit ( u ) is _ unit ( product ( u , v ) ) is _ unit ( u ) ∧ is _ unit ( v ) is _ unit ( quotient ( u , v ) ) is _ unit ( u ) ∧ is _ unit ( v ) is _ unit ( u ) is _ convertible ( u , c , v ) is _ unit ( u ) is _ convertible ( v , c , u ) is _ convertible ( u , v ) is _ convertible ( u , c , v ) is _ convertible ( u , v ) is _ convertible ( v , c , u ) is _ convertible ( u , v ) is _ convertible ( u , c , z ) ∧ is _ convertible ( z , v ) Tableau 4 . 3 – Règles d’inférences pour la description d’unitées 4 . 2 . 2 Description des unités composées et schéma de conversions Le tableau 4 . 3 liste les règles d’inférences utilisées pour construire des unités composées . Le SI considère qu’une unité peut être une unité ato - mique , un alias , une unité dérivée , une unité préﬁxée , une unité à laquelle on applique une puissance négative ou positive , un produit ou un quotient d’unités et toute unité convertible en une unité du SI . L’ensemble des règles du tableau 4 . 3 déﬁnit la grammaire qui décrit les expressions d’unités va - lides . Ainsi , dans un système avec les alias : pascal , joule et newton ; le newton pourrait se représenter par les expressions : quotient ( pr oduct ( pre f i xed _ uni t ( kilo , gr amme ) , m ) , power ( seconde , 2 ) ) , newton , quotient ( joule , m è tre ) ) ou encore pr oduct ( are , pascal ) . L’utilisation du prédicat is _ convertible était montré dans le tableau 4 . 2 . Ce prédicat déﬁnit une relation entre deux unités . Si une relation de conver - sion c u → v d’une unité u à une unité v existe , elle implique qu’une relation de conversion réciproque c − 1 v → u de v vers u existe . De plus , les relations de conversion peuvent être composées . Cette composition crée un chemin de conversions . Ces deux propriétés génèrent virtuellement un graphe non dirigé , dont les noeuds sont des unités et les arêtes sont des conversions autorisées entre des unités de mêmes dimensions . Les règles du tableau 4 . 3 permettent d’inférer ces relations de conversions en ajoutant des pro - priétés de réciprocité et la transitivité aux prédicats is _ convertible . 76 CHAPITRE 4 . REPRÉSENTATION DES CONNAISSANCES DE LA MÉTROLOGIE livre tonne kilomètre mètre mile pied UNITES kilogramme jour seconde heure m2 are newton dyne kip atomique dérivée base dérivée DIMENSIONS longueur masse temps aire force dimension réference Figure 4 . 2 – Classiﬁcation des unités par dimensions et relations de navigations par conversions . Les liens de conversion pleins présentent une relation indiquée sous la forme d’un prédicat du MKS et ceux en pointillés une relation inférée . Ainsi , un système de grandeurs dans un MKS peut être vu comme un en - semble de dimensions et d’unités liées par des conversions ou des relations de compositions qui forment un graphe ( ﬁgure 4 . 2 ) . L’ajout d’une nouvelle unité dans la KR se fait en deux temps : 1 . déﬁnition de l’unité atomique ou dérivée , 2 . connexion au graphe d’unités existantes ; avec un prédicat i s _ conver tible . Toutes les unités d’une dimension , donc d’un même sous - graphe , peuvent être énumérées à l’aide de la règle i s _ conver tible ( u , v ) Un système complet déﬁnit les relations entre les différentes unités dé - rivées et des combinaisons d’unités de base du système . Ces relations sont apportées dans le MKS par des alias ( newton ) , des conversions , ou des déﬁ - nitions explicites de l’unité de référence de la dimension ; l’avantage de ces dernières étant de proposer un point d’entrée clairement déﬁni au sous - graphe de conversion associé à la dimension . Pour chaque dimension , une référence est choisie en construisant une section dans l’ensemble des unités classiﬁées ( ﬁgure 4 . 2 ) . Pour les dimen - sions dérivées , les unités de références devraient être choisies comme une combinaison d’unités de référence des dimensions de base . Cela garantit que chaque dimension de chaque unité du système peut être réduite à une combinaison de dimensions de base . Par exemple , le tableau 4 . 2 montre cette déﬁnition pour les longueurs et les aires . La dimension de l’aire n’est pas décrite explicitement comme 77 CHAPITRE 4 . REPRÉSENTATION DES CONNAISSANCES DE LA MÉTROLOGIE une longueur au carrée ; son sous - graphe présente un point d’entrée déﬁni comme l’unité m 2 . Il est alors possible de remonter depuis l’unité are vers une combinaison d’unités de base qui la composent : are → m 2 → aire → longueur 2 . 4 . 3 Encodage des règles d’analyses 4 . 3 . 1 Analyse dimensionnelle Les grandeurs combinent une valeur et une unité , pour mesurer des grandeurs physiques . Les opérations sur les grandeurs manipulent des abs - tractions de phénomènes physiques . L’analyse dimensionnelle vériﬁe que ces opérations ont un sens par rapport aux règles de la physique . Puisque l’ensemble des unités employées peut être spéciﬁque à un domaine ou à une application ; l’analyse n’est pas faite sur les unités mais sur leurs di - mensions . Règles d’analyse Les vecteurs aux dimensions ( abrégés à partir de maintenant par d - vectors ) servent à encoder les types de grandeurs associés à toute unité . Chaque élément du vecteur est associé à une dimension de base et peut être élevé à la puissance n ; n étant un nombre entier . Par exemple , le SI propose sept grandeurs de bases , celles - ci impliquent un vecteur à sept di - mensions de la forme : < L , M , T , I , Θ , N , J > dont les symboles représentent respectivement : longueur , masse , temps , courant électrique , température thermodynamique , quantité de matière et intensité lumineuse . Avec cet en - codage , une longueur est associée au d - vector < 1 , 0 , 0 , 0 , 0 , 0 , 0 > , une aire au d - vector < 2 , 0 , 0 , 0 , 0 , 0 , 0 > et une vitesse au d - vector < 1 , 0 , − 1 , 0 , 0 , 0 , 0 > . L’analyse dimensionnelle empêche d’appliquer des opérations illégales sur des grandeurs . Pour les opérations autorisées , elle permet également de déﬁnir la dimension associée aux résultats de leurs applications . Il est possible de concaténer deux grandeurs , si elles représentent la même propriété physique . Cette concaténation produira un résultat repré - sentant les mêmes propriétés physiques . Les opérations d’addition et de soustraction nécessitent donc que tous les d - vectors impliqués soient iden - tiques . Par exemple : l’opération g 1 + g 2 + g 3 = g res , avec g x des grandeurs n’est autorisée que si : d - vector ( g 1 ) = d - vector ( g 2 ) = d - vector ( g 3 ) = d - vector ( g res ) . La combinaison de plusieurs types de grandeurs entraine la création 78 CHAPITRE 4 . REPRÉSENTATION DES CONNAISSANCES DE LA MÉTROLOGIE Constantes Description add , sub , mul , div opérations basiques sur les quantités Prédicats Description is _ dvector ( v ) v est un d - vector is _ at ( d , p ) la dimension d est à la position p is _ sum ( v , w , r ) r est la somme des vecteurs v , w is _ diff ( v , w , r ) r est la différence de v , w is _ valid ( o , v , w , r ) o est une opération valide pour les grandeurs v , w et r is _ cform ( u , c ) c est la forme canonique de u is _ dvector ( c , d ) d est le d - vectpr associé à la forme canonique c is _ dimension ( u , d ) d est le d - vector associé à l’unité u Tableau 4 . 4 – Prédicats pour inférer l’analyse dimensionnelle d’un nouveau type de grandeur en fonction des lois de la physique . Les opérations de multiplication et de division peuvent être réalisées sur tout ensemble de grandeurs . La dimension de la grandeur résultante est respec - tivement déﬁnie par la somme ou la soustraction vectorielle des grandeurs combinées . Ainsi , l’opération ( g 1 ∗ g 2 ) / g 3 = g res , avec g x des grandeurs , im - plique : d - vector ( g 1 ) + d - vector ( g 2 ) − d - vector ( g 3 ) = d - vector ( g res ) . Le tableau 4 . 4 montre les prédicats essentiels ajoutés au MKS pour per - mettre d’inférer l’analyse dimensionnelle . Ces règles permettent : — de transformer les expressions d’unités ( cf . tableau 4 . 3 en vecteurs aux dimensions , — de dériver l’effet que les opérations sur des grandeurs impliquent aux dimensions . is _ dvector identiﬁe les d - vectors valides pour un MKS donné . is _ at iden - tiﬁe l’index d’une dimension de base dans le d - vector . is _ sum et is _ diff iden - tiﬁent la somme et la différence de deux d - vectors . Le tableau 4 . 5 présente les faits et règles qui permettent d’appliquer les contraintes de l’analyse dimensionnelle associées aux concaténations et compositions de grandeurs . Les deux premiers faits servent à contraindre les additions et soustractions de grandeurs . Les deux règles suivantes en - codent les contraintes sur les multiplications et les divisions de grandeurs . En utilisant le prédicat is _ valid , il est possible de requérir au MKS pour assurer la cohérence d’opérations mathématiques sur des vecteurs aux di - mensions . L’uniﬁcation de la requête n’est possible que si les règles de l’analyse dimensionnelle sont respectées . 79 CHAPITRE 4 . REPRÉSENTATION DES CONNAISSANCES DE LA MÉTROLOGIE Tête Corps is _ valid ( add , v , v , v ) is _ valid ( sub , v , v , v ) is _ valid ( mul , v , w , r ) is _ sum ( v , w , r ) is _ valid ( div , v , w , r ) is _ diff ( v , w , r ) Tableau 4 . 5 – Faits et règles pour contraindre les fonctions de mesure à respecter l’analyse dimensionnelle . Transformation vers les vecteurs aux dimensions La combinaison de grandeurs arbitraires génère des expressions d’uni - tés comme ( m / ( s ∗ s ) ) ∗ kg ou ( kg ∗ ( m / s ) ) / s . Des expressions équivalentes , comme ces deux - ci , devraient être identiﬁées . Une approche pour réaliser cette identiﬁcation est de transformer les expressions sous une forme cano - nique . Cette forme doit garantir que deux expressions équivalentes ont une forme canonique identique . La forme canonique d’une expression d’unité est un ensemble , non or - donné , de puissances d’unités . Par exemple , la forme canonique des deux expressions précédentes est : { power ( meter , 1 ) , power ( kilogr am , 1 ) , power ( second , − 2 ) } . Une forme canonique est interprétée comme le produit des éléments qu’elle contient . Elle peut être transformée en un d - vector en utilisant la règle sui - vante qui combine des prédicats du tableau 4 . 4 : i s _ dimension ( u , d ) ← i s _ c f or m ( u , c ) ∧ i s _ dvector ( c , d ) . Le d - vecteur peut être utilisé et vériﬁé par les règles de l’analyse dimen - sionnelle à partir d’une requête au MKS . Le prédicat is _ cform permet la transformation d’une expression d’unité en une forme canonique . Une expression d’unité peut être vue comme un arbre syntaxique dont les opérations sont des branches et les unités des feuilles . Le processus de canonisation implique donc de visiter l’ensemble de l’arbre et d’appliquer une transformation spéciﬁque en fonction des élé - ments rencontrés . La canonisation respecte donc ce schéma : — unité de base : retourne l’unité de base à la puissance 1 , — unité préﬁxée : retourne la canonisation de l’unité , — puissance d’unité : retourne la canonisation de l’unité augmentée par la puissance , — somme , soustraction : retourne la canonisation d’une des unités , — multiplication : retourne la somme des canonisations des unités , 80 CHAPITRE 4 . REPRÉSENTATION DES CONNAISSANCES DE LA MÉTROLOGIE — division : retourne la différence des canonisations des unités , — alias , unité composée : retourne la canonisation de l’unité de déﬁni - tion . C’est cette canonisation qui bénéﬁcie le plus de la déﬁnition d’une unique unité de référence pour chaque dimension . En effet , cet unique point d’en - trée implique également une unique canonisation , permettant de remonter vers les différentes unités de base constituant les unités composées du sys - tème . Rappelons que la forme canonique contient au plus une occurrence des différentes unités de base du système . Ainsi , la transformation vers un d - vecteur is _ dvector est réalisée en associant chaque unité de base à sa di - mension et en assignant à chaque dimension la valeur de puissance corres - pondante . Exemple Les équations du code 4 . 1 représentent une procédure de mesure P qui implique de mesurer les longueurs et largeurs d’un toit , pour en calculer la surface , aﬁn de déﬁnir le nombre de panneaux solaires qui peuvent y être installés . Code 4 . 1 Equations de la procédure de mesure P qui permet de calculer le nombre de panneaux solaires à placer sur un toit . largeur * hauteur = toit toit / panneau = nbr _ panneaux largeur en mètre , hauteur en mile , panneau en are , nbr _ panneaux en un ( sans dimmension ) Le code 4 . 2 illustre une requête d’analyse dimensionnelle de P au MKS . Notez que l’unité un est employée pour dénoter une grandeur sans dimen - sion . La notation employée pour la requête est celle de ProLog . Un terme qui commence par une minuscule est une constante et par une majuscule est une variable . Cette requête pourrait être également écrite avec une syntaxe sous forme de système d’agents ( ﬁgure 4 . 3 ) . Les d - vecteurs qui se substituent aux variables lors de l’uniﬁcation de la requête sont afﬁchés en gris près des variables correspondantes La requête est confrontée à un MKS qui est dédié au domaine , avec un algorithme de résolution de problèmes qui prend en charge l’uniﬁcation . 81 CHAPITRE 4 . REPRÉSENTATION DES CONNAISSANCES DE LA MÉTROLOGIE Code 4 . 2 Exemple d’une requête pour la validation de la procédure de mesure P par l’analyse dimensionnelle du MKS ? - is _ dimension ( mètre , D _ largeur ) ^ is _ dimension ( mile , D _ hauteur ) ^ is _ dimension ( are , D _ panneau ) ^ is _ dimension ( un , D _ nbr _ panneaux ) ^ is _ valid ( mul , D _ largeur , D _ hauteur , D _ toit ) ^ is _ valid ( div , D _ toit , D _ panneau , D _ nbr _ panneaux ) mètre un mul D _ largeur u v rD _ toit mile D _ hauteur div u v are D _ panneau r D _ nbr _ Panneaux < 1 > < 1 > < 2 > < 2 > < 0 > Figure 4 . 3 – Modèle d’agents décrivant la requête d’application de l’analyse di - mensionnelle pour la procédure P . 82 CHAPITRE 4 . REPRÉSENTATION DES CONNAISSANCES DE LA MÉTROLOGIE Le domaine ne comportant que des longueurs , des surfaces et des gran - deurs sans dimension , un d - vector contient une dimension : < L > . Les va - riables D _ largeur et D _ hauteur sont substituées par le d - vector : < 1 > ; D _ panneau et D _ toit par : < 2 > ; D _ nbr _ panneaux par < 0 > . Ainsi is _ valid ( mul , D _ largeur , D _ hauteur , D _ toit ) devient is _ valid ( mul , < 1 > , < 1 > , < 2 > ) et is _ valid ( div , D _ toit , D _ panneau , D _ nbr _ panneaux ) devient is _ valid ( div , < 2 > , < 2 > , < 0 > ) . Ces deux opérations respectent les règles de l’analyse dimensionnelle décrite précédemment . L’uniﬁcation est un succès puisque toutes les va - riables ont été substituées . Alors , l’équation du code 4 . 1 est correcte du point de vue de l’analyse dimensionnelle et a donc du sens dans le monde physique . 4 . 3 . 2 Analyse des échelles Ces travaux cherchent à proposer une solution qui prend en charge les grandeurs physiques , codiﬁées par le SI , ainsi que les grandeurs non phy - siques . Pour étendre la vériﬁcation des procédures de mesure , ce sont les concepts de la théorie représentationnelle de la mesure , ou Representatio - nal Theory of Measurement ( RTM ) qui sont utilisés . Règles d’analyse La RTM déﬁnit des ensembles de capacités algébriques , associées aux grandeurs , appelés échelles de mesure . Les échelles sont déﬁnies en fonc - tion du phénomène qui est abstrait par une grandeur . Cette déﬁnition per - met la manipulation de grandeurs non physiques , telles que les genres hu - mains , les couleurs ou les notes d’examens . Pour ces grandeurs , la déﬁnition d’une échelle est sujette à discussions . Le genre humain , comme les couleurs , présentent une échelle nominale . À moins que les couleurs ne soient déﬁnies par une longueur d’onde , dans ce cas ce sera une échelle ordinale ( λ rouge < λ violet ) . Puisque les notes d’exa - mens sont considérées en France comme des valeurs continues , elles sont associées à l’échelle ratio , et il sera possible de calculer la moyenne arith - métique d’un ensemble de notes . En revanche , les pays anglo - saxons em - ploient une notation avec des lettres . Il est impossible de calculer une moyenne arithmétique sur un tel ensemble de valeurs . Les notes seront donc associées à une échelle ordinale permettant de calculer la valeur mé - diane d’un groupe . 83 CHAPITRE 4 . REPRÉSENTATION DES CONNAISSANCES DE LA MÉTROLOGIE Prédicats Description is _ scale ( s ) s est le nom d’une échelle is _ scale ( u , s ) l’unité u est associée à l’échelle s is _ default ( u , s ) s est l’échelle par défaut pour l’unité u is _ covering ( s , t ) s autorise au moins toutes les opérations de t is _ legal ( o , s ) l’opération o est autorisée par l’échelle s is _ operation ( o , s , t , r ) associe l’op . o , les entrées s et t et le résultat r is _ lowest ( s , t , r ) r est l’échelle la plus restrictive entre s et t Tableau 4 . 6 – Prédicats essentiels à l’ajout les notions d’échelles de mesure au MKS Les connaissances concernant les échelles de mesures sont ajoutées au MKS , en y ajoutant des prédicats et des règles pour l’analyse des échelles . Le tableau 4 . 6 présente les prédicats essentiels ajoutés . is _ default spéciﬁe l’échelle de mesure par défaut associée à une unité . Par exemple , l’échelle par défaut pour toutes unités représentant une lon - gueur est la ratio . L’échelle pour les températures en Kelvin est la ratio , celle pour les degrés Celsius et Fahrenheit est l’interval . Les échelles dé - ﬁnies par défaut permettent de simpliﬁer la mise en place d’une KR spé - ciﬁque et permettent d’appliquer l’analyse des échelles en empêchant les erreurs les plus communes . Notamment , la déﬁnition d’échelles par défaut pour des grandeurs non physiques est nécessaire puisque ces grandeurs présentent le plus souvent des propriétés mathématiques limitées . Le prédicat is _ covering déﬁnit une relation d’héritage des propriétés d’une échelle à l’autre . Cette relation est déﬁnie dans le chapitre 2 et est représentée dans le tableau 2 . 1 . Le prédicat is _ legal spéciﬁe les opérations autorisées par une échelle donnée . Ainsi , une opération peut être réalisée sur une grandeur , si et seulement si , l’échelle associée à la grandeur consi - dère légale ou couvre une échelle qui considère légale l’opération . Le prédicat is _ operation s’évalue comme vrai , seulement si l’opération est légale pour les opérandes en entrées . L’échelle associée au résultat est déﬁnie comme étant l’échelle la plus restrictive des deux échelles d’entrées . La table 4 . 7 présente les règles associées aux prédicats présentés . Transformation vers les échelles de mesure Le prédicat is _ scale ( u , s ) est la " tête " d’une règle qui consomme une ex - pression d’unité et la transforme en l’échelle associée à l’unité . Tout comme la transformation vers la forme canonique ( cf . 4 . 3 . 1 ) , la règle se résout en visitant l’arbre syntaxique de l’expression . Lors de la visite de cet arbre , les 84 CHAPITRE 4 . REPRÉSENTATION DES CONNAISSANCES DE LA MÉTROLOGIE Tête Corps is _ covering ( s , s ) is _ covering ( s , t ) is _ covering ( s , z ) ∧ is _ covering ( z , t ) is _ legal ( o , s ) is _ covering ( s , t ) ∧ is _ legal ( o , t ) is _ lowest ( s , t , s ) is _ covering ( t , s ) is _ lowest ( s , t , t ) is _ covering ( s , t ) is _ operation ( o , s , t , r ) is _ legal ( o , s ) ∧ is _ legal ( o , t ) ∧ is _ lowest ( s , t , r ) Tableau 4 . 7 – Règles associées aux échelles de mesure pour contraindre les opéra - tions avec l’analyse des échelles . sous - expressions sont analysées et leurs échelles évaluées en fonction des contraintes liées aux échelles sur les opérations . Cependant , il n’est pas raisonnable de prédéﬁnir ou de dériver automa - tiquement les échelles associées à toutes les unités qui sont décrites dans le MKS . En effet , l’échelle de mesure associée à une grandeur est fortement dépendante du contexte , tout particulièrement de l’instrument de mesure employé pour relever la grandeur . Par exemple : relever des couleurs avec un colorimètre ou simplement en choisissant une couleur dans une liste . Dans le premier cas , la grandeur est une longueur d’onde avec un échelle ratio . Dans le second c’est une couleur avec une échelle généralement no - minale ( voir ordinale ) . Pour pallier cela , le MKS permet à l’utilisateur d’entrer manuellement les échelles de mesure associées aux grandeurs . Ce point est expliqué plus en détail dans la section 4 . 4 . Exemple Rappelons que P est une procédure qui implique de mesurer les lon - gueurs et largeurs d’un toit , pour en calculer la surface , aﬁn de déﬁnir le nombre de panneaux solaires qui peuvent y être installés ( cf code 4 . 1 ) . Le code 4 . 3 montre une requête d’analyse des échelles de mesure pour la pro - cédure P . Dans cette analyse , l’échelle associée à la hauteur du toit et à la surface des panneaux est inférée à partir de leurs unités . L’échelle associée à la largeur du toit est le ratio , elle est imposée par la requête . L’uniﬁcation de cette requête propose de substituer S _ out par l’échelle ratio , apportant à l’utilisateur l’information concernant les capacités algé - briques de la grandeur résultante de la procédure de mesure . Puisque la requête s’uniﬁe pour l’analyse dimensionnelle et l’analyse des échelles de mesures , la procédure de mesure P est cohérente avec les 85 CHAPITRE 4 . REPRÉSENTATION DES CONNAISSANCES DE LA MÉTROLOGIE Code 4 . 3 Example of a scale analysis query ? - is _ scale ( meter , S _ hauteur ) ^ is _ scale ( are , S _ panneau ) ^ is _ operation ( mul , S _ hauteur , ratio , S _ toit ) ^ is _ operation ( div , S _ toit , S _ panneau , S _ nbr _ panneaux ) règles de la métrologie . P a donc du sens dans le monde physique . 86 CHAPITRE 4 . REPRÉSENTATION DES CONNAISSANCES DE LA MÉTROLOGIE 4 . 4 Vériﬁcation de procédures de mesures et langage de requêtes La section 4 . 3 a montré comment spéciﬁer et vériﬁer les dimensions et les échelles . Ces fonctionnalités sont étendues pour permettre de modéliser et d’analyser des procédures de mesures décrites par le MCM de la ﬁgure 4 . 1 . Ces extensions réduisent l’écart sémantique entre l’architecte qui déﬁ - nit des procédures de mesures sous la forme d’assemblage d’agents et les concepts essentiels de la métrologie . Ces extensions déﬁnissent le langage de requêtes du MKS , le Measurement Knowledge Query Language ( MKQL ) 4 . 4 . 1 Abstraction des procédures de mesure D’un point de vue architectural , les procédures de mesures sont décrites comme un ensemble d’agents interconnectés par des ports de communica - tions ( ﬁgure 4 . 3 ) . D’un point de vue métrologique , les agents sont des instruments de mesure , des fonctions de mesure et des instruments indicateurs ( ﬁgure 4 . 1 ) . Ceux - ci sont abstraits , par les unités des grandeurs d’entrées pro - duites et de sorties afﬁchées , ainsi que par les fonctions de transforma - tions entre les ports . Chaque port de communication est abstrait par une paire ( dimension , é chelle ) pour permettre les analyses dimensionnelle et des échelles . En effet , les notions d’unités et de grandeurs n’ont d’inté - rêts pour les analyses que pour déﬁnir ces entités qui sont employées pour contraindre les fonctions constituant la procédure . Le tableau 4 . 8 montre les prédicats essentiels utilisés pour l’abstraction des procédures de mesure . Le constructeur port assemble un d - vector et une échelle sous la forme d’une paire aﬁn de modéliser le point de commu - nication . Les prédicats is _ input sont utilisés pour abstraire les instruments de mesure . Les prédicats is _ output sont utilisés pour abstraire les instru - ments indicateurs . Les prédicats is _ function sont utilisés pour abstraire les fonctions de mesure . Pour les instruments de mesure , l’échelle produite peut être dérivée automatiquement des unités utilisées par l’instrument ou alors elles peuvent être déﬁnies manuellement par l’architecte . Le tableau 4 . 9 montre les règles utilisées pour appliquer les contraintes métrologiques aux modèles de procédures de mesures . Ces règles permettent de vériﬁer que les unités aux entrées et sorties de la procédure de mesure sont correctement rédigées , quelles prennent en charge la transformation des unités en d - vectors et en échelles , quelles appliquent les règles des deux analyses au niveau de chaque fonction de 87 CHAPITRE 4 . REPRÉSENTATION DES CONNAISSANCES DE LA MÉTROLOGIE Fonctions Description port ( d , s ) port appairant une dimension et une échelle Prédicats Description is _ input ( u , p ) l’unité u est transmise au port p is _ input ( u , s , p ) s est une échelle déﬁnie manuellement is _ function ( o , p1 , p2 , p3 ) op . o avec les ports d’entrées p1 , p2 et le port de sortie p3 is _ output ( p , u ) le port p produit l’unité u Tableau 4 . 8 – Prédicats utilisés pour abstraire les procédures de mesure sous la forme d’agents . Tête Corps is _ input ( u , port ( d , s ) ) is _ dimension ( u , d ) ∧ is _ scale ( u , s ) . is _ input ( u , s , port ( d , s ) ) is _ dimension ( u , d ) ∧ is _ scale ( s ) . is _ function ( op , port ( d1 , s1 ) , port ( d2 , s2 ) , port ( d3 , s3 ) ) is _ valid ( op , d1 , d2 , d3 ) ∧ is _ operation ( op , s1 , s2 , s3 ) . is _ output ( port ( d , s ) , u ) is _ dimension ( u , d ) . Tableau 4 . 9 – Règles pour l’application des contraintes métrologiques dans les pro - cédures de mesure 88 CHAPITRE 4 . REPRÉSENTATION DES CONNAISSANCES DE LA MÉTROLOGIE Predicates Description is _ trace ( f , t ) déﬁnie une trace t vers un ﬂux f is _ done ( t ) la trace t est terminée is _ itrace ( n , port ( d , s ) , t ) instrument de mesure n et trace t is _ ftrace ( n , op , port ( d1 , s1 ) , port ( d2 , s2 ) , port ( d3 , s3 ) , t ) fonction n is _ otrace ( n , port ( d , s ) , t ) instrument indicateur n is _ checked _ input ( n , p , t ) entrée vériﬁée n is _ checked _ input ( n , u , p , t ) is _ checked _ function ( n , op , p1 , p2 , p3 , t ) fonction vériﬁée n is _ checked _ output ( n , p , t ) sortie vériﬁée n is _ checked _ output ( n , p , u , t ) Tableau 4 . 10 – Prédicats pour la trace de la vériﬁcation mesure . 4 . 4 . 2 Vériﬁcation des procédures de mesure La cohérence avec la sémantique de la métrologie d’un modèle de pro - cédure de mesure construit avec les prédicats et règles présentés peut être vériﬁée . Ce modèle est donc appelé une requête de vériﬁcation . Si une sub - stitution peut être trouvée par uniﬁcation alors le modèle est correct . Sinon il est incorrect . Pour localiser précisément quel endroit du modèle est er - roné , il faut un système de traces . Le tableau 4 . 10 montre les prédicats utilisés pour générer la trace du processus de vériﬁcation du modèle . Les prédicats is _ trace et is _ done sont utilisés pour ouvrir et fermer un ﬂux dans lequel sera écrie la trace . Les pré - dicats is _ itrace , is _ ftrace et is _ otrace déﬁnissent les traces pour les entrées , fonctions et sorties . Les prédicats is _ checked _ input , is _ checked _ function et is _ checked _ output sont les contreparties capables de tracer des prédicats déﬁnis table 4 . 8 . Ceux - ci proposent de tracer le processus d’uniﬁcation et d’assigner des noms aux instruments et fonctions du modèle . Le tableau 4 . 11 donne les règles utilisées pour vériﬁer et tracer les er - reurs d’un modèle de procédure de mesure . La combinaison des prédicats des tableaux 4 . 8 et 4 . 10 permet à l’archi - tecte d’écrire une requête dont la vériﬁcation génère une trace pour les composants d’intérêt et est silencieuse pour les autres . Cela permet de fo - 89 CHAPITRE 4 . REPRÉSENTATION DES CONNAISSANCES DE LA MÉTROLOGIE T ê t e C o r p s i s _ c h e c k e d _ i n p u t ( n , p o r t ( d , s ) , t ) i s _ i t r a c e ( n , p o r t ( d , s ) , t ) . i s _ c h e c k e d _ i n p u t ( n , u , p o r t ( d , s ) , t ) i s _ i n p u t ( u , p o r t ( d , s ) ) ∧ i s _ i t r a c e ( n , p o r t ( d , s ) , t ) . i s _ c h e c k e d _ i n p u t ( n , u , s , p o r t ( d , s ) , t ) i s _ i n p u t ( u , s , p o r t ( d , s ) ) ∧ i s _ i t r a c e t ( n , p o r t ( d , s ) , t ) . i s _ c h e c k e d _ f un c t i o n ( n , o p , p o r t ( v 1 , s 1 ) , p o r t ( v 2 , s 2 ) , p o r t ( v 3 , s 3 ) , t ) i s _ f un c t i o n ( o p , p o r t ( v 1 , s 1 ) , p o r t ( v 2 , s 2 ) , p o r t ( v 3 , s 3 ) ) ∧ i s _ f t r a c e ( n , o p , p o r t ( v 1 , s 1 ) , p o r t ( v 2 , s 2 ) , p o r t ( v 3 , s 3 ) , t ) . i s _ c h e c k e d _ o u t p u t ( n , p o r t ( d , s ) , u , t ) i s _ o u t p u t ( p o r t ( d , s ) , u ) ∧ i s _ o t r a c e ( n , p o r t ( d , s ) , t ) . i s _ c h e c k e d _ o u t p u t ( n , p o r t ( d , s ) , s t ) i s _ o t r a c e ( n , p o r t ( d , s ) , t ) . T a b l e a u 4 . 11 – R è g l e s p o u r v é r i ﬁ e r e t t r a c e r l e s m o d è l e s d e p r o c é d u r e s d e m e s u r e 90 CHAPITRE 4 . REPRÉSENTATION DES CONNAISSANCES DE LA MÉTROLOGIE caliser la vériﬁcation sur un ensemble d’agents ajoutés , ou modiﬁés , au sein d’une architecture construite avec des structures d’agents réutilisables ou déjà vériﬁées . Exemple Le code 4 . 4 montre une requête qui permet d’appliquer l’analyse dimen - sionnelle et l’analyse des échelles de mesures à la procédure P . Rappelons que P sert à calculer le nombre de panneaux solaires à installer sur un toit en calculant sa surface ( cf code 4 . 1 ) . Ce code montre que le MKQL permet de simpliﬁer la description de la requête qui était auparavent constituée de deux parties distinctes , une pour chaque analyse ( cf codes 4 . 2 et 4 . 3 ) , moins lisibles . Code 4 . 4 Utilisation du MKQL pour simpliﬁer la requête d’application des deux analyse proposée par le MKS à la procédure P . ? - is _ trace ( fichier , t ) , is _ checked _ input ( instrument _ largeur , mètre , P _ largeur , t ) ^ is _ input ( instrument _ hauteur , mile , ratio , P _ hauteur ) ^ is _ input ( aire _ panneau , are , P _ panneau ) ^ is _ checked _ function ( aire _ toit , mul , P _ largeur , P _ hauteur , P _ toit , t ) ^ is _ checked _ function ( nbr _ p , div , P _ toit , P _ panneau , P _ nbr _ panneaux , t ) ^ is _ checked _ output ( resultat , P _ nbr _ panneaux , un , t ) ^ is _ done ( t ) . Notez que , en plus de proposer un seul code pour l’application des deux analyses , il est également plus compréhensible par un architecte logiciel non aguerri en métrologie . En effet , les mots - clefs employés sont proches du vocabulaire de la métrologie mais également de celui employé dans les approches composants ou agents . La requête modélise une procédure de mesure sous la forme d’agents . Chaque agent est une abstraction d’un ins - trument de mesure , d’une fonction de mesure ou d’un instrument indica - teur . La communication entre les agents est réalisée à l’aide de ports qui abstraient les grandeurs pour chacune des analyses . Ainsi , la modélisation d’une procédure de mesure se fait avec un voca - bulaire proche de celui de l’architecte logiciel . La modélisation peut être compréhensible par un potentiel utilisateur ﬁnal de l’application puisque les agents représentent soit des grandeurs à mesurer , soit des opérations sur les grandeurs , soit des grandeurs résultantes de la procédure de me - sure . De plus , le modèle peut être utilisé pour vériﬁer sa cohérence avec la sémantique de la métrologie en le confrontant au MKS puisqu’il est égale - ment une requête d’uniﬁcation pour la KR . 91 CHAPITRE 4 . REPRÉSENTATION DES CONNAISSANCES DE LA MÉTROLOGIE Avec un MKS contenant un système d’unités compatible avec le SI , il est possible de vériﬁer des procédures complexes . Le code 4 . 5 montre les équa - tions d’une procédure de mesure P2 . Le but de P2 est de valider l’emploi du MKQL pour créer une requête d’analyse de procédure de mesure utilisant diverses unités , composées ou non , types de grandeurs et opérations . P2 implique de mesurer deux longueurs et un temps . Les deux longueurs sont additionnées , le résultat est divisé par le temps pour trouver une vitesse . La vitesse est également divisée par le temps pour trouver une accélération . Les unités des longueurs sont le mètre et le inch . Le temps est en seconde . La vitesse est en mile / mois et l’accélération en g ( g étant l’accélération de la pesanteur sur terre ) et en kip / kg . Code 4 . 5 Equations de la procédure de mesure complexe P2 qui permet de tester l’expressivité du MKQL . longueur1 + longueur2 = longueur longueur / temps = vitesse vitesse / temps = accel1 vitesse / temps = accel2 longueur 1 en mètre longueur 2 en inch temps en seconde vitesse en mile / mois accel1 en g accel2 en kip / kg Le code 4 . 6 montre la requête au MKS correspondant à P2 , décrite à l’aide du MKQL . La ﬁgure 4 . 4 illustre ce code sous forme d’un modèle d’agents . Bien que cela soit possible , vériﬁer P2 à la main n’est pas tri - vial . L’uniﬁcation de cette procédure est réalisée par le MKS , assurant que la procédure est cohérente . Si l’on change une opération ou le type de gran - deur d’une des unités de P2 , la requête ne peut plus être uniﬁée , indiquant une erreur dans la procédure . Code 4 . 6 Requête de vériﬁcation d’une procédure de mesure complexe . ? - is _ checked _ output ( vitesse , quotient ( mile , mois ) , P _ v , t ) ^ is _ checked _ output ( accel1 , g ) , P _ a , t ) ^ is _ checked _ output ( accel2 , quotient ( kip , gram ) P _ a , t ) ^ is _ checked _ function ( vitesse _ calc , div , P _ l , P _ t , P _ v , t ) ^ is _ checked _ function ( accel _ calc , div , P _ v , P _ t , P _ a , t ) ^ is _ checked _ function ( add _ calc , add , P _ l1 , P _ l2 , P _ add , t ) ^ is _ checked _ input ( longueur1 , mètre , P _ l1 , t ) ^ is _ checked _ input ( longueur2 , inch , P _ l2 , t ) ^ is _ checked _ input ( temps , seconde , P _ t , t ) 92 CHAPITRE 4 . REPRÉSENTATION DES CONNAISSANCES DE LA MÉTROLOGIE P _ a r r mètre add P _ l1 u v P _ l inch P _ l2 div u v seconde P _ t longueur1 longueur2 div mile / mois P _ v r u temps add _ calc vitesse _ calc speed v g kip / kg accel _ calc accel2 accel1 Figure 4 . 4 – Modèle d’agents décrivant la requête d’application de l’analyse pour la procédure P2 . 4 . 5 Encodage des règles de conversion entre grandeurs Les systèmes d’unités qui peuvent être inférés par le MKS sont décrits sous la forme d’un graphe d’unités interconnectées par des relations de conversions et d’alias . Ce graphe est décomposé en sous - graphes , chacun des sous - graphes regroupant l’ensemble des unités associées à une dimen - sion du système . Le chapitre 2 a montré que l’emploi d’unités hors du SI est très répandu et souvent source d’erreurs . Cette section présente des faits et règles qui une fois ajoutés au MKS permettent de prendre en charge les conversion entre les unités d’un système d’unités . 4 . 5 . 1 Prédicats de conversion Chaque dimension est associée à une unité de référence . Cette unité de référence permet de déﬁnir le chemin entre les dimensions à l’aide d’opé - rations de compositions ( mult , div ) . C’est l’unité de référence qui type la dimension . En effet , le prédicat is _ reference _ unit ( longueur , mètre ) déclare que la dimension longueur a pour référence l’unité mètre . Les autres unités du sous - graphe longueur ne sont pas liées directement à la dimension , mais 93 CHAPITRE 4 . REPRÉSENTATION DES CONNAISSANCES DE LA MÉTROLOGIE fonctions Description conv ( ratio , r ) r est ratio de conversion conv ( interval , r , z ) r un ratio , z un décalage de zero pair ( v , w ) v et w des valeurs appairées conv ( nominal , lp ) lp une liste de paires < nom , nom > range ( v , w ) v et w des valeurs formant un intervalle conv ( to _ ordinal , lp ) kp une liste de paires < range , nom > conv ( reciprocal , c ) c une fonction de conversion conv ( chain , cc ) cc une liste de conversions Prédicats Description is _ convert _ to _ base ( u , c ) u est une unité et c une conversion is _ convert _ from _ base ( u , c ) u est une unité et c une conversion is _ conv _ applied _ l ( v1 , c , v2 ) v1 et v2 des valeurs , c une conversion is _ converted ( v1 , u1 , v2 , u2 ) u1 et u2 des unités , v1 et v2 des valeurs is _ ok _ converted ( v1 , u1 , v2 , u2 ) identique à is _ converted Tableau 4 . 12 – Prédicats du MKS permettant l’inférence de conversion entre deux grandeurs . à l’unité de référence directement ou par transitivité . La ﬁgure 4 . 2 montre que des relations de conversion sont inférées entre toutes les unités d’un sous - graphe . Les relations de conversion sont , soit déﬁnies par des prédicats dans le MKS , soit déduites à partir de la transi - tivité des relations de conversion . Cette propriété de transitivité qui sera employée pour gérer les conversions . Le tableau 4 . 12 présente les prédicats employés pour la description des conversions entre les unités d’un système . Rappelons que le MKS doit pou - voir prendre en charge les grandeurs non - physiques . Les constructeurs conv , permettent de décrire la fonction de conversion qui prend place entre deux unités . Par exemple , la relation de conversion entre le degré Celsius et le degré Fahrenheit se décrit par le prédicat : is _ convertible ( celsius , conv ( interval , 1 . 8 , 32 ) , fahrenheit ) . Ces fonctions de conversion sont identiﬁées avec l’échelle de mesure qui devrait être associée à la grandeur . Ratio déﬁnit le ratio de conversion entre deux unités . Intervale déﬁnit le ratio de conversion ainsi que le dé - calage entre les zéros de deux unités . Nominal déﬁnit les noms liés par la conversion . Par exemple , la conversion entre les stéréotypes de couleurs vues par deux individus peut comprendre les paires pair ( f r amboi se , r ose ) , pair ( r ose , r ose ) et pair ( saumon , r ose ) rien que pour la couleur rose . Cette 94 CHAPITRE 4 . REPRÉSENTATION DES CONNAISSANCES DE LA MÉTROLOGIE conversion peut également être utilisée pour les grandeurs ordinales . To _ - ordinal déﬁnit une conversion d’une grandeur interval ou ratio vers une grandeur ordinal . Pour cela elle permet d’associer des intervalles de valeurs ( range ) à des noms . Ainsi une conversion entre mètre et une catégorisation des tailles des humains peut être déﬁnie avec les paires : pair ( r ange ( 0 . 1 , 1 . 5 ) , peti t ) , pair ( r ange ( 1 . 51 , 1 . 8 ) , moyen ) et pair ( r ange ( 1 . 81 , 2 . 5 ) , gr and ) . Reciprocal permet de représenter la réciproque d’une opération de conver - sion c . Ainsi , si c est la fonction conv ( ratio , 1 . 6 ) qui permet de convertir des miles en kilomètres , alors conv ( reciprocal , c ) est équivalent à 1 / 1 . 6 et permet de convertir des kilomètres en miles . Normalement , la conversion conv ( reciprocal , conv ( reciprocal , c ) ) devrait être identique à c . Cependant , les conversions nominal et to _ ordinal peuvent induire une perte d’informa - tion qui empêche cette relation ; En se basant sur l’exemple des conversions de couleurs , la conversion de C f ( saumon ) donnera C h ( r ose ) . Cependant la conversion de C h ( r ose ) donnera C f ( f r amboi se ) , C f ( r ose ) ou C f ( saumon ) en fonction de l’algorithme d’uniﬁcation . Chain permet de regrouper une liste de conversions . La liste est inter - prétée sémantiquement comme une séquence de conversions à réaliser les unes après les autres . L’ordre dans la liste est primordial . En effet , une sé - quence de conversions doit être appliquée dans le bon ordre , sous peine de ne plus avoir de sens . Par exemple , pour convertir des Kelvin en degrés Fahrenheit , il pourrait y avoir la chaîne de conversion conv ( chain , [ c1 , c2 ] ) avec c1 la conversion K → ◦ C et c2 ◦ C → ◦ F . Prenons comme valeur à conver - tir 0K . En appliquant c1 puis c2 la valeur obtenue est − 459 . 67F ( la valeur correcte ) alors qu’en appliquant c2 puis c1 la valeur obtenue est − 241 . 15F . Les prédicats de conversion permettent la création d’un graphe d’uni - tés , connectant toutes les unités d’un système aux unités de référence de chaque dimension . Mais ces mêmes prédicats ne garantissent pas que des opérations de conversion ne soient pas , soit source de perte d’information , soit source d’imprécisions . En effet la première conversion perd des in - formations en passant un ensemble de valeurs vers une valeur unique . La seconde conversion est une source d’imprécisions car elle ne peut attri - buer précisément une valeur unique dans l’ensemble de destination . C’est le même procédé que l’emploi d’un instrument de mesure et d’un instru - ment indicateur qui ne gèrent pas les mêmes degrés de précision sur les valeurs . Les prédicats is _ convert _ to _ base et is _ convert _ from _ base permettent de déﬁnir la chaîne de conversion entre une unité et l’unité de base lui corres - pondant et inversement . Une unité de base étant l’unité de référence d’une dimension de base ou la décomposition d’une unité composée sous la forme d’une expression d’unité composée uniquement d’unités de base . Le mètre 95 CHAPITRE 4 . REPRÉSENTATION DES CONNAISSANCES DE LA MÉTROLOGIE est donc une unité de base pour la longueur . L’unité de base correspondant au newton pourra être par exemple quotient ( product ( preﬁxed _ unit ( kilo , gramme ) , m ) , power ( seconde , 2 ) ) . Le prédicat is _ conv _ applied est le prédicat qui permet de prendre en charge les conversions entre deux grandeurs . Il permet de déﬁnir que v1 est convertie en v2 par c . Le prédicat is _ converted permet de formuler une requête de conversion au MKS . En effet , ce prédicat prend deux grandeurs et infère qu’elles sont bien l’une et l’autre équivalentes après une conversion . Enﬁn , le prédicat is _ ok _ converted permet de formuler une requête de conversion en assurant sa faisabilité . Pour cela il vériﬁe que les deux unités sont bien de même dimension et qu’il existe donc une séquence de conversion entre les deux unités . 4 . 5 . 2 Règles de conversion Le tableau 4 . 13 montre les règles associées aux prédicats is _ convert _ - from _ base et is _ converted pour l’inférence de conversions entre deux gran - deurs . La notation x is p est employée ici pour simpliﬁer la notation des clauses . Elle associe à la variable x le prédicat p . La notation [ h , t ] représente une liste d’éléments dont h est le premier et t la liste de tous les autres éléments . Le tableau montre que les règles de is _ convert _ from _ base et is _ conver - ted dépendent du prédicat is _ convert _ to _ base ( u , c ) . Ce prédicat demande à trouver un chemin entre l’unité u et l’unité de base correspondante . Tout comme la canonisation ( cf section 4 . 3 ) la conversion visite l’arbre syn - taxique composant l’unité et génère la chaîne de conversions correspon - dante . La conversion d’une unité vers sa base peut être vue comme une opéra - tion qui : — pour chaque unité de base , cherche à remonter les arêtes vers la ré - férence du sous - graphe correspondant , — pour chaque unité composée , cherche les conversions vers les bases des unités qui la compose et les associe . Les règles associées au prédicat is _ conv _ applied permettent l’applica - tion de toutes les conversions en fonction de leur type . Notez que les règles pour les conversions reciprocal ne sont pas détaillées pour des soucis de lisibilité du tableau . Celles - ci impliquent simplement d’appliquer la conver - sion réciproque à celle contenue . 96 CHAPITRE 4 . REPRÉSENTATION DES CONNAISSANCES DE LA MÉTROLOGIE T ê t e C o r p s i s _ c o n v e r t _ f r o m _ b a s e ( u , c ) i s _ c o n v e r t _ t o _ b a s e ( u , d ) ∧ c i s c o n v ( r e c i p r o c a l , d ) ) i s _ c o n v _ a pp li e d ( v , c o n v ( r a t i o , r ) , w ) w i s v * r i s _ c o n v _ a pp li e d ( v , c o n v ( i n t e r v a l e , r , z ) , w ) w i s ( ( v * r ) + z ) i s _ c o n v _ a pp li e d ( v , c o n v ( n o m i n a l , p a i r ( v , w ) ) , w ) i s _ c o n v _ a pp li e d ( v , c o n v ( n o m i n a l , [ p a i r ( v , w ) , t ] , w ) i s _ c o n v _ a pp li e d ( v , c o n v ( n o m i n a l , [ h , t ] ) , w ) i s _ c o n v _ a pp li e d ( v , c o n v ( n o m i n a l , t ) , w ) i s _ c o n v _ a pp li e d ( v , c o n v ( o r d i n a l , p a i r ( r a n g e ( x , y ) , n ) , n ) ) < ( x , v ) ∧ < ( v , y ) i s _ c o n v _ a pp li e d ( v , c o n v ( o r d i n a l , [ h , t ] ) , w ) i s _ c o n v _ a pp li e d ( v , c o n v ( o r d i n a l , h ) , w ) i s _ c o n v _ a pp li e d ( v , c o n v ( o r d i n a l , [ h , t ] ) , w ) i s _ c o n v _ a pp li e d ( v , c o n v ( o r d i n a l , t ) , w ) ) i s _ c o n v _ a pp li e d ( v , c o n v ( c h a i n , [ h , t ] ) , w ) i s _ c o n v _ a pp li e d ( x , h , w ) ∧ i s _ c o n v _ a pp li e d ( v , c o n v ( c h a i n , t ) , x ) i s _ c o n v e r t e d ( v 1 , u 1 , v 2 , u 2 ) i s _ c o n v e r t _ t o _ b a s e ( u 1 , c 1 ) ∧ i s _ c o n v e r t _ f r o m _ b a s e ( u 2 , c 2 ) ∧ i s _ c o n v _ a pp li e d ( v 1 , c , v 2 ) ∧ c i s c o n v ( c h a i n , [ c 1 , c 2 ] ) i s _ o k _ c o n v e r t e d ( v 1 , u 1 , v 2 , u 2 ) i s _ d i m e n s i o n ( u 1 , D ) ∧ i s _ d i m e n s i o n ( u 2 , D ) ∧ i s _ c o n v e r t e d ( v 1 , u 1 , v 2 , u 2 ) T a b l e a u 4 . 13 – R è g l e s p o u r l a c o n v e r s i o n d e g r a n d e u r s . 97 CHAPITRE 4 . REPRÉSENTATION DES CONNAISSANCES DE LA MÉTROLOGIE Le prédicat is _ converted permet de convertir une grandeur g1 en une grandeur g2 . Pour cela la chaîne de conversion c1 pour convertir g1 vers sa base est cherchée . La chaîne de conversion c2 pour convertir g2 vers sa base est également cherchée . La conversion de g1 en g2 implique de chaîner c1 et la réciproque de c2 . Cette approche n’est pas la plus rapide . En effet , elle oblige à déduire le chemin de conversion vers la base de chaque grandeur alors qu’il pour - rait exister un chemin plus court . Cependant , il existe forcément une base pour chaque grandeur et cette base étant le point d’entrée de chaque sous - graphe , remonter vers elle est normalement réalisable à l’aide de la tran - sitivité de is _ convertible . Par contre , pour cibler directement une grandeur g2 à partir de g1 il faudra inférer un chemin de conversion qui , lui , risque d’être difﬁcile , si ce n’est impossible à déduire dans un temps raisonnable , en fonction du nombre d’unités et de dimensions du système . Enﬁn , le prédicat is _ ok _ converted vériﬁe que les d - vectors des deux uni - tés de la conversion soient identiques . En effet , le prédicat is _ converted trouve la chaîne de conversions pour chacune des unités vers son unité de base , mais ne vériﬁe pas que les bases soient identiques , ce qui peut per - mettre de convertir des grandeurs de nature différente . Exemple Le MKS permet de faire des conversions à l’aide du prédicat is _ conver - ted . Il est possible d’utiliser ce prédicat sur le système d’unités réduit pré - senté par le tableau 4 . 2 pour convertir des miles en kilomètres avec la re - quête : is _ converted ( 10 , mile , X , km ) . L’uniﬁcation de cette requête substitue la valeur 16 . 09344 à la variable X . La chaîne de conversion se compose de : conv ( ratio , 1 . 609344 ) , conv ( ratio , 1000 ) et conv ( reciprocal , conv ( ratio , 1000 ) , pour faire respectivement les conver - sions : mile → kilometre , kilom è tre → m è tre et m è tre → kilom è tre . Notez que la conversion contient deux opérations inutiles dans ce cas . Ce système ne présente pas beaucoup d’unités et ses capacités de conver - sions sont donc assez faibles . Pour aller plus loin , nous proposons de conver - tir deux grandeurs de force , des kips en méganewtons . Pour cela , un MKS avec un système d’unités compatible avec le SI été développé . Il comprend les dimensions longueur , masse , temps , force , puissance , vitesse , aire et vo - lume . À chacune de ces dimensions est associé un sous - graphe contenant les unités et les relations déﬁnies par les diagrammes d’unités disponibles sur le site web de l’entreprise Metric Methods SM , une entreprise consul - tante spécialisée en métrologie [ 46 ] . Notez que la certaines des opérations 98 CHAPITRE 4 . REPRÉSENTATION DES CONNAISSANCES DE LA MÉTROLOGIE de conversions déﬁnies sur ces diagrammes ne sont pas exactes . En ef - fet , les diagrammes employés proposent des unités qui sont déﬁnies hors du SI et dont les relations ne sont pas précisément déﬁnies . Ces inexacti - tudes de conversions peuvent être source d’imprécisions . Les calculs sur des nombres ﬂottants réalisés par la machine ajoutent également des im - précisions . L’uniﬁcation de la requête : is _ converted ( 100 , kip , X , preﬁxed _ unit ( mega , newton ) substitue la valeur 0 . 4448226 à la variable X . La chaîne de conversion se compose de : conv ( ratio , 1000 ) , conv ( reciprocal , conv ( ratio , 2 . 20462 ) et conv ( ratio , 9 . 80665 ) pour faire respectivement les conversions : kip → pound _ - force , pound _ force → kilogram _ force et kilogram _ force → newton . Le new - ton étant la référence pour cette dimension . Pour illustrer les imprécisions issues des conversions , nous pouvons convertir 1 ki p en pound _ force , au lieu d’obtenir 1000 , le MKS retourne 999 . 998 . Si maintenant on demande une conversion avec des expressions d’unités composées pour décrire une nouvelle force , non encodée dans le système la chaîne de conversions sera plus complexe . Par exemple : l’uniﬁcation de la requête : is _ converted ( 1 , power ( mile , 2 ) , X , mult ( km , km ) substitue la valeur 3097600 à la variable X . La chaîne de conversion se compose de : conv ( ratio , 1 . 609344 2 ) , conv ( ratio , 1000 2 ) et conv ( reciprocal , conv ( ratio , 1000000 ) pour faire respectivement les conversions : mile 2 → km 2 , km 2 → m 2 et km ∗ km → m ∗ m . 4 . 6 Utilisation de ProLog et conclusion 4 . 6 . 1 Utilisation de ProLog Les différents prédicats et règles présentés dans les sections précé - dentes ont été implémentées avec la distribution SWI - ProLog [ 133 ] de Pro - Log . ProLog permet d’encoder directement les prédicats et règles du MKS puisqu’il encode les connaissances d’un domaine en logique du premier ordre . Trace de l’uniﬁcation ProLog propose un mécanisme d’écriture sur des ﬂux ( ﬁchier , console ) . Ce mécanisme peut être employé pour tracer l’uniﬁcation d’une requête . 99 CHAPITRE 4 . REPRÉSENTATION DES CONNAISSANCES DE LA MÉTROLOGIE SWI - ProLog propose des prédicats pour ouvrir et fermer un ﬂux d’écriture ou de lecture d’un ﬁchier . Il propose également un prédicat pour écrire sur un ﬂux . À l’aide de ce ﬂux , il est possible d’écrire pour chaque agent tracé , le résultat de son uniﬁcation . Cela permet de remonter à l’utilisateur les dimensions impliquées à tous les niveaux de la procédure de mesure . Nous rappelons qu’une procédure de mesure décrite par le Measure - ment Knowledge Query Language ( MKQL ) ( cf sections 4 . 3 et 4 . 4 ) peut être vue comme un assemblage d’ agents ( cf ﬁgures 4 . 3 et 4 . 4 . Chaque agent permettant de représenter une mesure de grandeur , une opération sur des grandeurs ou une indication d’une grandeur résultante de la procédure de mesure . Notez que ProLog uniﬁe les requêtes avec un algorithme d’uniﬁcation à retour sur trace ( backtracking ) . Un tel algorithme va parcourir tous les prédicats de la base , jusqu’à substituer toutes les variables de la requête . Si le prédicat est une règle , alors chaque prédicat de la règle sera sou - mis à cette uniﬁcation . Lorsqu’une substitution s1 à une variable prouve un prédicat , l’uniﬁcation continue à prouver les autres prédicats . Si s1 est incorrecte pour un prédicat dans la continuité de l’uniﬁcation , alors l’al - gorithme d’uniﬁcation fait un retour sur trace au moment où s1 aura été uniﬁée . Après ce retour , il cherche une substitution s2 et recommence la suite de l’uniﬁcation . Ce cycle se répète jusqu’à trouver un ensemble de substitutions qui permette de substituer toutes les variables de la requête pour l’uniﬁer , ou jusqu’à avoir testé toutes les substitutions possibles et déclarer que l’uniﬁcation est impossible . Cet algorithme implique que , lors de l’uniﬁcation , les prédicats qui abs - traient les entités de la procédure de mesure auront de multiples substitu - tions pour leurs variables avant de trouver celle qui est correcte ou non . Lors de l’analyse d’une procédure erronée , tous les chemins de canonisa - tion possibles seront testés , toutes les substitutions de ports également . Ainsi , les informations tracées seront illisibles . Chaque retour sur trace im - plique des retours en arrière , qui réécriront des informations dans la trace à chaque nouvelle substitution testée . Gestion des erreurs SWI - ProLog propose un mécanisme d’exceptions qui permet de manipu - ler le processus d’uniﬁcation . Ce mécanisme utilise un prédicat pour lancer une exception et un autre pour l’intercepter . Ainsi , lorsqu’une erreur est détectée dans l’uniﬁcation d’une opération de la procédure de mesure , plu - tôt que de chercher à faire un retour sur trace et à ré - analyser des agents correctement uniﬁés , les agents tracés envoient une exception qui stoppe 100 CHAPITRE 4 . REPRÉSENTATION DES CONNAISSANCES DE LA MÉTROLOGIE type d’agent description de l’erreur reconnue 1 input unité non conforme 2 input échelle non conforme 3 input dimensions de l’unité et du port différentes 4 input échelles de l’unité et du port incompatibles 5 function échec de l’analyse dimensionnelle 6 function échec de l’analyse des échelles 7 function erreur en provenance du port res 8 output unité non conforme 9 output dimensions de l’unité et du port différentes 10 input erreur en provenance du port 11 function erreur en provenance du port a 12 function erreur en provenance du port b 13 output erreur en provenance du port Tableau 4 . 14 – Erreurs d’uniﬁcation de requêtes remontées par le MKS . l’uniﬁcation , après avoir notiﬁé le type d’erreur détectée dans la trace . Néanmoins , il peut être intéressant d’autoriser le retour sur trace pour certaines analyses , comme pour le mécanisme de prescription présenté plus loin dans cette section ( cf section 4 . 6 . 1 ) . Rappelons que pour cela , lorsque le système n’est pas capable d’uniﬁer un agent , l’agent substituera les di - mensions et échelles de ses ports avec le message error . Les agents , qui tentent une uniﬁcation avec un port qui contient le message d’erreur , l’in - diquent dans la trace et indiquent qu’ils ont bien été uniﬁés . Ainsi , toutes les substitutions possibles seront testées sur les agents . Le tableau 4 . 14 présente les différentes erreurs que nous avons identi - ﬁées . La partie supérieure du tableau présente les règles qui peuvent lancer des exceptions . La partie inférieure présente les règles qui sont employées pour gérer la prescription à l’aide de la diffusion de messages d’erreurs . Prescription de types de grandeurs Puisque ProLog est capable de chercher des substitutions pour toute variable du système , nous proposons également d’employer le MKS comme un outil de prescription capable de déﬁnir le type de grandeur qui pourrait être mesuré ou afﬁché par une procédure de mesure partiellement déﬁnie . La multiplication et la division de grandeurs sont abstraites pour l’ana - lyse dimensionnelle par le prédicat is _ valid ( op , v , w , r ) . La logique des prédi - cats permet de remplacer théoriquement , n’importe laquelle ou toutes , les valeurs d’un prédicat par des variables . 101 CHAPITRE 4 . REPRÉSENTATION DES CONNAISSANCES DE LA MÉTROLOGIE Ainsi , il est théoriquement possible de proposer une requête : is _ va - lid ( mul , < 1 , − 2 > , W , < 1 , 0 > dont l’uniﬁcation substituerait < 0 , 2 > à W . En prenant des d - vecteur < monnaie , longueur > la requête permet de dé - ﬁnir que : c’est avec la surface de panneaux solaires à installer qu’il faut multiplier le prix des panneaux pour une surface donnée , aﬁn d’obtenir le prix de l’installation en résultat . Cependant , l’analyse dimensionnelle manipule des d - vectors . Un d - vectors est un vecteur de nombres entiers . ProLog permet de substituer à une va - riable le résultat d’une opération de calcul de base ( addition , multiplication puissance ) sur des valeurs . Cependant , il n’est pas possible d’uniﬁer une telle opération si l’un des opérandes est une variable . SWI - ProLog propose une librairie qui utilise les concepts de la program - mation logique par contraintes sur les domaines ﬁnis [ 34 ] . Cette librairie permet une uniﬁcation tardive des variables impliquées dans des opéra - tions algébriques . Elle est donc capable de déﬁnir l’ensemble des solutions à un problème algébrique partiellement déﬁni . Par exemple , on pourra trouver tous les résultats positifs inférieur à 10 de la somme 2B + B . Cela peut être réalisé avec par exemple la requête : + ( A , B , R ) ∧− 1 < R ∧ R < 10 ∧ A = 2B . L’uniﬁcation de cette requête substitue à A la valeur B ∗ 2 , à R la valeur A + B et implique que la valeur de R est sur l’intervalle [ 0 , 9 ] . En remplaçant B par 2 , 4 substitue A et 6 substitue R . Ainsi le seul résultat de cette opération est 6 . Il devient donc possible de résoudre des requêtes avec des unités in - connues . Cependant , il existe un nombre inﬁni d’unités correspondant à une dimension . Pour simpliﬁer l’uniﬁcation et spéciﬁer ouvertement qu’une unité n’est pas déﬁnie , nous proposons d’ajouter deux prédicats à la liste de ceux disponibles dans le MKQL : — is _ input _ unknown ( n , p , t ) , avec n un nom , p un port et t une trace , — is _ output _ unknown ( n , p , t ) , avec n un nom , p un port et t une trace . Ces deux prédicats ajoutent à la trace le d - vector qui est contenu par le port . Pour tester la prescription de grandeurs , nous proposons de reprendre la procédure P2 de la section 4 . 4 . 2 . Rappelons que P2 est une procédure complexe qui a pour but de faire intervenir plusieurs opérations ainsi que plusieurs unités , complexes ou non ( cf code 4 . 5 ) . Nous proposons de remplacer tous les agents d’entrées par des agents prescripteurs aux unités inconnues . Les prédicats is _ checked _ input ( n , u , p , t ) du code 4 . 6 sont donc remplacés par des prédicats is _ input _ unkown ( n , p , t ) . L’uniﬁcation de la requête produite est un succès . La trace résultante 102 CHAPITRE 4 . REPRÉSENTATION DES CONNAISSANCES DE LA MÉTROLOGIE afﬁche les d - vectors : < 1 , 0 , 0 > , < 1 , 0 , 0 > et < 0 , 1 , 0 > pour les agents lon - gueur1 , longueur2 et temps . Le système employé étant composé des dimen - sions < longueur , temps , masse > , les agents prescrivent d’employer respec - tivement des unités de longueur , longueur et temps . Ce qui est cohérent avec la procédure de mesure . Il est possible d’obtenir des résultats moins attendus . Par exemple , avec l’opération O i 1 ∗ i 2 = m è tre , avec i1 et i2 des agents prescripteurs , l’uniﬁ - cation substitue les d - vectors < X , Y1 , Z > et < X , Y2 , Y > à i1 et i2 et ajoute la contrainte Y1 + 1 = Y2 . Cette uniﬁcation montre que l’opération O est au - torisée par l’analyse dimensionnelle si et seulement si , les dimensions de longueur et de masse sont identiques et la valeur de la dimension de temps de i1 est supérieure de 1 à celle de i2 . Réduction du champ des possibles Le mécanisme de retour sur trace de ProLog permet de visiter l’en - semble du champ des possibles pour toutes les variables présentes dans une requête . Lors de l’analyse d’une procédure de mesure , plusieurs des étapes de l’analyse peuvent être achevées par des ensembles différents de prédicats . Le retour sur trace peut être inutile dans ces cas . Par exemple , la canonisation d’une unité demande de trouver l’unité de référence corres - pondant à chaque unité qui compose l’expression de l’unité . La transitivité et réciprocité des conversions des unités impliquent qu’il existe potentiel - lement un nombre inﬁni de chemins pour trouver l’unité de référence . Par exemple , l’unité de référence du mile peut être trouvée par les chemins : mile → km → m , mile → yard → m , mile → yard → mile → km → m ou en - core mile → kilomile → milikilomile → kilomilikilomile → etc . . . ProLog propose le mécanisme de contrôle de l’algorithme d’uniﬁcation appelé cut . Placer un cut dans une règle , implique que tous les prédicats à gauche du cut ne doivent pas subir de retour sur trace , à moins que le retour n’implique une substitution déﬁnie avant l’évaluation de la règle . Prenons une procédure de mesure P3 qui implique de mesurer une lon - gueur , une masse puis d’additionner ces deux grandeurs pour calculer un résultat . La longueur et la masse ne peuvent être associés qu’à une unique dimension et une unique échelle de mesure . Cependant , il existe plusieurs chemins de conversions permettant de trouver la dimension de la longueur et de la masse avec leurs unités . Ainsi , non seulement il n’est pas utile d’em - ployer le mécanisme de retour sur trace pour modiﬁer ces résultats , mais ce sera une opération consommatrice de beaucoup de ressources . Aﬁn d’empêcher le retour sur trace de chercher plusieurs solutions pour les entrées de P3 , le code 4 . 7 utilise le prédicat cut . Lors de l’uniﬁcation , les 103 CHAPITRE 4 . REPRÉSENTATION DES CONNAISSANCES DE LA MÉTROLOGIE deux premiers agents vont trouver les dimensions et échelles pour les gran - deurs mesurées . trouver les échelles et les dimensions des unités mètre et gramme . Puis l’agent fonction tentera d’uniﬁer l’opération d’addition sans succès à cause de l’analyse dimensionnelle . Et le retour sur trace qui s’ini - tiera alors sera interrompu par le cut . Ce qui permet de prouver l’échec d’uniﬁcation plus rapidement sans opérations inutiles . Code 4 . 7 Exemple d’utilisation du cut de Prolog pour optimiser la vériﬁca - tion d’une procédure de mesure is _ input ( mètre , P _ longueur ) ^ is _ input ( gramme , P _ masse ) ^ cut ^ is _ function ( add , P _ longueur , P _ masse , P _ resultat ) L’ajout du cut permet de prévenir le retour sur trace de revenir sur les substitutions effectuées en amont . Ainsi , les uniﬁcations des deux premiers agents ne pourront pas être révisées par le retour . L’uniﬁcation sera im - possible avec ou sans le cut . Mais avec le cut , l’algorithme fera face à un ensemble de retours sur trace plus restreint et donc l’uniﬁcation sera opti - misée . Il est cependant à noter que , la transitivité et la réciprocité des conver - sions pourraient potentiellement être utilisées pour décrire l’ensemble des unités qui correspondent à une dimension ; cependant , cet ensemble est in - ﬁni . Il est possible de créer une inﬁnité d’expressions d’unités pour un type de grandeur , simplement en ajoutant une composition puis son inverse . Ce point n’a pas été résolu par ces travaux pour le moment . Les cuts sont donc utilisés dans chaque agent pour éviter un retour sur le résultat proposé à moins que ce ne soit un résultat précédent qui soit revu . 4 . 6 . 2 Conclusion Les différents prédicats et règles qui constituent le MKS viennent d’être présentés . L’intérêt principal de la structure proposée est la décomposition entre le système d’unités qui sert d’espace de raisonnement et l’inférence des analyses et du langage de requêtes . En effet , une fois les analyses encodées , il est possible de vériﬁer une procédure de mesure , du moment que les unités qu’elle contient sont déﬁ - nies . Le MKQL permet de simpliﬁer la déﬁnition des requêtes d’analyses , tout en proposant de remonter des informations sur les potentielles erreurs détectées lors d’une analyse . 104 CHAPITRE 4 . REPRÉSENTATION DES CONNAISSANCES DE LA MÉTROLOGIE Il est possible d’employer un MKS construit avec un système d’unités très restreint tel que celui présenté par le tableau 4 . 2 . Mais il est égale - ment possible d’étendre ce système pour autoriser la modélisation et la vériﬁcation de procédures de mesure dans des domaines plus complexes . L’intérêt étant donc de proposer un système modulaire . Un système d’unités restreint permet une analyse rapide , car le graphe des unités est petit et rapidement parcouru . Un système complexe permet d’exprimer plus de propriétés . L’analyse des échelles permet d’inclure des grandeurs non physiques dans les procédures de mesures . Plutôt que de considérer ces grandeurs comme étant de type sans dimension , le MKS permet de leur attribuer une dimension ( de base ou non ) . Cela induit que des grandeurs comme nombre d’habitants par kilomètre carré et nombre de pots de peinture par déci - mètre carré peuvent être différenciées et donc il ne sera pas possible de les additionner . Il est à noter que les quatre opérations proposées peuvent également être spéciﬁées . En ajoutant une dimension rotation , il sera également pos - sible de différencier le couple mécanique et une énergie ou encore une grandeur sans dimension et un angle . Cependant , un angle est déﬁni comme étant issu de la division de deux longueurs ; il faudra donc spéciﬁer les opé - rations de division et de multiplication pour permettre de prendre correc - tement en charge cette propriété . L’ajout de la règle suivante : is _ valid ( div , l , l , a ) ← is _ length ( v ) ∧ is _ angular ( a ) permet d’augmenter les capacités d’uniﬁcation de l’analyse dimensionnelle pour considérer les rotations . Nous n’avons pas exploré plus en avant cette capacité pour le moment : nos travaux s’étant focalisés sur la création d’un système dédié aux be - soins industriels et non à l’exploration systématique de la métrologie . De la même façon , certains experts [ 78 ] déclarent que les longueurs devraient être exprimées en trois dimensions pour permettre des analyses correctes . En effet , nous assurons que la multiplication de deux longueurs implique une surface . En réalité , ce n’est pas le cas si les deux longueurs sont ali - gnées . Les analyses présentées dans ce document ne permettent que l’utili - sation d’opérations de base . Mais la construction du MKS permet l’ajout d’autres opérations . Celles - ci permettent d’augmenter l’expressivité du MKQL et la précision des analyses . L’approche présentée dans ce chapitre a été validée par la conception d’un système d’unités , compatible avec le SI et étendu avec des dimen - sions et unités hors du SI ainsi qu’avec des dimensions et unités pour des grandeurs non - physiques incluant : les couleurs , les booléens et les notes 105 CHAPITRE 4 . REPRÉSENTATION DES CONNAISSANCES DE LA MÉTROLOGIE d’examens . Les booléens sont particulièrement intéressants . Vus comme le type de grandeur capable de mesurer le résultat d’un choix ou d’une déci - sion , ils permettent d’appliquer l’analyse dimensionnelle aux comparaisons ( opérateurs relationnels ) de grandeurs . Deux grandeurs sont comparables si elles sont du même type et le résultat de cette comparaison est de di - mension booléenne . Les comparaisons sont des opérations très communes pour les procédures de mesure et sont indispensables pour des grandeurs non physiques associées à l’échelle nominale . Ensemble , ces différentes ex - tensions produisent un MKS composé de plus de 200 unités , dimensions et alias qui impliquent des termes français et anglais . Le MKS est donc hautement conﬁgurable . Il est possible de l’utiliser pour de petits systèmes d’unités avec un ensemble d’opérations dédiées à des domaines très spéciﬁques . Mais il peut également proposer un système d’unités et un ensemble d’opérations important , pour des utilisations plus génériques . Toutes les descriptions proposées pour le MKS sont déclara - tives et résolues par uniﬁcation . 106 Chapitre 5 Génie Logiciel pour le développement d’applications d’assistance à la mesure « Simpliﬁer ce n’est pas faire simple . » Arthur Cravan Sommaire 5 . 1 Langage de description d’applications de mesure . . . . 109 5 . 1 . 1 Spéciﬁcations du langage . . . . . . . . . . . . . . . . . . 109 5 . 1 . 2 Interactions et modèles de processus . . . . . . . . . . 110 5 . 1 . 3 Métamodélisation du language de spéciﬁcation . . . . 111 5 . 2 Application d’assistance à la mesure . . . . . . . . . . . . 115 5 . 2 . 1 Choix d’intégration . . . . . . . . . . . . . . . . . . . . . . 115 5 . 2 . 2 Métamodèle . . . . . . . . . . . . . . . . . . . . . . . . . . 116 5 . 2 . 3 Agents d’activités . . . . . . . . . . . . . . . . . . . . . . . 117 5 . 2 . 4 Conﬁguration , construction et exécution . . . . . . . . 120 5 . 3 Intégration des outils dans la plateforme MEASURE . . 124 5 . 3 . 1 La vériﬁcation d’applications . . . . . . . . . . . . . . . . 126 5 . 3 . 2 L’implémentation d’applications . . . . . . . . . . . . . . 128 107 CHAPITRE 5 . GÉNIE LOGICIEL POUR LE DÉVELOPPEMENT D’APPLICATIONS D’ASSISTANCE À LA MESURE Le chapitre précédent a présenté le Metrology Knowledge Schema ( MKS ) , une représentation des connaissances en logique du premier ordre dédiée à la vériﬁcation de la sémantique de la métrologie . Le MKS déﬁnit les dif - férentes contraintes associées à l’utilisation de grandeurs pour assurer la possibilité de réaliser des transpositions correctes vers le monde empirique . De plus , il propose un langage pour la description de procédures de me - sure . Toute procédure exprimée à l’aide de ce langage peut être interpré - tée comme une requête de vériﬁcation de la sémantique de mesure pour le MKS . Le MKS est aussi capable de réaliser des conversions entre toutes les unités d’une même dimension , peu importe leurs formes ( base , alias , composée ) . Cette approche permet donc d’assurer la conformité des procédures de mesure par rapport à la métrologie . Cependant , l’expressivité du langage est limitée à la description de procédures de mesure rudimentaires . Il ne considère pas les besoins liés à la réalisation de la procédure . En effet , un système logiciel permettant d’appliquer ces procédures de mesures né - cessite non seulement la déﬁnition des éléments liés à la métrologie , mais également ceux liés aux interactions avec l’utilisateur et aux séquençages des activités . Ce chapitre propose tout d’abord la description d’un langage de modéli - sation formel qui mélange les éléments de la métrologie , de l’ingénierie des processus et des interfaces utilisateur , le langage de modélisation d’appli - cation d’assistance à la mesure , Measure Application Modelling Language ( MAML ) . Ce langage est dédié à la modélisation d’applications de mesures . Un éditeur capable de générer les modèles exprimés par ce langage est proposé . Ensuite , la conception d’une application conﬁgurable dédiée à la réalisation de procédures de mesure est présentée . Cette application est ca - pable d’adapter son comportement en fonction de la procédure de mesure que l’utilisateur souhaite réaliser . Enﬁn , l’intégration de l’éditeur de mo - dèles , du MKS et de l’application générique au sein d’une approche de dé - veloppement logiciel semi - automatisée et outillée est présentée . Cette ap - proche utilise les concepts de l’ Ingénierie Dirigée par les Modèles ( IDM ) , ou Model Driven Engineering pour utiliser le modèle de l’application comme source à vériﬁer et à implanter . 108 CHAPITRE 5 . GÉNIE LOGICIEL POUR LE DÉVELOPPEMENT D’APPLICATIONS D’ASSISTANCE À LA MESURE 5 . 1 Langage de description d’applications de mesure Les applications de mesure prennent en charge , habituellement auto - matiquement , les calculs impliquant des grandeurs et les déductions qui peuvent en être tirées ( le prix estimé est , le meuble peut être placé à cet em - placement , allumer les radiateurs ) . Cependant , des interventions humaines sont souvent nécessaires en fonction du contexte de la mesure . C’est d’au - tant plus vrai dans un contexte de mobilité qui implique des prises de me - sures non établies sur site . Cela implique des processus évolutifs car les méthodes changent en fonction de l’utilisateur et du contexte de mesure . 5 . 1 . 1 Spéciﬁcations du langage Idéalement une application de mesure devrait assister l’utilisateur pen - dant ses activités de mesure . Ce qui implique de connaitre la séquence des mesures et comment sont réalisées les interactions avec l’utilisateur , ou les différents instruments . Les procédures de mesure que peut exprimer le MKQL dans le chapitre 4 sont des spéciﬁcations des dépendances entre les grandeurs d’entrées , les manipulations des grandeurs et les grandeurs de sorties . Ces spéciﬁcations peuvent être utilisées pour décrire des applications de mesure basiques . Par contre , leurs comportements seraient certainement très éloignés des habitudes de mesure des utilisateurs . Le but du langage de modélisation MAML est de proposer une solution adaptée pour modéliser les applications de mesure . Le MAML permet de modéliser des applications qui assistent les utili - sateurs dans leurs tâches quotidiennes , incluant des activités de mesure . Ces utilisateurs possèdent des instruments dédiés à leurs méthodes de tra - vail et sont habitués à les utiliser . Les applications doivent pouvoir apporter une plus - value à l’utilisateur , tout en évitant de lui demander d’apprendre de nouvelles méthodes ou d’acheter de nouveaux instruments . Pour être acceptées par de potentiels utilisateurs , les applications doivent , en plus d’être correctes , être conﬁgurées spécialement pour chaque utilisateur . Cela implique des interfaces utilisateur intuitives qui permettent d’utili - ser des valeurs issues d’instruments de mesure de l’utilisateur . Les instru - ments de mesure peuvent être de trois types : — fourni par l’utilisateur , les valeurs sont entrées manuellement , sou - vent de manière textuelle , par l’utilisateur en utilisant des éléments d’interface , 109 CHAPITRE 5 . GÉNIE LOGICIEL POUR LE DÉVELOPPEMENT D’APPLICATIONS D’ASSISTANCE À LA MESURE — déclenché par l’utilisateur , les valeurs sont fournies par l’instrument , leur capture est activée par une interaction de l’utilisateur sur l’inter - face , — continue , les valeurs sont fournies en continu par l’instrument . Les applications doivent pouvoir s’adapter au rythme de l’utilisateur et ordonner les activités en fonction de l’utilisateur et des conditions environ - nantes . De plus , dans un contexte de prise de mesures sur site , des notes , des photos , des évènements de calendrier , des schémas peuvent être des informations importantes . Ainsi , le MAML devrait permettre la description de modèles d’applica - tions , composés d’activités de mesure ordonnées , d’interactions utilisateur et de capacités pour relever des informations autres que des grandeurs ; le tout adapté au contexte de la prise de mesures et à l’utilisateur . 5 . 1 . 2 Interactions et modèles de processus Plusieurs formalismes existent pour modéliser , implanter ou exploiter des processus pour les systèmes d’information [ 20 ; 85 ] . Typiquement , les processus opérationnels , ou workﬂows sont des abstractions pour l’automa - tisation de processus . Ils font intervenir plusieurs activités qui traitent tout types de données qui sont ordonnées par des transitions [ 131 ] . Ce sont des abstractions dédiées à la modélisation de processus , qui incluent des inter - actions entre des activités réalisées par des humains et des machines [ 59 ] . Les concepts de base des workﬂows sont des activités , qui traitent des don - nées à l’aide d’ actions ; et des transitions qui autorisent le séquençage d’ac - tivités en fonction de conditions . Les workﬂows sont capables de représenter tout type de processus et sont généralement à un haut niveau d’abstraction . Ils peuvent être spéciali - sés pour modéliser des procédures de mesure . En effet , les actions peuvent modéliser l’automatisation des fonctions de mesure ; les activités et les tran - sitions peuvent quant à elles modéliser l’ordonnancement des mesures . Il est à noté que nous ne considèrerons pas les processus adhoc dans ce docu - ment . En effet , une procédure de mesure nécessite un ensemble de relevés de mesurages ; mais n’impose pas forcément une séquence de ces activités . L’approche proposée impose une séquence des activités . Les Interfaces Humain - Machine ( IHM ) sont généralement construites en utilisant des composants graphiques simples et réutilisables appelés wid - gets [ 113 ] . Des widgets comme des champs de texte , des boutons , des af - ﬁchages d’images , etc . peuvent être assemblés pour constituer des IHM complexes . 110 CHAPITRE 5 . GÉNIE LOGICIEL POUR LE DÉVELOPPEMENT D’APPLICATIONS D’ASSISTANCE À LA MESURE Ainsi , une IHM peut être une vue composée comme un arrangement de plusieurs widgets . Les éléments constituants la vue peuvent être soumis à une mise en page spéciﬁque qui impose leurs positions . Les plateformes mobiles possèdent des écrans relativement petits et leurs IHM sont généra - lement épurées . Habituellement , les interfaces utilisateurs sont fortement dépendantes de la plateforme . Pour s’abstraire de ces dépendances dans le modèle , tout élément d’interface est un interactor . Les interactors sont composés pour construire des vues . Ils permettent des interactions en pro - venance de l’utilisateur et de capteurs . Ce sont les points d’entrée des in - teractions . Charge à l’application , dépendante de la plateforme , de déﬁnir les règles d’agencement et l’aspect des interactors . 5 . 1 . 3 Métamodélisation du language de spéciﬁcation L’IDM permet de représenter la structure et le comportement des sys - tèmes avec des modèles ( cf section 3 . 4 ) . La création d’un DSL est une ac - tivité de métamodélisation nécéssitant l’usage d’un environement de méta - modélisation . Le language MAML est formalisé avec le Diagrammatic Pre - dicate Framework ( DPF ) workbench [ 72 ; 110 ] . Pour présenter les différents métamodèles en respectant les capacités de métamodélisation à plusieurs niveaux de DPF , la convention suivante est adoptée . Un niveau Ni , contient un modèle Mi . Mi peut être utilisé comme métamodèle pour la génération d’un language de modélisation LMi . La gé - nération d’un LMi crée également un éditeur Ei . Un Ei permet de décrire des modèles Mi - 1 ; conformes au Mi , qui appartiennent donc au niveau Ni - 1 . L’architecture de métamodélisation du MAML est composée des modèles suivants : — M4 est le métamodèle de DPF , proposé par défaut par le workbench , il est autodescriptif , — M3 est le ( méta ) modèle utilisé pour décrire des processus interactifs , — M2 instancie M3 pour ajouter les entités spéciﬁques aux procédures de mesure . M2 est le modèle qui déﬁnit le MAML , — M1 est un modèle d’une application de mesure spéciﬁque , — M0 est la description de l’application qui assiste un utilisateur . Métamodèle pour les processus intéractifs Le métamodèle M3 combine des concepts issus des workﬂows [ 85 ] et ceux des interactions décrites dans la section 5 . 1 . 2 . À ce niveau d’abstrac - 111 CHAPITRE 5 . GÉNIE LOGICIEL POUR LE DÉVELOPPEMENT D’APPLICATIONS D’ASSISTANCE À LA MESURE tion , les procédures de mesure ne sont pas représentées . Elles seront mises en place par une spécialisation de M3 . La ﬁgure 5 . 1 représente le M3 et ses relations avec le M4 . Conformément à DPF , le DPF Metamodel ( M4 ) est utilisé comme méta - modèle décrivant le LM4 qui permet de décrire M3 . Ainsi il y a une relation entre chaque élément de M4 et l’un de ceux disponibles sur M3 . Ces re - lations apparaissent sur le diagramme comme : Node ou : arrow . Elles sont omises quand elles sont évidentes . Le même principe est appliqué pour les ( méta ) modèles des niveaux inférieurs , qui sont décrits ultérieurement . Pour tous les liens qui ne présentent pas de multiplicité ; c’est la multiplicité " ∗ " qui est sous entendue . Un lien avec plusieurs noms sous - entend l’existence de plusieurs liens identiques . Ils ne sont pas afﬁchés par souci de clarté du diagramme . Les transitions entre les activités peuvent être gardées par des condi - tions . Chaque activité est conﬁgurée comme une séquence d’actions . Les actions peuvent être déclenchées par des conditions . Le pont , entre les concepts de processus et ceux des interactions , est abstrait par les évé - nements qui sont notiﬁés par les interactions . Métamodèle du MAML Le M2 instancie M3 pour apporter les différents types de données , les concepts de la métrologie , des workﬂows plus évolués , des éléments inter - actifs , etc . Un extrait du M2 est présenté ﬁgure 5 . 2 , pour illustrer comment cette instanciation est réalisée . Par exemple , le concept de données Data , intro - duit par M3 est employé pour obtenir les nouveaux concepts nombre ( Num - ber ) , grandeur Quantity et texte Text . Les grandeurs possèdent deux membres ; l’unité et la valeur de la gran - deur . L’entité " : Data " présente sur le modèle implique que toutes les ins - tances de données peuvent être utilisées par une opération de comparaison ( Comparison ) . Les interactors sont spécialisés pour obtenir des afﬁchages de données ( Display ) , des instruments de mesure de type déclenché par l’utilisateur ( user - trigger Sensors ) , et des boutons pour déclencher des évènements : ( Button ) . D’autres interactors , plus évolués peuvent être proposés . Des interac - tors qui afﬁchent des images , prennent des photos , permettent de dessiner , de sélectionner une valeur parmi plusieurs , etc . Ceux - ci permettent de pro - poser de meilleures interactions avec l’utilisateur ; ce qui améliorera son expérience . 112 CHAPITRE 5 . GÉNIE LOGICIEL POUR LE DÉVELOPPEMENT D’APPLICATIONS D’ASSISTANCE À LA MESURE Les actions sont utilisées pour déﬁnir les comportements autonomes de l’application . Ils manipulent , mettent à jour les données et automatisent les relevés d’instruments de mesure . La ﬁgure 5 . 2 montre comment les manipulations de données peuvent être associées , soit à des grandeurs , soit à des valeurs . Le lien en pointillés associé à un XOR est une contrainte DPF qui assure que a1 , a2 et a3 sont tous de type Number ou Quantity pour une instance de DataManipulation . Le lien " then " introduit par M3 permet de chainer les actions . Pour déﬁnir le début d’une chaîne d’actions , une action Start est pro - posée . Ces actions détiennent une référence vers une condition Control et vers la première des actions à réaliser . Une fois la condition remplie , la chaîne d’action est évaluée . Des structures de contrôle plus complexes ( boucle , réalisation conditionnelle , synchronisation ) peuvent être ajoutées . Notez que le M2 présenté propose des modèles pour des instruments de mesure ( UserTriggerSensor , GyroscopePolling ) , des fonctions de mesure ( DataManipulation , Comparison ) et des instruments indicateurs ( Display ) . L’ensemble permet à l’architecte de modéliser des procédures de mesure à l’aide d’entités proches du vocabulaire de l’utilisateur . En effet , l’extrait présenté ne montre qu’un instrument de mesure spéciﬁque , le gyroscope . Mais en augmentant le nombre d’entités spéciﬁques , il sera possible de pro - poser des modélisations ad hoc pour chaque instrument proposé par l’uti - lisateur . Ce qui diminuera grandement la compréhension mutuelle entre l’architecte logiciel et l’utilisateur de l’application . Le UserTriggerSensor modélise un instrument de mesure générique . Le paramètre type permet optionnellement de spéciﬁer l’instrument employé . Cette spéciﬁcation per - met d’augmenter la connaissance des instruments intervenant dans la pro - cédure ( cf section 5 . 3 ) . Le M2 est utilisé comme un métamodèle dans le DPF workbench pour créer le langage de modélisation LM2 et l’éditeur associé . ML2 est capable de modéliser toutes applications impliquant des procédures de mesures . Il est donc appelé le langage de modélisation d’application d’assistance à la mesure , Measure Application Modelling Language ( MAML ) . La ﬁgure 5 . 3 montre un exemple de modèle décrit avec les concepts introduits par M2 . Le modèle montre une activité qui active une action réalisant la mise à jour d’une grandeur angulaire . La valeur de cette grandeur est comparée à zéro pour déﬁnir si la garde de la transition est validée et permet d’enchainer sur une autre activité . Un instrument de mesure déclenché par l’utilisateur est également présent . Il permet de mesurer une longueur en utilisant un capteur de distance laser . Le MAML présenté est généré à partir de la conﬁguration essentielle de M2 . Il est possible d’ajouter plus d’entités spéciﬁques au M2 pour augmen - 113 CHAPITRE 5 . GÉNIE LOGICIEL POUR LE DÉVELOPPEMENT D’APPLICATIONS D’ASSISTANCE À LA MESURE Node arrow M4 M3 Transition Activity post 1 . . 1 pre 1 . . 1 Event : Node event Condition enabler guard Action : Node action then trigger : arrow View Data Interactor member view 1 . . 1 interactor notiﬁcation argument : arrow content 1 . . 1 factor : arrow Process activityinitial1 . . 1 transition 0 . . 1 is a is a is a is a Figure 5 . 1 – Métamodèle pour les processus intéractifs ( M3 ) . La plupart des rela - tions entre les entités du M3 et du M4 étant évidentes , elles sont omises . : Data Text : Data Display : Interactor text : content data : content Quantity : Data DataManipulation : Action op : argument a1 : argument a2 : argument a3 : argument 1 . . 1 1 . . 1 1 . . 1 Number : Data 1 . . 1 1 . . 1 0 . . 1 XOR UserTriggerSensor : Interactor text : content 0 . . 1 type : content 0 . . 1 quantity : content 1 . . 1 Comparison : Condition op : factor 1 . . 1 Button : Interactor GyroscopePolling : Action phi : argument theta : argument psi : argument 0 . . 1 0 . . 1 0 . . 1 text : content 0 . . 1 : notification 1 . . 1 UserInteraction : Event Control : Condition : enabler 0 . . 1 Unit : Data 1 . . 1 unit : member value : member 1 . . 1 M2 right : factor left : factor 1 . . 1 1 . . 1 Figure 5 . 2 – Extrait du métamodèle du MAML décrit en utilisant le M3 : left : GyroscopePolling roof _ angle : Quantity degree : Unit : Number is _ plane : Comparison equals : Text : Transition 0 : Value : right : op leveling : Activity : psi : action : pre do _ if _ plane : Activity : post : guard width _ instrument : UserTriggerSensor roof width : Text laser tape : Text width _ port : Quantity : type M1 Figure 5 . 3 – Extrait d’un modèle décrit avec le MAML 114 CHAPITRE 5 . GÉNIE LOGICIEL POUR LE DÉVELOPPEMENT D’APPLICATIONS D’ASSISTANCE À LA MESURE ter l’expressivité du MAML . Cela augmenterait encore plus la compréhen - sion entre l’utilisateur et l’architecte logiciel . 5 . 2 Application d’assistance à la mesure Une application d’assistance à la mesure permet à un utilisateur de réa - liser une procédure de mesure . Cette procédure dépend du domaine , des activités et des buts de l’utilisateur . Le but de cette section est de propo - ser une approche permettant l’implantation de ces applications dans une plateforme mobile . 5 . 2 . 1 Choix d’intégration Pour proposer un système qui répond aux besoins spéciﬁques de chaque utilisateur il existe plusieurs alternatives : 1 . proposer une application qui ne fournit que des interfaces pour utiliser des instruments de mesure ; 2 . proposer une nouvelle application pour chaque procédure de mesure ; 3 . proposer une application capable de conﬁgurer son comportement . La solution ( 1 ) est la plus simple à réaliser . Mais c’est également la solu - tion qui présente le moins de plus - value . Le système remplacerait au mieux un bloc note sur lequel les mesures sont notées avant de réaliser un traite - ment ultérieur . Les solutions ( 2 ) et ( 3 ) présentent toutes deux des capacités équiva - lentes pour répondre aux besoins des utilisateurs . ( 2 ) a l’avantage d’être une solution ad hoc pour un problème donné . Elle sera donc potentiellement optimisée ( taille mémoire , vitesse de calculs ) pour répondre à ce problème . Par contre la génération et le déploiement d’une telle solution pour chaque procédure de mesure est plus difﬁcile qu’avec la solution ( 3 ) . ( 3 ) est une application plus complexe et plus consommatrice de res - sources . Elle doit contenir tous les éléments qui pourraient être utilisés dans toutes les procédures de mesure . Le fait de réaliser un comporte - ment spéciﬁque parmi un ensemble implique également des mécanismes de conﬁguration et peut être d’animation de l’ensemble des éléments permet - tant la réalisation d’une procédure . Ces deux mécanismes ont également un coût mémoire et peut être en performances sur le système . 115 CHAPITRE 5 . GÉNIE LOGICIEL POUR LE DÉVELOPPEMENT D’APPLICATIONS D’ASSISTANCE À LA MESURE D’un autre côté , ( 3 ) est capable de proposer une bibliothèque de procé - dures de mesures . De plus , une nouvelle conﬁguration est facile à ajouter au système . Il sufﬁt de lui transmettre la description de celle - ci . Pour les solutions ( 2 ) ou ( 3 ) , il est possible de proposer une génération automatique à partir d’un modèle d’application ( c . f . section 5 . 3 ) . Ces travaux présentent une implantation sous la forme de la solution ( 3 ) . Cette solution est plus proche des canons actuels des applications pour plateformes mobiles . En effet , il sera possible de rendre disponible l’appli - cation et un certain nombre de procédures de mesure gracieusement tout en valorisant , selon la politique de l’entreprise , des activités de création de procédures faites sur mesure . 5 . 2 . 2 Métamodèle Framework employé Les agents permettent d’abstraire la complexité d’un système logiciel . Chaque agent réalise une tâche unitaire de manière autonome 3 . 2 . L’utilisation d’un ensemble d’agents logiciels permet une grande modu - larité et permet une cohérence dans le formalisme employé sur l’ensemble de ces travaux . Aux agents logiciels s’ajoute un ensemble d’objets organi - sationnels permettant de prendre en charge les séquences d’activités et les transitions . Le système d’agents utilisé est dérivé de celui du framework PI [ 98 ] . Le framework est initialement conçu pour le pilotage en temps réel de sys - tèmes automatisés . Ce pilotage est réalisé à l’aide d’agents , de leurs com - portements et de leurs interactions . PI propose un ensemble de concepts et une sémantique de réalisation qui permettent de prendre en charge les aspects structurels et compor - tementaux . Les aspect comportementaux sont décrit par des évènements d’une par asynchrone et d’autre part synchrone . Ces aspects sont néces - saires pour la déﬁnition de la structure de l’application , l’évolution des sé - quences d’activités de mesure et la gestion des instruments . En utilisant PI nous assurons la réactivité du système et son évolution . L’ensemble des éléments de l’application de mesure sont des dérivés des agents proposés par PI . Agents de mesures La ﬁgure 5 . 4 montre la structure qui permet de modéliser les instru - ments de mesure , les fonctions de mesure et les instruments indicateurs . 116 CHAPITRE 5 . GÉNIE LOGICIEL POUR LE DÉVELOPPEMENT D’APPLICATIONS D’ASSISTANCE À LA MESURE M _ Agent < interface > ContinuousAgent Interactor Processor Conversion 0 . . 1 GUIInteractor View Port 1 * ComInteractor 1 0 . . 1 ComInterface * guards 0 . . 1 enable GardedPort Figure 5 . 4 – Spécialisation des agents continus de PI pour l’application de mesure . Les M _ agents peuvent être vus comme un ensemble d’agents continus dont l’évolution est provoquée séquentiellement par le mécanisme de ges - tion d’évenements ( société d’agents ) . Leurs comportement est réalisé en deux temps : — analyse du contexte et mise à jour des sorties . — analyse du contexte et mise à jour interne , Les Interactors permettent de prendre en charge les interactions avec le monde extérieur . Ils sont utilisés pour recevoir ou afﬁcher une grandeur sous la forme désirée par l’utilisateur . Les GUIInteractor gèrent des ins - truments fournis par l’utilisateur à l’aide d’une vue . Les ComInteractors prennent en charge des instruments déclenchés par l’utilisateur ou conti - nues en employant des interfaces de communications . Ils peuvent égale - ment proposer des retours à l’utilisateur à l’aide d’interfaces . Les Processors permettent de modéliser les différentes actions à réali - ser lors des activités . Notez que , contrairement aux actions des modèles d’application , il n’y a pas de liens entre eux . Cette relation n’est pas néces - saire puisque les agents continus actifs du système évoluent tous sur ordre de la société . L’évolution de chacun des processors est contrainte par une ou des gardes ( guards ) . Lorsqu’il met à jour ses sorties , un processor le signale grâce au port enable qui servira de garde pour d’autres agents . Ce méca - nisme permet de n’évaluer une fonction de mesure que lorsqu’elle le néces - site . 117 CHAPITRE 5 . GÉNIE LOGICIEL POUR LE DÉVELOPPEMENT D’APPLICATIONS D’ASSISTANCE À LA MESURE 5 . 2 . 3 Agents d’activités Les systèmes d’activités et de transition de la procédure de mesure per - mettent de guider l’utilisateur en limitant les informations à sa disposition et en contraignant son évolution dans la procédure [ 98 ] . La ﬁgure 5 . 5 pré - sente les entités qui jouent ce rôle pour l’application mobile A _ Agent < interface > DiscreteAgent Transition * Guard 1 . . * Port 1 . . * M _ Interactor * M _ Processor * to Figure 5 . 5 – Spécialisation des agents discrets de PI pour la réalisation d’un sé - quençage d’activités . Chaque activité est représentée par un agent A _ Agent qui est un agent discret . Les agents discrets sont évalués entre chaque évolution des agents continus . Lors de l’évaluation d’un A _ Agent , il considère toutes les transi - tions qui peuvent mener à des activités suivantes . Si toutes les gardes d’une transition sont valides , alors la transition est passante et l’activité courante du système devient inactive et c’est l’activité suivante ( to ) qui devient ac - tive . L’ensemble des M _ Agent contenu par une activité est l’ensemble des agents qui sont actifs pendant cette activité . Seuls les agents actifs évoluent dans le temps . Organisation des agents pour les vues Chaque activité peut présenter une vue à l’utilisateur pour : le guider , entrer des mesures , activer des mesurages , passer à d’autres activités . La vue associée à une activité est issue de la combinaison des différentes vues que ses Interactors proposent . La structure composée générée est proche de celle d’un modèle PAC ( Présentation , Abstraction , Contrôle ) [ 26 ] . La présentation de l’activité est représentée par la combinaison de toutes les présentations des sous - vues , auxquelles sont appliquées des contraintes de positions et de tailles . Il n’y a pas d’abstractions à ce niveau . Le contrôleur est la société d’agents qui aura pour but de faire évoluer les agents de l’activité . Les M _ Agents de l’activité sont des contrôleurs locaux . La présentation est une abstraction des vues ou interfaces de communication qu’ils pos - 118 CHAPITRE 5 . GÉNIE LOGICIEL POUR LE DÉVELOPPEMENT D’APPLICATIONS D’ASSISTANCE À LA MESURE sèdent . Ces présentations devront soit être mises à jour ou serviront de média d’informations en fonction de l’agent ( instrument de mesure ou indi - cateur ) . L’abstraction avec laquelle le contrôleur interagit est l’association des ports de communications donnant sur l’extérieur de l’agent ainsi que des éléments internes à l’agent . La ﬁgure 5 . 6 schématise cette architecture ainsi qu’une vue d’applica - tion résultante potentielle . L’activité présentée propose d’entrer manuelle - ment une surface à peindre puis de récupérer le prix d’une peinture par web - service et afﬁche le prix pour recouvrir la surface déﬁnie . Un bouton permet de terminer l’activité . Name : area a : UserSupplied name : area : UserSupplied value : 10000000 areaP : QPort ratio : 1000000 : RatioConvert text : 10 unit : km ^ 2 : TextField : WebService value : 3 unit : euro / m ^ 2 pPrice : QPort : RequestURL url : price . de request : paint name : total price : Display value : 30000000 totPrice : QPort ratio : 0 . 001 : RatioConvert ratio : 1 : RatioConvert : Activity text : 30000 unit : kiloeuro : TextField name : validate : Button value : false validateP : EPort text : validate validateP : EPort A A P A A A A A A P P C C C C Figure 5 . 6 – Structure PAC pour la gestion des vues de chaque activités . Notez que pour l’accès à des services web , capteurs communicants et autres utilisation des ComInteractor , nous considérons le modèle distant comme une présentation . Nous nous permettons ce raccourcis car c’est par le biais de cette communication que le contrôleur pourra accéder au monde extérieur à l’application . Cet accès permet de lire ou fournir des données à distance , tout comme une vue le fait localement sur l’écran de la plateforme . Prise en charge des unités L’utilisation d’unités dans les différents agents Processors demanderait : — de transmettre des grandeurs dans toute l’application , — d’adapter l’opération appliquée en fonction des unités d’entrées , — de déﬁnir la ou les conversions à chaque opération . L’avantage de ce procédé serait qu’avec un algorithme adapté , il serait possible de visiter la procédure de mesure dans sa globalité pour déﬁnir avec exactitude les opérations de conversion . Cela pourrait éviter certaines 119 CHAPITRE 5 . GÉNIE LOGICIEL POUR LE DÉVELOPPEMENT D’APPLICATIONS D’ASSISTANCE À LA MESURE conversions inutiles que notre approche implique . Mais en contrepartie , le système serait plus complexe à réaliser . Plutôt que de complexiﬁer la structure des différentes manipulations des grandeurs , nous proposons une approche d’homogénéisation des grandeurs dans le système . Pour cela , toutes les grandeurs , lorsqu’elles entrent dans l’application , sont converties automatiquement vers une unité de référence . Ainsi , comme l’illustre la ﬁgure 5 . 7 l’application , d’un point de vue mé - trologique , peut être vue comme un ensemble de processors qui manipulent les données , qui sont mesurées ou indiquées par des interactors . Ces inter - actors sont en relation directe avec différents matériels qui utilisent diffé - rents formalismes de communication et encodages des grandeurs . 1 2 GPS boussole Caméra FichierWebService TexteButtonDroplist Application Processors Interactors Interactors Actionneur Automate FichierWebServiceImprimante Ecran lit écrit écrit lit Figure 5 . 7 – Vue abstraite de l’extérieur de l’application . Les unités sont considé - rées comme homogénéisées dans l’application et doivent être traduites aux entrées et sorties du système . Les Interactors jouent le rôle de traducteur . Ils capturent les données provenant du monde mesuré , les formalisent pour qu’elles correspondent au formalisme et à la synchronisation de l’application . Ils peuvent donc éga - lement prendre en charge la conversion des unités qui interviennent dans le système . Les opérations de conversion sont simples dans le sens ou elles doivent toutes avoir le même rôle . Pour les interactors en entrée , conver - tir une grandeur en une grandeur équivalente déﬁnie à l’aide d’une unité de référence . Pour les interactors en sortie , convertir une référence vers l’unité désirée pour la communication . 5 . 2 . 4 Conﬁguration , construction et exécution L’application est capable d’assembler un ensemble d’agents qui colla - borent pour réaliser une procédure de mesure . Il faut maintenant que l’application puisse réaliser la procédure de me - sure d’un utilisateur . Pour cela , il faut être en mesure de décrire la conﬁ - 120 CHAPITRE 5 . GÉNIE LOGICIEL POUR LE DÉVELOPPEMENT D’APPLICATIONS D’ASSISTANCE À LA MESURE guration des agents ; il faut pouvoir la construire et il faut faire évoluer les agents dans le temps . La conﬁguration d’une application peut être décrite par un modèle . Ce modèle sera nommé modèle d’implantation . Le modèle d’implantation représente l’assemblage des éléments d’une conﬁguration de l’application . Le langage de modélisation correspondant est nommé le langage pour la description de conﬁguration d’application de mesure , ou Executable Mea - surement Application Model Language ( EMAML ) . Il décrit l’ensemble des conﬁgurations d’agents qui peuvent être instanciés par l’application . Sa syntaxe est donc fortement dépendante des capacités de l’application lo - gicielle . La ﬁgure 5 . 8 présente le métamodèle du EMAML . insouts * * name : Text Activity name : Text Transition name : Text type : Text Guard name : Text value : Value Port name : Text type : Text M _ Agent Value zero 0 . . 1 ratio 0 . . 1 agents * transitions * to 1 1 . . * ports * Process activitiesﬁrst * 1 Text texts * Figure 5 . 8 – Métamodèle représentant le langage EMAML Rappelons que l’avantage des agents réside en leur capacité à fonction - ner indépendamment les uns des autres . Un agent réalisant une addition ne se préoccupe pas de ce qui a produit les valeurs de ses opérandes , il a seulement besoin qu’elles existent . La conﬁguration de l’application peut donc être créée en décrivant les entités présentes dans le système puis les relations qui les lient . C’est la structure générée par ces relations qui va permettre de faire évoluer dans un ordre précis l’ensemble des agents . Le code 5 . 1 présente sous forme d’expressions EBNF la syntaxe d’un langage EMAML basique . Le but de cette syntaxe est d’être la plus générique possible aﬁn d’auto - riser simplement l’ajout de nouvelles phrases en fonction des éléments pré - sents dans l’application . Avec la syntaxe présenté il est possible de générer un ensemble d’entités de bases , en décrivant leurs types et les relations de compositions . Les éléments superTyped permettent de spéciﬁer le type de l’entité à créer . Notez que les conﬁgurations d’applications seront générées automa - 121 CHAPITRE 5 . GÉNIE LOGICIEL POUR LE DÉVELOPPEMENT D’APPLICATIONS D’ASSISTANCE À LA MESURE Code 5 . 1 Description de la syntaxe d’un EMAML basique sous forme d’ex - pressions EBNF . < conf > : : = [ < create > ] + / / / / / [ < configure > ] + / / / / / < first > < create > : : = [ < super > | < superTyped > ] < name > ; < configure > : : = < set > | < add > ; < set > : : = set ( < name > , < name > , < param > ) < add > : : = add ( < name > , < name > , < param > ) < first > : : = < name > ; < super > : : = Activity | Port | Transition < superTyped > : : = [ M _ Agent Gyro ] | [ M _ Agent LaserTape ] | [ Guard Equal ] | [ Guard Smaller ] < param > : : = < val > | < text > < name > : : = < text > < text > : : = [ " a " - " Z " | " _ " ] * tiquement ( cf section 5 . 3 ) . Il n’est donc pas essentiel de contraindre les entités qui peuvent composées les superTyped . < superTyped > : : = < name > < name > pourrait , dans ce cas , remplacer les spéciﬁcités déclarées dans l’EMAML présenté . La phrase set sert à déﬁnir la valeur d’un paramètre d’une entité . set ( gyro psi roofAngle ) , par exemple , permet de déﬁnir le port qui recevra les valeurs de l’angle psi d’un M _ agent nommé gyro . La phrase add permet d’ajouter une entité à une liste de paramètres d’une entité . Comme par exemple une transition à une activité ﬁrst indique l’activité active au démarrage de la procédure de mesure . Il faudra donc l’indiquer à la société d’agents comme telle . Attention , de par sa généricité , cette syntaxe autorise un grand nombre de phrases qui seront sémantiquement incorrectes pour l’application . set ( activity , psi , port ) est une phrase correcte pour le EMAML . Cependant elle n’a aucun sens du point de vue de la conﬁguration de l’application . Le but ici n’étant pas de proposer un langage exhaustif pour les conﬁgura - tions d’applications mais un moyen de communiquer des conﬁgurations qui seront générées à l’application . Aﬁn d’illustrer l’utilisation du EMAML , le code 5 . 2 présente la descrip - tion des entités présentes dans la partie gauche de la ﬁgure 5 . 3 . Rappelons que cet extrait de la ﬁgure représente deux activités de mesures leveling et 122 CHAPITRE 5 . GÉNIE LOGICIEL POUR LE DÉVELOPPEMENT D’APPLICATIONS D’ASSISTANCE À LA MESURE do _ if _ plane liées par une transition conditionnelle . L’activité leveling em - ploie un gyroscope embarqué pour mesurer l’angle de la surface sur la - quelle est posé le mobile . Lorsque cet angle est nul , la transition est valide , ce qui déclenche l’activation de l’activité suivante . Code 5 . 2 Description des entités de la ﬁgure 5 . 3 à l’aide du EMAML . Activity leveling ; Activity do _ if _ plane ; M _ Agent Gyro gyro ; QPort roofAngle ; QPort zero ; Transition t ; Guard Equal is _ plane ; / / / / / set ( gyro , dispName , 1 ) ; set ( gyro , ratio , 1 ) ; set ( gyro , zero , 275 ) ; set ( gyro , psi , roofAngle ) ; set ( is _ plane , right , roofAngle ) ; set ( is _ plane , left , zero ) ; set ( zero , value , 0 ) ; add ( leveling , transitions , t ) ; set ( t , next , do _ if _ plane ; add ( t , guards , is _ plane ) ; / / / / / t . add ( do _ if _ plane ) ; t . add ( is _ plane ) ; leveling . add ( t ) ; / / / / / leveling ; Notez la similarité entre les modèles décrits par MAML et EMAML . Bien que certaines relations ne soient plus présentes ( unités ) La conﬁguration représente les entités et les relations entre ces entités pour un système logiciel . L’application doit être capable de recevoir ces conﬁgurations , de les interpréter et de les exécuter . Pour envoyer la conﬁguration à l’application , différents systèmes existent . Elle peut être implantée directement dans l’application à la compilation , stockée dans la plateforme et cherchée à partir d’un explorateur de ﬁchiers ou transmise par un webservice . Une fois que l’application possède la conﬁguration , elle doit l’interpré - ter . La sémantique associée aux différentes structures du EMAML est simple . 123 CHAPITRE 5 . GÉNIE LOGICIEL POUR LE DÉVELOPPEMENT D’APPLICATIONS D’ASSISTANCE À LA MESURE Toutes les entités create sont des appels pour créer une nouvelle entité . Cela implique de créer l’entité et à l’ajouter à une liste qui gardera en mé - moire toutes les entités de la conﬁguration . Une fois que l’application a interprété la conﬁguration , elle peut réaliser la procédure de mesure qui en découle . Pour cela , le moteur d’exécution associé au framework PI est employé . Ce moteur permet de prendre un ensemble d’agents et de les faire évoluer dans le temps . La différence avec les applications du framework PI d’origine [ 98 ] est que l’application est séparée en un ensemble d’agents actifs et un ensemble d’agents inactifs . En effet , tous les agents de la conﬁguration sont paramè - trés lors de son interprétation . Ils existent donc tous dans l’application à tout moment de son évolution . Lorsqu’une activité est activée , tous les agents la constituant se voient ajoutés à l’ensemble des agents actifs . Lorsque l’activité est désactivée , tous ses agents sont inactifs . Seuls les agents actifs évoluent dans le temps à l’aide du moteur d’exécution . L’application mobile étant présentée et ses capacités d’adaptation à une conﬁguration précise présentées , tous les outils de la plateforme MEASURE ( cf . ﬁgure 1 . 2 ) ont été présentés . Il faut maintenant permettre de les utiliser dans un même processus de développement . 5 . 3 Intégration des outils dans la plateforme MEASURE Le MAML permet à un non expert en métrologie de modéliser des ap - plications de mesure , correspondant à une description du comportement espéré par l’utilisateur . Les métamodèles , comme M2 , décrivent souvent seulement la syntaxe abstraite d’un langage de modélisation . Ainsi , même si la déﬁnition de M2 assure la production de modèles corrects d’un point de vue syntaxique ou architectural , leur sémantique a besoin d’être déﬁnie et vériﬁée . En effet , les modèles d’applications de mesure sont vraisemblable - ment sujets aux erreurs du point de vue de la sémantique de la métrologie . Le chapitre 4 a présenté une approche pour vériﬁer les procédures de mesure à l’aide de requêtes de vériﬁcation . Les requêtes sont des abs - tractions qui peuvent être extraites des modèles d’applications . Plus pré - cisément , les modèles d’applications sont des modèles opérationnels qui contiennent des activités , des chaînes d’actions , des conditions , des évène - ments , etc . Les requêtes de vériﬁcation sont des modèles déclaratifs qui 124 CHAPITRE 5 . GÉNIE LOGICIEL POUR LE DÉVELOPPEMENT D’APPLICATIONS D’ASSISTANCE À LA MESURE décrivent les relations entre les quantités . Transformer un modèle d’appli - cation en requête de vériﬁcation implique de supprimer les aspects opéra - tionnels . Il faut également apporter la sémantique applicative à ces modèles . Sous leur forme actuelle , les interactions avec le monde extérieur ( afﬁchage de valeurs , communication avec les instruments , etc ) sont seulement énumé - rées ( il y a des instruments de mesure , indicateurs ) . Les éléments liés à l’application manquent : comment une vue afﬁche les interactors ? qu’est - ce qui permet de faire évoluer le système ? La section précédente a proposé un système logiciel capable de construire son comportement à partir de la description d’un processus à réaliser appe - lée modèle d’implantation . Ce système interprète le modèle , instancie la po - pulation d’entités logicielles correspondante et la fait évoluer dans le temps pour réaliser un comportement qui répond aux besoins de l’utilisateur . Le modèle d’implantation ne s’embarrasse pas des notions de grandeur . En ef - fet , la procédure de mesure réalisée est considérée correcte , la gestion des unités est homogénéisée par des conversions décrites dans le modèle et les instruments ne sont que des médias qui fournissent ( ou reçoivent ) des in - formations de l’application . Transformer un modèle d’application en modèle d’implantation implique de supprimer les aspects liés à la métrologie . La suite de cette section va présenter les deux transformations de mo - dèle M2VQ et M2APP qui permettent de transformer un modèle d’applica - tion en respectivement , une requête de vériﬁcation et un modèle d’implan - tation . 5 . 3 . 1 La vériﬁcation d’applications Transformation en requêtes de vériﬁcation Le MAML implique une construction syntaxiquement correcte des mo - dèles . Ils sont transformés en requête de vériﬁcation , pour déﬁnir et vériﬁer leurs sens [ 56 ] dans le domaine sémantique de la métrologie . Ces requêtes sont déﬁnie par le Measurement Knowledge Query Language ( MKQL ) qui a été décrit dans le chapitre 4 . Comme le présente la ﬁgure 1 . 2 , un extracteur de requêtes , nommé le Model to Veriﬁcation Query ( M2VQ ) , génère des requêtes de vériﬁcation qui sont vériﬁées par le vériﬁcateur de conformité qu’est le MKS . Bien qu’ils génèrent des modèles aux buts différents , les langages MAML et MKQL décrivent des procédures de mesure et les deux sont dérivés du modèle conceptuel ( MCM ) présenté . Ainsi , une déﬁnition de transformation utilisant les métamodèles de ces langages , respectivement M2 et le MKS , 125 CHAPITRE 5 . GÉNIE LOGICIEL POUR LE DÉVELOPPEMENT D’APPLICATIONS D’ASSISTANCE À LA MESURE peut être déﬁnie ( ﬁgure 5 . 9 ) . MAML M2 Modèle d’Application conforme à déﬁnit appartient à M2VQ MKS Requête de Vériﬁcation conceptssource conceptsdestination conforme à MKQL déﬁnit appartient à Application de mesure modèle de modèle vériﬁable de M2 M1 M0 Figure 5 . 9 – Transformation du modèle d’application à la requête de vériﬁcation . Le MKQL est un langage déclaratif dont la syntaxe est textuelle . Cela implique que la transformation vers une requête de vériﬁcation est un mo - dèle vers texte , ou Model to Text ( M2T ) . L’automatisation de cette transfor - mation assure , en plus d’autres avantages , la qualité et la consistence du résultat produit [ 110 ] . Déﬁnition de la transformation Les métamodèles source et destination partagent des concepts issus du MCM . Pour chaque languages , ces concepts sont spécialisés pour le rôle spéciﬁque qui leur est attribué ( modéliser , vériﬁer , appliquer ) . Quand les métamodèles de la source et de la destination partagent un concept du MCM , une relation doit être déﬁnie . Les interactors représentant des instruments de mesure du M2 , les ac - tions représentant des instruments de mesure , les interactors qui déﬁnissent des grandeurs et les grandeurs constantes sont tous liés au concept d’ins - trument de mesure . Ce concept est abstrait par le prédicat is _ checked _ in - put du MKS . Les interactors d’afﬁchage sont liées au concept d’instrument indicateur . Ce concept est abstrait par le prédicat is _ checked _ output . Les actions de manipulation de données qui traitent des grandeurs sont liés au concept de fonction de mesure . Ce concept est abstrait par le prédicat is _ checked _ function . Certaines grandeurs du modèle M2 peuvent contenir des unités pres - crites . Elles apportent des informations sur les grandeurs espérées pour cette grandeur précise . Elles devraient donc apparaitre dans la déﬁnition de la transformation . L’intérêt étant la création de requêtes les plus précises possible . Toutes ces grandeurs peuvent être abstraites par des prédicats is _ checked _ input ou is _ checked _ output . Rappelons que ces deux prédicats sont essentiels à l’application des analyses de la métrologie . Ils sont la tête 126 CHAPITRE 5 . GÉNIE LOGICIEL POUR LE DÉVELOPPEMENT D’APPLICATIONS D’ASSISTANCE À LA MESURE de règles qui considèrent une unité et la translate en un vecteur aux dimen - sion et en échelle de mesure . La transformation opère en visitant une première fois tous les noeuds grandeurs présents dans le modèle d’application . Si une grandeur a une unité prescrite , l’unité est considérée comme une constante et est abstraite par un instrument de mesure . Les autres grandeurs sont abstraites à des variables qui devront être substituées lors de l’uniﬁcation de la requête . Dans un second temps , la transformation visite tous les noeuds qui sont des instruments de mesure , les manipulations de données et les afﬁchages pour les transformer comme indiqué précédemment . Lorsqu’un tel noeud possède une caractéristique spéciﬁque ( type d’instrument ) ou essentielle ( unité de la grandeur ) , la transformation peut générer des connaissances supplémentaires . Ces connaissances ajoutent des redondances dans la vé - riﬁcation , ce qui consolide la requête . DPF workbench propose un plugin qui étend le langage XPAND pour prendre en charge les transformation modèle vers texte , ou Model to Text ( M2T ) [ 110 ] . Le code 5 . 3 montre la déﬁnition de la transformation appliquée aux noeuds UserTriggerSensors . Rappelons qu’un UserTriggerSensor est un instrument de mesure générique dont seule la grandeur générée est un paramètre obligatoire . Le MAML permet également de spéciﬁer le type de l’instrument employé . En connaissant le type de l’instrument , il est possible de déﬁnir le nombre et le type de grandeurs qu’il peut mesurer . Le code 5 . 3 montre la déﬁnition de la transformation de tout UserTrig - gerSensor , ainsi que la transformation spéciﬁquement appliqué lorsque le type de l’instrument est un laser tape ( ou capteur de distance laser ) . Comme expliqué , cela permet d’injecter des connaissances de la mé - trologie complémentaires que le modèle n’exprimait pas ouvertement . Ici , la transformation injecte un prédicat is _ checked _ input qui va spéciﬁque - ment énoncer qu’un instrument de mesure de type laser tape produit une grandeur dont le type est longueur . Un gyroscope se verra proposer une déﬁnition qui associe à chacune des grandeurs produites une grandeur de type angulaire . Cette capacité à injecter des connaissances additionnelles en produisant la requête simpliﬁe la modélisation de l’application . En ajoutant progressi - vement de nouveaux éléments liés à la métrologie au MAML et à la déﬁ - nition de la transformation , la communication entre l’architecte et l’utilisa - teur s’améliorera et le processus de vériﬁcation se renforcera . C’est la res - ponsabilité du créateur de l’outil de déﬁnir les connaissances additionnelles pour des interators spécialisés . Lorsque le MKS proposera la modélisation de capteurs , il sera possible de simpliﬁer la transformation en retirant cette 127 CHAPITRE 5 . GÉNIE LOGICIEL POUR LE DÉVELOPPEMENT D’APPLICATIONS D’ASSISTANCE À LA MESURE Code 5 . 3 Déﬁnition de transformation d’un modèle d’instrument de mesure déclenché par l’utilisateur en une requête de vériﬁcation FOREACH UserSuppliedSensor s " is _ checked _ input ( " + name + " , " + unit + " , " + q _ name + " _ port , t ) ∧ " IF type = = " laser tape " " is _ checked _ input ( " + name + " _ laser _ tape , length , " + q _ name + " _ port , t ) ∧ " ENDIF ENDFOREACH avec name = s . name ( ) type = s . type ( ) . name ( ) q _ name = s . quantity ( ) . name ( ) unit = s . quantity ( ) . unit ( ) . name ( ) injection de connaissances . 5 . 3 . 2 L’implémentation d’applications La section précédente a déjà montré comment une conﬁguration permet - tait de décrire le comportement d’une application . Elle a également briève - ment montré comment un modèle d’application pouvait être converti vers un modèle de conﬁguration . Les entités présentes dans le modèle d’application et celles du modèle de conﬁguration sont proches car les paradigmes employés pour les modéliser sont similaires . Le modèle de conﬁguration est un modèle épuré du modèle d’application dans le sens où il ne se préoccupe pas des notions de grandeur . La section précédente décrit comment sont prises en charge les unités des grandeurs pour simpliﬁer leurs manipulations de manière homogène au sein d’une application . La déﬁnition de transformation entre le modèle d’application et le mo - dèle de conﬁguration s’effectue entre le MAML et le EMAML . Son fonction - nement est similaire à celui entre le MAML et le MKS . La transformation visite les entités du MAML pour les transformer en texte représentant des créations , liaisons et compositions de la conﬁguration . De par l’organisation de la conﬁguration , la transformation visite plu - sieurs fois les entités . Le code 5 . 4 montre la transformation d’un instrument de mesure du modèle d’application en interactor du modèle de conﬁgura - 128 CHAPITRE 5 . GÉNIE LOGICIEL POUR LE DÉVELOPPEMENT D’APPLICATIONS D’ASSISTANCE À LA MESURE tion . Code 5 . 4 Déﬁnition de transformation d’un modèle d’instruments de me - sure en une conﬁguration pour l’application / / sensor creation FOREACH UserSuppliedSensor s IF type = = " laser tape " " LaserTape " + name + " " + name + " " + unit + " " + ratio + " " + zero + " ; " ENDIF ENDFOREACH / / sensor links FOREACH UserSuppliedSensor s IF type = = " laser tape " name + " . out - > " + q _ name + " ; " ENDIF ENDFOREACH avec name = s . name ( ) type = s . type ( ) . name ( ) q _ name = s . quantity ( ) . name ( ) unit = s . quantity ( ) . unit ( ) . name ( ) ratio et zero issus du MKS Les mots - clefs ratio et zero représentent le résultat d’une requête de conversion faite au MKS . La requête est : is _ convert _ to _ base ( unit , c ) unit étant le nom de l’unité associée à l’instrument de mesure du modèle . Le MKS prend donc ici une seconde utilité en décrivant les méthodes de conver - sion à appliquer aux grandeurs par les interactors Cette transformation est appelée Model to Application ( M2APP ) . 129 CHAPITRE 5 . GÉNIE LOGICIEL POUR LE DÉVELOPPEMENT D’APPLICATIONS D’ASSISTANCE À LA MESURE 130 Troisième partie Validation et Perspectives 131 Chapitre 6 Illustration de l’utilisation de la plateforme « Longue est la route par le précepte , courte et facile par l’exemple . » Sénèque Sommaire 6 . 1 Spéciﬁcation de l’application . . . . . . . . . . . . . . . . . 134 6 . 2 Vériﬁcation du modèle . . . . . . . . . . . . . . . . . . . . . . 138 6 . 3 Implantation . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140 6 . 4 Utilisation dans un contexte industriel . . . . . . . . . . . 143 6 . 4 . 1 Contexte . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143 6 . 4 . 2 Choix et limitations de MEASURE . . . . . . . . . . . . 144 6 . 4 . 3 Utilisation des travaux . . . . . . . . . . . . . . . . . . . . 145 133 CHAPITRE 6 . ILLUSTRATION DE L’UTILISATION DE LA PLATEFORME Cette section illustre le scénario du développement d’une application qu’un architecte rencontre en utilisant la plateforme MEASURE . L’appli - cation qui est développée est un assistant simple à l’estimation du coût d’installation de panneaux solaires . Après cet exemple , l’utilisation de ces travaux dans le contexte industriel d’Actimage GmbH est présentée . 6 . 1 Spéciﬁcation de l’application L’application développée pour cette illustration a été imaginée avec Ac - timage GmbH . Son but était de faire avancer la réﬂexion autour de la thé - matique des travaux . L’application devait être simple , tout en comportant un certain nombre d’éléments qui ont été présentés : 1 . les trois types d’instruments de mesure , 2 . des grandeurs de différents types , 3 . un système de grandeur réduit , 4 . une grandeur hors SI , 5 . des unités différentes pour un seul type de grandeur , 6 . plusieurs opérations automatiques sur les grandeurs , 7 . une opération permettant de valider la détection d’erreurs , 8 . plusieurs activités , 9 . une transition avec plusieurs gardes ( automatique et manuelle ) , 10 . un guide pour une mesure 11 . une donnée non grandeur . De plus , l’application devait servir de vitrine pour Actimage . Il fallait donc que la procédure de mesure soit une procédure à réaliser sur site et surtout , que le processus de développement de l’application à l’aide de la plateforme MEASURE soit compréhensible et utile . Finalement nous avons décidé de réaliser une application qui servira à calculer le coût impliqué par une installation de panneaux solaires . Les besoins exprimés sont : 1 . il faut pouvoir renseigner les informations concernant l’utilisateur , 2 . la largeur du toit est mesurée en mètres manuellement , 3 . la longueur du toit est mesurée en mètres avec un capteur laser com - municant , 4 . il faut pouvoir mesurer l’inclinaison du toit . 134 CHAPITRE 6 . ILLUSTRATION DE L’UTILISATION DE LA PLATEFORME 5 . actuellement l’angle est estimé à l’aide d’un niveau à bulle . Une mé - thode plus précise n’est pas exclue si elle est simple et guidée . 6 . il faut pouvoir estimer le prix de l’installation et l’afﬁcher à l’utilisa - teur . 7 . Le prix des panneaux solaires ( tiling price ) est exprimé en yards carrés installés par euro ( ex . : 0 . 01 yard 2 / e ) 8 . L’inclinaison du toit implique un surcoût de 10 dollars par degré . La solution proposée est une application qui présente deux vues , cha - cune correspondant à une activité spéciﬁque . Sur la première vue , l’utilisa - teur peut renseigner des champs de texte pour entrer l’identiﬁant du client ainsi que la largeur mesurée du toit . Un troisième champ afﬁche que l’ap - plication est en attente d’une mesure pour la hauteur du toit . Mesure qui sera relevée par un capteur laser . Une fois que les deux longueurs ont été renseignées , un bouton permet de passer à la seconde vue . Le modèle de cette activité et de sa vue est présenté ﬁgure 6 . 1 . La seconde vue afﬁche le prix de l’installation qui est calculé à partir de l’aire du toit et du prix des panneaux . Ensuite , un tutoriel explique com - ment placer l’appareil mobile sur le toit pour mesurer son inclinaison . Cette mesure est déclenchée par l’appui sur un bouton de capture . La capture dé - clenche une chaîne d’actions qui lit l’inclinaison du toit à partir des données du gyroscope . Une fois l’inclinaison renseignée , la chaîne évalue le surcoût impliqué . Le modèle de cette activité et de sa vue est présenté ﬁgure 6 . 2 . 135 CHAPITRE 6 . ILLUSTRATION DE L’UTILISATION DE LA PLATEFORME : p r e m ea s u r e _ ba s i cs : A c t i v i t y : V i e w u s e r : D a t a I npu t u s e r I D : T e x t u I D : T e x t : da t a w i d t h : D a t a I npu t r oo f w i d t h : T e x t r oo f _ w i d t h : Q uan t i t y : da t a m e t e r : U n i t 0 : N u m be r he i gh t : U s e r S upp li ed S en s o r : quan t i t y r oo f _ he i gh t : Q uan t i t y r oo f he i gh t : T e x t l a s e r t ape : T e x t : t y pe 0 : N u m be r b1 : B u tt on : no t i ﬁc a t i on : U s e r I n t e r a c t i on “ c on t i nue ” : T e x t c 1 : C on t r o l : enab l e r he i gh t _ o k : C o m pa r i s on d i ff e r en t : T e x t 0 : N u m be r : l e ft : r i gh t w i d t h _ o k : C o m pa r i s on d i ff e r en t : T e x t 0 : N u m be r : l e ft : r i gh t : po s t t 1 : T r an s i t i on : gua r d : gua r d : gua r d e s t i m a t e _ p r i c e : A c t i v i t y : i n t e r a c t o r : op : op F i g u r e 6 . 1 – M o d è l e d e l ’ a c t i v i t é d e m e s u r e s i m p l e . 136 CHAPITRE 6 . ILLUSTRATION DE L’UTILISATION DE LA PLATEFORME : t hen deg r ee : U n i t : N u m be r m u l : T e x t $ / deg r ee : U n i t 10 : N u m be r : U n i t : N u m be r add : T e x t : t hen : a1 : a3 : a2 : a2 : a3 : a2 : a1 : V i e w p r i c e _ d i s p l a y : D i s p l a y p r i c e : T e x t g y r o _ t u t o r i a l : D i s p l a y : p i c t u r e p l a c e phone on r oo f an d c ap t u r e : T e x t b2 : B u tt on : no t i ﬁc a t i on : U s e r I n t e r a c t i on C ap t u r e : T e x t c 3 : C on t r o l : enab l e r e s t i m a t e _ p r i c e : A c t i v i t y : i n t e r a c t o r t o t a l _ p r i c e : Q uan t i t y € : U n i t 0 : N u m be r en t e r _ a c t i v i t y : E v en t c 2 : C on t r o l : enab l e r s 1 : S t a r t : t r i gge r e v a l _ a r ea : D a t a M an i pu l a t i on : t hen r oo f _ w i d t h : Q uan t i t y r oo f _ he i gh t : Q uan t i t y r oo f A r ea : Q uan t i t y e v a l _ p r i c e : D a t a M an i pu l a t i on : a1 m u l : T e x t : op m u l : T e x t t ili ng _ p r i c e : Q uan t i t y y a r d ^ 2 / € : U n i t 0 . 01 : N u m be r : U n i t : N u m be r s 2 : S t a r t g y r o : G y r o sc ope P o lli ng r oo f _ ang l e : Q uan t i t y : t he t a e v a l _ e x t r a _ c o s t : D a t a M an i pu l a t i on : t hen : a1 ang l e _ c o s t : Q uan t i t y e x t r a _ c o s t : Q uan t i t y upda t e _ p r i c e : D a t a M an i pu l a t i on : t hen : op : t r i gge r : a2 : a3 : a3 F i g u r e 6 . 2 – M o d è l e d e l ’ a c t i v i t é d e m e s u r e s i m p l e . 137 CHAPITRE 6 . ILLUSTRATION DE L’UTILISATION DE LA PLATEFORME 6 . 2 Vériﬁcation du modèle Une fois l’application modélisée , il faut la vériﬁer . Notez que l’activité qui estime le coût ( estimate _ price ) contient une erreur . En effet , total _ - price devrait être un prix , alors que l’action eval _ price réalise l’opération suivante : m 2 ∗ yard 2 / e ce qui produit des longueur s 4 / pr i x . Cette erreur doit être détectée par la vériﬁcation . Comme expliqué dans la section 3 . 4 . 2 ; une requête de vériﬁcation est extraite du modèle de l’application ( code 6 . 1 ) . Premièrement , les grandeurs avec des unités prescrites sont transformées en entrées . Ensuite , les ins - truments de mesure et indicateurs , ainsi que les fonctions de mesure , sont transformés en prédicats . La transformation a généré des connaissances additionnelles pour les instruments de mesure laser et gyroscope . Celles - ci renseignent les types de grandeurs générées par l’instrument . La requête est analysée pour identiﬁer les erreurs sur les dimensions et les échelles . Comme il n’y a que trois dimensions d’intérêt dans l’applica - tion , les d - vector auront donc la forme < longueur , monnaie , angle > . L’action eval _ price est de la forme : mul ( < 2 , 0 , 0 > , < 2 , − 1 , 0 > ) → < 0 , 1 , 0 > ce qui est incohérent . Pour pouvoir réaliser la vériﬁcation , les connaissances du domaine dé - ﬁnies par le MKS contiennent les dimensions longueur , monnaie et angle ; les unités mètre , yard , dollar , euro et degré ( angulaire ) ; et les conversions mètre → yard , dollar → euro au minimum . Lors de la résolution de la requête par uniﬁcation , la trace rapporte une incohérence . L’instrument price _ display requiert en sortie des dollars ( < 0 , 1 , 0 > ) et le port connecté contient le vecteur de dimension ( < 4 , − 1 , 0 > . Donc , cette trace indique qu’il y a une incohérence au niveau de ce port . Pour corriger une incohérence sur un port , il faut se questionner sur la cohérence des entités directement connectées dessus . Dans ce cas , il y a plusieurs choix possibles : 1 . modiﬁer l’unité afﬁchée par price _ display , 2 . modiﬁer l’opération réalisée par eval _ price , 3 . modiﬁer une unité ou opération plus loin dans la procédure . C’est à l’architecte de faire le choix qui répondra le mieux à la situation . Pour cette application , le choix ( 1 ) n’est pas envisageable . Les besoins im - posent d’afﬁcher une valeur monétaire en sortie . Puisque le but est d’es - timer un prix , il ne fait aucun doute que c’est ce qui est recherché . En 138 CHAPITRE 6 . ILLUSTRATION DE L’UTILISATION DE LA PLATEFORME Code 6 . 1 Requête de vériﬁcation extraite du modèle d’application is _ trace ( file , t ) ∧ / / quantities with prescribed units is _ checked _ input ( roof _ width , meter , roof _ width _ port , t ) ∧ is _ checked _ input ( roof _ height , meter , roof _ height _ port , t ) ∧ is _ checked _ input ( tiling _ price , quotient ( power ( meter , 2 ) , euro ) , tiling _ price _ port , t ) ∧ is _ checked _ input ( roof _ angle , degree , roof _ angle _ port , t ) ∧ is _ checked _ input ( extra _ cost , quotient ( euro , degree ) , extra _ cost _ port , t ) ∧ is _ checked _ input ( total _ price , euro , total _ price _ port , t ) ∧ / / measuring instruments is _ checked _ input ( width , meter , roof _ width _ port , t ) ∧ is _ checked _ input ( height , meter , roof _ height _ port , t ) ∧ is _ checked _ input ( height _ laser _ tape , length , roof _ height _ port , t ) ∧ is _ checked _ input ( gyro _ theta , degree , roof _ angle _ port , t ) ∧ is _ checked _ input ( gyro _ theta _ GyroscopePolling , angular , roof _ angle _ port , t ) ∧ / / measurement functions is _ checked _ function ( eval _ area , mul , roof _ width _ port , roof _ height _ port , roof _ area _ port , t ) ∧ is _ checked _ function ( eval _ price , mul , roof _ area _ port , tiling _ price _ port , total _ price _ port , t ) ∧ is _ checked _ function ( eval _ extra _ cost , mul , roof _ angle _ port , extra _ cost _ port , extra _ cost _ port , t ) ∧ is _ checked _ function ( update _ price , add , extra _ cost _ port , total _ price _ port , total _ price _ port , t ) ∧ / / indicating instruments is _ checked _ output ( price _ display , euro , total _ price _ port , t ) ∧ is _ done ( t ) . 139 CHAPITRE 6 . ILLUSTRATION DE L’UTILISATION DE LA PLATEFORME revanche , les choix ( 2 ) et ( 3 ) sont cohérents . Avec ( 2 ) il est possible de changer l’opération en un quotient : quot ( < 2 , 0 , 0 > , < 2 , − 1 , 0 > ) → < 0 , 1 , 0 > est une opération cohérente . Avec ( 3 ) , modiﬁer l’unité tiling _ price est éga - lement un choix discutable . Ce n’est pas commun de rencontrer une unité comme celle - ci , habituellement ce sera plutôt le prix pour une aire donnée qui sera utilisé . Cependant , faisant partie des besoins exprimés par le client il convient de faire le choix ( 2 ) . Notez qu’il serait également possible de modiﬁer la dimension présente sur le second port d’entrée de l’opération . Mais cela revient à réaliser des modiﬁcations qui sont de plus en plus éloignées de la source d’erreurs dé - tectée . Dans une procédure de mesure , un port peut être connecté à plus de deux entités ( instrument de mesure , indicateur ou fonction de mesure ) . Donc , plus la grandeur est éloignée du port dans lequel le problème est dé - tecté , plus les risques de propager de nouvelles erreurs dans la procédure sont élevés . Il ne faut pas oublier que l’algorithme d’uniﬁcation proposé ne détecte que la première erreur d’une procédure . Une fois celle - ci corrigée , de nouvelles erreurs plus en aval peuvent apparaître . Une fois la correction établie , la requête issue de la nouvelle transfor - mation s’uniﬁe . Ce qui prouve que la procédure de mesure est correcte par rapport à la sémantique de la métrologie . 6 . 3 Implantation Une fois l’application vériﬁée , elle peut être transmise à l’application sous la forme d’une conﬁguration . Puisque toutes les opérations sur les grandeurs ont été validées par le MKS et que toutes les unités sont converties vers leurs références dans l’ap - plication , toutes les fonctions de mesures sont garanties d’être cohérentes . L’application de la transformation M2APP correspondant au modèle de la ﬁgure 6 . 1 est décrite dans les codes 6 . 2 . Le résultat de la conﬁguration est une application visuellement simple . La ﬁgure 6 . 3 montre les deux visuels obtenus . L’application prend en charge un capteur de distance connecté . Ces capteurs permettent , une fois connectés à une plateforme mobile , de lui envoyer des informations sur une socket de communication . L’interactor prend en charge le protocole de communication . Une fois qu’il devient ac - tif , il ouvre une socket de communication avec le capteur . Et quand une valeur a été communiquée , lors de sa prochaine activation l’agent lit la va - leur , la convertit ( ici la conversion n’a aucun effet ) et la met à disposition 140 CHAPITRE 6 . ILLUSTRATION DE L’UTILISATION DE LA PLATEFORME Code 6 . 2 Source de conﬁguration issue de la transformation M2APP Activity : measure _ basics ; Activity : estimate _ price ; DataInputText user userID ; DataInputQ width " roof width " meter 1 0 ; LaserTape height " roof height " meter 1 0 ; Button b1 continue ; transition t1 ; Different width _ ok ; Different length _ ok ; Control c1 ; TPort uID ; QPort roof _ width ; QPort roof _ height ; QPort zero ; / / / / / width . data - > roof _ width ; height . data - > roof _ height ; width _ ok . left - > roof _ width ; width _ ok . right - > zero ; height _ ok . left - > roof _ height ; height _ ok . right - > zero ; / / / / / measure _ basics . add ( t1 ) ; measure _ basics . add ( user ) ; measure _ basics . add ( width ) ; measure _ basics . add ( height ) ; measure _ basics . add ( b1 ) ; t1 . add ( estimate _ price ) ; t1 . add ( width _ ok ) ; t1 . add ( height _ ok ) ; t1 . add ( c1 ) ; / / / / / measure _ basics ; 141 CHAPITRE 6 . ILLUSTRATION DE L’UTILISATION DE LA PLATEFORME user ID : roof width : 0 meter roof height : 0 meter Continue place phone on the roof and capture price : 0 € Capture Figure 6 . 3 – Visuel de l’application auto - générée par la plateforme MEASURE . dans le QPort connecté . Un autre instrument de mesure est employé , le gyroscope embarqué dans l’appareil mobile . Une fois démarré il permet de mesurer l’orienta - tion du mobile en ﬂux continu . L’agent est un ComInteractor basé sur une structure PAC ( cf . ﬁgure 5 . 6 ) dont le processeur requête un second PAC . Le second PAC est un agent qui gère en continu le capteur embarqué . Il prend en charge le démarrage de l’instrument et en capture les données en ﬂux continu . Le processeur de l’agent ComInteractor quant à lui attend de recevoir le signal de l’utilisateur pour solliciter la valeur la plus récente du gyroscope au second processeur . Valeur qu’il convertira puis sauvegardera dans son abstraction . Cette composition est réalisable grâce à l’évolution maîtrisée des agents offerte par le moteur d’exécution du framework PI . Notez que l’application peut être facilement améliorée en proposant un ensemble plus varié d’agents . Un agent WebService pourrait contacter le site de vente des panneaux solaires pour obtenir une liste des panneaux et de leurs prix . Cela permet - trait , à l’aide d’un afﬁchage sous forme de liste , de choisir les panneaux en fonction de leurs prix . Cette communication pourrait être encore plus pous - sée en proposant de choisir les panneaux en fonction de leurs rendements et de leur coût d’installation . Le retour sur investissement de l’installation , qui est un très bon argument de vente , serait donc calculable . Ce méca - nisme permet de mettre en place des fonctionnalités avancées . La communication peut également être utilisée pour envoyer le devis de l’installation créé une fois qu’il a été signé par le client . Cela permet de lancer le processus d’archivage et de production plus rapidement ; sans risquer de perdre la commande . En ajoutant une seconde base de données , il est possible de connaître l’ensoleillement moyen de la région . À l’aide du capteur GPS et de la bous - 142 CHAPITRE 6 . ILLUSTRATION DE L’UTILISATION DE LA PLATEFORME sole embarqués , on peut récupérer , la position et l’orientation du toit . Ces informations permettent une estimation de la production électrique plus précise , en utilisant une base de données et deux capteurs embarqués dans tous les appareils mobiles actuels . La position permet également de simpli - ﬁer le rapport concernant le client en associant à son adresse des coordon - nées GPS . Il est aussi envisageable de proposer une application qui permet de mesurer le niveau de l’utilisateur ( débutant , habitué , expert ) associé à la procédure de mesure . Cette mesure peut être prise en intégrant la vitesse d’exécution de l’utilisateur , en lui proposant d’entrer l’information manuel - lement , ou bien , la encore , celle - ci pourrait être associée aux informations de connexion de l’utilisateur . Prendre en compte le niveau de l’utilisateur , permet à l’application de proposer des activités adaptées pour être plus ou moins guidées . 6 . 4 Utilisation dans un contexte industriel La section précédente a montré la puissance de développement offerte par la plateforme MEASURE . Cette section revient sur le contexte industriel du projet . Puis elle présente les développements qui en sont issus . 6 . 4 . 1 Contexte Actimage GmbH a pour but le développement d’une ﬂotte d’applications d’assistances aux mesures réalisées par des professionnels en situation de mobilité dans un premier temps et aux particuliers dans un second . Ces applications ont pour but de devenir une boîte à outils personnalisée capable de proﬁter des capacités des systèmes mobiles pour : 1 . partiellement remplacer la multitude de capteurs qui permettent de réaliser la procédure de mesure par des capteurs embarqués dans un système mobile , 2 . guider l’utilisateur dans la réalisation de la prise de mesure , 3 . réaliser des calculs fastidieux encore souvent effectués manuellement ultérieurement , 4 . proposer des résultats in situ ( estimations , contrat de vente , etc . ) , 5 . intégrer plus aisément les résultats dans un système d’information d’entreprise . La plateforme MEASURE est l’un des résultats de recherches réalisées autour de cette thématique . L’objectif original était l’analyse de la faisabilité 143 CHAPITRE 6 . ILLUSTRATION DE L’UTILISATION DE LA PLATEFORME de l’utilisation de capteurs embarqués ou de capteurs communicants au sein d’une solution logicielle unique . Depuis 2012 , le monde du logiciel mobile a beaucoup évolué . Alors qu’à l’époque les premiers capteurs communicants grand public commençaient à faire leur apparition sur le marché , ils sont maintenant nombreux . De plus , pour créer une application , chaque plateforme mobile néces - sitait un développement spéciﬁque . Aujourd’hui des technologies comme le moteur d’exécution Unity ou le langage Qt permettent de développer une application mobile qui pourra être utilisée sur toutes les plateformes mobiles . Dans ce contexte , il fallait pouvoir diffuser un logiciel capable de répondre à potentiellement l’ensemble des besoins de mesures de l’utilisa - teur , et ce quelle que soit la plateforme qu’il utilise . Le projet qui servait de ﬁnancement à ces travaux était un projet en par - tenariat avec la Hochschule de Offenburg . Ce projet visait à proposer un système logiciel capable de faire bon usage d’un capteur de distance déve - loppé par la Hochschule . Ce capteur est capable de capturer une vue 3D de l’espace environnant sous la forme d’un ensemble d’images contenant cha - cune 121 mesures de distances entre cinq et dix mètres . Chaque mesure étant précise à 2 . 5 millimètres près . 6 . 4 . 2 Choix et limitations de MEASURE Le contexte décrit présente un champ des possibles extrêmement large . Plusieurs expertises sont nécessaires pour résoudre en entier les probléma - tiques posées par le contexte . Que faire d’un nuage de points lors d’activi - tés de mesures ? Quelles interfaces permettent d’en maximiser l’utilisation ? Quel est l’impact des incertitudes de mesures sur un ensemble composé de multiples captures ( nuage de points 3D ) ? Comment proposer une applica - tion adaptée aux besoins de tous les utilisateurs ? Qu’est - ce qu’une mesure ? Comment faire interagir les différentes grandeurs que peuvent relever les instruments de mesure ? Comment gérer les différents capteurs qui peuvent exister ? Comment favoriser le choix d’un capteur par rapport à un autre ? La plateforme MEASURE a fait le choix de se limiter aux problématiques abordées dans ce travail de recherche aﬁn d’y répondre , à notre sens , cor - rectement . Les travaux qui sont présentés dans les chapitres précédents montrent la capacité de la plateforme à produire des modèles d’applica - tions , dont le sens est garanti au niveau de la métrologie . Ces modèles sont transposables sous la forme de conﬁgurations d’un logiciel . Cette transpo - sition est réalisée à l’aide d’un langage qui propose un ensemble de termes réduits et proches de ceux qu’emploie l’utilisateur de l’application . 144 CHAPITRE 6 . ILLUSTRATION DE L’UTILISATION DE LA PLATEFORME 6 . 4 . 3 Utilisation des travaux Actimage GmbH 1 a utilisé ces travaux dans deux de ces projets récents : Datapipe et ActiNote 4 . 0 . Datapipe est un projet ﬁnancé par le programme Eurostar de la commis - sion européenne . Le but de ce projet est le développement d’un ensemble d’outils communicants qui permettront la semi - automatisation de processus d’analyse de données dans le domaine pétrolier ( Oil & Gaz ) [ 15 ] . Ce projet nécessite de pouvoir modéliser les processus sous la forme d’un ensemble de tâches potentiellement automatisées , qui devront être réalisées pour analyser les données . Les tâches peuvent être : l’accès à des données , leur décompression , l’application d’un algorithme , etc . Ces pro - cessus sont complexes et étaient entièrement gérés manuellement puisque leur modélisation requiert un ensemble de connaissances poussées dans la manipulation de données hétérogènes massives . Datapipe propose un éditeur de modèle de processus qui permet de chaîner les différentes tâches à réaliser . De plus , une représentation des connaissances , ou Knowledge Representation ( KR ) encode les connaissances spéciﬁques au domaine de l’analyse de ces données . Elle permet de vériﬁer la cohérence d’un modèle de processus par rapport aux types de données qui y interagissent et par rapport à l’enchaînement de certaines tâches dont les dépendances sont clairement déﬁnies . ActiNote 4 . 0 est la réalisation commercialisée de MEASURE . Il permet la modélisation , la vériﬁcation et l’implantation de processus d’assistance à des personnes dans des contextes de mobilité . Il est composé de trois outils : un éditeur , un compilateur et une application mobile . L’éditeur permet la modélisation d’un processus à l’aide d’un langage graphique complexe . La syntaxe abstraite du langage est proche de celle de MEASURE . Par contre , l’éditeur proposé est plus avenant . Il permet la description des vues à l’aide d’une interface de composition de widgets qui représente l’écran du mobile tel qu’il sera présenté à l’utilisateur . De plus , les erreurs détectées dans le modèle sont afﬁchées directement sur le modèle par un système de balises . Le compilateur est un outil qui vériﬁe la syntaxe des modèles et leurs cohérences avec la sémantique propre à la plateforme . Il réalise également une transformation du langage vers une description d’une conﬁguration de l’application mobile . Lors des développements préliminaires d’ActiNote , une version adaptée du MKS avait été intégrée au processus de compilation . Le compilateur transformait l’ensemble des actions du processus sous la 1 . http : / / www . actimage . de 145 CHAPITRE 6 . ILLUSTRATION DE L’UTILISATION DE LA PLATEFORME forme d’une requête de validation de la procédure de mesure comprise dans le processus . Toutes les conversions d’unités impliquées dans un processus étaient prises en charge par le MKS . Cependant , pour simpliﬁer l’utilisation de l’éditeur actuel , le MKS n’est employé que pour ses capacités de prescriptions dans la version actuelle d’ActiNote 4 . 0 . L’application mobile est une application multi - plateforme qui est capable de recevoir et stocker des ﬁchiers de conﬁguration . Une conﬁguration dé - crit l’ensemble des éléments qui sont présents pour générer un comporte - ment conforme aux besoins d’un utilisateur spéciﬁque . Mais à part l’intégration de la sémantique de la mesure , l’ensemble d’Ac - tinote 4 . 0 est une réalisation industrielle et commerciale dans laquelle sont utilisés les concepts de ces travaux . 146 Chapitre 7 Conclusion et perspectives « Car enﬁn , que sert - il d’écrire ? N’est - ce pas assez de penser ? » Cardinal de Bernis Sommaire 7 . 1 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 148 7 . 2 Perspectives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150 147 CHAPITRE 7 . CONCLUSION ET PERSPECTIVES 7 . 1 Conclusion Actimage GmbH 1 est un éditeur de logiciels proposant des solutions de prise d’informations en situation de mobilité aﬁn d’en automatiser le trai - tement et le transfert vers les systèmes d’informations des clients . Dans ce contexte Actimage cherche à proposer des solutions logicielles qui assistent la prise de mesure , tout en étant de qualité et rapide à développer . Les tra - vaux présentés ont été ﬁnancés par Actimage pour proposer une solution à cette problématique . Ces travaux ont présenté une approche de conception de logiciels d’as - sistance à la mesure en situation de mobilité . Les développements logiciels impliquant des procédures de mesure ont tendance à être développés sans forcément considérer les règles relatives au domaine de la métrologie . Mal - gré le sentiment de maîtrise du domaine que chacun possède de par son éducation , ce domaine est vaste et complexe . L’approche présentée pro - pose une plateforme de développement logiciel qui augmente la qualité de systèmes impliquant des mesures . Pour cela , trois outils coopèrent grâce aux concepts de l’IDM . Un système expert construit sur une représentation des connaissances de la métrologie ; le MKS . L’analyse dimensionnelle et l’analyse des échelles de mesure permettent d’assurer que des contraintes algébriques sur les grandeurs miment les relations du monde réel . En les appliquant sur une procédure de mesure , il est possible de garantir la cohérence des gran - deurs mesurées et calculées avec les propriétés observées ou estimées . Le MKS encode ces connaissances en logique du premier ordre . Cela permet de raisonner sur l’ensemble des connaissances . Il encode la construction de systèmes de grandeurs , l’analyse dimensionnelle , l’analyse des échelles et la conversion d’unités . En plus de ces raisonnements , le MKS propose un langage de requêtes permettant la vériﬁcation de procédures de mesures . Ces requêtes sont décrites à l’aide d’un language de requête le MKQL . Il exprime des requêtes sous la forme de procédures de mesure constituées d’instruments de mesure , de fonctions de mesure et d’instruments indica - teurs . Un éditeur d’application de mesure spécialement conçu pour réduire l’écart sémantique entre un architecte logiciel et l’utilisateur de son tra - vail . Cet éditeur propose à l’architecte d’employer un langage spéciﬁque de domaine ; le MAML . Le MAML est décrit par des concepts de la méta - modélisation et implanté avec l’outil DPF workbench . Il permet la création de langages de modélisation et d’éditeurs conformes aux langages . Leurs 1 . http : / / www . actimage . de 148 CHAPITRE 7 . CONCLUSION ET PERSPECTIVES conformité étant prouvée par la théorie des catégories et des homomor - phismes de graphes . Le MAML réunit des concepts de la métrologie , de l’ingénierie des processus et des interfaces utilisateur . Il permet ainsi la description de procédures de mesures outillées impliquant des interactions humaines . Le vocabulaire qu’il propose est constitué de termes proches de ceux qui permettent à l’utilisateur ﬁnal de décrire ses procédures de me - sures quotidiennes . Une application mobile hautement conﬁgurable dédiée à l’assistance à la prise de mesure en situation de mobilité . L’application est construite à l’aide du framework d’agents PI . Ce framework permet la déﬁnition d’agents conti - nus et réactifs dont l’évolution est garantie et maitrisée dans le temps . L’application mobile propose une librairie d’agents . Ces agents , une fois as - semblés correctement , génèrent un comportement qui permet de répondre aux besoins de mesure de tout utilisateur . Un langage de description de conﬁgurations d’agents est proposé , le EMAML . Ces conﬁgurations peuvent être interprétées par l’application logicielle . Elle assemble les agents qui y correspondent pour générer un comportement spéciﬁque . Un ensemble de conﬁguration d’agents peut être stocké dans l’application , permettant de réaliser le comportement adéquat au contexte d’utilisation . La plateforme MEASURE ( cf ﬁgure 1 . 2 ) est dédiée au développement d’applications de mesures vériﬁées . Elle propose un cycle de développe - ment complet ( spéciﬁcation , vériﬁcation , implantation ) . Ce cycle est réalisé en utilisant les outils présentés ( respectivement l’éditeur issu du MAML , le MKS et l’application logicielle . Pour cela , les concepts de l’IDM sont utilisés . Chaque outil fonctionne en produisant ou en utilisant des modèles de procé - dures de mesure spécialisés pour l’opération qu’ils réalisent . Ces modèles sont conformes à des métamodèles qui décrivent les langages de modéli - sation présentés ( respectivement MAML , MKQL et EMAML ) . Aﬁn d’auto - matiser le processus de développement , deux déﬁnitions de formations de modèles sont proposées . La première ( Model to Veriﬁcation Query ( M2VQ ) ) permet de transformer les modèles d’application en requêtes de vériﬁca - tion ; la seconde ( Model to Application ( M2APP ) ) permet de transformer en conﬁguration de l’application . Ces deux transformations permettent l’auto - matisation des processus de vériﬁcation et d’intégration à partir du modèle de description de l’application de mesure . La plateforme MEASURE permet donc de simpliﬁer la spéciﬁcation de ces applications ; de garantir la qualité des procédures de mesures impliquées ; et d’automatiser l’intégration de la procédure de mesure dans une application mobile . L’approche est ensuite illustrée par l’utilisation de la plateforme pour dé - velopper une application , simple , permettant de mesurer d’évaluer le coût d’une installation de panneaux solaires sur une toiture . La vériﬁcation est 149 CHAPITRE 7 . CONCLUSION ET PERSPECTIVES illustrée en incorporant volontairement une erreur dans le modèle de l’ap - plication . L’implantation du système est illustrée par des visuels de l’ap - plication générée . De plus , les capacités d’extensions de l’application sont expliquées . Enﬁn , une brève explication des réalisations industrielles déri - vées de ces travaux est présentée . Les deux projets présentés sont Datapipe et Actinote 4 . 0 de l’entreprise Actimage GmbH . 7 . 2 Perspectives L’ensemble des travaux présentés permet d’augmenter la qualité des ap - plications de mesure et d’assurer que leur comportement soit conforme aux attentes des utilisateurs . Plusieurs axes d’évolutions sont envisagés pour approfondir les résultats obtenus . Les résultats obtenus , avec les utilisations conjointes de l’éditeur de mo - dèles et du vériﬁcateur , sont prometteurs . L’axe qui sera donc prioritaire pour les travaux à venir est l’élaboration d’un langage spéciﬁque de do - maine embarqué ( embedded DSL ) [ 122 ] . Le but de ce langage sera le dé - veloppement de logiciels impliquant des mesures vériﬁées . L’avantage de cette approche sur l’approche actuelle est que les embedded DSL étendent les capacités expressives d’autres langages de programmation . Il serait donc possible de proposer une extension à l’un des langages de programma - tion très usités ( Java , C + + ) . Extensions capables de vériﬁer les procédures de mesure incluses dans les systèmes développés . Les contraintes liées à l’utilisation de termes spéciﬁques aux instruments de mesures et indica - teurs seront limités par le langage . Avec une telle plateforme ( embedded DSL + MKS ) , il serait possible de toucher une communauté bien plus large de développeurs . Et peut être même les sensibiliser aux problématiques de la métrologie . Une autre perspective envisageable est l’ajout d’une nouvelle vériﬁca - tion dans le processus de développement . Pour le moment la sémantique de la métrologie proposée est celle liée aux analyses dimensionnelle et des échelles . Nous avons évoqué dans la section 3 . 4 l’importance des incerti - tudes de mesures dans un mesurage . Techniquement , un mesurage n’a pas de sens s’il n’est pas associé à une valeur d’incertitude qui permet de dé - ﬁnir la ﬁabilité de la grandeur [ 88 ] . Vue l’étendue de ces travaux , il a été choisi de ne pas aborder cette thématique . Mais l’évaluation d’incertitudes de mesures , même sur un modèle , pourrait encore augmenter la ﬁabilité des résultats . La transformation du modèle en requête de vériﬁcation implique déjà la prise en compte des différents instruments . Ce sont eux les principales 150 CHAPITRE 7 . CONCLUSION ET PERSPECTIVES sources d’incertitudes dans une procédure de mesure . Une représentation des connaissances des instruments de mesure permettrait d’ajouter les no - tions de vériﬁcation des incertitudes . Elle préviendrait donc l’utilisation d’instruments incapables de réaliser des mesurages corrects par rapport à des tolérances d’erreurs . Cette représentation des connaissances , ou Knowledge Representation ( KR ) des instruments de mesure pourrait également permettre de déﬁnir quels sont les instruments qui ne peuvent être utilisés pour obtenir un type de grandeur . L’intérêt serait double : premièrement , la transformation du modèle d’application vers la requête de vériﬁcation pourrait être allégée des spéciﬁcités liées aux instruments . Celles - ci étant apportées par la base de connaissances . Deuxièmement , il serait possible de proposer à l’utilisa - teur une liste des instruments de mesure qui répondent à ses besoins . En effet , le travail de métrologue implique également la déﬁnition des instru - ments de mesures intervenant dans une procédure de mesure . En connais - sant les types de grandeurs fournies , l’incertitude de mesure des instru - ments et des notions de prix ; il devient possible de proposer un capteur qui sera optimisé pour une tâche donnée . Le MKS sera donc non seulement ca - pable de prescrire le type des grandeurs qui sont attendues en entrée d’un système ; mais également les instruments qui peuvent être envisagés pour jouer ces rôles . Bien que cela ne mène pas à de nouvelles recherches , l’intégration du système de vériﬁcation dans la plateforme Actinote 4 . 0 est également pré - vue . Cette intégration permettra de stresser le système pour en voir les limites ou les capacités . Nous n’avons en effet pas réalisé de tests à grande échelle sur le MKS . Cependant il faut toujours garder à l’esprit que les grandeurs produites par une procédure de mesure peuvent être considé - rées comme issues d’un instrument de mesure complexe . La vériﬁcation d’une procédure de mesure complexe revient donc à découper la procédure en plusieurs sous procédures . Chacune est vériﬁée séparément avant d’être assemblée aux autres , jusqu’à arriver à la procédure globale . L’optimisation de cette approche de décomposition par rapport à sa confrontation avec le MKS peut s’avérer intéressante . L’optimisation est un réel problème dans la vériﬁcation réalisée par le MKS . Actuellement seuls deux mécanismes permettant d’optimiser les uni - ﬁcations de requêtes de vériﬁcation sont utilisés . Le premier est l’utilisation des cuts qui permet de limiter la portée du retour sur trace . Le second est l’utilisation d’un système d’unités créé à partir d’un arbre dont les conver - sions ont , généralement , tendance à s’éloigner de la racine . Un chemin de conversion est donc assez simple à trouver en remontant ces conversions . La précision des conversions souffre de cette structure . Toutes les conver - 151 CHAPITRE 7 . CONCLUSION ET PERSPECTIVES sions entre deux unités u 1 → u 2 impliquent de passer par l’unité de ré - férence de la dimension u 1 → re f erence → u 2 . Cela même s’il existe une conversion directe déﬁnie dans la base de connaissances . De plus , les conver - sions entre deux unités sont parfois approximatives , de par la déﬁnition de leurs unités . Un algorithme de conversion efﬁcace devrait donc favoriser les conversions exactes . Cependant , les machines actuelles ne sont pas pré - cises . Donc , si le chemin de conversion exacte implique plus d’opérations , il pourrait tout aussi bien être moins précis . La RTM et l’analyse des échelles permet de prendre en compte des gran - deurs non physiques . Notre approche considère ces grandeurs comme des dimensions supplémentaires pour le système . Nous n’avons que peu exploré les capacités apportées par ces dimensions supplémentaires . La métrologie " largement " déﬁnie ( widely - deﬁned measurement ) [ 78 ] est une branche de la métrologie , hors des références , qui propose de considérer plus de di - mensions pour chaque domaine . Par exemple l’utilisation de trois longueurs de types séparés pour chaque axe d’un plan à trois dimensions . Il semble intéressant d’approfondir nos travaux dans cette direction également . Enﬁn , bien que nous employons la RTM , notre analyse des échelles est encore faible . Nous ne sommes pas capables de résoudre le problème du trajet en voiture cité ﬁgure 2 . 4 . Pour rappel , il devrait être interdit de calculer une moyenne lorsque , pour une unité composée de la forme numer ateur / denominateur , c’est l’unité du dénominateur qui est variable . Actuellement , l’analyse des échelles de mesure proposée est limitée à une simple répercussion des échelles proposées en entrée de la procédure vers ses sorties . Il faudra donc proposer des règles d’analyse plus poussées . Cela pourrait être réalisé avec des agents qui vériﬁent plusieurs opérations à la fois , pour avoir une plus grande connaissance de la procédure . 152 Bibliographie Bibliographie [ 1 ] 2010 , «Modelica® - a uniﬁed object - oriented language for physical systems modeling - language speciﬁcation - version 3 . 2» , . 29 [ 2 ] Allemang , D . et J . Hendler . 2011 , Semantic web for the working onto - logist : effective modeling in RDFS and OWL , Elsevier . 43 [ 3 ] Almendros - JimÃ©nez , J . M . 2011 , «A Prolog - based Query Language for OWL» , Electronic Notes in Theoretical Computer Science , vol . 271 , doi : http : / / dx . doi . org / 10 . 1016 / j . entcs . 2011 . 02 . 008 , p . 3 – 22 , ISSN 1571 - 0661 . URL http : / / www . sciencedirect . com / science / article / pii / S1571066111000454 . 45 [ 4 ] Astarita , G . 1997 , «Dimensional analysis , scaling , and orders of magnitude» , Chemical Engineering Science , vol . 52 , n o 24 , doi : http : / / dx . doi . org / 10 . 1016 / S0009 - 2509 ( 97 ) 85420 - 6 , p . 4681 – 4698 , ISSN 0009 - 2509 . URL http : / / www . sciencedirect . com / science / article / pii / S0009250997854206 . 24 [ 5 ] Baader , F . , éd . . 2003 , The description logic handbook : theory , im - plementation , and applications , Cambridge University Press , Cam - bridge , UK ; New York , ISBN 978 - 0 - 521 - 78176 - 3 . 42 [ 6 ] Barvik , P . 2014 , Model to Model Transformation Tool for the DPF Workbench , thèse de doctorat , Department of Informa - tics , University of Bergen , Department of Computing , Mathe - matics and Physics Bergen University College , Norway . URL http : / / gs . hib . no / trac / eclipsep / export / 1378 / latex _ sources / petter / Thesis / MasterVersion3 . pdf . 61 [ 7 ] Bell , A . E . 2004 , «Death by UML Fever» , Queue , doi : 10 . 1145 / 984458 . 984495 , ISSN 15427730 . 54 , 55 153 CHAPITRE 7 . CONCLUSION ET PERSPECTIVES [ 8 ] Berners - Lee , T . , J . Hendler , O . Lassila et others . 2001 , «The semantic web» , Scientiﬁc american , vol . 284 , n o 5 , p . 28 – 37 . 42 [ 9 ] Bindi , C . 2006 , Dictionnaire pratique de la métrologie , AFNOR , La Plaine Saint - Denis , ISBN 2124607227 9782124607228 . 26 [ 10 ] BIPM . 2006 , «SI brochure , 8th edition - the international system of units ( SI ) » , . 17 , 20 [ 11 ] Bishop , J . 2007 , C # 3 . 0 Design Patterns : Use the Power of C # 3 . 0 to Solve Real - World Problems , " O’Reilly Media , Inc . " . 47 [ 12 ] Boehm , B . W . 1988 , «A spiral model of software development and enhancement» , Computer , vol . 21 , n o 5 , p . 61 – 72 . 8 [ 13 ] Booch , G . 1986 , «Object - oriented development» , IEEE transactions on Software Engineering , , n o 2 , p . 211 – 221 . 46 [ 14 ] Botts , M . et A . Robin . 2007 , «OpenGIS sensor model language ( SensorML ) implementation speciﬁcation» , OpenGIS Implementation Speciﬁcation OGC 07 – 000 . 27 [ 15 ] Bourgeois , F . et P . Arlaud . 2015 , «Datapipe : A Conﬁgurable Oil & amp ; Gas Automated Data Processor : » , SCITEPRESS - Science and and Technology Publications , ISBN 978 - 989 - 758 - 176 - 2 , p . 75 – 96 , doi : 10 . 5220 / 0006163700750096 . URL http : / / www . scitepress . org / DigitalLibrary / Link . aspx ? doi = 10 . 5220 / 0006163700750096 . 145 [ 16 ] Boyd , T . D . et M . H . Jameson . 1981 , «Urban and rural land division in ancient Greece» , Hesperia : The Journal of the American School of Classical Studies at Athens , vol . 50 , n o 4 , p . 327 – 342 . 16 [ 17 ] Brambilla , M . , J . Cabot et M . Wimmer . 2012 , Model - driven soft - ware engineering in practice , n o 1 dans Synthesis lectures on soft - ware engineering , Morgan & Claypool , San Rafael , Calif . , ISBN 9781608458820 9781608458820 9781608458837 . 8 , 52 , 57 , 62 , 64 [ 18 ] Bratko , I . 2001 , Prolog programming for artiﬁcial intelligence , Pear - son education . 35 [ 19 ] Bruneliere , H . , J . Cabot , F . Jouault et F . Madiot . 2010 , «MoDisco : a generic and extensible framework for model driven reverse enginee - ring» , dans Proceedings of the IEEE / ACM international conference on Automated software engineering , ACM , p . 173 – 174 . 55 154 CHAPITRE 7 . CONCLUSION ET PERSPECTIVES [ 20 ] Bustard , D . , M . Norris et P . Kawalek , éd . . 2000 , Systems Modeling for Business Process Improvement , 1 re éd . , Artech House , Inc . , Norwood , MA , USA , ISBN 1 - 58053 - 050 - 8 . 110 [ 21 ] Chardigny , S . 2009 , Extraction d’une architecture logicielle à base de composants depuis un système orienté objet . Une aproche par exploration , Thèse de doctorat , Université de Nantes . 48 [ 22 ] Chein , M . et M . - L . Mugnier . 2009 , Graph - based knowledge represen - tation : computational foundations of conceptual graphs , Advanced information and knowledge processing , Springer , New York ; London , ISBN 978 - 1 - 84800 - 285 - 2 978 - 1 - 84800 - 286 - 9 . OCLC : ocn277067628 . 37 [ 23 ] Cmelik , R . F . et N . H . Gehani . 1988 , «Dimensional analysis with c + + » , Software , IEEE , vol . 5 , n o 3 , doi : 10 . 1109 / 52 . 2021 , p . 21 – 27 , ISSN 0740 - 7459 . URL http : / / ieeexplore . ieee . org / xpls / abs _ all . jsp ? arnumber = 2021 . 29 , 70 [ 24 ] Consortium , E . 2010 , Java Emitter Templates ( JET ) . 64 [ 25 ] Cori , R . et D . Lascar . 1993 , «Logique mathématique . 1 , Calcul pro - positionnel , algèbres de Boole , calcul des prédicats : cours et exer - cices» , . 34 , 37 , 41 [ 26 ] Coutaz , J . 1997 , «PAC - ing the architecture of your user interface» , dans DSV - IS , p . 13 – 27 . 50 , 118 [ 27 ] Covington , M . A . 1994 , Natural language processing for Prolog pro - grammers , Prentice hall Englewood Cliffs ( NJ ) . 56 [ 28 ] Cox , M . G . , P . M . Harris et I . M . Smith . 2010 , Software speciﬁ - cations for uncertainty evaluation , National Physical Laboratory . URL http : / / resource . npl . co . uk / docs / science _ technology / scientific _ computing / ssfm / documents / dem - es _ 010 . pdf . 26 [ 29 ] Cunningham , R . J . et S . Zappacosta - Amboldi . 1983 , «Software tools for ﬁrst - order logic» , Software : Practice and Experience , vol . 13 , n o 11 , doi : 10 . 1002 / spe . 4380131106 , p . 1019 – 1025 , ISSN 00380644 , 1097024X . URL http : / / doi . wiley . com / 10 . 1002 / spe . 4380131106 . 41 [ 30 ] Czarnecki , A . et T . Sitek . 2013 , «Ontologies vs . Rules—Comparison of Methods of Knowledge Representation Based on the Example of IT 155 CHAPITRE 7 . CONCLUSION ET PERSPECTIVES Services Management» , Information Systems Architecture and Tech - nology : Intelligent Information Systems , Knowledge Discovery , Big Data and High Performance Computing , p . 99 – 109 . 45 [ 31 ] Czarnecki , K . et S . Helsen . 2006 , «Feature - based survey of mo - del transformation approaches» , IBM Systems Journal , vol . 45 , n o 3 , p . 621 – 645 . URL http : / / ieeexplore . ieee . org / xpls / abs _ all . jsp ? arnumber = 5386627 . 62 [ 32 ] Davis , R . , H . Shrobe et P . Szolovits . 1993 , «What is a knowledge re - presentation ? » , AI magazine , vol . 14 , n o 1 , p . 17 . 6 , 34 , 35 [ 33 ] De Wolf , T . et T . Holvoet . 2004 , «Emergence versus self - organisation : Different concepts but promising when combined» , dans Internatio - nal Workshop on Engineering Self - Organising Applications , Springer , p . 1 – 15 . 50 [ 34 ] Diaz , D . et P . Codognet . 1993 , «A Minimal Extension of the WAM for clp ( FD ) . » , dans ICLP , p . 774 – 790 . 102 [ 35 ] Eardley , A . et L . Uden , éd . . 2011 , Innovative knowledge ma - nagement : concepts for organizational creativity and collabora - tive design , Information Science Reference , Hershey , PA , ISBN 9781605667010 9781605667027 . 36 [ 36 ] Eckel , B . 2003 , Thinking in JAVA , Prentice Hall Professional . 34 , 46 [ 37 ] EDF , EADS et PhiMeca . 2013 , «Reference guide OpenTURNS version 1 . 1» , URL http : / / trac . openturns . org / wiki / Documentation . 26 [ 38 ] Ellison , S . L . R . , M . Rosslein , A . Williams et collab . . 2000 , «Quanti - fying uncertainty in analytical measurement» , dans Eurachem / CITAC Guide , Eurachem . 26 [ 39 ] Farrance , I . et R . Frenkel . 2012 , «Uncertainty of measurement : A review of the rules for calculating uncertainty components through functional relationships» , The Clinical Biochemist Reviews , vol . 33 , n o 2 , p . 49 – 75 , ISSN 0159 - 8090 . URL http : / / www . ncbi . nlm . nih . gov / pmc / articles / PMC3387884 / . 26 [ 40 ] Finkelstein , L . 2009 , «Widely - deﬁned measurement - an ana - lysis of challenges» , Measurement , vol . 42 , n o 9 , doi : http : / / dx . doi . org / 10 . 1016 / j . measurement . 2009 . 03 . 009 , p . 1270 – 1277 , ISSN 0263 - 2241 . URL http : / / www . sciencedirect . com / science / 156 CHAPITRE 7 . CONCLUSION ET PERSPECTIVES article / pii / S0263224109000645 , < ce : title > Concerning Founda - tional Concepts of Measurement Special Issue Section < / ce : title > . 25 [ 41 ] Fitting , M . 2012 , First - order logic and automated theorem proving , Springer Science & Business Media . 41 [ 42 ] Foster , M . P . 2013 , «Quantities , units and computing» , Computer Standards & Interfaces , vol . 35 , n o 5 , doi : http : / / dx . doi . org / 10 . 1016 / j . csi . 2013 . 02 . 001 , p . 529 – 535 , ISSN 0920 - 5489 . URL http : / / www . sciencedirect . com / science / article / pii / S0920548913000160 . 7 , 27 , 70 [ 43 ] Foucart , S . 2006 , «Modèle de composants pour le développement d’agents logiciels . MALICE» , cahier de recherche , Université de Montpellier II , Université de Montpellier II . 48 , 51 [ 44 ] Fowler , M . 1997 , Analysis patterns : reusable object models , Addison Wesley Professional , ISBN 0201895420 9780201895421 . 47 [ 45 ] Fowler , M . 2010 , Domain - speciﬁc languages , Pearson Education . 7 , 54 , 55 [ 46 ] Frysinger , J . R . «Metric Methods : SI Charts , Visualizing The Interna - tional System of Units ( SI ) » , URL http : / / www . metricmethods . com / Resources . php . 98 [ 47 ] García - Magariño , I . et G . Palacios - Navarro . 2016 , «A model - driven approach for constructing ambient assisted - living multi - agent sys - tems customized for Parkinson patients» , Journal of Systems and Software , vol . 111 , doi : 10 . 1016 / j . jss . 2015 . 09 . 014 , p . 34 – 48 , ISSN 01641212 . URL http : / / linkinghub . elsevier . com / retrieve / pii / S0164121215002083 . 62 [ 48 ] Garlan , D . et M . Shaw . 1993 , «An introduction to software architec - ture» , Advances in software engineering and knowledge engineering , vol . 1 , n o 3 . 4 . 50 [ 49 ] Grosan , C . et A . Abraham . 2011 , «Rule - Based Expert Systems» , dans Intelligent Systems : A Modern Approach , édité par C . Grosan et A . Abraham , Springer Berlin Heidelberg , Berlin , Heidelberg , ISBN 978 - 3 - 642 - 21004 - 4 , p . 149 – 185 . URL http : / / dx . doi . org / 10 . 1007 / 978 - 3 - 642 - 21004 - 4 _ 7 . 42 157 CHAPITRE 7 . CONCLUSION ET PERSPECTIVES [ 50 ] Guarino , N . , D . Oberle et S . Staab . 2009 , «What Is an Ontology ? » , dans Handbook on Ontologies , édité par S . Staab et R . Studer , Sprin - ger Berlin Heidelberg , Berlin , Heidelberg , ISBN 978 - 3 - 540 - 92673 - 3 , p . 1 – 17 . URL http : / / dx . doi . org / 10 . 1007 / 978 - 3 - 540 - 92673 - 3 _ 0 , dOI : 10 . 1007 / 978 - 3 - 540 - 92673 - 3 _ 0 . 28 [ 51 ] Habra , N . , A . Abran , M . Lopez et A . Sellami . 2008 , «A fra - mework for the design and veriﬁcation of software measu - rement methods» , Journal of Systems and Software , vol . 81 , n o 5 , doi : http : / / dx . doi . org / 10 . 1016 / j . jss . 2007 . 07 . 038 , p . 633 – 648 , ISSN 0164 - 1212 . URL http : / / www . sciencedirect . com / science / article / pii / S0164121207002336 , < ce : title > Software Process and Product Measurement < / ce : title > . 70 [ 52 ] Hall , B . D . 2006 , «Component interfaces that support measure - ment uncertainty» , Computer Standards & Interfaces , vol . 28 , n o 3 , doi : http : / / dx . doi . org / 10 . 1016 / j . csi . 2005 . 07 . 009 , p . 306 – 310 , ISSN 0920 - 5489 . URL http : / / www . sciencedirect . com / science / article / pii / S0920548905001066 . 26 [ 53 ] Hand , D . J . 1996 , «Statistics and the theory of measurement» , Journal of the Royal Statistical Society . Series A ( Statistics in Society ) , vol . 159 , n o 3 , p . pp . 445 – 492 , ISSN 09641998 . URL http : / / www . jstor . org / stable / 2983326 . 24 [ 54 ] Hannemann , J . et G . Kiczales . 2002 , «Design pattern implementation in Java and AspectJ» , dans ACM Sigplan Notices , vol . 37 , ACM , p . 161 – 173 . 47 [ 55 ] Harel , D . et B . Rumpe . 2000 , «Modeling Languages : Syntax , Seman - tics and All That Stuff , Part I : The Basic Stuff» , cahier de recherche , Weizmann Science Press of Israel , Jerusalem , Israel , Israel . 52 [ 56 ] Harel , D . et B . Rumpe . 2004 , «Meaningful modeling : what’s the se - mantics of " semantics " ? » , Computer , vol . 37 , n o 10 , doi : 10 . 1109 / MC . 2004 . 172 , p . 64 – 72 , ISSN 0018 - 9162 . 7 , 53 , 56 , 126 [ 57 ] Henrio , L . , F . Kammüller et M . Rivera . 2009 , «An asynchronous distri - buted component model and its semantics» , dans FMCO ( Formal Me - thods for Components and Objects ) - 08 , Sophia antiopolis , France . URL http : / / hal . inria . fr / inria - 00435145 . 48 , 51 158 CHAPITRE 7 . CONCLUSION ET PERSPECTIVES [ 58 ] Hodgson , R . , P . J . Keller , J . Hodges et J . Spivak . 2013 , «QUDT - quanti - ties , units , dimensions and types» , URL http : / / www . qudt . org / . 28 , 70 [ 59 ] Hollingsworth , D . et U . Hampshire . 1993 , «Workﬂow management coalition the workﬂow reference model» , Workﬂow Management Coalition , vol . 68 , p . 26 . 110 [ 60 ] Horn , A . 1951 , «On sentences which are true of direct unions of algebras» , The Journal of Symbolic Logic , vol . 16 , n o 01 , doi : 10 . 2307 / 2268661 , p . 14 – 21 , ISSN 0022 - 4812 , 1943 - 5886 . URL https : / / www . cambridge . org / core / product / identifier / S0022481200102385 / type / journal _ article . 44 [ 61 ] Inc , E . A . 2010 , Sparx Systems . 55 [ 62 ] Ishikawa , K . 1986 , Guide to quality control , Quality Resources . 26 [ 63 ] ISO . 2009 , «Iso 80000 - 1 : 2009 quantities and units – part 1 : Gene - ral» , International Standards Organization . 23 [ 64 ] ISO . 2011 , «ISO 19156 : 2011 geographic information – observations and measurements» , International Standards Organization . 27 , 70 [ 65 ] Jackson , P . 1986 , Introduction to expert systems , Addison - Wesley Pub . Co . , Reading , MA . 35 , 36 [ 66 ] Jennings , N . R . 2000 , «On agent - based software engineering» , Artiﬁcial Intelligence , vol . 117 , n o 2 , doi : http : / / dx . doi . org / 10 . 1016 / S0004 - 3702 ( 99 ) 00107 - 1 , p . 277 – 296 , ISSN 0004 - 3702 . URL http : / / www . sciencedirect . com / science / article / pii / S0004370299001071 . 51 [ 67 ] Klatt , B . 2007 , «Xpand : A closer look at the model2text transforma - tion language» , Language , vol . 10 , n o 16 , p . 2008 . 64 [ 68 ] Knuth , D . E . 1964 , «Backus normal form vs . backus naur form» , Com - munications of the ACM , vol . 7 , n o 12 , p . 735 – 736 . 56 [ 69 ] Kolski , C . , P . Forbrig , B . David , P . Girard , C . Tran et H . Ezzedine . 2009 , «Agent - based architecture for interactive system design : Current approaches , perspectives and evaluation» , dans Human - Computer Interaction . New Trends , Lecture Notes in Computer Science , vol . 5610 , édité par J . Jacko , Springer Berlin Heidelberg , 159 CHAPITRE 7 . CONCLUSION ET PERSPECTIVES ISBN 978 - 3 - 642 - 02573 - 0 , p . 624 – 633 . URL http : / / dx . doi . org / 10 . 1007 / 978 - 3 - 642 - 02574 - 7 _ 70 . 50 , 51 [ 70 ] Krantz , D . , D . Luce , P . Suppes et A . Tversky . 1971 , Foundations of Measurement , Vol . I : Additive and Polynomial Representations , NY Academic Press . 6 , 24 [ 71 ] Krötzsch , M . , F . Simancik et I . Horrocks . 2012 , «A Description Logic Primer» , CoRR , vol . abs / 1201 . 4089 . URL http : / / arxiv . org / abs / 1201 . 4089 . 43 [ 72 ] Lamo , Y . , X . Wang , F . Mantz , ø . Bech , A . Sandven et A . Rutle . 2013 , «DPF Workbench : a multi - level language workbench for MDE» , Pro - ceedings of the Estonian Academy of Sciences , vol . 62 , n o 1 , doi : 10 . 3176 / proc . 2013 . 1 . 02 , p . 3 , ISSN 1736 - 6046 . 59 , 61 , 111 [ 73 ] Liang , V . - C . et C . J . J . Paredis . 2004 , «A port ontology for concep - tual design of systems» , Journal of Computing and Information Science in Engineering , vol . 4 , n o 3 , doi : 10 . 1115 / 1 . 1778191 , p . 206 , ISSN 15309827 . URL http : / / ComputingEngineering . asmedigitalcollection . asme . org / article . aspx ? articleid = 1400017 . 48 [ 74 ] Lloyd , J . W . 1994 , «Practical Advtanages of Declarative Program - ming . » , dans GULP - PRODE ( 1 ) , p . 18 – 30 . 35 [ 75 ] Lloyd , J . W . 2012 , Foundations of logic programming , Springer Science & Business Media . 42 [ 76 ] Luce , R . D . et L . Narens . 1994 , «Fifteen problems concerning the representational theory of measurement» , Patrick suppes : scientiﬁc philosopher , p . 219 – 249 . 25 [ 77 ] Mannion , M . 2002 , «Using First - Order Logic for Product Line Mo - del Validation» , dans Software Product Lines : Second International Conference , SPLC 2 San Diego , CA , USA , August 19 – 22 , 2002 Pro - ceedings , édité par G . J . Chastek , Springer Berlin Heidelberg , Berlin , Heidelberg , ISBN 978 - 3 - 540 - 45652 - 0 , p . 176 – 187 . URL http : / / dx . doi . org / 10 . 1007 / 3 - 540 - 45652 - X _ 11 , dOI : 10 . 1007 / 3 - 540 - 45652 - X _ 11 . 7 [ 78 ] Mari , L . 2013 , «A quest for the deﬁnition of measurement» , Measu - rement , vol . 46 , n o 8 , doi : http : / / dx . doi . org / 10 . 1016 / j . measurement . 2013 . 04 . 039 , p . 2889 – 2895 , ISSN 0263 - 2241 . URL http : / / www . 160 CHAPITRE 7 . CONCLUSION ET PERSPECTIVES sciencedirect . com / science / article / pii / S0263224113001504 . 25 , 105 , 152 [ 79 ] Mariem Mahfoudh . 2015 , «Adaptation d’ontologies avec les grammaires de graphes typés : évolution et fusion» , DOI : 10 . 13140 / RG . 2 . 1 . 4995 . 6563 . 42 [ 80 ] Mazanec , M . et O . Macek . 2012 , «On General - purpose Textual Mode - ling Languages» , dans Proceedings of the Dateso 2012 Annual Inter - national Workshop on DAtabases , TExts , Speciﬁcations and Objects , Zernov , Rovensko pod Troskami , Czech Republic , April 18 , 2012 , p . 1 – 12 . URL http : / / ceur - ws . org / Vol - 837 / paper10 . pdf . 55 [ 81 ] Mehta , N . R . , N . Medvidovic et S . Phadke . 2000 , «Towards a taxo - nomy of software connectors» , dans Proceedings of the 22nd inter - national conference on Software engineering , ACM , p . 178 – 187 . 49 [ 82 ] Metzger , A . 2005 , «A Systematic Look at Model Transformations» , dans Model - Driven Software Development , édité par S . Beydeda , M . Book et V . Gruhn , Springer - Verlag , Berlin / Heidelberg , ISBN 3 - 540 - 25613 - X , p . 19 – 33 . URL http : / / link . springer . com / 10 . 1007 / 3 - 540 - 28554 - 7 _ 2 . 62 [ 83 ] Moalla , N . , H . Chettaoui , Y . Ouzrout , F . Noël et A . Bouras . 2008 , «Model - Driven Architecture to enhance interoperability between pro - duct applications» , PLM08 Proceedings , Seoul , Korea . 63 [ 84 ] Moormann , D . , P . J . Mosterman et G . Looye . 1999 , «Object - oriented computational model building of aircraft ﬂight dynamics and systems» , Aerospace Science and Technology , vol . 3 , n o 3 , doi : http : / / dx . doi . org / 10 . 1016 / S1270 - 9638 ( 99 ) 80036 - 4 , p . 115 – 126 , ISSN 1270 - 9638 . URL http : / / www . sciencedirect . com / science / article / pii / S1270963899800364 . 29 [ 85 ] Morley , C . 2007 , Processus métiers et systèmes d’information : évaluation , modélisation , mise en oeuvre , Dunod , Paris , ISBN 9782100515684 2100515683 . 110 , 111 [ 86 ] Naish , L . 1995 , «Pruning in Logic Programming» , cahier de re - cherche , University of Melbourne . 45 [ 87 ] Nwana , H . S . 1996 , «Software agents : an overview» , The Knowledge Engineering Review , vol . 11 , n o 3 , doi : 10 . 1017 / S026988890000789X , p . 205 – 244 . 50 161 CHAPITRE 7 . CONCLUSION ET PERSPECTIVES [ 88 ] OIML , BIPM , CEI , IFCC , ILAC , ISO , UICPA et UIPPA . 2008 , «Evalua - tion of measurement data - guide to the expression of uncertainty in measurement - JCGM 100 : 2008 ( GUM ) - NF ENV 13005 : 2009» , . 26 , 150 [ 89 ] OIML , BIPM , CEI , IFCC , ILAC , ISO , UICPA et UIPPA . 2012 , «Inter - national vocabulary of metrology – basic and general concepts and associated terms ( VIM ) . JCGM 200 : 2012 [ ISO / IEC guide 99 ] » , . 16 , 17 , 71 , 74 [ 90 ] O’Leary , D . E . 1998 , «Using AI in knowledge management : know - ledge bases and ontologies» , IEEE Intelligent Systems and their Ap - plications , vol . 13 , n o 3 , doi : 10 . 1109 / 5254 . 683180 , p . 34 – 39 , ISSN 1094 - 7167 . 35 , 42 [ 91 ] OMG , M . 2003 , «Guide Version 1 . 0 . 1» , Object Management Group , vol . 62 , p . 34 . 59 [ 92 ] Parr , T . 2012 , The deﬁnitive ANTLR 4 reference , The pragma - tic programmers , The Pragmatic Bookshelf , Dallas , Texas , ISBN 9781934356999 1934356999 . 56 [ 93 ] Picard , G . 2004 , Méthodologie de développement de systèmes multi - agents adaptatifs et conception de logiciels à fonctionnalité émer - gente , thèse de doctorat , Université Paul Sabatier Toulouse III . 50 [ 94 ] Pokahr , A . , L . Braubach et K . Jander . 2010 , «Unifying agent and component concepts : Jadex active components» , dans Proceedings of the 8th German conference on Multiagent system technolo - gies , MATES’10 , Springer - Verlag , Berlin , Heidelberg , ISBN 3 - 642 - 16177 - 4 , 978 - 3 - 642 - 16177 - 3 , p . 100 – 112 . URL http : / / dl . acm . org / citation . cfm ? id = 1887504 . 1887519 . 48 , 50 , 51 [ 95 ] Rabbi , F . , Y . Lamo et W . MacCaull . 2014 , «A Flexible Metamodelling Approach for Healthcare Systems» , dans 2nd European Workshop on Practical Aspects of Health Informatics ( PAHI ) , p . 115 – 128 . URL http : / / ceur - ws . org / Vol - 1251 / paper11 . pdf . 61 [ 96 ] Rabbi , F . , Y . Lamo , I . Yu et L . Kristensen . 2015 , «A Diagrammatic Ap - proach to Model Completion» , dans Proceedings of the 4th Workshop on the Analysis of Model Transformations co - located with the 18th In - ternational Conference on Model Driven Engineering Languages and Systems ( MODELS 2015 ) , Ottawa , Canada , September 28 , 2015 . , p . 56 – 65 . URL http : / / ceur - ws . org / Vol - 1500 / paper7 . pdf . 63 162 CHAPITRE 7 . CONCLUSION ET PERSPECTIVES [ 97 ] Rasiowa , H . et R . Sikorski . 1963 , The mathematics of metamathema - tics , Panstwowe Wydawnictwo Naukowe Warszawa . 37 [ 98 ] Rasse , A . 2005 , Une Approche Orientée Modèles pour la Spéci - ﬁcation , la Vériﬁcation et l’Implantation des Systèmes Logiciels Critiques , Electronique , electrotechnique et automatique , MIPS - Laboratoire Modélisation , Intelligence , Processus , Systèmes , Univer - sité de Haute - Alsace . 48 , 50 , 51 , 116 , 117 , 124 [ 99 ] Rijgersberg , H . 2013 , Semantic support for quantitative research , thèse de doctorat , s . n . ] , S . l . 28 [ 100 ] Rijgersberg , H . , M . van Assem et J . Top . 2013 , «Ontology of units of measure and related concepts» , Semantic Web , vol . 4 , n o 1 , doi : 10 . 3233 / SW - 2012 - 0069 , p . 3 – 13 . URL http : / / iospress . metapress . com / index / M57R51P2417602N2 . pdf . 70 [ 101 ] Ritchie , C . 2008 , Database principles and design , Cengage Learning , London , ISBN 978 - 1 - 84480 - 540 - 2 . OCLC : 176925731 . 35 [ 102 ] Robins , J . , D . Redmiles et D . Hilbert . 1999 , ArgoUML . 55 [ 103 ] Roques , A . 2012 , PlantUML . 55 [ 104 ] Rose , L . M . , R . F . Paige , D . S . Kolovos et F . A . Polack . 2008 , «The epsilon generation language» , dans European Conference on Model Driven Architecture - Foundations and Applications , Springer , p . 1 – 16 . 64 [ 105 ] Royer , J . - C . et M . Xu . 2003 , «Analysing mailboxes of asynchro - nous communicating components» , dans On The Move to Mea - ningful Internet Systems 2003 : CoopIS , DOA , and ODBASE , Lec - ture Notes in Computer Science , vol . 2888 , édité par R . Meers - man , Z . Tari et D . Schmidt , Springer Berlin Heidelberg , ISBN 978 - 3 - 540 - 20498 - 5 , p . 1421 – 1438 . URL http : / / dx . doi . org / 10 . 1007 / 978 - 3 - 540 - 39964 - 3 _ 89 . 50 [ 106 ] Rumbaugh , J . , I . Jacobson et G . Booch . 2004 , Uniﬁed Modeling Lan - guage Reference Manual , The ( 2Nd Edition ) , Pearson Higher Educa - tion , ISBN 0 - 321 - 24562 - 8 . 54 [ 107 ] Rumpe , B . et R . France . 2011 , «Variability in UML language and semantics» , Software & Systems Modeling , vol . 10 , n o 4 , doi : 10 . 1007 / s10270 - 011 - 0210 - 3 , ISSN 1619 - 1366 , 1619 - 1374 . 54 163 CHAPITRE 7 . CONCLUSION ET PERSPECTIVES [ 108 ] Rutle , A . , H . Wang et W . MacCaull . 2013 , «A Formal Diagrammatic Approach to Compensable Workﬂow Modelling» , dans Foundations of Health Information Engineering and Systems , vol . 7789 , édité par D . Hutchison , T . Kanade , J . Kittler , J . M . Kleinberg , F . Mattern , J . C . Mitchell , M . Naor , O . Nierstrasz , C . Pandu Rangan , B . Stef - fen , M . Sudan , D . Terzopoulos , D . Tygar , M . Y . Vardi , G . Weikum , J . Weber et I . Perseil , Springer Berlin Heidelberg , Berlin , Heidel - berg , ISBN 978 - 3 - 642 - 39087 - 6 , 978 - 3 - 642 - 39088 - 3 , p . 194 – 212 . URL http : / / link . springer . com / 10 . 1007 / 978 - 3 - 642 - 39088 - 3 _ 13 . 61 [ 109 ] SAMUEL , K . , L . OBRST , S . STOUTENBERG , K . FOX , P . FRANKLIN , A . JOHNSON , K . LASKEY , D . NICHOLS , S . LOPEZ , J . PETERSON et e . al . 2008 , «Translating OWL and semantic web rules into prolog : Moving toward description logic programs» , Theory and Practice of Logic Programming , vol . 8 , n o 3 , doi : 10 . 1017 / S1471068407003249 , p . 301 – 322 . 45 [ 110 ] Sandven , A . 2012 , Metamodel based Code Generation in DPF Edi - tor , informatique , Department of Informatics , University of Bergen , Department of Computing , Mathematics and Physics Bergen Univer - sity College , Norway . URL http : / / dl . acm . org / citation . cfm ? id = 359723 . 64 , 111 , 126 , 127 [ 111 ] Schadow , G . et C . J . McDonald . 2009 , «The uniﬁed code for units of measure» , Regenstrief Institute and UCUM Organization : Indiana - polis , IN , USA . 27 , 70 [ 112 ] Schnabel , M . C . et S . Watanebe . 2013 , «Boost c + + libraries boost . units 1 . 1 . 0» , URL http : / / www . boost . org / doc / libs / 1 _ 55 _ 0 / doc / html / boost _ units . html . 29 [ 113 ] Sears , A . 1993 , «Layout appropriateness : A metric for evaluating user interface widget layout» , IEEE Transactions on Software Engi - neering , vol . 19 , n o 7 , p . 707 – 719 . 110 [ 114 ] Sendall , S . et W . Kozaczynski . 2003 , «Model transformation : the heart and soul of model - driven software development» , IEEE Software , vol . 20 , n o 5 , doi : 10 . 1109 / MS . 2003 . 1231150 , p . 42 – 45 , ISSN 0740 - 7459 . URL http : / / ieeexplore . ieee . org / lpdocs / epic03 / wrapper . htm ? arnumber = 1231150 . 62 [ 115 ] Rodrigues da Silva , A . 2015 , «Model - driven engineering : A sur - vey supported by the uniﬁed conceptual model» , Computer Lan - guages , Systems & Structures , doi : 10 . 1016 / j . cl . 2015 . 06 . 001 , ISSN 164 CHAPITRE 7 . CONCLUSION ET PERSPECTIVES 14778424 . URL http : / / linkinghub . elsevier . com / retrieve / pii / S1477842415000408 . 8 , 57 [ 116 ] Smith , F . et M . Proietti . 2014 , «Ontology - based Representation and Reasoning on Process Models : A Logic Programming Approach» , arXiv preprint arXiv : 1410 . 1776 . URL http : / / arxiv . org / abs / 1410 . 1776 . 45 [ 117 ] Steinberg , D . , F . Budinsky , E . Merks et M . Paternostro . 2008 , EMF : eclipse modeling framework , Pearson Education . 59 [ 118 ] Stephenson , A . G . , L . S . LaPiana , D . R . Mulville , P . J . Rutledge , F . H . Bauer , D . Folta , G . A . Dukeman , R . Sackheim et P . Norvig . 1999 , «Mars climate orbiter mishap investigation board phase I report november 10 , 1999» , URL http : / / www . cs . cmu . edu / ~ . / 15 - 610 / READINGS / required / casestudies / mco - report - 1999 . pdf . 3 , 21 [ 119 ] Stevens , S . S . 1946 , «On the theory of scales of measurement» , Science , vol . 103 , n o 2684 , p . 677 – 680 . 6 , 24 , 25 [ 120 ] Stobo , J . 1989 , Problem solving with Prolog , Pitman , London , ISBN 978 - 0 - 273 - 02933 - 5 . OCLC : 19266584 . 42 [ 121 ] Stroustrup , B . 1995 , The C + + programming language , Pearson Edu - cation India . 34 [ 122 ] Sujeeth , A . K . , K . J . Brown , H . Lee , T . Rompf , H . Chaﬁ , M . Odersky et K . Olukotun . 2014 , «Delite : A Compiler Architecture for Performance - Oriented Embedded Domain - Speciﬁc Languages» , ACM Trans . Embed . Comput . Syst . , vol . 13 , n o 4s , doi : 10 . 1145 / 2584665 , p . 134 : 1 – 134 : 25 , ISSN 1539 - 9087 . URL http : / / doi . acm . org / 10 . 1145 / 2584665 . 150 [ 123 ] Torchiano , M . , F . Ricca et P . Tonella . 2010 , «Empirical comparison of graphical and annotation - based re - documentation approaches» , IET software , vol . 4 , n o 1 , p . 15 – 31 . 55 [ 124 ] Tran , C . D . , H . Ezzedine et C . Kolski . 2013 , «EISEval , a generic re - conﬁgurable environment for evaluating agent - based interactive sys - tems» , International Journal of Human - Computer Studies , vol . 71 , n o 6 , doi : http : / / dx . doi . org / 10 . 1016 / j . ijhcs . 2013 . 02 . 001 , p . 725 – 761 , ISSN 1071 - 5819 . URL http : / / www . sciencedirect . com / science / article / pii / S1071581913000098 . 50 165 CHAPITRE 7 . CONCLUSION ET PERSPECTIVES [ 125 ] Vestbø , E . , L . Kristensen et Y . Lamo . 2014 , Application of Model Transformations and State Spaces for Veriﬁcation of Diagrammatic Workﬂow Models , thèse de doctorat , Department of Informatics , Uni - versity of Bergen , Department of Computing , Mathematics and Phy - sics Bergen University College , Norway . URL http : / / dpf . hib . no / wp - content / uploads / Vestbo14 . pdf . 61 [ 126 ] Walter , T . , F . S . Parreiras et S . Staab . 2009 , «Ontodsl : An ontology - based framework for domain - speciﬁc languages» , dans International Conference on Model Driven Engineering Languages and Systems , Springer , p . 408 – 422 . 56 [ 127 ] Walter , T . , F . S . Parreiras et S . Staab . 2014 , «An ontology - based fra - mework for domain - speciﬁc modeling» , Software & Systems Mode - ling , vol . 13 , n o 1 , doi : 10 . 1007 / s10270 - 012 - 0249 - 9 , p . 83 – 108 , ISSN 1619 - 1374 . 42 , 56 [ 128 ] Wang , A . J . A . 2005 , Component - oriented programming , Wiley , Hobo - ken , N . J , ISBN 0471644463 . 48 [ 129 ] Wang , H . , A . Rutle et W . MacCaull . 2012 , «A formal diagramma - tic approach to timed workﬂow modelling» , dans Theoretical As - pects of Software Engineering ( TASE ) , 2012 Sixth International Sym - posium on , IEEE , p . 167 – 174 . URL http : / / ieeexplore . ieee . org / xpls / abs _ all . jsp ? arnumber = 6269641 . 61 [ 130 ] Warmer , J . B . et A . G . Kleppe . 1998 , «The Object Constraint Lan - guage : Precise Modeling With Uml ( Addison - Wesley Object Techno - logy Series ) » , . 56 , 60 [ 131 ] WFMC . 1999 , «Terminology and glossary» , cahier de recherche WFMC - TC - 1011 , Issue 3 . 0 , Workﬂow Management Coalition . URL http : / / www . wfmc . org / standards / docs / TC - 1011 _ term _ glossary _ v3 . pdf . 110 [ 132 ] Wielemaker , J . 2009 , Logic programming for knowledge - intensive in - teractive applications , thèse de doctorat , University of Amsterdam . Http : / / dare . uva . nl / en / record / 300739 . 42 [ 133 ] Wielemaker , J . , T . Schrijvers , M . Triska et T . Lager . 2012 , «SWI - Prolog» , Theory and Practice of Logic Programming , vol . 12 , n o 1 - 2 , p . 67 – 96 , ISSN 1471 - 0684 . 42 , 45 , 69 , 99 [ 134 ] Wolfgang , P . 1994 , Design patterns for object - oriented software de - velopment , Reading , Mass . : Addison - Wesley . 47 166 Annexe A Liste des contributions scientiﬁques Publications scientiﬁques Publications avec comité de lecture — F . Bourgeois , P . Studer , B . Thirion , and J . - M . Perronne , “A Domain Spe - ciﬁc Platform for Engineering Well Founded Measurement Applica - tions” , in Proceedings of the 10th International Conference on Soft - ware Engineering and Applications , 2015 , pp . 309 - 318 . DOI : 10 . 5220 / 0005512103090318 — F . Bourgeois , P . Studer , B . Thirion , and J . - M . Perronne , “Datapipe” pre - sented in the European Project Space , a satellite event of the 10th International Conference on Software Engineering and Applications , 2015 . DOI : 10 . 5220 / 0006163700750096 Présentations sans comité de lecture — F . Bourgeois , P . Studer , B . Thirion , and J . - M . Perronne , “MEASURE , a platform for adaptive qualiﬁed mobile measuring system creation” , Journée Doctorale Sciences de l’Université de Haute - Alsace , 2015 — F . Bourgeois and P . Arlaud , “Datapipe : a Conﬁgurable Oil & Gas Au - tomated Data Processor” , in The Success of European Projects using New Information and Communication Technologies , SCITEPRESS , 2016 Soumis — F . Bourgeois , P . Studer , B . Thirion , and J . - M . Perronne , “A Domain Spe - ciﬁc Platform for Engineering Well Founded Measurement Applica - I ANNEXE A . LISTE DES CONTRIBUTIONS SCIENTIFIQUES tions” Interventions — Président de session : 10th International Conference on Software En - gineering and Applications , 2015 Projets industriels utilisant les travaux — Mobile Measure Actimage GmbH & Hochschule Offenburg . Financé par le ministère fédéral de l’économie et de la technologie ( BMWI ) , c’est un AIF Projekt dans le cadre du programme ZIM ( Zentrales Inno - vationsprogramm Mittelstand ) . Les deux buts du projet sont : l’étude d’approches pour l’utilisation d’instruments de mesures connectés avec des application mobiles ; le développement d’un capteur de mesures 3D de haute précision connecté ainsi que son intégration dans une application mobile . C’est la source des ﬁnancements de ces travaux . Le projet s’est soldé par la création d’un système de vériﬁcation des procédures de mesure conçu à l’aide des règles de la métrologie mo - délisées en logique du premier ordre . — Datapipe Actimage Consulting Sas & Dalim Software & Ovation Data Services Inc Uk & Root6 Ltd . . Datapipe est un projet européen FP7 EUREKA Eurostar de la commission européenne . Le but du projet est de proposer une plateforme pour la gestion , l’analyse , la publication et l’afﬁchage de données issues de l’exploration de poches de gaz ou d’huile . Ces données sont hétérogènes et stockées sur des supports multiples . La plateforme emploie un système automatisant la selection de la procédure à appliquer sur les données à l’aide d’un système em - ployant un ensembe de règles modélisés en logique du premier ordre . Ce système de règle est issu des travaux de recherche . C’est les be - soins de ce projets qui ont poussé à intégrer le système de vériﬁcation au sein d’une plateforme d’automatisée les interactions entre diffé - rents systèmes . — Alubar Actimage GmbH & Fraunhofer ( IZM & IPK ) & Siemens AG & Universität Bielefeld ( CITEC ) . Le projet ALUBAR ( Adaptives Lern - und Unterstützungssystem basierend auf Augmented Reality ou sys - tème d’apprentissage adaptif et de soutien basé sur la réalité aug - mentée ) est un projet de recherche innovant soutenu par le ministère fédéral de l’éducation et de la recherche allemand . Il regroupe plu - sieurs laboratoires de recherches et industriels autour de la théma - II ANNEXE A . LISTE DES CONTRIBUTIONS SCIENTIFIQUES tique de l’utilisation des nouvelles technologies ( plateformes mobiles , réalité augmentée , intelligence artiﬁcielle ) pour accompagner les in - tervenants dans leurs opérations de manutention nécessitant l’utilisa - tion des deux mains dans des environnements permettant des mouve - ments restreints . Ce projet à donné naissance à la plateforme Actinote 4 . 0 de Actimage . Cette plateforme permet la modélisation et l’implan - tation dans des applications mobiles de procédures assistant les in - tervenants . Cette plateforme utilise les concepts de modélisation et d’implantation de procédures issues des travaux de thèse . Un système limité pour la vériﬁcation de procédures de mesure a également été implanté dans la plateforme . III ANNEXE A . LISTE DES CONTRIBUTIONS SCIENTIFIQUES IV Annexe B Liste des acronymes CGS Système d’unité Centimètre , Gramme , Seconde . 20 DPF Diagrammatic Predicate Framework . 59 , 61 , 111 , 148 DSL langage dédié , ou Domain Speciﬁc Language . 7 , 54 , 55 , 111 EMAML Langage pour la description de conﬁguration d’application de me - sure , ou Executable Measurement Application Model Language . 7 , 11 , 121 , 149 EMF Eclipse Modelling Framework . 59 , 60 FOL logique du premier ordre . 37 – 39 , 41 , 43 , 44 , 72 GPL langage générique , ou General Purpose Language . 54 GUM Guide pour l’expression de l’incertitude des mesurages . 26 IDM Ingénierie Dirigée par les Modèles , ou Model Driven Engineering . 8 , 57 , 69 , 108 , 111 , 148 , 149 IHM Interface Humain - Machine . 110 ISQ système international de grandeurs . 23 JCGM Joint Committee for Guides in Metrology . 17 KR représentation des connaissances . 34 – 37 , 41 – 45 , 68 , 72 , 76 , 145 , 151 M2APP Transformation permettant la génération d’une d’application de - puis un modèle de spéciﬁcation , ou Model to Application . 8 , 10 , 125 , 129 , 149 M2M modèle vers model , ou Model to Model . 63 V Liste des acronymes M2T modèle vers texte , ou Model to Text . 62 , 63 , 126 , 127 M2VQ Transformation permettant l’extraction de requêtes de vériﬁcations depuis un modèle de spéciﬁcation , ou Model to Veriﬁcation Query . 8 , 125 , 149 MAML Langage de modélisation d’application d’assistance à la mesure , ou Measure Application Modelling Language . 7 , 11 , 72 , 108 – 111 , 114 , 148 MCM modèle conceptuel de la métrologie , ou Metrology Conceptual Mo - del . 69 , 70 , 86 MDA architecture dirigée par les modèles , ou Model Driven Architecture . 58 MKQL Langage de requêtes de vériﬁcation de procédures de mesures , ou Measurement Knowledge Query Language . 7 , 11 , 68 , 86 , 99 , 125 , 148 MKS Schéma des connaissances de la métrologie , ou Metrology Know - ledge Schema . 10 , 68 , 72 , 80 , 81 , 108 , 148 NIST National Institute of Standards and Technology . 23 O & M Observations and Measurements . 27 OM Ontology of units of Measure and related concepts . 28 OMG Object Management Group . 59 QUDT Quantities , Units , Dimensions and data Types . 28 RDFS Resource Description Framework Schema . 43 RTM théorie représentationnelle de la mesure . 24 , 70 , 82 SI Système International . 17 , 23 , 70 UCUM Uniﬁed Code For Units of Measure . 27 , 28 UML Uniﬁed Modeling Language . 54 VIM Vocabulaire international de métrologie . 17 , 70 VI Annexe C Glossaire conversion opération permettant de changer la référence d’une grandeur en une autre . 19 échelle de mesure ensemble des opérations algorithmiques applicables à une grandeur . 24 étalon réalisation de la déﬁnition d’une grandeur donnée utilisée comme référence . 18 fonction de mesure Fonction de manipulation algorithmique de grandeurs . 19 grandeur Propriété d’un phénomène exprimable sous forme d’une valeur et d’une référence . 18 grandeur de base grandeur d’un sous - ensemble choisi par convention dans un système de grandeurs donné de façon à ce qu’aucune grandeur du sous - ensemble ne puisse être exprimée en fonction des autres . 23 grandeur dérivée grandeur déﬁnie , dans un système de grandeurs , en fonction des grandeurs de base de ce système . 23 incertitude de mesure paramètre non négatif qui caractérise la disper - sion des valeurs attribuées à un mesurande . 26 instrument de mesure dispositif utilisé pour faire des mesurages . 2 , 19 instrument indicateur dispositif utilisé pour afﬁcher des grandeurs . 19 langage déclaratif langage dont l’ensemble des phrases décrivent le sys - tème sans en déﬁnir l’exécution . 35 langage impératif langage dont l’ensemble des phrases constituent les actions réalisées par le système développé . 34 VII Glossaire mesurage Action de mesurer . 3 , 16 , 19 métrologie Science des mesurages et ses applications . 6 nature de grandeur Aspect commun à des grandeurs mutuellement com - parables . 23 nom spécial nom attribué à une unité dérivée du SI pour en simpliﬁer l’utilisation . 23 procédure de mesure Description détaillée d’un mesurage . 2 , 19 référence Représente une quantité connue et ﬁxe d’un évènement obser - vable . Peut être une unité de mesure mais peut également être une procédure de mesure , un matériau de référence , ou une de leurs com - binaisons . . 18 résultat de mesure Résultat d’un mesurage . 2 sémantique Signiﬁcation de l’énoncé . 7 , 39 système de grandeurs ensemble de grandeurs associé à un ensemble de relations non contradictoires entre ces grandeurs . 23 système expert système capable de raisonner sur les connaissances d’un domaine et d’en déduire des solutions . 36 unité Grandeur scalaire réelle , déﬁnie et adoptée par convention . 18 valeur numérique Valeur associée à une référence pour déﬁnir une gran - deur . 18 vecteur aux dimensions vecteur dont chaque dimension représente une grandeur de base du système d’unités employé . Il est la représentation canonique assimilable à toute unité d’un système . . 24 widget composants graphiques simples et réutilisables . 110 workﬂow abstraction dédiée à la modélisation de processus . 110 , 111 VIII