Code Complexity Analyser and Visualiser for Novice Programmer Siripond Mullanu Swinburne University of Technology Melbourne , Australia 101318801 @ student . swin . edu . au Sunwit Petchoo Swinburne University of Technology Melbourne , Australia 101318759 @ student . swin . edu . au Caslon Chua Swinburne University of Technology Melbourne , Australia cchua @ swin . edu . au Abstract — Code complexity can have a significant influence on software quality . With studies showing program developed by novice programmers can influence software complexity due to lack of experience , practice , and understanding of the concept of programming . This paper investigates the utilisation of machine learning techniques to analyse code complexity levels . Using a public collection of JavaScript codes , we developed a machine learning model to identify the relationship between code characteristics and complexity level . We selected six methods and performed k - fold cross - validation . It was observed that Classification and Regression Trees ( CART ) and K - Nearest Neighbours ( KNN ) yielded the best prediction results . Finally , we also implemented a visualisation tool to present the code analysis results providing a means to gain insights on JavaScript codes through their characteristics and complexity level . Keywords—Code Complexity , Machine Learning , Visualisation I . I NTRODUCTION Software is a part of daily life , and it is also one of the core subjects in computer science education . Learning to code is relevant to computing , mathematics , science , design , and technology . It requires higher problem - solving abilities [ 1 , 2 ] . However , novice programmers cannot master programming without continuous practice because an understanding of the concept does not guarantee the ability to generate a good computer program [ 3 ] . In addition , lack of skills , practice , and understanding of programming’s concept might lead to complexity in software which results in various problems [ 3 ] . There are different coding styles used by programmers . As different coding styles can produce software having the same functionality , it may result in varying levels of code complexity . Moreover , this can be dependent on the ability of programmers to write quality software . However , there is no clear and common agreement on the definition of software complexity . In the book by Zuse [ 4 ] , Ramamoorthy et al . defined software complexity as “the degree of difficulty in analysis , testing , design and implementation of software , ” while Sheppard stated that “complexity is a metaphysical property and thus not directly observable . What is required a means to link the behaviour of the product characteristics that are measurable . ” Despite ambiguous definitions , there are characteristics that are relevant to software complexity such as cost , reliability , and performance of software [ 5 ] . In measuring complexity , Malhotra and Jain defined the cyclomatic complexity number based on the number of linearly independent paths in a program , and that complexity increases with this number . Moreover , they also suggested that reliability is an inverse of complexity , when reliability decreases complexity increases [ 6 ] . Defects in software may result in a serious situation because the use of software systems is ubiquitous including life - critical systems and critical economic functions . [ 7 ] . Therefore , understanding complexity will improve software quality and help programmers , especially students improve their code quality and avoid developing complex software . Complex software has negative effects on software development process . Majority of software budget is spent on software maintenance which is a time - consuming process and requires large numbers of human resources [ 8 ] . The decrease of complexity will reduce the repetition of software maintenance and improve code standards . Furthermore , other developers can effortlessly expand or modify the code . Defect detection and vulnerability detection may also assist programmers in improving their programming skills and mitigating the possibility of creating complex software . Several studies conducted focus on using various machine learning techniques for defect prediction [ 6 , 9 ] and vulnerability detection [ 10 ] . Defects and vulnerability are the results of complexity . Supposing , we can define the level of code complexity in the early stage , this will lead to lower time in testing , software defect reduction , and better software quality . Machine learning is an effective method used to study large dataset . It can perform classification and prediction [ 11 ] . The aim of this study is to provide a better understanding of code complexity for novice programmers and assist them to improve their code quality through visualisation with code complexity predicted using machine learning techniques The paper is organised as follows : Section II describes the background of code complexity and related work . Section III presents method for this study . Section IV discusses the analysis of the data set , and the machine learning techniques used . Section V presents the visualisation of the code complexity and the analysis and evaluation of the models . Finally , Section VI draws our conclusion and future work . II . B ACKGROUND AND R ELATED W ORK In software development , two codes can perform the same functionality , and yet be totally different in terms of complexity [ 8 ] . There are several researches conducted on various aspects of complexity such as cause of code complexity , use of complexity metrics , and code characteristics . More specifically , code characteristics are commonly used for software quality prediction because they can be easily collected and suitable for any code sizes [ 9 , 11 ] . A . Cyclomatic Complexity Number Cyclomatic complexity provides a quantitative measure of the logical complexity of a code [ 12 ] . Cyclomatic complexity number ( CCN ) is defined as : (cid:2) C = E – N (cid:2)(cid:3)(cid:2)(cid:4) P (cid:2) (cid:5) Eq (cid:6)(cid:7)(cid:8)(cid:2) where E is the number of flow graph edges , N is the number of flow graph nodes and P is the number of connected components . 2020 I EEE A s i a - P ac i f i c C on f e r e n ce on C o m pu t e r S c i e n ce a nd D a t a E ng i n ee r i ng ( C S D E ) | 978 - 1 - 6654 - 1974 - 1 / 20 / $ 31 . 00 © 2020 I EEE | DO I : 10 . 1109 / C S D E 50874 . 2020 . 9411562 From Eq . 1 , cyclomatic complexity number is calculated from control flow graph of the given program . Each node represents a block of sequential code , while the edges represent control flow between nodes and a branch of decision in the program [ 13 ] . McCabe explained that given “unique entry and exit nodes , all nodes reachable from the entry , and the exit reachable from all nodes would result in all control graphs having only one connected component” [ 14 ] . For our study , we compute the cyclomatic complexity number for each function in a file , thus the number of connected components is always 1 . In the study conducted by Mohamed et al . [ 15 ] , they used the cyclomatic complexity number to represent the complexity of expected answers for programming problems from tests / assignments submitted in a programming course . They looked at the relationship between the complexity and the grade that the student obtained . They found that majority of the students , whose expected solution in a final exam have a higher complexity number , passed the exam . Result of the study assisted the researchers in the design of exam questions and allocating appropriate time for students to perform the tasks . However , the study did not present directly what factors influence code complexity . It was also not convenient for teachers and students to evaluate their code because there was no tool and visualisation provided in the research . The complexity number by itself does not clearly explain how complex a program is . It only suggests the program is more complex if complexity number is higher . For this reason , the complexity number is categorised to provide meaningful information and used for risk assessment [ 5 , 6 ] . Software Engineering Institute [ 16 ] presents CCN and corresponding meaning with risk level as shown in Table I . TABLE I . CCN AND C OMPLEXITY L EVEL Complexity Number Complexity Level Description Risk Evaluation 1 - 10 Simple Without Much Risk 11 - 20 More Complex Moderate Risk 21 - 50 Complex High Risk Greater than 50 Untestable Very High Risk Table I describes the ranges of complexity that will help programmers determine program’s risk and stability . We define risk as characteristics that could impact the time and cost in software development . A simple program with low risk indicates that the program is stable and safe to be modified or maintained , whereas a complex program with high risk may lead to failure . As complexity number can be used to determine the risk , assessing risk using complexity number allow programmers to keep the development under control . Moreover , risk evaluation is useful in change management , therefore measuring complexity will help one make an informed decision and mitigate risk . Furthermore , it can be used for test planning because complex program will require more test steps [ 16 ] . Our study utilises this interpretation when presenting the results of the code complexity analysis , B . Code Characteristics Apart from CCN , we also investigate other code characteristics . Ajami et al . [ 17 ] conducted an experiment to identify characteristics that affect code complexity . In the study , the participants were required to interpret code snippets which consisted of similar functionality but different code structures . The research pointed out that different syntactic structures affect code complexity differently . For example , for loop is usually interpreted as more complex than if statement . The study showed that syntactic structures influence code complexity . In another study conducted by Antinyan , Staron , and Sandberg [ 18 ] , they identified key characteristics that influence code complexity are nesting depth , lack of structure , and control statement ( if , for , while ) . The result of the work established that there is a relationship between code complexity and code quality . It pointed out that complexity is strongly influenced by three attributes of code quality , namely readability , understandability , and modifiability . As these three attributes are difficult to measure , this study adopted CCN and frequency count of code characteristics that are measurable to capture code complexity . III . M ETHODOLOGY Our study looked at codes in JavaScript language , because JavaScript is widely used in web application development by innumerable programmers including novice programmers [ 19 ] . We implemented a rule - based system to extract the characteristics of the JavaScript codes , and calculate the code’s CCN . The extracted characteristics and CCN are used to train and develop the machine learning model to infer the complexity level . To evaluate the model , we compare the complexity levels result with that from the CCN calculation system . Figure 1 illustrates the workflow of our study that compares the developed model against the CCN calculation . Fig . 1 . System Work Flow All information extracted and inferred complexity level are fed into a code analysis tool to generate visual outputs . A . Data Collection To investigate whether code characteristics might influence code complexity , the public JavaScript source code ( JavaScript ASTs ) were gathered from Learning from " Big Code” community which is a research community that provides numerous data sets for research and development purpose [ 20 ] . From thousands of different files , we randomly selected 1000 JavaScript files and chose 2000 functions for analysing The data set was split into training and testing data set , where 80 % of data were used to train models , while another 20 % were used to test the trained models . B . Data Processing As studies have shown that the code characteristics impacted on the level of complexity , we analysed the data set to explore correlation between the identified code characteristics . We assigned code characteristics to be feature vectors and the corresponding labels are the complexity level . Table II lists the code characteristics that are extracted from the code in the dataset . JavaScript CCN ML ML Model CCN Code Analysis Char . Extractor TABLE II . C ODE C HARACTERISTICS C1 Number of lines C2 Number of parameters C3 Frequency count of if statement C4 Frequency count of switch statement C5 Frequency count of for statement C6 Frequency count of while statement C7 Token count C . Data Properties We perform a statistical analysis of the data set that we collected . It helps us understand the data better and explore patterns , trends , and relationship between the features in the data set . 1 ) Descriptive statistics Descriptive statistics enable us to see the frequency distribution and range [ 21 ] , as this provides short summaries and overall understanding of the data . They describe the size of data , centre of the data , and data distribution . The descriptive statistics of current dataset are shown in Figure 2 . Fig . 2 . Statistical description of the data set ( C1 - code lines , C2 - parameters , C3 - if , C4 - switch , C5 - for , C6 - while , and C7 - token ) Figure 2 also shows that the function size is between 1 to 394 lines . In addition , the average token count in a function is roughly 200 which is calculated from the number of operators and operands 2 ) Univariate analysis To see the distribution of data , we visualised each feature using histograms , and box and whisker plot . It can be observed in histograms ( Figure 3 ) that selected functions normally contain 1 – 3 parameters ( C2 ) , less than 50 lines ( C1 ) , and less than 250 tokens ( C7 ) . In terms of control flow statements , if statement ( C3 ) is the most frequently used , followed by for statement ( C5 ) . A function normally consists of 0 - 10 if statements , while switch ( C4 ) and while ( C6 ) statements are rarely used . 1 ) Bivariate analysis Each code characteristic in the dataset may have a relationship between code characteristics . To investigate that , we applied scatter plot matrix to visualise these relationships between a pair of variables . Figure 4 presents the relationship between these code characteristics . Fig . 3 . Frequency distribution of characteristics ( C1 - code lines , C2 - parameters , C3 - if , C4 - switch , C5 - for , C6 - while , and C7 - token ) Fig . 4 . Scatter plot matrix for each code characteristic . C2 - parameters , C3 - if , C4 - switch , C5 - for , C6 - while , and C7 - token ) It was observed that the number of token count ( C7 ) is influenced by number of if statements ( C3 ) because there is a combination of operators and operands in the statement parentheses . It was also noted that the number of if statements ( C3 ) and token count ( C7 ) influence the number of lines . IV . M ODEL E VALUATION In selecting the appropriate model , we explored various models that are commonly used and supported by wide range of tools for supervised learning [ 22 , 23 ] . Our study looked at six models namely : Logistic Regression ( LR ) , Linear Discriminant Analysis ( LDA ) , K - Nearest Neighbours ( KNN ) , Classification and Regression Trees ( CART ) , Gaussian Naive Bayes ( NB ) and Support Vector Machines ( SVM ) . We selected each model based on its advantages . LR can perform classification and provide false positive and false negative rate . LDA is widely used for feature extraction and dimension reduction . KNN is simple and effective which is based on problems . CART can be used to construct prediction model and represent as a decision tree . NB is suitable for large dataset . Finally , SVM shows good performance in classification , regression , and prediction . [ 19 , 24 , 25 , 26 , 27 , 28 , 29 ] . We performed K - fold Cross - Validation where the value of K is 10 to identify the best model . We summarise the results in Table III showing CART as the most accurate followed by KNN . The average accuracy in Table III indicates the overall accuracy classification rate , where the mean reflects the estimated accuracy , and the standard deviation reflects the spread of the accuracy estimates . TABLE III . E VALUATION RESULT OF MACHINE LEARNING MODELS Model Mean of the Estimated accuracy Standard deviation of the estimated accuracy LR 0 . 801215 0 . 022774 LDA 0 . 805036 0 . 029649 KNN 0 . 863765 0 . 021773 CART 0 . 865707 0 . 017062 NB 0 . 762432 0 . 022478 SVM 0 . 823799 0 . 014421 We found that both CART and KNN have similar performance in terms of prediction . According to confusion matrix , the accuracy of CART is 83 % , while KNN has 85 % accuracy . In addition to evaluating the model accuracy using the confusion matrix , we also compared CNN with the model use 400 JavaScript functions that were not used in model training . Comparing the results of the calculated CCN and the inferred complexity level on the test data tabulated in Tables IV , we also found 80 % accuracy for CART and 85 % accuracy for KNN . On the wrong predictions highlighted in Table IV , both models have the same 50 - 50 split on under and over risk inference . TABLE IV . C OMPARATIVE T ABLE R ESULT B ETWEEN CCN R ISK EVALUATION AND M ACHINE L EARNING P REDICTION CART model KNN model Sample Code CCN Risk Evaluation ML Prediction CCN Risk Evaluation ML Prediction code 1 Without much risk Without much risk Without much risk Without much risk code 2 High risk Very high risk High risk Moderate risk code 3 Without much risk Without much risk Without much risk Without much risk code 4 Without much risk Without much risk Without much risk Without much risk code 5 Without much risk Moderate risk Without much risk Without much risk code 6 Moderate risk Moderate risk Moderate risk Moderate risk code 7 Without much risk Without much risk Without much risk Without much risk code 8 Without much risk Without much risk Without much risk Without much risk code 9 Without much risk Without much risk Without much risk Without much risk code 10 Without much risk Without much risk Without much risk Without much risk code 11 Without much risk Without much risk Without much risk Without much risk code 12 Without much risk Without much risk Without much risk Without much risk code 13 Moderate risk Moderate risk Moderate risk Moderate risk code 14 Without much risk Without much risk Without much risk Without much risk code 15 Moderate risk Moderate risk Moderate risk Moderate risk code 16 Without much risk Moderate risk Without much risk Moderate risk code 17 Without much risk Without much risk Without much risk Without much risk code 18 Without much risk Without much risk Without much risk Without much risk code 19 Moderate risk Moderate risk Moderate risk Moderate risk code 20 High risk Without much risk High risk Moderate risk V . C ODE A NALYSIS To present the analysis of the code to novice programmers , we developed a web - based prototype shown in Figures 5 , 6 , and 7 , and visualise the calculated data shown in Figures 8 to 15 . Fig . 5 . Web - based prototype ( User input page ) Fig . 6 . Web - based prototype ( Results page ) Fig . 7 . Web - based prototype ( Complexity level prediction page ) The backend extracts and analyses the input JavaScript file . It extracts the number of parameters and lines of code and computes and generates a summary analysis of the JavaScript code per function . The prototype provides five different visualisation outputs . A . Complexity Number The prototype calculates the CCN of each function from the uploaded file and generates results . We provide a reference table ( see Figure 8 ) for the user to interpret the obtained results . The complexity level of each function in the code is summarised in Figure 9 , while the relative CCN comparison is represented as a bar chart in Figure 10 . Fig . 8 . Complexity level reference table For illustrating the output on this paper , we used validate . js JavaScript file that contains 7 functions . The file contains code that enables us to test all features and functionalities of the prototype . Uploading validate . js will generate a series of visualisations ( Figures 9 to 15 ) . Fig . 9 . Cyclomatic complexity result of each function in validate . js Fig . 10 . CCN comparison for all functions in validate . js The prototype calculates the CCN of each function to present the complexity level of the function . Users can then see which functions need to be examined . Subsequently , they can explore statistical details to gain deeper ideas of the code complexity . B . Function details The prototype also generates a function information table that summarises the characteristics of each function such as number of variables , parameters as shown in Figure 11 . Fig . 11 . Function information summary Lines of code is a simple metric that presents the number of lines without comment or blank line [ 30 ] . While the number of lines cannot be guaranteed that the greater line of code leads to complex code , this number will help users to consider their code and make improvement if possible . The prototype also visualises lines of code per function in bar chart as shown in Figure 12 . Fig . 12 . Number of lines summary C . Conditional Statement Related works show that control structures cause negative effects on complexity . In our study , we provide frequency count of conditional statements in every function and present them accordingly as shown in Figure 13 . This allows the users to see the numbers of each statement that can be adjusted to decrease complexity . Fig . 13 . Control structure summary D . Nested Level The increase of nested level possibly results in high complexity . Thus , our study aims to provide nested level for each control structure to facilitate users to focus the complicated part of the code . Figures 14 and 15 visualise the nesting level details of the validate . js . Fig . 14 . Nested level visualisation of validate . js : Fig . 15 . Nested level data summary in validate . js VI . C ONCLUSION AND F UTURE WORK To provide a better understanding of code complexity for novice programmers as well as developers who are enthusiastic about software quality improvement , we implemented an analysis and visualisation tool using machine learning techniques . Our study examined six models to analyse the complexity of JavaScript code and the correlation between code characteristics that affect code complexity . We implemented a machine learning model utilising public JavaScript source codes . The results show that CART and KNN outperform other models for JavaScript code complexity prediction . In addition , the study shows that there are relationships between code characteristics . For example , if statement and token count increase lines of code . We also implemented a web - based prototype to visualise the code characteristics and complexity of a user code . The prototype may assist users to gain insights about their JavaScript codes , reduce code complexity and improve their code quality For our future work , we plan to explore more metrics , different programming languages , and unsupervised learning for code improvement . We also plan to look at unsupervised learning to cluster similar characteristics and study the correlation between them as well as potential characteristics that reflect the complexity levels . R EFERENCES [ 1 ] M . Mladenović , D . Krpan , and S . Mladenović , “Learning programming from Scratch” , International Conference on New Horizons in Education INTE , Jan 2017 . [ 2 ] G . K . Wong , H . Y . Cheung , E . C . Ching , and J . M . Huen , “School perceptions of coding education in K - 12 : A large scale quantitative study to inform innovative practices” , IEEE International Conference on Teaching , Assessment , and Learning for Engineering ( TALE ) , pp . 5 - 10 , Dec 2015 . [ 3 ] K . M . Ala - Mutka , “A survey of automated assessment approaches for programming assignments” , Computer science education , 15 ( 2 ) , pp . 83 - 102 , 2005 . [ 4 ] H . Zuse , “Software complexity : measures and methods” , Walter de Gruyter GmbH & Co KG , Oct 2019 . [ 5 ] H . Kaur , and G . Verma , “Software Complexity Measurement : A Critical Review , ” International Journal of Engineering and Applied Computer Science ( IJEACS ) , pp . 12 - 16 , 2016 . [ 6 ] R . Malhotra , and A . Jain , “Fault prediction using statistical and machine learning methods for improving software quality , ” Journal of Information Processing Systems , 8 ( 2 ) , pp . 241 - 262 , 2012 . [ 7 ] P . K . Bandara , G . N . Wikramanayake , and J . S . Goonethillake , “Software reliability estimation based on cubic splines” , Proceedings of the world congress on engineering , vol . 1 , 2009 . [ 8 ] E . E . Ogheneovo , “On the relationship between software complexity and maintenance costs , ” Journal of Computer and Communications , 2 ( 14 ) , p . 1 , 2014 . [ 9 ] T . Menzies , J . Greenwald , and A . Frank , “Data mining static code attributes to learn defect predictors , ” IEEE transactions on software engineering , 33 ( 1 ) , pp . 2 - 13 , 2006 . [ 10 ] X . Ban , S . Liu , C . Chen , and C . Chua , “A performance evaluation of deep (cid:826) learnt features for software vulnerability detection , ” Concurrency and Computation : Practice and Experience , 31 ( 19 ) , p . e5103 , 2019 . [ 11 ] V . Barstad , M . Goodwin , and T . Gjøsæter , “Predicting source code quality with static analysis and machine learning , ” In Norsk IKT - konferanse for forskning og utdanning , 2014 . [ 12 ] W . Florac , R . E . Park , and A . D . Carleton , “Practical software measurement : Measuring for process management and improvement , ” Software Engineering Institute , 1997 . [ 13 ] M . N . Clark , B . Salesky , C . Urmson , and D . Brenneman , “Measuring software complexity to target risky modules in autonomous vehicle systems , ” 2008 . [ 14 ] T . J . McCabe , “A complexity measure” , IEEE Transactions on software Engineering , ( 4 ) , pp . 308 - 320 , 1976 . [ 15 ] N . Mohamed , R . F . R . Sulaiman , and W . R . W . Endut , “The use of cyclomatic complexity metrics in programming performance ' s assessment . Procedia - Social and Behavioral Sciences , ” pp . 497 - 503 , Oct . 2013 . [ 16 ] M . Bray , K . Brune , D . A . Fisher , J . Foreman , and M . Gerken , “C4 Software Technology Reference Guide - A Prototype , ” Carnegie - Mellon Univ Pittsburgh Pa Software Engineering Inst , 1997 [ 17 ] S . Ajami , Y Woodbridge , D . G . Feitelson , “Syntax , predicates , idioms—what really affects code complexity ? ” Empirical Software Engineering , pp . 287 - 328 , Feb . 2019 . [ 18 ] V . Antinyan , M . Staron , and A . Sandberg , “Evaluating code complexity triggers , use of complexity measures and the influence of code complexity on maintenance time , ” Empirical Software Engineering , 22 ( 6 ) , pp . 3057 - 3087 , 2017 . [ 19 ] D . R . Patil , and J . B . Patil , “Detection of malicious javascript code in web pages” , Indian Journal of Science and Technology , 10 ( 19 ) , pp . 1 - 12 , 2017 . [ 20 ] Learning from “big code” , [ online ] Available : http : / / learnbigcode . github . io / datasets / . [ 21 ] M . J . Fisher , and A . P . Marshall , “Understanding descriptive statistics” , Australian Critical Care , 22 ( 2 ) , pp . 93 - 97 , 2009 . [ 22 ] K . Das , and R . N . Behera , “A survey on machine learning : concept , algorithms and applications” , International Journal of Innovative Research in Computer and Communication Engineering , 5 ( 2 ) , pp . 1301 - 1309 , 2017 . [ 23 ] A . Dey , “Machine learning algorithms : a review” , International Journal of Computer Science and Information Technologies , 7 ( 3 ) , pp . 1174 - 1179 , 2016 . [ 24 ] Y . Shin , and L . Williams , “An empirical model to predict security vulnerabilities using code complexity metrics” , In Proceedings of the Second ACM - IEEE international symposium on Empirical software engineering and measurement , pp . 315 - 317 , Oct . 2008 . [ 25 ] I . Chowdhury , and M . Zulkernine , M . , “Using complexity , coupling , and cohesion metrics as early indicators of vulnerabilities” , Journal of Systems Architecture , 57 ( 3 ) , pp . 294 - 313 , 2011 . [ 26 ] R . Scandariato , J . Walden , A . Hovsepyan , and W . Joosen , “Predicting vulnerable software components via text mining” , IEEE Transactions on Software Engineering , 40 ( 10 ) , pp . 993 - 1006 , 2014 . [ 27 ] J . Ye , R . Janardan , and Q . Li , “Two - dimensional linear discriminant analysis” , Advances in neural information processing systems , 17 , pp . 1569 - 1576 , 2004 . [ 28 ] M . S . Khan , and P . Coulibaly , “Application of support vector machine in lake water level prediction” , Journal of Hydrologic Engineering , 11 ( 3 ) , pp . 199 - 205 , 2006 . [ 29 ] M . Sarkar , and T . Y . Leong , “Application of K - nearest neighbors algorithm on breast cancer diagnosis problem” , In Proceedings of the AMIA Symposium , American Medical Informatics Association , p . 759 , 2000 . [ 30 ] E . Morozoff , “Using a line of code metric to understand software rework , ” IEEE software , pp . 72 - 77 , Sep 2009 .