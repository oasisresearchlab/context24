Published in IET Software Received on 31st July 2007 Revised on 22nd February 2008 doi : 10 . 1049 / iet - sen : 20070095 In Special Section on Software Evolvability ISSN 1751 - 8806 Story - driven approach to software evolution J . Rilling 1 W . J . Meng 1 R . Witte 1 P . Charland 2 1 Department of Computer Science and Software Engineering , Concordia University , Montreal , Canada 2 System of Systems Section , Defence R & D Canada – Valcartier , Que´bec , Canada E - mail : rilling @ cse . concordia . ca Abstract : From a maintenance perspective , only software that is well understood can evolve in a controlled and high - quality manner . Software evolution itself is a knowledge - driven process that requires the use and integration of different knowledge resources . The authors present a formal representation of an existing process model to support the evolution of software systems by representing knowledge resources and the process model using a common representation based on ontologies and description logics . This formal representation supports the use of reasoning services across different knowledge resources , allowing for the inference of explicit and implicit relations among them . Furthermore , an interactive story metaphor is introduced to guide maintainers during their software evolution activities and to model the interactions between the users , knowledge resources and process model . 1 Introduction Software evolution is a knowledge - driven process , with knowledge being continually integrated from different sources ( including source code repositories , documentation , test case results ) and at different levels of abstraction ( from single variables to complete system architectures ) . For maintainers to perform and complete a particular maintenance task , they typically need to use and interact with various tools and techniques ( e . g . parsers , debuggers , source code analysers , visualisation tools ) . Identifying knowledge resources that are applicable in a given maintenance context can become a major challenge for software maintainers . Furthermore , there often exist non - obvious direct or indirect dependencies among these knowledge resources that require maintainers to follow a certain sequence of steps in order to accomplish a particular evolution task . As a result , both maintainers and organisations are facing the challenge of deriving and applying procedures that provide for guidance to utilise these existing resources more efﬁciently [ 1 – 3 ] . Various process models [ 3 – 7 ] supporting the evolution of software have been introduced . Common to most software and , more speciﬁcally , software evolution process models , is that they share a generality in abstracting and describing activities to be performed and resources to be used as part of the process . This generality can become , from an organisational viewpoint , a major challenge in adopting them . Organisations often have to adapt their own internal processes to support a particular process model , and they also need to modify and customise this process model so that it can be supported or sustained as part of a larger organisational context . Organizations are often left alone in establishing context - awareness and customization of process models . From an organizational perspective , it is possible to deﬁne processes in such a detail that the resulting model not only describes the required maintenance activities , but also resources that must be employed . However , these well - deﬁned process models are typically based on the assumption that resources and the knowledge provided by these resources are known at the process speciﬁcation time , resulting in a static ( closed world ) resource and knowledge allocation . This closed world assumption , however , restricts the ability to integrate newly gained knowledge and resources within these process models . There has been little work in examining how these resources can be applied and used collaboratively to support a speciﬁc software maintenance task [ 8 ] . Maintainers are often left with no guidance on how to complete a particular task within a given context , using a set of available resources ( e . g . tools , artefacts ) . Current research in software evolution has led to a set of task - speciﬁc tools and techniques that are not integrated , due to a lack of integration standards and frameworks to allow sharing services among them . 304 IET Softw . , 2008 , Vol . 2 , No . 4 , pp . 304 – 320 & The Institution of Engineering and Technology 2008 doi : 10 . 1049 / iet - sen : 20070095 www . ietdl . org The problem of knowledge and process integration is not unique to software maintenance . Other application domains , including Internet search engines ( e . g . Google , www . google . com ) or online shopping sites ( e . g . Amazon , www . amazon . com ) are facing similar challenges . Common to these application domains is that they use different information resources to support users in a given context . For example , during an online shopping session , users will typically ﬁnd related information on other relevant products , customer reviews , product summaries and so on . Tools and techniques are utilised to enhance the shopping experience and facilitate the online shopping process . The two major challenges in applying similar approaches to support software evolution are : ( 1 ) the lack of formal models to represent and link relevant knowledge resources and process activities and ( 2 ) the resulting lack of a suitable metaphor to model the interaction between the users , the model and the relevant resources . In this research , we focus in particular on modelling the interactions between the maintainers , a process model and its relevant knowledge resources . The presented research is a continuation of our previous work on modelling programme comprehension [ 9 ] by introducing a software evolution ontology that models both software evolution process speciﬁc aspects and knowledge resources relevant to software evolution . We introduce a novel formal ontological representation that models and integrates software process speciﬁc information with software and other knowledge resources ( e . g . domain knowledge , documents , user expertise , historical data etc . ) . The goal of this common representation is to reduce the conceptual gap caused by the type of abstractions and languages found in these artefacts . Having a common ontological representation allows maintainers not only to explore knowledge relevant to their given task across the different modelled artefacts , but also to enrich their current understanding of a system and share their knowledge . Furthermore , traceability between the software processes and knowledge resources can be established by providing non - trivial relationships among these artefacts . Ontologies also provide support for extending an existing knowledge base ( KB ) to reﬂect more closely an ‘open’ world assumption [ 10 ] , by allowing for both the modelling of incomplete knowledge and the enrichment of the KB with newly gained knowledge . Moreover , having a formal ontological representation also allows us to take advantage of automated reasoning services provided by ontology reasoners to infer implicit relations ( links ) between the processes and knowledge resources . Fig . 1 shows a simpliﬁed example that restricts the available information resources to tools and tasks . Different strategies ( top - down , bottom - up or integrated approach ) are provided to support maintainers in the use of the knowledge resources and to answer questions such as : 1 . Which tools might directly or indirectly be required to perform a particular comprehension task following a top - down approach ? 2 . Given a current knowledge level acquired using a bottom - up strategy , what are the potential ( directly / indirectly ) related tasks that can be performed ? Our research is not only motivated by this need to synthesise these different information and knowledge resources used within our formal framework , but also by the ability to provide maintainers with a context directly related to a speciﬁc process activity . The acceptance of any new technology or approach is directly dependent on delivering added beneﬁts to the users or management of an organisation . For a process environment to be accepted by maintainers , it is essential that it provides a supporting framework that captures the context in which the process model is applied and that it also links resources to the process . For the contextual representation , an intuitive visual metaphor is needed to establish an interaction model between the user and the process model . We introduce a story metaphor that addresses the following three major issues : 1 . a metaphor that is familiar to users ; 2 . a metaphor that can be mapped closely to the activities of a software evolution process and its activities ; 3 . a metaphor that can be expressed at different levels of abstraction to reﬂect the different granularity of knowledge and context that need to be represented . The story metaphor not only models the interactions between the users and the ontological representation in terms of process context and resources , but it also provides the basis for developing a supporting environment . The overall goal of our research is not to provide a concrete solution to a speciﬁc software evolution activity , but rather make use of explicit and implicit knowledge found in the software maintenance domain . We focus on the integration Figure 1 Conceptual model IET Softw . , 2008 , Vol . 2 , No . 4 , pp . 304 – 320 305 doi : 10 . 1049 / iet - sen : 20070095 & The Institution of Engineering and Technology 2008 www . ietdl . org of this knowledge within the maintenance process by establishing traceability links between the process activities and applicable resources at the knowledge level , and modelling the interaction between the users and the process . Our approach differs from existing work on comprehension models [ 11 – 13 ] , tool integration [ 8 , 14 ] , and software evolution related process models [ 4 – 7 , 15 ] in several important aspects . 1 . We introduce a formal ontological representation based on description logics ( DL ) to support the modelling , integration and linking of processes ( process activities ) and knowledge resources relevant to these processes . 2 . The ability to reason about knowledge modelled using this ontological representation to infer explicit and implicit knowledge , in order to provide an active and context sensitive guidance during a software evolution process . This includes knowledge inference across multiple sub - ontologies and the ability to model incomplete knowledge . 3 . An interactive story metaphor was adopted to model the dynamic interaction aspects between the users and the comprehension process . 4 . An environment utilising the modelled knowledge , process and user interaction to guide maintainers during software maintenance tasks . The remainder of the paper is organised as follows : Section 2 provides a brief review of existing software evolution process models and their limitations . Section 3 introduces the background related to web ontology language ( OWL ) ontologies and inference services provided by ontological reasoners . Section 4 introduces the conceptualisation of software evolution and its corresponding ontological model . Section 5 introduces the story metaphor used to model the interaction between the users and the process . Section 6 discusses the implementation and validation issues , followed by Section 7 with the related work . Conclusions and future work are outlined in Section 8 . 2 Software evolution process models Historically , software lifecycle and process models have focused on the software development cycle . However , with much of a system’s operational lifetime cost occurring during the maintenance phase , this should be reﬂected in both the development practices and process models supporting maintenance activities . One approach to model software maintenance is to include software maintenance aspects as part of the total system life cycle / process model , as suggested , for example , in [ 4 , 7 ] . Other approaches to model software maintenance include deriving maintenance - speciﬁc process models . Among these maintenance - speciﬁc models are the quick - ﬁx , iterative enhancement , full - reuse model [ 4 ] , the staged model [ 5 ] , the SEI CMMI model [ 6 ] , and the IEEE Std 14764 - 2006 – Software Life Cycle Processes – Maintenance [ 7 ] . One of the challenges in applying these models is that various aspects can affect software evolution [ 12 , 16 , 17 ] , making it an inherently complex and difﬁcult problem to address . Some of these aspects inﬂuencing software evolution include a user’s comprehension ability ( e . g . experience , knowledge background ) , the characteristics of a software system to be maintained ( e . g . its application domain , size and complexity ) , the maintenance task itself to be performed ( e . g . adaptive , corrective or perfective maintenance ) , as well as the tools and software artefacts available to support the evolution . Common to most existing process models , including evolution models , is that they do not specify how any available supporting resources ( tool , system , user expertise , software artefacts etc . ) should be integrated within the process in a given context . Current research in software maintenance focuses mostly on providing conceptual guidance ( such as the documented standards ) or on developing tool support to address some speciﬁc aspects of a software maintenance task . An example of such a process model is the IEEE Std 14764 - 2006 [ 7 ] that lists and describes activities and their sub - activities , referred to as task - steps , as part of the process model . However , the standard provides only limited or no details on how to implement or perform the activities and task - steps speciﬁed in it . Common observations that can be made from most existing software evolution process models are : † They tend to provide only general descriptions of the steps involved in a process , lacking details or guidelines on how to complete these steps in a given task and / or organisational context . † They are limited in their ability to provide a cohesive integration of existing knowledge resources ( e . g . user expertise , source code information , tools ) and newly gained knowledge ( e . g . experienced gained from previously performed maintenance tasks ) within the process . † Lack of tool support that can provide users with an active , context - driven guidance during the comprehension process , to help reduce their cognitive load . 3 Ontologies and reasoning Intuitively , maintainers perform various activities while maintaining a software product . These activities include understanding , conceptualising and reasoning about the software to be maintained . Therefore support for developing a user’s mental model during software evolution 306 IET Softw . , 2008 , Vol . 2 , No . 4 , pp . 304 – 320 & The Institution of Engineering and Technology 2008 doi : 10 . 1049 / iet - sen : 20070095 www . ietdl . org is needed to assist and improve human thinking processes . Research in cognitive science has suggested that mental models may take many forms , but the content normally constitutes an ontology [ 18 ] . Ontologies have their origins in philosophy , where ontologies correspond to a theory about the nature of existence and the categories of things that exist [ 19 ] . In computer science , ontology is ‘an explicit speciﬁcation of conceptualisation’ [ 20 ] to provide a formal model of a certain domain . There exists a variety of ontology languages with different degrees of formality . Some of these languages are based on graphical notations such as semantic network , UML or RDF . Others are based on logic such as DL ( e . g . OIL , DAML þ OIL , OWL ) , rules ( e . g . prolog ) or ﬁrst - order logic ( e . g . KIF ) [ 10 , 21 , 22 ] . DLs are a family of logic - based knowledge representation formalisms [ 23 ] that can be distinguished by their formal semantics and inference services . DLs describe domains in terms of TBox ( also known as concepts or classes ) , roles ( also known as relationships or properties ) and ABox ( also known as individuals or instances ) . Particular DLs can be characterised by the set of constructors they support for building complex concepts and roles from simpler ones and the set of axioms available for asserting facts about concepts , roles and individuals [ 21 ] . Although DLs have many applications ( e . g . databases , conﬁguration , software engineering and natural language processing [ 23 ] ) , they are currently best known as the basis for formal ontological languages such as OIL , DAML þ OIL and OWL [ 21 ] . 3 . 1 Web ontology language ( OWL ) The OWL [ 21 , 24 ] is the foundation of the semantic web [ 25 ] , providing machine understandable Web information to enable automatic processing and integration of Web resources . OWL was created based on Web standards such as XML and RDF ( s ) and it exploits SHOIN ( D ) DL for supporting greater machine interpretability of Web content [ 21 ] . OWL is built on earlier DL - based ontology languages OIL and DAML þ OIL and is the current recommendation of the World Wide Web Consortium ( W3C , http : / / www . w3 . org / ) [ 24 ] . OWL has three increasingly expressive sublanguages : OWL Lite , OWL – DL and OWL Full . We adopted OWL - DL as it provides the best tradeoff between the expressiveness and reasoning power . An OWL ontology can be seen as a DL KB that consists of DL , TBox and ABox . OWL describes a domain in terms of classes , properties and individuals . OWL ontologies can be constructed incrementally by ﬁrst specifying elementary descriptions , such as simple classes and properties , and then deﬁning more complex class and property descriptions inductively through a set of OWL – DL constructors and axioms . A class description can also be used to deﬁne queries to describe the sets of individuals [ 23 ] . OWL ontologies can simply be used as a data storage medium , similar to traditional databases . However , the use of DL to deﬁne the ontological model allows for a more precise and expressive representation than traditional data semantics [ 23 ] and is also the foundation for automated reasoning support . Reasoning is a mechanism to infer implicitly represented knowledge from the knowledge that is explicitly represented in a KB [ 23 ] . DL has been designed to support both TBox ( concept ) reasoning and ABox ( individual ) reasoning . Typical reasonings for TBox are satisﬁability check to determine whether a description is satisﬁable ( can have individuals ) or subsumption test , to examine whether one description is more general than another one [ 23 ] . Concepts can be organised into a terminology hierarchy according to their generality through the use of subsumption reasoning [ 23 ] . Other TBox reasoning includes classiﬁcation and consistency check . Basic reasoning for the ABox includes instance checking , that is , whether a given individual is an instance of a certain concept . Additional ABox instance reasonings can be derived from instance checking , such as instance retrieval tuple retrieval and instance realisation . For a more detailed coverage of DL and reasoning services , we refer the reader to [ 23 , 25 ] . 3 . 2 Process ontology example In what follows , we brieﬂy illustrate the use of both ontologies and reasoning services on a simpliﬁed subset of our ontological model . Fig . 2 presents a simpliﬁed ontology that consists of four atomic concepts ( person , team , organization and project ) and three atomic roles ( manage , program and work ) . The ontology is populated with four individuals , Mike ( person ) , InfoGlue _ 001 , uDig _ 001 and Debrief _ 001 ( project ) . 3 . 2 . 1 Deﬁning new concepts : Two new concepts , Manager and Programmer , can be deﬁned to enrich the existing ontology ( Fig . 2 ) . In the following two expressions , Manager is ﬁrst deﬁned as a person who has managed some project ; likewise , Programmer can be deﬁned as a person who has performed some programming as part of a project . Based on these concept deﬁnitions , one can now verify the following assumptions about a person Mike . If the assumption ‘ Mike has programmed in a certain project such as Debrief _ 001 ’ is true , the assumption that ‘Mike is a programmer’ will also Figure 2 Simpliﬁed partial maintenance ontology IET Softw . , 2008 , Vol . 2 , No . 4 , pp . 304 – 320 307 doi : 10 . 1049 / iet - sen : 20070095 & The Institution of Engineering and Technology 2008 www . ietdl . org automatically hold . Manager ; Person u 9 manage . Project . Programmer ; Person u 9 program . Project . 3 . 2 . 2 TBox reasoning : OWL – DL allows for the speciﬁcation of a role hierarchy through the use of the subproperty axiom . The following example illustrates a TBox classiﬁcation through the use of such a subPropertyOf axiom . A new role participate can be deﬁned as a super role of manage and program , denoted as : manage v participate , program v participate . Having such a participate role speciﬁed , a new concept participant can now be deﬁned as a person who has participated previously in some projects : Participant ; Person u 9 participate . Project . Given the above knowledge , the reasoner can now infer that Manager and Programmer are both subconcepts of Participant and therefore all instances of Manager and Programmer become instances of Participant . OWL – DL also supports transitive roles . Given the transitive roles P ( x , y ) and P ( y , z ) - > P ( x , z ) . In Fig . 2 , work corresponds to such a transitive role , where a person works in a team and a team itself works on some projects . The person works in an organisation relationship is not asserted , but based on the transitive work role , the reasoner can now infer that all persons who work in a team also work for the organisation the team belongs to . 3 . 2 . 3 ABox reasoning : In addition to TBox reasoning , ABox reasoning can also be applied to perform instance checking . For example , Mike is a person and Debrief _ 001 uDig _ 001 , and InfoGlue _ 001 are three different project instances . We can now deﬁne a new concept ExperiencedProgrammer as : ExperiencedProgrammer ; Programmer u 9 (cid:2) 3program . Project . Given that Mike has programmed in three project instances ( Debrief _ 001 , uDig _ 001 and InfoGlue ) , the reasoner can now automatically infer that Mike is a project participant and also an experienced programmer . 3 . 2 . 4 Summary : Based on the above discussion , we adopted OWL – DL as the ontological modelling language for our research . OWL – DL representation is applicable to model the dynamically evolving software maintenance domain , because of its support for domain knowledge evolution ( concept , role and instance creation and population ) . In addition , it not only provides a more precise and expressive representation of the domain , but also enables automated reasoning to process the content of the represented domain . For a more detailed discussion on OWL ontologies , DL and reasoning , we refer the reader to [ 23 , 24 , 26 ] . 4 Uniﬁed ontological software evolution process model Models are essentially an abstraction of real and conceptually complex systems to represent their signiﬁcant features and characteristics [ 27 ] . For any model to provide added beneﬁts , it is essential that the model is being accepted and used by the expected users . In what follows , we introduce two criteria we applied for modelling software evolution processes and their related knowledge resources . † Support and adaptability : For a process model to be adopted by an organisation and / or end - user , the model has to be adaptable to a given organisational structure . It also has to provide additional beneﬁts to the user in the form of providing guidance in applying the model towards a speciﬁc maintenance task . † Flexibility and extendibility : Process models have to be able to adapt to ever changing maintenance contexts and knowledge resources , therefore requiring the ability to evolve over time to reﬂect these new requirements . 4 . 1 Conceptualising software evolution Building a formal ontology for software evolution requires the analysis of concepts and relations in this discourse domain . From a software practitioner’s perspective , it is therefore essential that the ontological KB includes and models concepts and roles critical to software evolution processes . Indeed , our conceptualisation work has been inﬂuenced by other works in modelling software maintenance [ 28 – 30 ] and the observations of best software maintenance practices . Our approach to construct this KB is 2 - fold : ( 1 ) We created sub - ontologies for each of the key discourse domains , such as tasks , software , documents and tools and ( 2 ) we linked them via a number of shared high - level concepts , such as artefact , task or tool , which have been modelled akin to a ( simple ) upper level ontology [ 31 ] . Fig . 3 provides a simpliﬁed view of the resulting meta - model , focusing only on the major concepts and their roles . In what follows , we brieﬂy summarise these key sub - ontologies . Task : Describes a unit of work that is triggered by an emerging modiﬁcation request ( MR ) or problem report ( PR ) . Information about MRs or PRs , task assignment , tool log ( tool used in the task solving process ) , activity log and so on is modelled in this sub - ontology . For example , 308 IET Softw . , 2008 , Vol . 2 , No . 4 , pp . 304 – 320 & The Institution of Engineering and Technology 2008 doi : 10 . 1049 / iet - sen : 20070095 www . ietdl . org the instances in this sub - ontology might be ‘Debrief XML decrypt / encrypt component substitution request’ ( an instance of concept Request ) , ‘corrective’ ( an instance for concept RequestType ) and ‘successfully ﬁnished’ ( an instance for concept TaskStatus ) . User : Describes maintainers involved in the software maintenance process . Information about the involved roles and their related skills , competencies and responsibilities are modelled . The users involved in the software maintenance can be an individual , an organisational team or an entire organisation . The example instances in this sub - ontology might be ‘Mike Smith’ ( an instance of concept Person ) , ‘SE group’ ( an instance of concept Maintainer ) and ‘MR reporter’ ( an instance of concept Role ) . Artefact : Describes artefacts associated with both the software product ( source code , documentation etc . ) and the maintenance process ( documents , models etc . ) that are produced as part of the maintenance process ( Fig . 4 ) . At the current stage , we consider artefacts to be either related to the software system or to the maintenance task . Fig . 4 shows a partial view part of the taxonomy of the artefact sub - ontology . Artefact itself is a super class of the Artefact sub - ontology , which has two sub - classes : SoftwareArtefact and TaskArtefact . The software system related artefacts are further classiﬁed into software documents , software components and libraries , and artefacts made available by supporting tools . Task - related process artefacts correspond to artefacts , such as guidelines , reports and so on . Subject system : Describes the software system to be maintained and includes information about the programming language ( s ) used , application domain and so on . Process : Describes the interactions and relationships among different sub - activities within a maintenance process model . The example instances in this sub - ontology can be ‘IEEE Std 14764 – Software Life Cycle Processes – Maintenance’ ( an instance of concept ProcessModel ) , ‘5 . 3 Modiﬁcation Implementation’ ( an instance of concept Activity ) , ‘5 . 3 . 2 . 1 Analysis’ ( an instance of concept Task ) , and ‘5 . 3 . 2 . 1 a’ ( an instance of concept TaskStep ) . Technique : Describes the software techniques that can be used for supporting software maintenance ( program comprehension technique , source code analysis technique , impact analysis technique , etc . ) . Based on the previous work by Dias et al . [ 32 ] and Pressman [ 33 ] , the following techniques supporting the following activities can be identiﬁed : requirement elicitation , maintenance support , programming related , testing , conﬁguration management , documentation and modelling technique . Tool : Describes the software tools used to carry out a function or service with the goal to simplify maintenance tasks [ 34 ] . At the current stage , our tool sub - ontology provides general categories for commonly used maintenance tools and describes their key features for supporting software maintenance activities . Tools can be classiﬁed by their functionality , their role in supporting managers and maintainers , their particular use during the various steps of a software engineering process , their supported environment ( hardware and software ) , or even by their origin or cost . Pressman [ 33 ] provides a comprehensive classiﬁcation of tools by their functions , which includes , among others , analysis , design , programming , software conﬁguration management , testing and documentation Figure 3 Software maintenance meta - model Figure 4 Partial view of the Artefact sub - ontology IET Softw . , 2008 , Vol . 2 , No . 4 , pp . 304 – 320 309 doi : 10 . 1049 / iet - sen : 20070095 & The Institution of Engineering and Technology 2008 www . ietdl . org tools . In our approach , tools and techniques in the KB are automatically classiﬁed through the use of reasoning . For example , programming tools can be classiﬁed based on their support for a particular programming language , operating system , applicability for a speciﬁc task and so on . As discussed previously , software evolution is a multifaceted and dynamic activity involving different resources , which utilises these resources to enhance the current knowledge about a system . Existing work on ontological modelling of the software engineering domain , including its processes , has focused on conceptualising the domain [ 35 , 36 ] to establish a common terminology or to model speciﬁc aspects of software engineering processes [ 34 – 37 ] . In the context of our research , we adopt core parts of these ontologies and further enrich them with new concepts and relationships to more closely reﬂect : ( 1 ) the particular needs of our particular modelling goal – establishing traceability links between the process and various knowledge process related knowledge resources and ( 2 ) provide a design that fully supports and utilises optimised DL reasoners , such as Racer [ 25 ] in our case , to infer additional knowledge . An essential part of our model is the ability to support both the knowledge acquisition and use of the newly gained knowledge . The uniﬁed ontological representation provides the ability to dynamically add new concepts and relationships , as well as new instances of these to the KB . This extendibility enables our model to be constructed in an incremental way , closely modelling the same iterative knowledge acquisition behaviour used to create a mental model as part of human cognition of a software system . Having these different sub - domains modelled as sub - ontologies also allows for the automated processing ( e . g . reasoning ) and integration of this knowledge at a concept and / or instance level . However , it would not be realistic to expect that all these sources share a single , consistent view within a maintenance task . Rather , we expect disagreements between the individual users and sub - ontologies during an analysis . We explicitly capture those different views using a representational model that attributes information to ( nested ) contexts using so - called viewpoints [ 38 ] . The detailed knowledge management strategies have been discussed already in our previous paper [ 9 ] . Having this knowledge management mechanism in place , our ontological model can evolve over time to reﬂect new maintenance contexts and knowledge resources , addressing the ﬂexibility and extendibility acceptance criteria introduced earlier . 4 . 2 Ontology - based software evolution process model For the foundation of our evolution model , we have adopted the most recent IEEE software maintenance standard [ 7 ] . The maintenance standard describes activities for both managing and executing software maintenance tasks . The starting point for the maintenance process is either a MR or PR . The maintenance process itself is detailed within the standard by six major activities : process implementation , problem and modiﬁcation analysis , modiﬁcation implementation , maintenance review / acceptance , migration and retirement . Each of these activities is again described by a set of tasks , which are further reﬁned by a list of task - steps . These task - steps correspond to the most ﬁne - grained activities described by the standards document . However , the IEEE standard , like most process models , describes only a general software maintenance process without specifying any details on how to adopt or perform these speciﬁc activities and tasks in a given maintenance context . Furthermore , the IEEE standard also lacks support on how existing knowledge and resources within an organisation can be adopted to support these process activities . Presently , we are limiting our modelling scope to a subset of these activities described within the IEEE standard , namely the problem modiﬁcation analysis , modiﬁcation implementation and acceptance phase , corresponding , respectively , to Sections 5 . 2 , 5 . 3 and 5 . 4 in the document . These activities are closely related to performing the actual maintenance task rather than addressing more global organisational issues related to software maintenance ( Sections 5 . 1 , 5 . 5 and 5 . 6 [ 17 ] ) . The major concepts ( e . g . MR , activities , tasks , task - steps and their required input and output ) and their relationships ( e . g . follows , requires , delivers ) documented in the maintenance standard have been modelled as part of our process sub - ontology . Fig . 5 shows a partial view of the ontological representation of the IEEE software maintenance process . The IEEE software maintenance model is formalised as part of our process sub - ontology , allowing for both the provision of a uniﬁed representation of process and knowledge resources and the ability to establish links between the knowledge resources and the process activities in the existing maintenance standard . In our approach , these traceability links are established through either design level links via OWL – DL axioms and relations , or at the logical level through a set of pre - deﬁned queries . In terms of the design level links , OWL – DL axioms or concepts can be used to establish the links between the process model and other knowledge resources modelled . Relationships / properties speciﬁed as OWL axioms can be used to establish implicit links as well . For example , in task - step ‘5 . 3 . 2 . 1a Identify the elements to be modiﬁed in the existing system’ [ 17 ] , the supportedBy property can be utilised to link automatically the task - step with supporting tool resources . The supportedBy relation shown in Fig . 6 is deﬁned as a transitive property used to link task - step with technique ( 1 ) as well as for linking technique with tool ( 2 ) . Then the links between the TaskStep and tools can be automatically derived through the inferred link ( 3 ) . As a result , each task - step in the process ontology can automatically be linked through this transitive supportedBy property to the sub - ontologies 310 IET Softw . , 2008 , Vol . 2 , No . 4 , pp . 304 – 320 & The Institution of Engineering and Technology 2008 doi : 10 . 1049 / iet - sen : 20070095 www . ietdl . org of technique and tool . Through further traversing of the transitive closures across the sub - ontologies , other knowledge resources can be identiﬁed ( Fig . 6 ) . In addition to these design level links , logical links between the process and the knowledge resources can be established through pre - deﬁned queries for each task - step . Fig . 7 illustrates the use of a set of pre - deﬁned queries to support different process task - steps . Users can also deﬁne their own supporting queries based on their experience to extract , explore and reason upon the information stored in the KB . These pre - deﬁned queries supporting the different task - steps allow users to retrieve explicitly modelled knowledge , as well as inferring implicit knowledge across the KB to support a particular task - step ( Fig . 7 ) . The query below shows such an implicit knowledge support through a pre - deﬁned nRQL query [ 39 ] : ( retrieve ( ? tool ? technique ) ( and ( IEEE Step5 . 3 . 2 . 1a ? tool supportedBy ) ( ? technique ? tool supportedBy ) ) ) In this query , all tools providing techniques applicable to task - step 5 . 3 . 2 . 1a in the IEEE standard will be identiﬁed . In this query , several sub - ontologies ( process , tools , techniques ) are queried to retrieve the task - step relevant information . As discussed , our uniﬁed ontological representation allows for conceptualising , storing , linking and retrieving software evolution processes and their relevant knowledge resources . Figure 5 Partial view of the process sub - ontology Figure 6 Transitive design level links Figure 7 Task supporting queries IET Softw . , 2008 , Vol . 2 , No . 4 , pp . 304 – 320 311 doi : 10 . 1049 / iet - sen : 20070095 & The Institution of Engineering and Technology 2008 www . ietdl . org Providing both pre - deﬁned and user - deﬁned queries addresses our ﬁrst acceptance criterion for the process model , related to support and adaptability . Through the use of the pre - deﬁned and user - deﬁned queries and the underlying reasoning services , our model allows customisation of the process support and also provides users with contextual information relevant to their given task . However , a metaphor is needed to represent the interaction between the users and the ontological model . In the following section , we introduce a story [ 40 , 41 ] based metaphor to model this interaction between the users and our uniﬁed ontology . 5 Software evolution story model Stories are ubiquitous , universal and readily implanted and recalled in human minds [ 42 ] . They are widely used to convey information , cultural values and experience [ 43 ] . It is suggested that humans build cognitive structures that represent real events in their lives using models similar to the ones used for narrative stories in order to better understand the world around them [ 44 ] . People usually ﬁnd it is easier to understand information integrated within a story context instead of serial lists [ 43 ] . Learners constantly adjust their understanding in accordance with their exposure to conventional narratives , making the construction of narrative a central cognitive goal [ 45 ] . 5 . 1 Story models in software engineering A story itself is a narrative , which , in its simplest form , provides a temporally ordered sequence of events ( Table 1 ) [ 46 ] . Storytelling can be applied by scripting a story of the complete system at design time or by generating stories dynamically on a per - session basis [ 41 ] . A system that can generate stories dynamically is capable of adapting the story narrative to the user’s preferences and abilities . Stories themselves can be represented in various ways , such as using text , image or animation . The story notation has already been applied in different domains . In extreme programming , stories are used as a communication media to elicit requirements . In UML , a scenario diagram is a descriptive story of a use case , detailing what happens between the users and the system for a speciﬁc function . Sequence diagrams can also be viewed as a more formal story representation of a system behaviour , delineating how operations are carried out – what messages are sent and when , by emphasising the time ordering of message passing among objects [ 47 ] . 5 . 2 Story - driven interaction model In this section , we introduce our interactive story - driven software evolution model . The major motivation for applying a story metaphor is to provide us with a metaphor that allows us to model ( map ) user interactions between the process models and knowledge resources to a visual metaphor . The story - driven metaphor not only supports the mapping of user interactions with the underlying process model and knowledge resources . It also provides the basis for developing a tool environment to support user interactions with the process model . Table 1 Story model [ 40 ] Story model Description theme overall message , concept or essence of a story ; ties every structure and dynamic element genre characters establishes an author’s overall attitude , which casts a background on all other considerations protagonist main story character – driver of the story : the one who forces the action to resolve the problem and reach the ultimate goal impact character Might be an antagonist ( desire to let the problem grow ) , guardian ( functions as a helper / teacher , a protective character who eliminates obstacles and illuminates the path ahead ) , or contagonist ( works to place obstacles in the path of the protagonist , and to lure it away from success ) etc . settings place , time , weather conditions , social conditions , or mood or atmosphere etc . plot a series of logic events that develop a story ; details the order in which the elements must occur within that story throughline the point of view and growth of the main character within the story world interaction what occurs between the characters ( or even ideas ) is presented . Interaction can occur as connections and disconnections conﬂict everything that prevents or gets in the way of the protagonist in achieving the goal climax / resolution at this point , the obstacles are no longer a threat and any conﬂict disappears 312 IET Softw . , 2008 , Vol . 2 , No . 4 , pp . 304 – 320 & The Institution of Engineering and Technology 2008 doi : 10 . 1049 / iet - sen : 20070095 www . ietdl . org From a maintenance perspective , maintainers typically become immersed in the setting in which the particular maintenance task ( story ) unfolds [ 2 , 48 ] and the user ( maintainer ) is considered as an active character in the story , able to interact with different elements , including relevant knowledge resources [ 3 , 49 ] ( e . g . tools , techniques , maintainers and their expertise ) and other characters ( e . g . system or historic user data ) while following the process ( through line ) . From a story perspective , the evolution process can be viewed as authoring an interactive narrative between the users and knowledge resources towards completing a speciﬁc goal ( task ) . The similarities among a story model and a maintenance process model allow for a direct mapping of the formal ( ontological ) representation of the process and resources with the story metaphor . Furthermore , given the story model , this model can be easily mapped to different metaphors , such as text , image , animation , depending on the abstraction level needed . Table 2 illustrates this mapping between the story model and the evolution process . A typical usage scenario for our story - based evolution process model is illustrated in Fig . 8 , reﬂecting the iterative nature of the knowledge acquisition and its use by the loop ( messages 2 – 22 ) . A user ( maintainer ) corresponds to the protagonist in the story who has to complete a particular evolution task . The story manager , ontology manager ( process manager ) and reasoner are all examples of impact characters that might impact the user and therefore the story interaction . Knowledge resources are the available elements in the story environment ( setting ) , and users can use them during the task solving process . The story manager is the main character with whom the user interacts during the task solving process . Based on a given story ( task ) setting ( message 1 ) , the story manager applies a set of pre - deﬁned queries to support the different process activities , by identifying potential knowledge and other resources that might be applicable to the current activities ( messages 2 – 14 ) . The user interacts with the process through the story metaphor , providing the current process context and the ability to trigger new events and actions . One of the major advantages of our ontological representation is not only the ability to reason across the different information resources , but also the ability for users to add newly gained knowledge ( concepts , relations and instances ) to the system and make these available for further processing . For instance , message 9 may return a list of techniques that support a particular maintenance activity , like impact analysis or reverse engineering . The resulting set of tools will be further analysed by the process manager and a potential applicability ranking of the tools and techniques is provided . At this point , the protagonist has the choice between three different options : ( 1 ) accept one of the suggestions ( shown in the scenario in Fig . 3 – messages 15 – 18 ) , ( 2 ) explore all available knowledge and other resources stored in the ontologies or ( 3 ) create customised queries to search and ﬁlter information for speciﬁc settings , tools or historical data . After the completion of a task - step , the protagonist will provide feedback and annotate brieﬂy the applicability of the knowledge resource towards solving a particular task - step ( messages 18 – 22 ) . The feedback is used to further Table 2 Mapping between the story metaphor and the software evolution process model Story model Software evolution model theme evolution task story a speciﬁc MR or PR genre characters type of maintenance activity , for example , perfective , adaptive , corrective maintenance protagonist The maintainer or user who performs the evolution task impact / other characters historical user experience , process manager , ontology manager and reasoner settings organisational settings , available knowledge resources : software , tools , techniques , maintainers , etc plot process management throughline interactive communication between the user and plot based on the underlying process model ( activities and task - steps ) interaction inter - relationships between the characters and the knowledge resources and process activities conﬂict lack of necessary resources , unsuccessful use of resources climax / resolution ﬁnal outcome of the process ( success / failure ) IET Softw . , 2008 , Vol . 2 , No . 4 , pp . 304 – 320 313 doi : 10 . 1049 / iet - sen : 20070095 & The Institution of Engineering and Technology 2008 www . ietdl . org enrich the ontology , as well as triggering the next task - step or activity in the evolution process . 6 Implementation and validation In this section , we provide an overview of our system implementation followed by a discussion evaluating our presented approach . As stated earlier , our research focuses not on developing a new tool or technique in attempt to support a speciﬁc maintenance activity . Instead , our goal is to automatically integrate implicit and explicit knowledge resources through the use of queries and automated reasoning within a maintenance process . Within our system , maintainers can directly query the KB to explore knowledge or utilise pre - deﬁned views and queries to automatically establish a task ( story ) speciﬁc context . 6 . 1 System overview We have developed an environment that supports our uniﬁed model built on a client / server architecture with both the server and the client being implemented as Eclipse plug - ins ( Fig . 9 ) . Ontology , persistent storage management and reasoning services are provided through the server application . They are implemented in Java and built on top of the Jena Semantic Web Framework ( http : / / jena . sourceforge . net / ) . Jena provides the backend repository for both concepts ( TBox ) and instance data ( ABox ) . Leveraging Jena’s persistent storage support , the model storage can be based on ﬁles or a relational database . TBox management is centralised on the server to ensure consistency , quality of the ontology design and standardisation of the KB . Reasoning services are provided by Racer [ 26 ] , which provides highly optimised TBox and ABox reasoning capabilities . The client provides the foundation for our visual integration , supporting the interaction and linking between the maintenance activities and the relevant resources . Similar to more traditional database applications , ABox management is provided through the client . The client also provides the story interface that is part of the local process manager . The contextual process views are established through separate process views and resource advisors . The Figure 9 System architecture Figure 8 Resources usage sequence diagram 314 IET Softw . , 2008 , Vol . 2 , No . 4 , pp . 304 – 320 & The Institution of Engineering and Technology 2008 doi : 10 . 1049 / iet - sen : 20070095 www . ietdl . org story manager also integrates both the contextual navigation through the KB ( through pre - deﬁned queries ) , as well as the query interface for user - deﬁned queries . 6 . 2 Process support A successful process - centred support system is based on the premise that the right information should be made available at the right time in the right format . Achieving this premise depends greatly on the available knowledge resources and the speciﬁc task context . From a software maintainer’s perspective , the challenge is speciﬁcally the need to adjust both information and context in real time to the current process task - step being performed . Our process environment supports such traceability between the involved process steps and other supporting resources ( e . g . artefacts , maintainers , techniques and tools ) . The story ( process ) manager is built on top of the ontology manager infrastructure . The story manager provides for the user both the context and the interactive guidance during the evolution task . The story manager coordinates the protagonist ( the user ) to dynamically author the speciﬁc evolution task solving story . In addition , the story management is also responsible for providing an intuitive visual metaphor to vividly model the whole task solving process . The different aspects of the story metaphor can be mapped with the help of existing visualisation metaphors ( such as static and dynamic 2D and 3D graphs , textual representations and different types of animation ) . During the process , the story manager is monitoring events and triggers that might affect the storyline of the evolution process , for example , user or system activities . A software maintenance process typically originates from an MR . Similarly , our environment will initiate the maintenance process with a request view ( Fig . 10 ) . The MR view also establishes the initial process context and the traceability between the process and the available resources . The context sensitivity levels are supported through customisable views and abstraction hierarchies that both support ﬁltering and extracting details - on - demand [ 50 ] . The process supporting queries establish the link to the KB and automatically populate the relevant resource views . The process and its task - steps are supported through a workﬂow like view and a tree structure view , with both of them adopting similar techniques as the IBM Rational RMC [ 51 ] . Those views allow for easy process navigation by expanding / collapsing of process task - steps and their details . For a speciﬁc task - step , we also support context switching to the advisor views that provide suggestions on what relevant knowledge resources and other related task - steps might be applicable in the given context . 6 . 3 Initial evaluation and discussion Our research contains two main contributions : The OWL – DL KB capturing both process and knowledge resources , as well as an environment utilising the KB . The use of OWL – DL as the ontology language to formalise the KB provides additional beneﬁts compared with less formal knowledge and information sharing approaches . Our constructed ontological representation can be used with many available OWL – DL tools such as Prote´ge´ ( http : / / protege . stanford . edu / ) ( ontology management ) , Pellet ( http : / / pellet . owldl . com / ) ( ontology reasoner ) , and ( SWOOP http : / / www . mindswap . org / 2004 / SWOOP / ) ( ontology browsing / debugging ) . Our model design has been evaluated with Pellet and Racer [ 26 ] for model consistency and reasoning support . Management and evolution of the KB is supported by existing ontology management tools such as Prote´ge´ . In addition , the visual tool environment we developed promotes the use and adaptation of process models and is not limited to maintenance process models . Our environment provides maintainers with process guidance Figure 10 MR and linked views IET Softw . , 2008 , Vol . 2 , No . 4 , pp . 304 – 320 315 doi : 10 . 1049 / iet - sen : 20070095 & The Institution of Engineering and Technology 2008 www . ietdl . org without the need for a prior knowledge about formal ontologies or OWL . Maintainers can use and customise both the standard process as well as the traceability between the context relevant knowledge , through the different advisor views and pre - deﬁned or customisable queries . It has to be noted that one of the main challenges for our approach is the population of the KB . In this respect , our approach does not differ from any existing KB or data mining approach . We are currently following two main strategies to address this challenge . In the ﬁrst phase , we are performing several case studies in collaboration with Defence Research and Development Canada ( DRDC ) Valcartier . The case studies are performed in a controlled environment that restricts both the type of task performed ( component substitution ) and the resources to be modelled . This limited knowledge corpus is sufﬁcient to provide an initial proof of concept that our ontological representation can capture the relevant information and model the context levels . To date , we have conducted two component substitution case studies on Debrief ( http : / / www . debrief . info / index . php ) , a medium size open source application for the analysis and reporting of maritime exercises . Both of the maintenance tasks were related to substituting a non - secure XML data exchange component within Debrief by open source components that perform XML encryption . 6 . 3 . 1 Case study settings : We selected eight graduate students from our Software Maintenance Research Group at Concordia University to participate in both case studies in a controlled environment . The technical and maintenance experience levels varied signiﬁcantly among the students . Their Java programming experience ranged from 2 to 8 years and their industrial maintenance experience from no previous experience to several years as senior programmer . A commonality among all students participating in the case study was that they had no previous experience using or maintaining Debrief . For the case studies , 30 software maintenance relevant tools were selected and installed on the computers in two software engineering labs accessible to the students . The software packages included source code analysis tools , software measurement tools , software visualisation tools and other software maintenance support tools . Information related to these tools was manually collected and populated within the KB . Since most of the students were unfamiliar with these tools , tutorials and manuals were provided to allow them to familiarise themselves with the tools prior to using them in their assigned maintenance task . Artefacts that were made available with Debrief included source code , class ﬁles , a detailed analysis document , a system design document , user guide and tutorials . The intent of the ﬁrst case study was 2 - fold : ﬁrst to validate whether our uniﬁed model was capable to sufﬁciently and correctly capture the information required to support a software maintenance tasks . Secondly , the case study was used to collect some user , tool and feedback data from the case study to allow for an initial population of the ontology . Given the results and feedbacks collected from the second case study , we were able to extend and reﬁne our ontological model to improve its ability to support more task - speciﬁc queries . The collected feedback was also used to further populate the ontology , which included after the second case study 295 concepts , 129 relationships and 765 instances . The studies provided us with a proof of concept that our approach is capable of providing additional beneﬁts to maintainers . It was in particular the integration of process , task and resource relevant information that was well received . Ontology population is a major concern at this point of time , since our process advisor support is driven by the quantity and quality of the information available . The collected feedback conﬁrmed our initial hypothesis that considering associated knowledge resources without a particular maintenance context does not provide sufﬁcient guidance to assist a maintainer ( protagonist ) in completing a given maintenance task . During the second evaluation phase , we will further extended and generalise our environment by including additional tasks and resources to the KB . Currently , we are facing the challenge of ontology population and exploring different avenues to address this issue . Potential solutions for the ontology population problem include the creation of an Internet community portal and / or the concrete adoption of our tool within an industrial setting . 7 Related work As a knowledge representation language , OWL has already been applied in many applications of the software engineering domain such as model - driven software development [ 52 ] , a CMMI - SW model representation and reasoning for classifying organisational maturity levels [ 53 ] , reverse engineering tool integration [ 14 ] , component reuse [ 39 ] and open source bug tracking [ 54 ] . However , there exists only limited research in modelling software maintenance and evolution using ontologies . Ruiz et al . [ 30 ] present a semi - formal ontology based on REFSENO for managing software maintenance projects . They consider both the static [ 29 ] and dynamic aspects such as workﬂow in software maintenance processes . The ontology was constructed using KM - MANTIS , a knowledge management system with the goal of improving maintenance project management . However , no implementation or usage details are provided . Kitchenham et al . [ 29 ] designed a UML - based ontology for software maintenance to identify and model factors that affect the results of empirical studies . Their goal differs from ours by utilising ontologies to establish a common understanding context for empirical studies . Furthermore , the resulting 316 IET Softw . , 2008 , Vol . 2 , No . 4 , pp . 304 – 320 & The Institution of Engineering and Technology 2008 doi : 10 . 1049 / iet - sen : 20070095 www . ietdl . org ontology was not formally modelled and no reasoning services were used to infer implicit knowledge . Dias et al . [ 28 ] extended the work by Kitchenham by applying a ﬁrst - order logic to formalise knowledge involved in software maintenance . Although they stated that it is worthwhile to provide a KB , they only identiﬁed knowledge relevant to the software maintenance domain without actually providing a concrete KB implementation . Gonza´lez - Pe´rez and Henderson - Sellers present a comprehensive ontology for software development [ 55 ] that includes a process sub - ontology modelling , among others , techniques , tasks and workﬂows . The ontology is presented using UML diagrams . No implementation is given , implying that the authors also have not examined the integration of their ontology in an actual software development process . Common to all of these approaches is that their main intent is to support in one form or another the conceptualisation of knowledge , mainly by standardising the terminology and to support knowledge sharing based on a common understanding . These approaches fall short on adopting and formalising a process model to support traceability links between the process and the knowledge resources in the KB . They also lack the use of reasoning services to infer implicit knowledge . To the best of our knowledge , there exists no previous work that focuses on developing a formal OWL – DL software maintenance process model and utilises automated reasoning to establish the links between the process activities and involved resources . The collaborative nature of software engineering has more recently been addressed by introducing Wiki systems into the SE process . Semantic Wiki extensions such as Semantic MediaWiki [ 56 ] or IkeWiki [ 57 ] add formal structuring and querying extensions based on RDF / OWL metadata . These works can be seen as complementary to our approach , in that they can support the creation and visualisation of the developed KB . However , by themselves they do not address the main concern covered by our approach , delivering active and context - sensitive guidance to an individual developer for his current task , based on knowledge both explicitly encoded and implicitly derived by actions performed by other developers . Compared with other modelling approaches such as model - driven architecture ( MDA ) and related modelling standards ( e . g . UML / MOF [ 58 ] or the eclipse modelling framework ( EMF ) [ 59 ] ) , our approach differs fundamentally in its objective . ( 1 ) These modeling approaches focus on forward engineering , that is , producing code from abstract , human - elaborated speciﬁcations , following a strict modelling process . We , on the other hand , focus on software evolution , where one has to extract , model , integrate and utilise knowledge from various and often not well - deﬁned resources and ( 2 ) MDA and EMF both focus on modelling well - deﬁned processes , in an attempt to derive complete models . Our approach , on the other hand , is based on an open world assumption , focusing on the integration of existing and newly gained knowledge and by making this knowledge available to the end - user . With regard to tool support for process guidance , recent work by IBM rational on its method composer ( RMC ) [ 51 ] and process advisor [ 60 ] are the closest related approaches to our research . RMC is a process management tool for authoring , conﬁguring and publishing development process like the rational uniﬁed process ( RUP ) . The IBM rational process advisor integrates RUP process guidance within the context of software development tools [ 60 ] . Because of the required tool customisation , the contextual guidance through the process advisor is currently only supported within a selected set of rational tools . Our approach has similarities in process modelling and customisation with the RMC , due to the fact that we adopted parts of the RMC , namely EPF ( http : / / www . eclipse . org / epf / ) and GEF ( http : / / www . eclipse . org / gef / ) , to graphically model and customise the IEEE maintenance process . However , our approach differs in its overall motivation . These differences can be summarised as follows : ( 1 ) The process advisor focuses on the integration of RUP - based process guidance into the context of several rational development tools ( http : / / www - 128 . ibm . com / developerworks / rational / products / rup ) by requiring a customisation of these tools to support the process advisor . Our focus instead is on the general knowledge integration of the process activities and resources by creating links between the process activities and resources which are not limited by a set of speciﬁc tools and ( 2 ) We focus on knowledge integration rather than tool integration by providing a ﬂexible and dynamic knowledge management . Within our approach , any newly gained knowledge ( process and / or resources ) automatically becomes an integrated part of our model . Furthermore , we support reasoning services that can infer implicit knowledge not explicitly modelled in the KB . In comparison , the process advisor is a more static approach that requires a manual adaptation of tools to be able to take advantage of the process advisor and its context sensitive guidance . 8 Conclusions and future work Software evolution is a major part in terms of effort and cost involved in any software life cycle . Our work promotes the use of both formal ontology and automated reasoning in software evolution by providing a formal DL - based ontological representation for the modelling of both software evolution processes and resources relevant to support these processes . We have adopted the IEEE software maintenance standard to illustrate the modelling of software evolution processes using a formal ontological representation . The uniﬁed ontological representation allows for the integration of these knowledge resources and establishes traceability links between the process and the resources . The ﬂexibility and extensibility of the ontologies also enables the evolution and enrichment of the KB . IET Softw . , 2008 , Vol . 2 , No . 4 , pp . 304 – 320 317 doi : 10 . 1049 / iet - sen : 20070095 & The Institution of Engineering and Technology 2008 www . ietdl . org We introduce a story - based software evolution process model to provide a metaphor that supports the interaction and context visualisation between the process model , modelled resources and users . The visual format for the task story model is still under development . As part of our future work , we will conduct further case studies to enrich our current ontologies and optimise our current tool in supporting particular software evolution process models . 9 Acknowledgment This research was partially funded by DRDC Valcartier ( contract no . W7701 - 052936 / 001 / QCL ) . 10 References [ 1 ] STOREY M . - A . D . , WONG K . , MU¨LLER H . A . : ‘How do program understanding tools affect how programmers understand programs ? ’’ , Sci . Comput . Program . , 2000 , 36 , ( 2 – 3 ) , pp . 183 – 207 [ 2 ] VON MAYRHAUSER A . , MARIE VANS A . : ‘Program comprehension during software maintenance and evolution’ , Comput . , 1995 , 28 , ( 8 ) , pp . 44 – 55 [ 3 ] LEHMAN M . M . , BELADY L . A . : ‘Program evolution : processes of software change’ ( Academic Press Professional , Inc . , San Diego , CA , 1985 ) [ 4 ] BASILI V . R . : ‘Viewing maintenance as reuse oriented software development’ , IEEE Softw . , 1990 , pp . 19 – 25 [ 5 ] BENNETT K . H . , RAJLICH V . T . : ‘Software maintenance and evolution : a roadmap’ . Proc . Conf . Future of Software , 2000 , pp . 73 – 87 [ 6 ] CMMI for Development , Version 1 . 2 : Technical Report CMU / SEI - 2006 - TR - 008 , Carnegie Mellon , Software Engineering Institute , USA , 2006 [ 7 ] International Standard : ISO / IEC 14764 IEEE Std 14764 - 2006 Software Engineering , Software Life Cycle Processes , Maintenance . ISBN : 0 - 7381 - 4961 - 6 , 2006 [ 8 ] STOREY M . - A . D . , SIM S . E . , WONG K . : ‘A collaborative demonstration of reverse engineering tools’ , ACM SIGAPP Appl . Comput . Rev . , 2002 , 10 , ( 1 ) , pp . 18 – 25 [ 9 ] MENG W . , RILLING J . , ZHANG Y . , WITTE R . , CHARLAND P . : ‘An ontological software comprehension process model’ . 3rd Int . Workshop on Metamodels , Schemas , Grammars , and Ontologies for Reverse Engineering ( ATEM ) , 2006 , pp . 28 – 35 [ 10 ] BAADER F . , HORROCKS I . , SATTLER U . : ‘Description logics as ontology languages for the semantic web’ , in HUTTER D . , STEPHAN W . ( EDS . ) : ‘Lecture notes in artiﬁcial intelligence’ ( Springer , 2005 ) , vol . 2605 , pp . 228 – 248 [ 11 ] LETOVSKY S . : ‘Cognitive processes in program comprehension’ ( Empirical studies of programmers ( Ablex Publishing Corp . , 1986 ) , pp . 58 – 79 [ 12 ] MAYHAUSER A . V . , VANS A . M . : ‘Program comprehension during software maintenance and evolution’ , IEEE Comput . , 1995 , 28 , ( 8 ) , pp . 44 – 55 [ 13 ] SHNEIDERMAN B . : ‘Software psychology : human factors in computer and information systems’ ( Winthrop Publishers , 1980 ) [ 14 ] JIN D . , CORDY J . R . : ‘Ontology - based software analysis and reengineering tool integration : the OASIS service - sharing methodology’ . 21st IEEE Int . Conf . Software Engineering ( ICSM ) , 2005 [ 15 ] RIVA C . : ‘Reverse architecting : an industrial experience report’ . Proc . 7th IEEE Working Conf . Reverse Engineering ( WCRE 2000 ) , 2000 , pp . 42 – 52 [ 16 ] PACIONE M . J . , ROPER M . , WOOD M . : ‘A novel software visualisation model to support software comprehension’ . 11th Working Conf . Reverse Engineering ( WCRE 2004 ) , 2004 [ 17 ] STOREY M . - A . D . : ‘Theories , methods and tools in program comprehension : past , present , and future’ . Proc . 13th Int . Workshop on Program Comprehension ( IWPC 2005 ) , Missouri , USA , 2005 , pp . 181 – 191 [ 18 ] JOHNSON - LAIRD P . N . : ‘Mental models : towards a cognitive science of language , inference and consciousness’ ( Harvard University , Cambridge , MA , 1983 ) [ 19 ] OWL web ontology language reference , W3C Recommendation , http : / / www . w3 . org / TR / owl - ref , accessed June 2007 [ 20 ] GRUBER T . R . : ‘A translation approach to portable ontology speciﬁcations’ , Knowl . Acquis . , 1993 , 5 , ( 2 ) , pp . 199 – 220 [ 21 ] HORROCKS I . , PATEL - SCHNEIDER P . F . , HARMELEN F . : ‘From SHIQ and RDF to OWL : the making of a web ontology language’ , J . Web Semant . , 2003 , 1 , ( 1 ) , pp . 7 – 26 [ 22 ] SOWA J . F . : ‘Knowledge representation : logical , philosophical , and computational foundations’ ( Brooks / Cole Publishing Co , Paciﬁc Grove , CA , USA , 2000 , ISBN : 0 534 - 94965 - 7 [ 23 ] BAADER F . , CALVANESE D . , MCGUINNESS D . , NARDI D . , SCHNEIDER P . P . : ‘The description logic handbook’ ( Cambridge University Press , 2003 ) 318 IET Softw . , 2008 , Vol . 2 , No . 4 , pp . 304 – 320 & The Institution of Engineering and Technology 2008 doi : 10 . 1049 / iet - sen : 20070095 www . ietdl . org [ 24 ] Web ontology language , http : / / www . w3 . org / 2004 / OWL / , accessed June 2007 [ 25 ] BERNERS - LEE T . , HENDLER J . , LASSILA O . : ‘The semantic web’ , Sci . Am . , 2001 , 284 , ( 5 ) , pp . 34 – 43 [ 26 ] HAARSLEV V . , MO¨LLER R . : ‘RACER system description’ . Proc . Int . Joint Conf . Automated Reasoning ( IJCAR’2001 ) , Springer - Verlag , 2001 , pp . 701 – 705 [ 27 ] KELLER I . M . , MADACHY R . J . , RAFFO D . M . : ‘Software process simulation modeling : Why ? What ? How ? ’ , J . Syst . Softw . , 1999 , 46 , ( 2 / 3 ) , pp . 91 – 105 [ 28 ] DIAS M . G . B . , ANQUETIL N . , OLIVEIRA K . M . : ‘Software maintenance ontology’ , in CALEOR C . , RUIZ F . , PIATTINI M . ( EDS ) : ‘Ontologies for software engineering and software maintenance’ ( Springer , 2006 ) , Ch . 5 , pp . 153 – 173 [ 29 ] KITCHENHAM B . , TRAVASSOS G . H . , MAYRHAUSER A . V . , ET AL . : ‘Towards an ontology of software maintenance’ , J . Softw . Maint . Pract . , 1999 , 11 , ( 6 ) , pp . 365 – 389 [ 30 ] RUIZ F . , VIZCAI´NO A . , PIATTINI M . , GARCI´A F . : ‘An ontology for the management of software maintenance projects’ , Int . J . Softw . Eng . Knowl . Eng . , 2004 , 14 , ( 3 ) , pp . 323 – 349 [ 31 ] NILES I . , PEASE A . : ‘Towards a standard upper ontology’ . Proc . 2nd Int . Conf . Formal Ontology in Information System ( FOIS ) , Maine , 2001 [ 32 ] GREYCK M . , DIAS B . , ANQUETIL N . , MARCAL DE OLIVEIRA K . : ‘Organizing the knowledge used in software maintenance’ , J . Univers . Comput . Sci . , 2003 , 9 , ( 7 ) , pp . 641 – 658 [ 33 ] PRESSMAN R . : ‘Software engineering : a practioner’s approach’ ( McGraw Hill College , 2005 , 6th edn . ) , ISBN - 10 : 007301933X [ 34 ] JAHNKE J . H . , WALENSTEIN A . : ‘Reverse engineering tools as media for imperfect knowledge’ . IEEE Working Conf . Reverse Engineering ( WCRE’2000 ) , pp . 22 – 31 [ 35 ] WONGTHONGTHAM P . , CHANG E . , DILLON T . S . , SOMMERVILLE I . : ‘Software engineering ontology – instance knowledge ( Part I ) ’ , Int . J . Comput . Sci . Netw . Secur . ( USA ) , 2007 , 7 , ( 2 ) , pp . 15 – 26 [ 36 ] BONTCHEVA K . , SABOU M . : ‘Learning ontologies from software artifacts : exploring and combining multiple sources’ . Proc . 2nd Int . Workshop on Semantic Web Enabled Software Engineering SWESE , 2006 [ 37 ] Software Engineering Coordinating Committee : SWEBOK , version 2004 , http : / / www . swebok . org [ 38 ] BALLIM A . , WILKS Y . : ‘Artiﬁcial believers : the ascription of belief’ ( Lawrence Erlbaum , 1991 ) [ 39 ] HAPPEL H . - J . , KORTHAUS A . , SEEDORF S . , TOMCZYK P . : ‘KOntoR : an ontology - enabled approach to software reuse’ . 18th Int . Conf . Software Engineering and Knowledge Engineering ( SEKE ) , San Francisco , July 2006 [ 40 ] PHILLIPS M . A . , HUNTLEY C . : ‘Dramatic a new theory of story’ , Screenplay ( Systems Inc . , 2001 , 5th edn . ) [ 41 ] RIEDL M . O . , YONG R . M . : ‘From linear story generation to branching story graphs’ . ‘IEEE Computer Graphics and Applications’ ( IEEE Computer Society , 2006 ) [ 42 ] HARTLAND E . S . : ‘The science of fairy tales’ ( Walter Scott , 1891 ) [ 43 ] GONZA´LEZ - PE´REZ C . , HENDERSON - SELLERS B . : ‘An ontology for software development methodologies and endeavours’ , in CALEOR C . , RUIZ F . , PIATTINI M . ( EDS . ) : ‘Ontologies for software engineering and software maintenance’ ( Springer , 2006 ) , pp . 123 – 151 [ 44 ] BRUNER J . : ‘Acts of meaning’ ( Harvard University Press , Cambridge , MA , 1990 ) [ 45 ] PLOWMAN L . , LUCKIN R . , LAURILLARD D . , STRATFOLD M . , TAYLOR J . : ‘Designing multimedia for learning : narrative guidance and narrative construction’ . Proc . SIGCHI Conf . Human Factors in Computing Systems : The CHI is Limit , ACM Press , May 1999 [ 46 ] RIEDL M . O . , YOUNG R . M . : ‘An intent - driven planner for multi - agent story generation’ . Proc . 3rd Int . Conf . Autonomous Agents and Multi Agents Systems , July 2004 [ 47 ] Open Management Group ( OMG ) : ‘Uniﬁed modeling language’ , www . uml . org , accessed February 2008 [ 48 ] BROOKS R . : ‘Towards a theory of the comprehension of computer programs’ , Int . J . Man - Mach . Stud . , 1983 , 18 , pp . 543 – 554 [ 49 ] WONGTHONGTHAM P . , CHANG E . , DILLON T . S . : ‘Towards ontology - based software engineering for multi - site software development’ . 3rd IEEE Int . Conf . Industrial Informatics ( INDIN ) , 2005 [ 50 ] RILLING J . , MENG W . , CHEN F . , CHARLAND P . : ‘Software visualization – a process perspective’ . 4th IEEE Int . Workshop on VISSOFT , Banff , Canada , 2007 [ 51 ] HAUNER P . : ‘IBM rational method composer . Part 1 : Key concepts’ , IBM Report , December 2005 [ 52 ] Ontological Driven Architectures and Potential Uses of the Semantic Web in Systems and SE , www . w3 . org / 2001 / sw / BestPractices / SE / ODA / , accessed May 2007 IET Softw . , 2008 , Vol . 2 , No . 4 , pp . 304 – 320 319 doi : 10 . 1049 / iet - sen : 20070095 & The Institution of Engineering and Technology 2008 www . ietdl . org [ 53 ] SOYDAN G . H . , KOKAR M . : ‘An OWL ontology for representing the CMMI - SW model’ . Workshop on Semantic Web Enabled Software Engineering ( SWESE ) , 2006 [ 54 ] ANKOLEKAR A . : ‘Supporting online problem – solving communities with the semantic web’ , PhD Thesis , Carnegie Mellon University , Pittsburgh , PA , 2005 [ 55 ] GERSHON N . , PAGE W . : ‘What storytelling can do for information visualization’ , CACM 2001 , 8 , ( 44 ) , pp . 31 – 37 [ 56 ] KRO¨TZSCH M . , VRANDECˇIC´ D . , VO¨LKEL M . : ‘Semantic MediaWiki’ , in CRUZ I . , DECKER S . , ALLEMANG D . , PREIST C . , SCHWABE D . , MIKA P . , USCHOLD M . , AROYO L . ( EDS . ) : ‘The seman . tic web – ISWC 2006’ ( LNCS , 4273 , Springer , 2006 ) , pp . 935 – 942 [ 57 ] SCHAFFERT S . : ‘IkeWiki : a semantic wiki for collaborative knowledge management’ . WETICE , IEEE Computer Society , 2006 , pp . 388 – 396 [ 58 ] OMG : ‘Uniﬁed modeling language’ , / www . uml . org / , accessed February 2008 [ 59 ] Eclipse and Open Development Platform , www . eclipse . org , accessed February 2008 [ 60 ] SMITH J . , POPESCU D . , BENCOMO A . : ‘IBM rational process advisor : integrating the software development process with IBM rational developer and tester V7 tools’ . IBM Report , December 2006 320 IET Softw . , 2008 , Vol . 2 , No . 4 , pp . 304 – 320 & The Institution of Engineering and Technology 2008 doi : 10 . 1049 / iet - sen : 20070095 www . ietdl . org