Package ‘lme4’ April 16 , 2016 Version 1 . 1 - 12 Title Linear Mixed - Effects Models using ' Eigen ' and S4 Contact LME4 Authors < lme4 - authors @ lists . r - forge . r - project . org > Description Fit linear and generalized linear mixed - effects models . The models and their components are represented using S4 classes and methods . The core computational algorithms are implemented using the ' Eigen ' C + + library for numerical linear algebra and ' RcppEigen ' ` ` glue ' ' . Depends R ( > = 3 . 0 . 2 ) , Matrix ( > = 1 . 1 . 1 ) , methods , stats LinkingTo Rcpp ( > = 0 . 10 . 5 ) , RcppEigen Imports graphics , grid , splines , utils , parallel , MASS , lattice , nlme ( > = 3 . 1 - 123 ) , minqa ( > = 1 . 1 . 15 ) , nloptr ( > = 1 . 0 . 4 ) Suggests knitr , boot , PKPDmodels , MEMSS , testthat ( > = 0 . 8 . 1 ) , ggplot2 , mlmRev , optimx ( > = 2013 . 8 . 6 ) , gamm4 , pbkrtest , HSAUR2 , numDeriv VignetteBuilder knitr LazyData yes License GPL ( > = 2 ) URL https : / / github . com / lme4 / lme4 / http : / / lme4 . r - forge . r - project . org / BugReports https : / / github . com / lme4 / lme4 / issues NeedsCompilation yes Author Douglas Bates [ aut ] , Martin Maechler [ aut ] , Ben Bolker [ aut , cre ] , Steven Walker [ aut ] , Rune Haubo Bojesen Christensen [ ctb ] , Henrik Singmann [ ctb ] , Bin Dai [ ctb ] , Gabor Grothendieck [ ctb ] , Peter Green [ ctb ] Maintainer Ben Bolker < bbolker + lme4 @ gmail . com > Repository CRAN Date / Publication 2016 - 04 - 16 20 : 40 : 11 1 2 R topics documented : R topics documented : lme4 - package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 Arabidopsis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 bootMer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6 cake . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9 cbpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 conﬁnt . merMod . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11 convergence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13 devcomp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15 drop1 . merMod . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 dummy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18 Dyestuff . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18 expandDoubleVerts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19 factorize . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20 ﬁndbars . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21 ﬁxef . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22 fortify . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23 getME . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23 GHrule . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27 glmer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28 glmer . nb . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31 glmerLaplaceHandle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 glmFamily . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 glmFamily - class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 golden - class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34 GQdk . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35 grouseticks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36 hatvalues . merMod . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37 InstEval . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38 isNested . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39 isREML . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39 lmer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40 lmerControl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43 lmList . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48 lmList4 - class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50 lmResp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51 lmResp - class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52 merMod - class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53 merPredD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57 merPredD - class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58 mkdevfun . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59 mkMerMod . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60 mkRespMod . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60 mkReTrms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61 mkSimulateTemplate . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62 mkVarCorr . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63 modular . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63 lme4 - package 3 NelderMead . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67 NelderMead - class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69 ngrps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70 nlformula . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71 nlmer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72 nloptwrap . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74 nobars . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76 Pastes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77 Penicillin . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78 plot . lmList4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79 plot . merMod . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80 plots . thpr . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82 predict . merMod . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84 proﬁle - methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85 prt - utilities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88 pvalues . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91 ranef . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92 reﬁt . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94 reﬁtML . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96 rePos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96 rePos - class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97 residuals . merMod . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97 sigma . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98 simulate . merMod . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99 sleepstudy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101 subbars . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102 troubleshooting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103 VarCorr . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104 varianceProf . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105 vcconv . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106 VerbAgg . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107 Index 109 lme4 - package Linear , generalized linear , and nonlinear mixed models Description lme4 provides functions for ﬁtting and analyzing mixed models : linear ( lmer ) , generalized linear ( glmer ) and nonlinear ( nlmer . ) 4 lme4 - package Differences between nlme and lme4 lme4 covers approximately the same ground as the earlier nlme package . The most important differences are : • lme4 uses modern , efﬁcient linear algebra methods as implemented in the Eigen package , and uses reference classes to avoid undue copying of large objects ; it is therefore likely to be faster and more memory - efﬁcient than nlme . • lme4 includes generalized linear mixed model ( GLMM ) capabilities , via the glmer function . • lme4 does not currently implement nlme ’s features for modeling heteroscedasticity and cor - relation of residuals . • lme4 does not currently offer the same ﬂexibility as nlme for composing complex variance - covariance structures , but it does implement crossed random effects in a way that is both easier for the user and much faster . • lme4 offers built - in facilities for likelihood proﬁling and parametric bootstrapping . • lme4 is designed to be more modular than nlme , making it easier for downstream package developers and end - users to re - use its components for extensions of the basic mixed model framework . It also allows more ﬂexibility for specifying different functions for optimizing over the random - effects variance - covariance parameters . • lme4 is not ( yet ) as well - documented as nlme . Differences between current ( 1 . 0 . + ) and previous versions of lme4 • [ gn ] lmer now produces objects of class merMod rather than class mer as before • the new version uses a combination of S3 and reference classes ( see ReferenceClasses , merPredD - class , and lmResp - class ) as well as S4 classes ; partly for this reason it is more interoperable with nlme • The internal structure of [ gn ] lmer is now more modular , allowing ﬁner control of the different steps of argument checking ; construction of design matrices and data structures ; parameter estimation ; and construction of the ﬁnal merMod object ( see modular ) • proﬁling and parametric bootstrapping are new in the current version • the new version of lme4 does not provide an mcmcsamp ( post - hoc MCMC sampling ) method , because this was deemed to be unreliable . Alternatives for computing p - values include para - metric bootstrapping ( bootMer ) or methods implemented in the pbkrtest package and lever - aged by the lmerTest package and the Anova function in the car package ( see pvalues for more details ) . Caveats and trouble - shooting • Some users who have previously installed versions of the RcppEigen and minqa packages may encounter segmentation faults ( ! ! ) ; the solution is to make sure to re - install these packages before installing lme4 . ( Because the problem is not with the explicit version of the packages , but with running packages that were built with different versions of Rcpp in conjunction with each other , simply making sure you have the latest version , or using update . packages , will not necessarily solve the problem ; you must actually re - install the packages . The problem is most likely with minqa . ) Arabidopsis 5 Arabidopsis Arabidopsis clipping / fertilization data Description Data on genetic variation in responses to fertilization and simulated herbivory in Arabidopsis Usage data ( " Arabidopsis " ) Format A data frame with 625 observations on the following 8 variables . reg region : a factor with 3 levels NL ( Netherlands ) , SP ( Spain ) , SW ( Sweden ) popu population : a factor with the form n . R representing a population in region R gen genotype : a factor with 24 ( numeric - valued ) levels rack a nuisance factor with 2 levels , one for each of two greenhouse racks nutrient fertilization treatment / nutrient level ( 1 , minimal nutrients or 8 , added nutrients ) amd simulated herbivory or " clipping " ( apical meristem damage ) : unclipped ( baseline ) or clipped status a nuisance factor for germination method ( Normal , Petri . Plate , or Transplant ) total . fruits total fruit set per plant ( integer ) Source From Josh Banta References Joshua A . Banta , Martin H . H Stevens , and Massimo Pigliucci ( 2010 ) A comprehensive test of the ’limiting resources’ framework applied to plant tolerance to apical meristem damage . Oikos 119 ( 2 ) , 359 – 369 ; http : / / dx . doi . org / 10 . 1111 / j . 1600 - 0706 . 2009 . 17726 . x Examples data ( Arabidopsis ) summary ( Arabidopsis [ , " total . fruits " ] ) table ( gsub ( " [ 0 - 9 ] . " , " " , levels ( Arabidopsis [ , " popu " ] ) ) ) library ( lattice ) stripplot ( log ( total . fruits + 1 ) ~ amd | nutrient , data = Arabidopsis , groups = gen , strip = strip . custom ( strip . names = c ( TRUE , TRUE ) ) , type = c ( ’p’ , ’a’ ) , # # points and panel - average value - - # # see ? panel . xyplot scales = list ( x = list ( rot = 90 ) ) , main = " Panel : nutrient , Color : genotype " ) 6 bootMer bootMer Model - based ( Semi - ) Parametric Bootstrap for Mixed Models Description Perform model - based ( Semi - ) parametric bootstrap for mixed models . Usage bootMer ( x , FUN , nsim = 1 , seed = NULL , use . u = FALSE , re . form = NA , type = c ( " parametric " , " semiparametric " ) , verbose = FALSE , . progress = " none " , PBargs = list ( ) , parallel = c ( " no " , " multicore " , " snow " ) , ncpus = getOption ( " boot . ncpus " , 1L ) , cl = NULL ) Arguments x a ﬁtted merMod object : see lmer , glmer , etc . FUN a function taking a ﬁtted merMod object as input and returning the statistic of interest , which must be a ( possibly named ) numeric vector . nsim number of simulations , positive integer ; the bootstrap B ( or R ) . seed optional argument to set . seed . use . u logical , indicating whether the spherical random effects should be simulated / bootstrapped as well . If TRUE , they are not changed , and all inference is condi - tional on these values . If FALSE , new normal deviates are drawn ( see Details ) . re . form formula , NA ( equivalent to use . u = FALSE ) , or NULL ( equivalent to use . u = TRUE ) : alternative to use . u for specifying which random effects to incorporate . See simulate . merMod for details . type character string specifying the type of bootstrap , " parametric " or " semiparametric " ; partial matching is allowed . verbose logical indicating if progress should print output . progress character string - type of progress bar to display . Default is " none " ; the function will look for a relevant * ProgressBar function , so " txt " will work in general ; " tk " is available if the tcltk package is loaded ; or " win " on Windows systems . Progress bars are disabled ( with a message ) for parallel operation . PBargs a list of additional arguments to the progress bar function ( the package authors like list ( style = 3 ) ) . parallel The type of parallel operation to be used ( if any ) . If missing , the default is taken from the option " boot . parallel " ( and if that is not set , " no " ) . ncpus integer : number of processes to be used in parallel operation : typically one would choose this to be the number of available CPUs . cl An optional parallel or snow cluster for use if parallel = " snow " . If not supplied , a cluster on the local machine is created for the duration of the boot call . bootMer 7 Details The semi - parametric variant is only partially implemented , and we only provide a method for lmer and glmer results . The working name for bootMer ( ) was “simulestimate ( ) ” , as it is an extension of simulate ( see simulate . merMod ) , but we want to emphasize its potential for valid inference . • If use . u is FALSE and type is " parametric " , each simulation generates new values of both the “ spherical ” random effects u and the i . i . d . errors (cid:15) , using rnorm ( ) with parameters corre - sponding to the ﬁtted model x . • If use . u is TRUE and type = = " parametric " , only the i . i . d . errors ( or , for GLMMs , response values drawn from the appropriate distributions ) are resampled , with the values of u staying ﬁxed at their estimated values . • If use . u is TRUE and type = = " semiparametric " , the i . i . d . errors are sampled from the dis - tribution of ( response ) residuals . ( For GLMMs , the resulting sample will no longer have the same properties as the original sample , and the method may not make sense ; a warning is generated . ) The semiparametric bootstrap is currently an experimental feature , and therefore may not be stable . • The case where use . u is FALSE and type = = " semiparametric " is not implemented ; Morris ( 2002 ) suggests that resampling from the estimated values of u is not good practice . Value an object of S3 class " boot " , compatible with boot package’s boot ( ) result . References Davison , A . C . and Hinkley , D . V . ( 1997 ) Bootstrap Methods and Their Application . Cambridge University Press . Morris , J . S . ( 2002 ) . The BLUPs Are Not ‘best’ When It Comes to Bootstrapping . Statistics & Probability Letters 56 ( 4 ) : 425 – 430 . doi : 10 . 1016 / S0167 - 7152 ( 02 ) 00041 - X . See Also • confint . merMod , for a more speciﬁc approach to bootstrap conﬁdence intervals on parame - ters . • refit ( ) , or PBmodcomp ( ) from the pbkrtest package , for parametric bootstrap comparison of models . • boot ( ) , and then boot . ci , from the boot package . • profile - methods , for likelihood - based inference , including conﬁdence intervals . • pvalues , for more general approaches to inference and p - value computation in mixed models . Examples fm01ML < - lmer ( Yield ~ 1 | Batch , Dyestuff , REML = FALSE ) # # see ? " profile - methods " mySumm < - function ( . ) { s < - sigma ( . ) c ( beta = getME ( . , " beta " ) , sigma = s , sig01 = unname ( s * getME ( . , " theta " ) ) ) } 8 bootMer ( t0 < - mySumm ( fm01ML ) ) # just three parameters # # alternatively : mySumm2 < - function ( . ) { c ( beta = fixef ( . ) , sigma = sigma ( . ) , sig01 = sqrt ( unlist ( VarCorr ( . ) ) ) ) } set . seed ( 101 ) # # 3 . 8s ( on a 5600 MIPS 64bit fast ( year 2009 ) desktop " AMD Phenom ( tm ) II X4 925 " ) : system . time ( boo01 < - bootMer ( fm01ML , mySumm , nsim = 100 ) ) # # to " look " at it require ( " boot " ) # # a recommended package , i . e . * must * be there boo01 # # note large estimated bias for sig01 # # ( ~ 30 % low , decreases _ slightly _ for nsim = 1000 ) # # extract the bootstrapped values as a data frame . . . head ( as . data . frame ( boo01 ) ) # # - - - - - - Bootstrap - based confidence intervals - - - - - - - - - - - - # # warnings about " Some . . . intervals may be unstable " go away # # for larger bootstrap samples , e . g . nsim = 500 # # intercept ( bCI . 1 < - boot . ci ( boo01 , index = 1 , type = c ( " norm " , " basic " , " perc " ) ) ) # beta # # Residual standard deviation - original scale : ( bCI . 2 < - boot . ci ( boo01 , index = 2 , type = c ( " norm " , " basic " , " perc " ) ) ) # # Residual SD - transform to log scale : ( bCI . 2L < - boot . ci ( boo01 , index = 2 , type = c ( " norm " , " basic " , " perc " ) , h = log , hdot = function ( . ) 1 / . , hinv = exp ) ) # # Among - batch variance : ( bCI . 3 < - boot . ci ( boo01 , index = 3 , type = c ( " norm " , " basic " , " perc " ) ) ) # sig01 # # Extract all CIs ( somewhat awkward ) bCI . tab < - function ( b , ind = length ( b $ t0 ) , type = " perc " , conf = 0 . 95 ) { btab0 < - t ( sapply ( as . list ( seq ( ind ) ) , function ( i ) boot . ci ( b , index = i , conf = conf , type = type ) $ percent ) ) btab < - btab0 [ , 4 : 5 ] rownames ( btab ) < - names ( b $ t0 ) a < - ( 1 - conf ) / 2 a < - c ( a , 1 - a ) pct < - stats : : : format . perc ( a , 3 ) colnames ( btab ) < - pct return ( btab ) } bCI . tab ( boo01 ) # # Graphical examination : plot ( boo01 , index = 3 ) cake 9 # # Check stored values from a longer ( 1000 - replicate ) run : load ( system . file ( " testdata " , " boo01L . RData " , package = " lme4 " ) ) plot ( boo01L , index = 3 ) mean ( boo01L $ t [ , " sig01 " ] = = 0 ) # # note point mass at zero ! cake Breakage Angle of Chocolate Cakes Description Data on the breakage angle of chocolate cakes made with three different recipes and baked at six different temperatures . This is a split - plot design with the recipes being whole - units and the differ - ent temperatures being applied to sub - units ( within replicates ) . The experimental notes suggest that the replicate numbering represents temporal ordering . Format A data frame with 270 observations on the following 5 variables . replicate a factor with levels 1 to 15 recipe a factor with levels A , B and C temperature an ordered factor with levels 175 < 185 < 195 < 205 < 215 < 225 angle a numeric vector giving the angle at which the cake broke . temp numeric value of the baking temperature ( degrees F ) . Details The replicate factor is nested within the recipe factor , and temperature is nested within replicate . Source Original data were presented in Cook ( 1938 ) , and reported in Cochran and Cox ( 1957 , p . 300 ) . Also cited in Lee , Nelder and Pawitan ( 2006 ) . References Cook , F . E . ( 1938 ) Chocolate cake , I . Optimum baking temperature . Master’s Thesis , Iowa State College . Cochran , W . G . , and Cox , G . M . ( 1957 ) Experimental designs , 2nd Ed . New York , John Wiley \ & Sons . Lee , Y . , Nelder , J . A . , and Pawitan , Y . ( 2006 ) Generalized linear models with random effects . Uniﬁed analysis via H - likelihood . Boca Raton , Chapman and Hall / CRC . 10 cbpp Examples str ( cake ) # # ’temp’ is continuous , ’temperature’ an ordered factor with 6 levels ( fm1 < - lmer ( angle ~ recipe * temperature + ( 1 | recipe : replicate ) , cake , REML = FALSE ) ) ( fm2 < - lmer ( angle ~ recipe + temperature + ( 1 | recipe : replicate ) , cake , REML = FALSE ) ) ( fm3 < - lmer ( angle ~ recipe + temp + ( 1 | recipe : replicate ) , cake , REML = FALSE ) ) # # and now " choose " : anova ( fm3 , fm2 , fm1 ) cbpp Contagious bovine pleuropneumonia Description Contagious bovine pleuropneumonia ( CBPP ) is a major disease of cattle in Africa , caused by a mycoplasma . This dataset describes the serological incidence of CBPP in zebu cattle during a follow - up survey implemented in 15 commercial herds located in the Boji district of Ethiopia . The goal of the survey was to study the within - herd spread of CBPP in newly infected herds . Blood samples were quarterly collected from all animals of these herds to determine their CBPP status . These data were used to compute the serological incidence of CBPP ( new cases occurring during a given time period ) . Some data are missing ( lost to follow - up ) . Format A data frame with 56 observations on the following 4 variables . herd A factor identifying the herd ( 1 to 15 ) . incidence The number of new serological cases for a given herd and time period . size A numeric vector describing herd size at the beginning of a given time period . period A factor with levels 1 to 4 . Details Serological status was determined using a competitive enzyme - linked immuno - sorbent assay ( cELISA ) . Source Lesnoff , M . , Laval , G . , Bonnet , P . , Abdicho , S . , Workalemahu , A . , Kiﬂe , D . , Peyraud , A . , Lancelot , R . , Thiaucourt , F . ( 2004 ) Within - herd spread of contagious bovine pleuropneumonia in Ethiopian highlands . Preventive Veterinary Medicine 64 , 27 – 40 . conﬁnt . merMod 11 Examples # # response as a matrix ( m1 < - glmer ( cbind ( incidence , size - incidence ) ~ period + ( 1 | herd ) , family = binomial , data = cbpp ) ) # # response as a vector of probabilities and usage of argument " weights " m1p < - glmer ( incidence / size ~ period + ( 1 | herd ) , weights = size , family = binomial , data = cbpp ) # # Confirm that these are equivalent : stopifnot ( all . equal ( fixef ( m1 ) , fixef ( m1p ) , tolerance = 1e - 5 ) , all . equal ( ranef ( m1 ) , ranef ( m1p ) , tolerance = 1e - 5 ) ) # # GLMM with individual - level variability ( accounting for overdispersion ) cbpp $ obs < - 1 : nrow ( cbpp ) ( m2 < - glmer ( cbind ( incidence , size - incidence ) ~ period + ( 1 | herd ) + ( 1 | obs ) , family = binomial , data = cbpp ) ) confint . merMod Compute Conﬁdence Intervals for Parameters of a [ ng ] lmer Fit Description Compute conﬁdence intervals on the parameters of a * lmer ( ) model ﬁt ( of class " merMod " ) . Usage # # S3 method for class ’merMod’ confint ( object , parm , level = 0 . 95 , method = c ( " profile " , " Wald " , " boot " ) , zeta , nsim = 500 , boot . type = c ( " perc " , " basic " , " norm " ) , FUN = NULL , quiet = FALSE , oldNames = TRUE , . . . ) Arguments object a ﬁtted [ ng ] lmer model parm parameters for which intervals are sought . Speciﬁed by an integer vector of positions , character vector of parameter names , or ( unless doing parametric bootstrapping with a user - speciﬁed bootstrap function ) " theta _ " or " beta _ " to specify variance - covariance or ﬁxed effects parameters only : see the which parameter of profile . level conﬁdence level < 1 , typically above 0 . 90 . method a character string determining the method for computing the conﬁdence inter - vals . zeta ( for method = " profile " only : ) likelihood cutoff ( if not speciﬁed , as by de - fault , computed from level ) . 12 conﬁnt . merMod nsim number of simulations for parametric bootstrap intervals . FUN bootstrap function ; if NULL , an internal function that returns the ﬁxed - effect pa - rameters as well as the random - effect parameters on the standard deviation / correlation scale will be used . See bootMer for details . boot . type bootstrap conﬁdence interval type , as described in boot . ci . ( Methods ‘stud’ and ‘bca’ are unavailable because they require additional components to be cal - culated . ) quiet ( logical ) suppress messages about computationally intensive proﬁling ? oldNames ( logical ) use old - style names for variance - covariance parameters , e . g . " . sig01 " , rather than newer ( more informative ) names such as " sd _ ( Intercept ) | Subject " ? ( See signames argument to profile ) . . . . additional parameters to be passed to profile . merMod or bootMer , respec - tively . Details Depending on the method speciﬁed , confint ( ) computes conﬁdence intervals by " profile " : computing a likelihood proﬁle and ﬁnding the appropriate cutoffs based on the likeli - hood ratio test ; " Wald " : approximating the conﬁdence intervals ( of ﬁxed - effect parameters only ; all variance - covariance parameters CIs will be returned as NA ) based on the estimated local curvature of the likelihood surface ; " boot " : performing parametric bootstrapping with conﬁdence intervals computed from the boot - strap distribution according to boot . type ( see bootMer , boot . ci ) . Value a numeric table ( matrix with column and row names ) of conﬁdence intervals ; the conﬁdence inter - vals are computed on the standard deviation scale . Note The default method " profile " amounts to confint ( profile ( object , which = parm ) , signames = oldNames , . . . ) , level , zeta ) where the profile method profile . merMod does almost all the computations . Therefore it is typically advisable to store the proﬁle ( . ) result , say in pp , and then use confint ( pp , level = * ) e . g . , for different levels . Examples fm1 < - lmer ( Reaction ~ Days + ( Days | Subject ) , sleepstudy ) fm1W < - confint ( fm1 , method = " Wald " ) # very fast , but . . . . fm1WtestLevel < - if ( nzchar ( s < - Sys . getenv ( " LME4 _ TEST _ LEVEL " ) ) ) as . numeric ( s ) else 1 convergence 13 if ( interactive ( ) | | testLevel > = 3 ) { # # ~ 20 seconds , MacBook Pro laptop system . time ( fm1P < - confint ( fm1 , method = " profile " , # # default oldNames = FALSE ) ) # # ~ 40 seconds system . time ( fm1B < - confint ( fm1 , method = " boot " , . progress = " txt " , PBargs = list ( style = 3 ) ) ) } elseload ( system . file ( " testdata " , " confint _ ex . rda " , package = " lme4 " ) ) fm1Pfm1B convergence Assessing Convergence for Fitted Models Description The lme4 package uses general - purpose nonlinear optimizers ( e . g . Nelder - Mead or Powell’s BOBYQA method ) to estimate the variance - covariance matrices of the random effects . Assessing reliably whether such algorithms have converged is difﬁcult . For example , evaluating the Karush - Kuhn - Tucker conditions ( convergence criteria which in the simplest case of non - constrained optimization reduce to showing that the gradient is zero and the Hessian is positive deﬁnite ) is challenging be - cause of the difﬁculty of evaluating the gradient and Hessian . We ( the lme4 authors and maintainers ) are still in the process of ﬁnding the best strategies for testing convergence . Some of the relevant issues are • the gradient and Hessian are the basic ingredients of KKT - style testing , but when they have to be estimated by ﬁnite differences ( as in the case of lme4 ; direct computation of derivatives based on analytic expressions may eventually be available for some special classes , but we have not yet implemented them ) they may not be sufﬁciently accurate for reliable convergence testing . • The Hessian computation in particular represents a difﬁcult tradeoff between computational expense and accuracy . At present the Hessian computations used for convergence checking ( and for estimating standard errors of ﬁxed - effect parameters for GLMMs ) follow the ordinal package in using a naive but computationally cheap centered ﬁnite difference computation ( with a ﬁxed step size of 10 − 4 ) . A more reliable but more expensive approach is to use Richardson extrapolation , as implemented in the numDeriv package . • it is important to scale the estimated gradient at the estimate appropriately ; two reasonable approaches are 1 . don’t scale random - effects ( Cholesky ) gradients , since these are essentially already unit - less ( for LMMs they are scaled relative to the residual variance ; for GLMMs they are scaled relative to the sampling variance of the conditional distribution ) ; for GLMMs , scale ﬁxed - effect gradients by the standard deviations of the corresponding input vari - able , or 2 . scale gradients by the inverse Cholesky factor of the Hessian , equivalent to scaling by the estimated Wald standard error of the estimated parameters . The latter approach is 14 convergence used in the current version of lme4 ; it has the disadvantage that it requires us to estimate the Hessian ( although the Hessian is required for reliable estimation of the ﬁxed - effect standard errors for GLMMs in any case ) . • Exploratory analyses suggest that ( 1 ) the naive estimation of the Hessian may fail for large data sets ( number of observations greater than approximately 10 5 ) ; ( 2 ) the magnitude of the scaled gradient increases with sample size , so that warnings will occur even for apparently well - behaved ﬁts with large data sets . If you do see convergence warnings , and want to trouble - shoot / double - check the results , the fol - lowing steps are recommended ( examples are given below ) : • double - check the model speciﬁcation and the data for mistakes • center and scale continuous predictor variables ( e . g . with scale ) • check for singularity : if any of the diagonal elements of the Cholesky factor are zero or very small , the convergence testing methods may be inappropriate ( see examples ) • double - check the Hessian calculation with the more expensive Richardson extrapolation method ( see examples ) • restart the ﬁt from the apparent optimum , or from a point perturbed slightly away from the optimum • try all available optimizers ( e . g . several different implementations of BOBYQA and Nelder - Mead , L - BFGS - B from optim , nlminb , . . . ) While this will of course be slow for large ﬁts , we consider it the gold standard ; if all optimizers converge to values that are practically equivalent , then we would consider the convergence warnings to be false positives . To quote Douglas Adams , we apologize for the inconvenience . See Also lmerControl Examples fm1 < - lmer ( Reaction ~ Days + ( Days | Subject ) , sleepstudy ) # # 1 . center and scale predictors : ss . CS < - transform ( sleepstudy , Days = scale ( Days ) ) fm1 . CS < - update ( fm1 , data = ss . CS ) # # 2 . check singularity diag . vals < - getME ( fm1 , " theta " ) [ getME ( fm1 , " lower " ) = = 0 ] any ( diag . vals < 1e - 6 ) # FALSE # # 3 . recompute gradient and Hessian with Richardson extrapolation devfun < - update ( fm1 , devFunOnly = TRUE ) if ( isLMM ( fm1 ) ) { pars < - getME ( fm1 , " theta " ) } else { # # GLMM : requires both random and fixed parameters pars < - getME ( fm1 , c ( " theta " , " fixef " ) ) } devcomp 15 if ( require ( " numDeriv " ) ) { cat ( " hess : \ n " ) ; print ( hess < - hessian ( devfun , unlist ( pars ) ) ) cat ( " grad : \ n " ) ; print ( grad < - grad ( devfun , unlist ( pars ) ) ) cat ( " scaled gradient : \ n " ) print ( scgrad < - solve ( chol ( hess ) , grad ) ) } # # compare with internal calculations : fm1 @ optinfo $ derivs # # 4 . restart the fit from the original value ( or # # a slightly perturbed value ) : fm1 . restart < - update ( fm1 , start = pars ) # # 5 . try all available optimizers source ( system . file ( " utils " , " allFit . R " , package = " lme4 " ) ) fm1 . all < - allFit ( fm1 ) ss < - summary ( fm1 . all ) ss $ fixef # # extract fixed effects ss $ llik # # log - likelihoods ss $ sdcor # # SDs and correlations ss $ theta # # Cholesky factors ss $ which . OK # # which fits worked devcomp Extract the deviance component list Description Return the deviance component list Usage devcomp ( x ) Arguments x a ﬁtted model of class merMod Details A ﬁtted model of class merMod has a devcomp slot as described in the value section . Value a list with components dims a named integer vector of various dimensions cmp a named numeric vector of components of the deviance 16 drop1 . merMod Note This function is deprecated , use getME ( . , " devcomp " ) drop1 . merMod Drop all possible single ﬁxed - effect terms from a mixed effect model Description Drop allowable single terms from the model : see drop1 for details of how the appropriate scope for dropping terms is determined . Usage # # S3 method for class ’merMod’ drop1 ( object , scope , scale = 0 , test = c ( " none " , " Chisq " , " user " ) , k = 2 , trace = FALSE , sumFun , . . . ) Arguments object a ﬁtted merMod object . scope a formula giving the terms to be considered for adding or dropping . scale Currently ignored ( included for S3 method compatibility ) test should the results include a test statistic relative to the original model ? The χ 2 test is a likelihood - ratio test , which is approximate due to ﬁnite - size effects . k the penalty constant in AIC trace print tracing information ? sumFun a summary function to be used when test = = " user " . It must allow arguments scale and k , but these may be ignored ( e . g . speciﬁed in dots ) . The ﬁrst two ar - guments must be object , the full model ﬁt , and objectDrop , a reduced model . If objectDrop is missing , sumFun should return a vector of with the appropriate length and names ( the actual contents are ignored ) . . . . other arguments ( ignored ) Details drop1 relies on being able to ﬁnd the appropriate information within the environment of the formula of the original model . If the formula is created in an environment that does not contain the data , or other variables passed to the original model ( for example , if a separate function is called to deﬁne the formula ) , then drop1 will fail . A workaround ( see example below ) is to manually specify an appropriate environment for the formula . Value An object of class anova summarizing the differences in ﬁt between the models . drop1 . merMod 17 Examples fm1 < - lmer ( Reaction ~ Days + ( Days | Subject ) , sleepstudy ) # # likelihood ratio tests drop1 ( fm1 , test = " Chisq " ) # # use Kenward - Roger corrected F test , or parametric bootstrap , # # to test the significance of each dropped predictor if ( require ( pbkrtest ) & & packageVersion ( " pbkrtest " ) > = " 0 . 3 . 8 " ) { KRSumFun < - function ( object , objectDrop , . . . ) { krnames < - c ( " ndf " , " ddf " , " Fstat " , " p . value " , " F . scaling " ) r < - if ( missing ( objectDrop ) ) { setNames ( rep ( NA , length ( krnames ) ) , krnames ) } else { krtest < - KRmodcomp ( object , objectDrop ) unlist ( krtest $ stats [ krnames ] ) } attr ( r , " method " ) < - c ( " Kenward - Roger via pbkrtest package " ) r } drop1 ( fm1 , test = " user " , sumFun = KRSumFun ) if ( lme4 : : : testLevel ( ) > = 3 ) { # # takes about 16 sec nsim < - 100 PBSumFun < - function ( object , objectDrop , . . . ) { pbnames < - c ( " stat " , " p . value " ) r < - if ( missing ( objectDrop ) ) { setNames ( rep ( NA , length ( pbnames ) ) , pbnames ) } else { pbtest < - PBmodcomp ( object , objectDrop , nsim = nsim ) unlist ( pbtest $ test [ 2 , pbnames ] ) } attr ( r , " method " ) < - c ( " Parametric bootstrap via pbkrtest package " ) r } system . time ( drop1 ( fm1 , test = " user " , sumFun = PBSumFun ) ) } } # # workaround for creating a formula in a separate environment createFormula < - function ( resp , fixed , rand ) { f < - reformulate ( c ( fixed , rand ) , response = resp ) # # use the parent ( createModel ) environment , not the # # environment of this function ( which does not contain ’data’ ) environment ( f ) < - parent . frame ( ) f } createModel < - function ( data ) { mf . final < - createFormula ( " Reaction " , " Days " , " ( Days | Subject ) " ) lmer ( mf . final , data = data ) } drop1 ( createModel ( data = sleepstudy ) ) 18 Dyestuff dummy Dummy variables ( experimental ) Description Largely a wrapper for model . matrix that accepts a factor , f , and returns a dummy matrix with nlevels ( f ) - 1 columns ( the ﬁrst column is dropped by default ) . Useful whenever one wishes to avoid the behaviour of model . matrix of always returning an nlevels ( f ) - column matrix , either by the addition of an intercept column , or by keeping one column for all levels . Usage dummy ( f , levelsToKeep ) Arguments f An object coercible to factor . levelsToKeep An optional character vector giving the subset of levels ( f ) to be converted to dummy variables . Value A model . matrix with dummy variables as columns . Examples data ( Orthodont , package = " nlme " ) lmer ( distance ~ age + ( age | Subject ) + ( 0 + dummy ( Sex , " Female " ) | Subject ) , data = Orthodont ) Dyestuff Yield of dyestuff by batch Description The Dyestuff data frame provides the yield of dyestuff ( Naphthalene Black 12B ) from 5 different preparations from each of 6 different batchs of an intermediate product ( H - acid ) . The Dyestuff2 data were generated data in the same structure but with a large residual variance relative to the batch variance . Format Data frames , each with 30 observations on the following 2 variables . Batch a factor indicating the batch of the intermediate product from which the preparation was created . Yield the yield of dyestuff from the preparation ( grams of standard color ) . expandDoubleVerts 19 Details The Dyestuff data are described in Davies and Goldsmith ( 1972 ) as coming from “an investigation to ﬁnd out how much the variation from batch to batch in the quality of an intermediate product ( H - acid ) contributes to the variation in the yield of the dyestuff ( Naphthalene Black 12B ) made from it . In the experiment six samples of the intermediate , representing different batches of works manufacture , were obtained , and ﬁve preparations of the dyestuff were made in the laboratory from each sample . The equivalent yield of each preparation as grams of standard colour was determined by dye - trial . ” The Dyestuff2 data are described in Box and Tiao ( 1973 ) as illustrating “ the case where between - batches mean square is less than the within - batches mean square . These data had to be constructed for although examples of this sort undoubtably occur in practice , they seem to be rarely published . ” Source O . L . Davies and P . L . Goldsmith ( eds ) , Statistical Methods in Research and Production , 4th ed . , Oliver and Boyd , ( 1972 ) , section 6 . 4 G . E . P . Box and G . C . Tiao , Bayesian Inference in Statistical Analysis , Addison - Wesley , ( 1973 ) , section 5 . 1 . 2 Examples require ( lattice ) str ( Dyestuff ) dotplot ( reorder ( Batch , Yield ) ~ Yield , Dyestuff , ylab = " Batch " , jitter . y = TRUE , aspect = 0 . 3 , type = c ( " p " , " a " ) ) dotplot ( reorder ( Batch , Yield ) ~ Yield , Dyestuff2 , ylab = " Batch " , jitter . y = TRUE , aspect = 0 . 3 , type = c ( " p " , " a " ) ) ( fm1 < - lmer ( Yield ~ 1 | Batch , Dyestuff ) ) ( fm2 < - lmer ( Yield ~ 1 | Batch , Dyestuff2 ) ) expandDoubleVerts Expand terms with ’ | | ’ notation into separate ’ | ’ terms Description From the right hand side of a formula for a mixed - effects model , expand terms with the double vertical bar operator into separate , independent random effect terms . Usage expandDoubleVerts ( term ) Arguments term a mixed - model formula 20 factorize Value the modiﬁed term Note Because | | works at the level of formula parsing , it has no way of knowing whether a variable is a factor . It just takes the terms within a random - effects term and literally splits them into the intercept and separate no - intercept terms , e . g . ( 1 + x + y | f ) would be split into ( 1 | f ) + ( 0 + x | f ) + ( 0 + y | f ) . However , | | will fail to break up factors into separate terms ; the dummy function can be useful in this case , although it is not as convenient as | | . See Also formula , model . frame , model . matrix , dummy . Other utilities : mkRespMod , mkReTrms , nlformula , nobars , subbars Examples m < - ~ x + ( x | | g ) expandDoubleVerts ( m ) set . seed ( 101 ) dd < - expand . grid ( f = factor ( letters [ 1 : 3 ] ) , g = factor ( 1 : 200 ) , rep = 1 : 3 ) dd $ y < - simulate ( ~ f + ( 1 | g ) + ( 0 + dummy ( f , " b " ) | g ) + ( 0 + dummy ( f , " c " ) | g ) , newdata = dd , newparams = list ( beta = rep ( 0 , 3 ) , theta = c ( 1 , 2 , 1 ) , sigma = 1 ) , family = gaussian ) [ [ 1 ] ] m1 < - lmer ( y ~ f + ( f | g ) , data = dd ) VarCorr ( m1 ) m2 < - lmer ( y ~ f + ( 1 | g ) + ( 0 + dummy ( f , " b " ) | g ) + ( 0 + dummy ( f , " c " ) | g ) , data = dd ) VarCorr ( m2 ) factorize Attempt to convert grouping variables to factors Description If variables within a data frame are not factors , try to convert them . Not intended for end - user use ; this is a utility function that needs to be exported , for technical reasons . Usage factorize ( x , frloc , char . only = FALSE ) ﬁndbars 21 Arguments x a formula frloc a data frame char . only ( logical ) convert only character variables to factors ? Value a copy of the data frame with factors converted findbars Determine random - effects expressions from a formula Description From the right hand side of a formula for a mixed - effects model , determine the pairs of expressions that are separated by the vertical bar operator . Also expand the slash operator in grouping factor ex - pressions and expand terms with the double vertical bar operator into separate , independent random effect terms . Usage findbars ( term ) Arguments term a mixed - model formula Value pairs of expressions that were separated by vertical bars Note This function is called recursively on individual terms in the model , which is why the argument is called term and not a name like form , indicating a formula . See Also formula , model . frame , model . matrix . Other utilities : mkRespMod , mkReTrms , nlformula , nobars , subbars 22 ﬁxef Examples findbars ( f1 < - Reaction ~ Days + ( Days | Subject ) ) # # = > list ( Days | Subject ) # # These two are equivalent : % tests in . . / inst / tests / test - doubleVertNotation . R findbars ( y ~ Days + ( 1 | Subject ) + ( 0 + Days | Subject ) ) findbars ( y ~ Days + ( Days | | Subject ) ) # # = > list of length 2 : list ( 1 | Subject , 0 + Days | Subject ) findbars ( ~ 1 + ( 1 | batch / cask ) ) # # = > list of length 2 : list ( 1 | cask : batch , 1 | batch ) fixef Extract ﬁxed - effects estimates Description Extract the ﬁxed - effects estimates Usage # # S3 method for class ’merMod’ fixef ( object , add . dropped = FALSE , . . . ) Arguments object any ﬁtted model object from which ﬁxed effects estimates can be extracted . add . dropped for models with rank - deﬁcient design matrix , reconstitute the full - length param - eter vector by adding NA values in appropriate locations ? . . . optional additional arguments . Currently none are used in any methods . Details Extract the estimates of the ﬁxed - effects parameters from a ﬁtted model . Value a named , numeric vector of ﬁxed - effects estimates . Examples fixef ( lmer ( Reaction ~ Days + ( 1 | Subject ) + ( 0 + Days | Subject ) , sleepstudy ) ) fm2 < - lmer ( Reaction ~ Days + Days2 + ( 1 | Subject ) , data = transform ( sleepstudy , Days2 = Days ) ) fixef ( fm2 , add . dropped = TRUE ) # # first two parameters are the same . . . stopifnot ( all . equal ( fixef ( fm2 , add . dropped = TRUE ) [ 1 : 2 ] , fixef ( fm2 ) ) ) fortify 23 fortify add information to data based on a ﬁtted model Description add information to data based on a ﬁtted model Usage fortify . merMod ( model , data = getData ( model ) , . . . ) Arguments model ﬁtted model data original data set , if needed . . . additional arguments Details fortify is a function deﬁned in the ggplot2 package , q . v . for more details . fortify is not deﬁned here , and fortify . merMod is deﬁned as a function rather than an S3 method , to avoid ( 1 ) inducing a dependency on ggplot2 or ( 2 ) masking methods from ggplot2 . This is currently an experimental feature . getME Extract or Get Generalized Components from a Fitted Mixed Effects Model Description Extract ( or “get” ) “components” – in a generalized sense – from a ﬁtted mixed - effects model , i . e . , ( in this version of the package ) from an object of class " merMod " . Usage getME ( object , name , . . . ) # # S3 method for class ’merMod’ getME ( object , name = c ( " X " , " Z " , " Zt " , " Ztlist " , " mmList " , " y " , " mu " , " u " , " b " , " Gp " , " Tp " , " L " , " Lambda " , " Lambdat " , " Lind " , " Tlist " , " A " , " RX " , " RZX " , " sigma " , " flist " , " fixef " , " beta " , " theta " , " ST " , " REML " , " is _ REML " , " n _ rtrms " , " n _ rfacs " , " N " , " n " , " p " , " q " , 24 getME " p _ i " , " l _ i " , " q _ i " , " k " , " m _ i " , " m " , " cnms " , " devcomp " , " offset " , " lower " , " devfun " , " glmer . nb . theta " ) , . . . ) Arguments object a ﬁtted mixed - effects model of class " merMod " , i . e . , typically the result of lmer ( ) , glmer ( ) or nlmer ( ) . name a character vector specifying the name ( s ) of the “component” . If length ( name ) > 1 or if name = " ALL " , a named list of components will be returned . Possi - ble values are : " X " : ﬁxed - effects model matrix " Z " : random - effects model matrix " Zt " : transpose of random - effects model matrix . Note that the structure of Zt has changed since lme4 . 0 ; to get a backward - compatible structure , use do . call ( Matrix : : rBind , getME ( . , " Ztlist " ) ) " Ztlist " : list of components of the transpose of the random - effects model ma - trix , separated by individual variance component " mmList " : list of raw model matrices associated with random effects terms " y " : response vector " mu " : conditional mean of the response " u " : conditional mode of the “spherical” random effects variable " b " : conditional mode of the random effects variable " Gp " : groups pointer vector . A pointer to the beginning of each group of ran - dom effects corresponding to the random - effects terms , beginning with 0 and including a ﬁnal element giving the total number of random effects " Tp " : theta pointer vector . A pointer to the beginning of the theta sub - vectors corresponding to the random - effects terms , beginning with 0 and including a ﬁnal element giving the number of thetas . " L " : sparse Cholesky factor of the penalized random - effects model . " Lambda " : relative covariance factor Λ of the random effects . " Lambdat " : transpose Λ (cid:48) of Λ above . " Lind " : index vector for inserting elements of θ into the nonzeros of Λ . " Tlist " : vector of template matrices from which the blocks of Λ are generated . " A " : Scaled sparse model matrix ( class " dgCMatrix " ) for the unit , orthogonal random effects , U , equal to getME ( . , " Zt " ) % * % getME ( . , " Lambdat " ) " RX " : Cholesky factor for the ﬁxed - effects parameters " RZX " : cross - term in the full Cholesky factor " sigma " : residual standard error ; note that sigma ( object ) is preferred . " flist " : a list of the grouping variables ( factors ) involved in the random effect terms " fixef " : ﬁxed - effects parameter estimates " beta " : ﬁxed - effects parameter estimates ( identical to the result of fixef , but without names ) getME 25 " theta " : random - effects parameter estimates : these are parameterized as the relative Cholesky factors of each random effect term " ST " : A list of S and T factors in the TSST’ Cholesky factorization of the rela - tive variance matrices of the random effects associated with each random - effects term . The unit lower triangular matrix , T , and the diagonal matrix , S , for each term are stored as a single matrix with diagonal elements from S and off - diagonal elements from T . " n _ rtrms " : number of random - effects terms " n _ rfacs " : number of distinct random - effects grouping factors " N " : number of rows of X " n " : length of the response vector , y " p " : number of columns of the ﬁxed effects model matrix , X " q " : number of columns of the random effects model matrix , Z " p _ i " : numbers of columns of the raw model matrices , mmList " l _ i " : numbers of levels of the grouping factors " q _ i " : numbers of columns of the term - wise model matrices , ZtList " k " : number of random effects terms " m _ i " : numbers of covariance parameters in each term " m " : total number of covariance parameters " cnms " : the “component names” , a list . " REML " : 0 indicates the model was ﬁtted by maximum likelihood , any other positive integer indicates ﬁtting by restricted maximum likelihood " is _ REML " : same as the result of isREML ( . ) " devcomp " : a list consisting of a named numeric vector , cmp , and a named in - teger vector , dims , describing the ﬁtted model . The elements of cmp are : ldL2 twice the log determinant of L ldRX2 twice the log determinant of RX wrss weighted residual sum of squares ussq squared length of u pwrss penalized weighted residual sum of squares , “wrss + ussq” drsum sum of residual deviance ( GLMMs only ) REML REML criterion at optimum ( LMMs ﬁt by REML only ) dev deviance criterion at optimum ( models ﬁt by ML only ) sigmaML ML estimate of residual standard deviation sigmaREML REML estimate of residual standard deviation tolPwrss tolerance for declaring convergence in the penalized iteratively weighted residual sum - of - squares ( GLMMs only ) The elements of dims are : N number of rows of X n length of y p number of columns of X nmp n - p 26 getME nth length of theta q number of columns of Z nAGQ see glmer compDev see glmerControl useSc TRUE if model has a scale parameter reTrms number of random effects terms REML 0 indicates the model was ﬁtted by maximum likelihood , any other positive integer indicates ﬁtting by restricted maximum likelihood GLMM TRUE if a GLMM NLMM TRUE if an NLMM " offset " : model offset " lower " : lower bounds on model parameters ( random effects parameters only ) . " devfun " : deviance function ( so far only available for LMMs ) " glmer . nb . theta " : negative binomial θ parameter , only for glmer . nb . " ALL " : get all of the above as a list . . . . currently unused in lme4 , potentially further arguments in methods . Details The goal is to provide “everything a user may want” from a ﬁtted " merMod " object as far as it is not available by methods , such as fixef , ranef , vcov , etc . Value Unspeciﬁed , as very much depending on the name . See Also getCall ( ) . More standard methods for " merMod " objects , such as ranef , fixef , vcov , etc . : see methods ( class = " merMod " ) Examples # # shows many methods you should consider * before * using getME ( ) : methods ( class = " merMod " ) ( fm1 < - lmer ( Reaction ~ Days + ( Days | Subject ) , sleepstudy ) ) Z < - getME ( fm1 , " Z " ) stopifnot ( is ( Z , " CsparseMatrix " ) , c ( 180 , 36 ) = = dim ( Z ) , all . equal ( fixef ( fm1 ) , b1 < - getME ( fm1 , " beta " ) , check . attributes = FALSE , tolerance = 0 ) ) # # A way to get * all * getME ( ) s : # # internal consistency check ensuring that all work : parts < - getME ( fm1 , " ALL " ) str ( parts , max = 2 ) stopifnot ( identical ( Z , parts $ Z ) , identical ( b1 , parts $ beta ) ) GHrule 27 GHrule Univariate Gauss - Hermite quadrature rule Description Create a univariate Gauss - Hermite quadrature rule . Usage GHrule ( ord , asMatrix = TRUE ) Arguments ord scalar integer between 1 and 25 - the order , or number of nodes and weights , in the rule . When the function being multiplied by the standard normal density is a polynomial of order 2k - 1 the rule of order k integrates the product exactly . asMatrix logical scalar - should the result be returned as a matrix . If FALSE a data frame is returned . Defaults to TRUE . Details This version of Gauss - Hermite quadrature provides the node positions and weights for a scalar integral of a function multiplied by the standard normal density . Originally based on package SparseGrid ’s hidden GQN ( ) . Value a matrix ( or data frame , is asMatrix is false ) with ord rows and three columns which are z the node positions , w the weights and ldnorm , the logarithm of the normal density evaluated at the nodes . See Also a different interface is available via GQdk ( ) . Examples ( r5 < - GHrule ( 5 , asMatrix = FALSE ) ) # # second , fourth , sixth , eighth and tenth central moments of the # # standard Gaussian density with ( r5 , sapply ( seq ( 2 , 10 , 2 ) , function ( p ) sum ( w * z ^ p ) ) ) 28 glmer glmer Fitting Generalized Linear Mixed - Effects Models Description Fit a generalized linear mixed - effects model ( GLMM ) . Both ﬁxed effects and random effects are speciﬁed via the model formula . Usage glmer ( formula , data = NULL , family = gaussian , control = glmerControl ( ) , start = NULL , verbose = 0L , nAGQ = 1L , subset , weights , na . action , offset , contrasts = NULL , mustart , etastart , devFunOnly = FALSE , . . . ) Arguments formula a two - sided linear formula object describing both the ﬁxed - effects and ﬁxed - effects part of the model , with the response on the left of a ~ operator and the terms , separated by + operators , on the right . Random - effects terms are distin - guished by vertical bars ( " | " ) separating expressions for design matrices from grouping factors . data an optional data frame containing the variables named in formula . By default the variables are taken from the environment from which lmer is called . While data is optional , the package authors strongly recommend its use , especially when later applying methods such as update and drop1 to the ﬁtted model ( such methods are not guaranteed to work properly if data is omitted ) . If data is omitted , variables will be taken from the environment of formula ( if speciﬁed as a formula ) or from the parent frame ( if speciﬁed as a character vector ) . family a GLM family , see glm and family . control a list ( of correct class , resulting from lmerControl ( ) or glmerControl ( ) re - spectively ) containing control parameters , including the nonlinear optimizer to be used and parameters to be passed through to the nonlinear optimizer , see the * lmerControl documentation for details . start a named list of starting values for the parameters in the model , or a numeric vector . A numeric start argument will be used as the starting value of theta . If start is a list , the theta element ( a numeric vector ) is used as the starting value for the ﬁrst optimization step ( default = 1 for diagonal elements and 0 for off - diagonal elements of the lower Cholesky factor ) ; the ﬁtted value of theta from the ﬁrst step , plus start [ [ " fixef " ] ] , are used as starting values for the second optimization step . If start has both fixef and theta elements , the ﬁrst optimization step is skipped . For more details or ﬁner control of optimization , see modular . verbose integer scalar . If > 0 verbose output is generated during the optimization of the parameter estimates . If > 1 verbose output is generated during the individual PIRLS steps . glmer 29 nAGQ integer scalar - the number of points per axis for evaluating the adaptive Gauss - Hermite approximation to the log - likelihood . Defaults to 1 , corresponding to the Laplace approximation . Values greater than 1 produce greater accuracy in the evaluation of the log - likelihood at the expense of speed . A value of zero uses a faster but less exact form of parameter estimation for GLMMs by optimizing the random effects and the ﬁxed - effects coefﬁcients in the penalized iteratively reweighted least squares step . ( See Details . ) subset an optional expression indicating the subset of the rows of data that should be used in the ﬁt . This can be a logical vector , or a numeric vector indicating which observation numbers are to be included , or a character vector of the row names to be included . All observations are included by default . weights an optional vector of ‘prior weights’ to be used in the ﬁtting process . Should be NULL or a numeric vector . na . action a function that indicates what should happen when the data contain NA s . The de - fault action ( na . omit , inherited from the ‘factory fresh’ value of getOption ( " na . action " ) ) strips any observations with any missing values in any variables . offset this can be used to specify an a priori known component to be included in the linear predictor during ﬁtting . This should be NULL or a numeric vector of length equal to the number of cases . One or more offset terms can be included in the formula instead or as well , and if more than one is speciﬁed their sum is used . See model . offset . contrasts an optional list . See the contrasts . arg of model . matrix . default . mustart optional starting values on the scale of the conditional mean , as in glm ; see there for details . etastart optional starting values on the scale of the unbounded predictor as in glm ; see there for details . devFunOnly logical - return only the deviance evaluation function . Note that because the deviance function operates on variables stored in its environment , it may not return exactly the same values on subsequent calls ( but the results should always be within machine tolerance ) . . . . other potential arguments . A method argument was used in earlier versions of the package . Its functionality has been replaced by the nAGQ argument . Details Fit a generalized linear mixed model , which incorporates both ﬁxed - effects parameters and ran - dom effects in a linear predictor , via maximum likelihood . The linear predictor is related to the conditional mean of the response through the inverse link function deﬁned in the GLM family . The expression for the likelihood of a mixed - effects model is an integral over the random effects space . For a linear mixed - effects model ( LMM ) , as ﬁt by lmer , this integral can be evaluated exactly . For a GLMM the integral must be approximated . The most reliable approximation for GLMMs is adaptive Gauss - Hermite quadrature , at present implemented only for models with a single scalar random effect . The nAGQ argument controls the number of nodes in the quadrature for - mula . A model with a single , scalar random - effects term could reasonably use up to 25 quadrature points per scalar integral . 30 glmer Value An object of class merMod ( more speciﬁcally , an object of subclass glmerMod ) for which many methods are available ( e . g . methods ( class = " merMod " ) ) See Also lmer ( for details on formulas and parameterization ) ; glm for Generalized Linear Models ( without random effects ) . nlmer for nonlinear mixed - effects models . glmer . nb to ﬁt negative binomial GLMMs . Examples # # generalized linear mixed model library ( lattice ) xyplot ( incidence / size ~ period | herd , cbpp , type = c ( ’g’ , ’p’ , ’l’ ) , layout = c ( 3 , 5 ) , index . cond = function ( x , y ) max ( y ) ) ( gm1 < - glmer ( cbind ( incidence , size - incidence ) ~ period + ( 1 | herd ) , data = cbpp , family = binomial ) ) # # using nAGQ = 0 only gets close to the optimum ( gm1a < - glmer ( cbind ( incidence , size - incidence ) ~ period + ( 1 | herd ) , cbpp , binomial , nAGQ = 0 ) ) # # using nAGQ = 9 provides a better evaluation of the deviance # # Currently the internal calculations use the sum of deviance residuals , # # which is not directly comparable with the nAGQ = 0 or nAGQ = 1 result . ( gm1a < - glmer ( cbind ( incidence , size - incidence ) ~ period + ( 1 | herd ) , cbpp , binomial , nAGQ = 9 ) ) # # GLMM with individual - level variability ( accounting for overdispersion ) # # For this data set the model is the same as one allowing for a period : herd # # interaction , which the plot indicates could be needed . cbpp $ obs < - 1 : nrow ( cbpp ) ( gm2 < - glmer ( cbind ( incidence , size - incidence ) ~ period + ( 1 | herd ) + ( 1 | obs ) , family = binomial , data = cbpp ) ) anova ( gm1 , gm2 ) # # glmer and glm log - likelihoods are consistent gm1Devfun < - update ( gm1 , devFunOnly = TRUE ) gm0 < - glm ( cbind ( incidence , size - incidence ) ~ period , family = binomial , data = cbpp ) # # evaluate GLMM deviance at RE variance = theta = 0 , beta = ( GLM coeffs ) gm1Dev0 < - gm1Devfun ( c ( 0 , coef ( gm0 ) ) ) # # compare stopifnot ( all . equal ( gm1Dev0 , c ( - 2 * logLik ( gm0 ) ) ) ) # # the toenail oncholysis data from Backer et al 1998 # # these data are notoriously difficult to fit # # Not run : if ( require ( " HSAUR2 " ) ) { gm2 < - glmer ( outcome ~ treatment * visit + ( 1 | patientID ) , data = toenail , family = binomial , nAGQ = 20 ) glmer . nb 31 } # # End ( Not run ) glmer . nb Fitting Negative Binomial GLMMs Description Fits a generalized linear mixed - effects model ( GLMM ) for the negative binomial family , building on glmer , and initializing via theta . ml from MASS . Usage glmer . nb ( . . . , interval = log ( th ) + c ( - 3 , 3 ) , tol = 5e - 5 , verbose = FALSE , nb . control = NULL , initCtrl = list ( limit = 20 , eps = 2 * tol , trace = verbose ) ) Arguments . . . arguments as for glmer ( . ) such as formula , data , control , etc , but not family ! interval interval in which to start the optimization . The default is symmetric on log scale around the initially estimated theta . tol tolerance for the optimization via optimize . verbose logical indicating how much progress information should be printed during the optimization . Use verbose = 2 ( or larger ) to enable verbose = TRUE in the glmer ( ) calls . nb . control optional list , like glmerControl ( ) , used in refit ( * , control = control . nb ) during the optimization . initCtrl ( experimental , do not rely on this : ) a list with named components as in the default , passed to theta . ml ( package MASS ) for the initial value of the negative binomial parameter theta . Value An object of class glmerMod , for which many methods are available ( e . g . methods ( class = " glmerMod " ) ) , see glmer . Note For historical reasons , the shape parameter of the negative binomial and the random effects param - eters in our ( G ) LMM models are both called theta ( θ ) , but are unrelated here . The negative binomial θ can be extracted from a ﬁt g < - glmer . nb ( ) by getME ( g , " glmer . nb . theta " ) . Parts of glmer . nb ( ) are still experimental and methods are still missing or suboptimal . In particu - lar , there is no inference available for the dispersion parameter θ , yet . 32 glmerLaplaceHandle See Also glmer ; from package MASS , negative . binomial ( which we re - export currently ) and theta . ml , the latter for initialization of optimization . The ‘Details’ of pnbinom for the deﬁnition of the negative binomial distribution . Examples set . seed ( 101 ) dd < - expand . grid ( f1 = factor ( 1 : 3 ) , f2 = LETTERS [ 1 : 2 ] , g = 1 : 9 , rep = 1 : 15 , KEEP . OUT . ATTRS = FALSE ) summary ( mu < - 5 * ( - 4 + with ( dd , as . integer ( f1 ) + 4 * as . numeric ( f2 ) ) ) ) dd $ y < - rnbinom ( nrow ( dd ) , mu = mu , size = 0 . 5 ) str ( dd ) require ( " MASS " ) # # and use its glm . nb ( ) - as indeed we have zero random effect : # # Not run : m . glm < - glm . nb ( y ~ f1 * f2 , data = dd , trace = TRUE ) summary ( m . glm ) m . nb < - glmer . nb ( y ~ f1 * f2 + ( 1 | g ) , data = dd , verbose = TRUE ) m . nb # # The neg . binomial theta parameter : getME ( m . nb , " glmer . nb . theta " ) LL < - logLik ( m . nb ) # # mixed model has 1 additional parameter ( RE variance ) stopifnot ( attr ( LL , " df " ) = = attr ( logLik ( m . glm ) , " df " ) + 1 ) plot ( m . nb , resid ( . ) ~ g ) # works , as long as data ’dd’ is found # # End ( Not run ) glmerLaplaceHandle Handle for glmerLaplace Description Handle for calling the glmerLaplace C + + function . Not intended for routine use . Usage glmerLaplaceHandle ( pp , resp , nAGQ , tol , maxit , verbose ) Arguments pp merPredD object resp lmResp object nAGQ see glmer tol tolerance maxit maximum number of pwrss iterations verbose display optimizer progress glmFamily 33 Value Value of the objective function glmFamily Generator object for the glmFamily class Description The generator object for the glmFamily reference class . Such an object is primarily used through its new method . Usage glmFamily ( . . . ) Arguments . . . Named argument ( see Note below ) Methods new ( family = family ) Create a new glmFamily object Note Arguments to the new method must be named arguments . See Also glmFamily glmFamily - class Class " glmFamily " - a reference class for family Description This class is a wrapper class for family objects specifying a distibution family and link function for a generalized linear model ( glm ) . The reference class contains an external pointer to a C + + object representing the class . For common families and link functions the functions in the family are implemented in compiled code so they can be accessed from other compiled code and for a speed boost . Extends All reference classes extend and inherit methods from " envRefClass " . 34 golden - class Note Objects from this reference class correspond to objects in a C + + class . Methods are invoked on the C + + class using the external pointer in the Ptr ﬁeld . When saving such an object the external pointer is converted to a null pointer , which is why there is a redundant ﬁeld ptr that is an active - binding function returning the external pointer . If the Ptr ﬁeld is a null pointer , the external pointer is regenerated for the stored family ﬁeld . See Also family , glmFamily Examples str ( glmFamily $ new ( family = poisson ( ) ) ) golden - class Class " golden " and Generator for Golden Search Optimizer Class Description " golden " is a reference class for a golden search scalar optimizer , for a parameter within an interval . golden ( ) is the generator for the " golden " class . The optimizer uses reverse communications . Usage golden ( . . . ) Arguments . . . ( partly optional ) arguments passed to new ( ) must be named arguments . lower and upper are the bounds for the scalar parameter ; they must be ﬁnite . Extends All reference classes extend and inherit methods from " envRefClass " . Examples showClass ( " golden " ) golden ( lower = - 100 , upper = 1e100 ) GQdk 35 GQdk Sparse Gaussian / Gauss - Hermite Quadrature grid Description Generate the sparse multidimensional Gaussian quadrature grids . Currently unused . See GHrule ( ) for the version currently in use in package lme4 . Usage GQdk ( d = 1L , k = 1L ) GQN Arguments d integer scalar - the dimension of the function to be integrated with respect to the standard d - dimensional Gaussian density . k integer scalar - the order of the grid . A grid of order k provides an exact result for a polynomial of total order of 2k - 1 or less . Value GQdk ( ) returns a matrix with d + 1 columns . The ﬁrst column is the weights and the remaining d columns are the node coordinates . GQN is a list of lists , containing the non - redundant quadrature nodes and weights for integration of a scalar function of a d - dimensional argument with respect to the density function of the d - dimensional Gaussian density function . The outer list is indexed by the dimension , d , in the range of 1 to 20 . The inner list is indexed by k , the order of the quadrature . Note GQN contains only the non - redundant nodes . To regenerate the whole array of nodes , all possible permutations of axes and all possible combinations of ± 1 must be applied to the axes . This entire array of nodes is exactly what GQdk ( ) reproduces . The number of nodes gets very large very quickly with increasing d and k . See the charts at http : / / www . sparse - grids . de . Examples GQdk ( 2 , 5 ) # 53 x 3 GQN [ [ 3 ] ] [ [ 5 ] ] # a 14 x 4 matrix 36 grouseticks grouseticks Data on red grouse ticks from Elston et al . 2001 Description Number of ticks on the heads of red grouse chicks sampled in the ﬁeld ( grouseticks ) and an aggregated version ( grouseticks _ agg ) ; see original source for more details Usage data ( grouseticks ) Format INDEX ( factor ) chick number ( observation level ) TICKS number of ticks sampled BROOD ( factor ) brood number HEIGHT height above sea level ( meters ) YEAR year ( - 1900 ) LOCATION ( factor ) geographic location code cHEIGHT centered height , derived from HEIGHT meanTICKS mean number of ticks by brood varTICKS variance of number of ticks by brood Details grouseticks _ agg is just a brood - level aggregation of the data Source Robert Moss , via David Elston References Elston , D . A . , R . Moss , T . Boulinier , C . Arrowsmith , and X . Lambin . 2001 . " Analysis of Aggre - gation , a Worked Example : Numbers of Ticks on Red Grouse Chicks . " Parasitology 122 ( 05 ) : 563 - 569 . doi : 10 . 1017 / S0031182001007740 . http : / / journals . cambridge . org / action / displayAbstract ? fromPage = online & aid = 82701 . hatvalues . merMod 37 Examples data ( grouseticks ) # # Figure 1a from Elston et al par ( las = 1 , bty = " l " ) tvec < - c ( 0 , 1 , 2 , 5 , 20 , 40 , 80 ) pvec < - c ( 4 , 1 , 3 ) with ( grouseticks _ agg , plot ( 1 + meanTICKS ~ HEIGHT , pch = pvec [ factor ( YEAR ) ] , log = " y " , axes = FALSE , xlab = " Altitude ( m ) " , ylab = " Brood mean ticks " ) ) axis ( side = 1 ) axis ( side = 2 , at = tvec + 1 , label = tvec ) box ( ) abline ( v = 405 , lty = 2 ) # # Figure 1b with ( grouseticks _ agg , plot ( varTICKS ~ meanTICKS , pch = 4 , xlab = " Brood mean ticks " , ylab = " Within - brood variance " ) ) curve ( 1 * x , from = 0 , to = 70 , add = TRUE ) # # Model fitting form < - TICKS ~ YEAR + HEIGHT + ( 1 | BROOD ) + ( 1 | INDEX ) + ( 1 | LOCATION ) ( full _ mod1 < - glmer ( form , family = " poisson " , data = grouseticks ) ) hatvalues . merMod Diagonal elements of the hat matrix Description Returns the values on the diagonal of the hat matrix , which is the matrix that transforms the response vector ( minus any offset ) into the ﬁtted values ( minus any offset ) . Note that this method should only be used for linear mixed models . It is not clear if the hat matrix concept even makes sense for generalized linear mixed models . Usage # # S3 method for class ’merMod’ hatvalues ( model , fullHatMatrix = FALSE , . . . ) Arguments model An object of class merMod . fullHatMatrix Return full hat matrix ( not just diagonal values ) ? . . . Not currently used Value The diagonal elements of the hat matrix . 38 InstEval Examples m < - lmer ( Reaction ~ Days + ( Days | Subject ) , sleepstudy ) hatvalues ( m ) InstEval University Lecture / Instructor Evaluations by Students at ETH Description University lecture evaluations by students at ETH Zurich , anonymized for privacy protection . This is an interesting “medium” sized example of a partially nested mixed effect model . Format A data frame with 73421 observations on the following 7 variables . s a factor with levels 1 : 2972 denoting individual students . d a factor with 1128 levels from 1 : 2160 , denoting individual professors or lecturers . studage an ordered factor with levels 2 < 4 < 6 < 8 , denoting student’s “age” measured in the semester number the student has been enrolled . lectage an ordered factor with 6 levels , 1 < 2 < . . . < 6 , measuring how many semesters back the lecture rated had taken place . service a binary factor with levels 0 and 1 ; a lecture is a “service” , if held for a different depart - ment than the lecturer’s main one . dept a factor with 14 levels from 1 : 15 , using a random code for the department of the lecture . y a numeric vector of ratings of lectures by the students , using the discrete scale 1 : 5 , with meanings of ‘poor’ to ‘very good’ . Each observation is one student’s rating for a speciﬁc lecture ( of one lecturer , during one semester in the past ) . Details The main goal of the survey is to ﬁnd “the best liked prof” , according to the lectures given . Statis - tical analysis of such data has been the basis for a ( student ) jury selecting the ﬁnal winners . The present data set has been anonymized and slightly simpliﬁed on purpose . Examples str ( InstEval ) head ( InstEval , 16 ) xtabs ( ~ service + dept , InstEval ) isNested 39 isNested Is f1 nested within f2 ? Description Does every level of f1 occur in conjunction with exactly one level of f2 ? The function is based on converting a triplet sparse matrix to a compressed column - oriented form in which the nesting can be quickly evaluated . Usage isNested ( f1 , f2 ) Arguments f1 factor 1 f2 factor 2 Value TRUE if factor 1 is nested within factor 2 Examples with ( Pastes , isNested ( cask , batch ) ) # # = > FALSE with ( Pastes , isNested ( sample , batch ) ) # # = > TRUE isREML Check characteristics of models Description Check characteristics of models : whether a model ﬁt corresponds to a linear ( LMM ) , generalized linear ( GLMM ) , or nonlinear ( NLMM ) mixed model , and whether a linear mixed model has been ﬁtted by REML or not ( isREML ( x ) is always FALSE for GLMMs and NLMMs ) . Usage isREML ( x , . . . ) isLMM ( x , . . . ) isNLMM ( x , . . . ) isGLMM ( x , . . . ) 40 lmer Arguments x a ﬁtted model . . . . additional , optional arguments . ( None are used in the merMod methods ) Details These are generic functions . At present the only methods are for mixed - effects models of class merMod . Value a logical value See Also getME Examples fm1 < - lmer ( Reaction ~ Days + ( Days | Subject ) , sleepstudy ) gm1 < - glmer ( cbind ( incidence , size - incidence ) ~ period + ( 1 | herd ) , data = cbpp , family = binomial ) nm1 < - nlmer ( circumference ~ SSlogis ( age , Asym , xmid , scal ) ~ Asym | Tree , Orange , start = c ( Asym = 200 , xmid = 725 , scal = 350 ) ) isLMM ( fm1 ) isGLMM ( gm1 ) # # check all : is . MM < - function ( x ) c ( LMM = isLMM ( x ) , GLMM = isGLMM ( x ) , NLMM = isNLMM ( x ) ) stopifnot ( cbind ( is . MM ( fm1 ) , is . MM ( gm1 ) , is . MM ( nm1 ) ) = = diag ( rep ( TRUE , 3 ) ) ) lmer Fit Linear Mixed - Effects Models Description Fit a linear mixed - effects model ( LMM ) to data , via REML or maximum likelihood . Usage lmer ( formula , data = NULL , REML = TRUE , control = lmerControl ( ) , start = NULL , verbose = 0L , subset , weights , na . action , offset , contrasts = NULL , devFunOnly = FALSE , . . . ) lmer 41 Arguments formula a two - sided linear formula object describing both the ﬁxed - effects and random - effects part of the model , with the response on the left of a ~ operator and the terms , separated by + operators , on the right . Random - effects terms are dis - tinguished by vertical bars ( | ) separating expressions for design matrices from grouping factors . Two vertical bars ( | | ) can be used to specify multiple uncor - related random effects for the same grouping variable . ( Because of the way it is implemented , the | | - syntax works only for design matrices containing numeric ( continuous ) predictors ; to ﬁt models with independent categorical effects , see dummy or the lmer _ alt function from the afex package . ) data an optional data frame containing the variables named in formula . By default the variables are taken from the environment from which lmer is called . While data is optional , the package authors strongly recommend its use , especially when later applying methods such as update and drop1 to the ﬁtted model ( such methods are not guaranteed to work properly if data is omitted ) . If data is omitted , variables will be taken from the environment of formula ( if speciﬁed as a formula ) or from the parent frame ( if speciﬁed as a character vector ) . REML logical scalar - Should the estimates be chosen to optimize the REML criterion ( as opposed to the log - likelihood ) ? control a list ( of correct class , resulting from lmerControl ( ) or glmerControl ( ) re - spectively ) containing control parameters , including the nonlinear optimizer to be used and parameters to be passed through to the nonlinear optimizer , see the * lmerControl documentation for details . start a named list of starting values for the parameters in the model . For lmer this can be a numeric vector or a list with one component named " theta " . verbose integer scalar . If > 0 verbose output is generated during the optimization of the parameter estimates . If > 1 verbose output is generated during the individual PIRLS steps . subset an optional expression indicating the subset of the rows of data that should be used in the ﬁt . This can be a logical vector , or a numeric vector indicating which observation numbers are to be included , or a character vector of the row names to be included . All observations are included by default . weights an optional vector of ‘prior weights’ to be used in the ﬁtting process . Should be NULL or a numeric vector . Prior weights are not normalized or standardized in any way . In particular , the diagonal of the residual covariance matrix is the squared residual standard deviation parameter sigma times the vector of inverse weights . Therefore , if the weights have relatively large magnitudes , then in order to compensate , the sigma parameter will also need to have a relatively large magnitude . na . action a function that indicates what should happen when the data contain NA s . The de - fault action ( na . omit , inherited from the ’factory fresh’ value of getOption ( " na . action " ) ) strips any observations with any missing values in any variables . offset this can be used to specify an a priori known component to be included in the linear predictor during ﬁtting . This should be NULL or a numeric vector of length equal to the number of cases . One or more offset terms can be included in the 42 lmer formula instead or as well , and if more than one is speciﬁed their sum is used . See model . offset . contrasts an optional list . See the contrasts . arg of model . matrix . default . devFunOnly logical - return only the deviance evaluation function . Note that because the deviance function operates on variables stored in its environment , it may not return exactly the same values on subsequent calls ( but the results should always be within machine tolerance ) . . . . other potential arguments . A method argument was used in earlier versions of the package . Its functionality has been replaced by the REML argument . Details • If the formula argument is speciﬁed as a character vector , the function will attempt to coerce it to a formula . However , this is not recommended ( users who want to construct formulas by pasting together components are advised to use as . formula or reformulate ) ; model ﬁts will work but subsequent methods such as drop1 , update may fail . • When handling perfectly collinear predictor variables ( i . e . design matrices of less than full rank ) , [ gn ] lmer is not quite as sophisticated as some simpler modeling frameworks such as lm and glm . While it does automatically drop collinear variables ( with a message rather than a warning ) , it does not automatically ﬁll in NA values for the dropped coefﬁcients ; these can be added via fixef ( fitted . model , add . dropped = TRUE ) . This information can also be retrieved via attr ( getME ( fitted . model , " X " ) , " col . dropped " ) . • the deviance function returned when devFunOnly is TRUE takes a single numeric vector ar - gument , representing the theta vector . This vector deﬁnes the scaled variance - covariance matrices of the random effects , in the Cholesky parameterization . For models with only sim - ple ( intercept - only ) random effects , theta is a vector of the standard deviations of the random effects . For more complex or multiple random effects , running getME ( . , " theta " ) to retrieve the theta vector for a ﬁtted model and examining the names of the vector is probably the easiest way to determine the correspondence between the elements of the theta vector and elements of the lower triangles of the Cholesky factors of the random effects . Value An object of class merMod ( more speciﬁcally , an object of subclass lmerMod ) , for which many methods are available ( e . g . methods ( class = " merMod " ) ) See Also lm for linear models ; glmer for generalized linear ; and nlmer for nonlinear mixed models . Examples # # linear mixed models - reference values from older code ( fm1 < - lmer ( Reaction ~ Days + ( Days | Subject ) , sleepstudy ) ) summary ( fm1 ) # ( with its own print method ; see class ? merMod % . / merMod - class . Rd str ( terms ( fm1 ) ) stopifnot ( identical ( terms ( fm1 , fixed . only = FALSE ) , lmerControl 43 terms ( model . frame ( fm1 ) ) ) ) attr ( terms ( fm1 , FALSE ) , " dataClasses " ) # fixed . only = FALSE needed for dataCl . fm1 _ ML < - update ( fm1 , REML = FALSE ) ( fm2 < - lmer ( Reaction ~ Days + ( Days | | Subject ) , sleepstudy ) ) anova ( fm1 , fm2 ) sm2 < - summary ( fm2 ) print ( fm2 , digits = 7 , ranef . comp = " Var " ) # the print . merMod ( ) method print ( sm2 , digits = 3 , corr = FALSE ) # the print . summary . merMod ( ) method ( vv < - vcov . merMod ( fm2 , corr = TRUE ) ) as ( vv , " corMatrix " ) # extracts the ( " hidden " ) ’correlation’ entry in @ factors # # Fit sex - specific variances by constructing numeric dummy variables # # for sex and sex : age ; in this case the estimated variance differences # # between groups in both intercept and slope are zero . . . data ( Orthodont , package = " nlme " ) Orthodont $ nsex < - as . numeric ( Orthodont $ Sex = = " Male " ) Orthodont $ nsexage < - with ( Orthodont , nsex * age ) lmer ( distance ~ age + ( age | Subject ) + ( 0 + nsex | Subject ) + ( 0 + nsexage | Subject ) , data = Orthodont ) lmerControl Control of Mixed Model Fitting Description Construct control structures for mixed model ﬁtting . All arguments have defaults , and can be grouped into • general control parameters , most importantly optimizer , further restart _ edge , etc ; • model - or data - checking speciﬁcations , in short “checking options” , such as check . nobs . vs . rankZ , or check . rankX ( currently not for nlmerControl ) ; • all the parameters to be passed to the optimizer , e . g . , maximal number of iterations , passed via the optCtrl list argument . Usage lmerControl ( optimizer = " bobyqa " , restart _ edge = TRUE , boundary . tol = 1e - 5 , calc . derivs = TRUE , use . last . params = FALSE , sparseX = FALSE , # # input checking options check . nobs . vs . rankZ = " ignore " , check . nobs . vs . nlev = " stop " , check . nlev . gtreq . 5 = " ignore " , 44 lmerControl check . nlev . gtr . 1 = " stop " , check . nobs . vs . nRE = " stop " , check . rankX = c ( " message + drop . cols " , " silent . drop . cols " , " warn + drop . cols " , " stop . deficient " , " ignore " ) , check . scaleX = c ( " warning " , " stop " , " silent . rescale " , " message + rescale " , " warn + rescale " , " ignore " ) , check . formula . LHS = " stop " , # # convergence checking options check . conv . grad = . makeCC ( " warning " , tol = 2e - 3 , relTol = NULL ) , check . conv . singular = . makeCC ( action = " ignore " , tol = 1e - 4 ) , check . conv . hess = . makeCC ( action = " warning " , tol = 1e - 6 ) , # # optimizer args optCtrl = list ( ) ) glmerControl ( optimizer = c ( " bobyqa " , " Nelder _ Mead " ) , restart _ edge = FALSE , boundary . tol = 1e - 5 , calc . derivs = TRUE , use . last . params = FALSE , sparseX = FALSE , tolPwrss = 1e - 7 , compDev = TRUE , nAGQ0initStep = TRUE , # # input checking options check . nobs . vs . rankZ = " ignore " , check . nobs . vs . nlev = " stop " , check . nlev . gtreq . 5 = " ignore " , check . nlev . gtr . 1 = " stop " , check . nobs . vs . nRE = " stop " , check . rankX = c ( " message + drop . cols " , " silent . drop . cols " , " warn + drop . cols " , " stop . deficient " , " ignore " ) , check . scaleX = " warning " , check . formula . LHS = " stop " , check . response . not . const = " stop " , # # convergence checking options check . conv . grad = . makeCC ( " warning " , tol = 1e - 3 , relTol = NULL ) , check . conv . singular = . makeCC ( action = " ignore " , tol = 1e - 4 ) , check . conv . hess = . makeCC ( action = " warning " , tol = 1e - 6 ) , # # optimizer args optCtrl = list ( ) ) nlmerControl ( optimizer = " Nelder _ Mead " , tolPwrss = 1e - 10 , optCtrl = list ( ) ) . makeCC ( action , tol , relTol , . . . ) lmerControl 45 Arguments optimizer character - name of optimizing function ( s ) . A character vector or list of func - tions : length 1 for lmer or glmer , possibly length 2 for glmer ) . The built - in optimizers are Nelder _ Mead and bobyqa ( from the minqa package ) . Any min - imizing function that allows box constraints can be used provided that it ( 1 ) takes input parameters fn ( function to be optimized ) , par ( starting parame - ter values ) , lower ( lower bounds ) and control ( control parameters , passed through from the control argument ) and ( 2 ) returns a list with ( at least ) elements par ( best - ﬁt parameters ) , fval ( best - ﬁt function value ) , conv ( convergence code , equal to zero for successful con - vergence ) and ( optionally ) message ( informational message , or explanation of convergence failure ) . Special provisions are made for bobyqa , Nelder _ Mead , and optimizers wrapped in the optimx package ; to use the optimx optimizers ( including L - BFGS - B from base optim and nlminb ) , pass the method argument to optim in the optCtrl ar - gument ( you may also need to load the optimx package manually using library ( optimx ) or require ( optimx ) ) . For glmer , if length ( optimizer ) = = 2 , the ﬁrst element will be used for the preliminary ( random effects parameters only ) optimization , while the second will be used for the ﬁnal ( random effects plus ﬁxed effect parameters ) phase . See modular for more information on these two phases . calc . derivs logical - compute gradient and Hessian of nonlinear optimization solution ? use . last . params logical - should the last value of the parameters evaluated ( TRUE ) , rather than the value of the parameters corresponding to the minimum deviance , be returned ? This is a " backward bug - compatibility " option ; use TRUE only when trying to match previous results . sparseX logical - should a sparse model matrix be used for the ﬁxed - effects terms ? Cur - rently inactive . restart _ edge logical - should the optimizer attempt a restart when it ﬁnds a solution at the boundary ( i . e . zero random - effect variances or perfect + / - 1 correlations ) ? ( Cur - rently only implemented for lmerControl . ) boundary . tol numeric - within what distance of a boundary should the boundary be checked for a better ﬁt ? ( Set to zero to disable boundary checking . ) tolPwrss numeric scalar - the tolerance for declaring convergence in the penalized itera - tively weighted residual sum - of - squares step . compDev logical scalar - should compiled code be used for the deviance evaluation during the optimization of the parameter estimates ? nAGQ0initStep do one initial run with nAGQ = 0 . check . nlev . gtreq . 5 character - rules for checking whether all random effects have > = 5 levels . See action . check . nlev . gtr . 1 character - rules for checking whether all random effects have > 1 level . See action . 46 lmerControl check . nobs . vs . rankZ character - rules for checking whether the number of observations is greater than ( or greater than or equal to ) the rank of the random effects design matrix ( Z ) , usually necessary for identiﬁable variances . As for action , with the addition of " warningSmall " and " stopSmall " , which run the test only if the dimensions of Z are < 1e6 . nobs > rank ( Z ) will be tested for LMMs and GLMMs with estimated scale parameters ; nobs > = rank ( Z ) will be tested for GLMMs with ﬁxed scale parameter . The rank test is done using the method = " qr " option of the rankMatrix function . check . nobs . vs . nlev character - rules for checking whether the number of observations is less than ( or less than or equal to ) the number of levels of every grouping factor , usually necessary for identiﬁable variances . As for action . nobs < nlevels will be tested for LMMs and GLMMs with estimated scale parameters ; nobs < = nlevels will be tested for GLMMs with ﬁxed scale parameter . check . nobs . vs . nRE character - rules for checking whether the number of observations is greater than ( or greater than or equal to ) the number of random - effects levels for each term , usually necessary for identiﬁable variances . As for check . nobs . vs . nlev . check . conv . grad rules for checking the gradient of the deviance function for convergence . A list as returned by . makeCC , or a character string with only the action . check . conv . singular rules for checking for a singular ﬁt , i . e . one where some parameters are on the boundary of the feasible space ( for example , random effects variances equal to 0 or correlations between random effects equal to + / - 1 . 0 ) ; as for check . conv . grad above . check . conv . hess rules for checking the Hessian of the deviance function for convergence . ; as for check . conv . grad above . check . rankX character - specifying if rankMatrix ( X ) should be compared with ncol ( X ) and if columns from the design matrix should possibly be dropped to ensure that it has full rank . Sometimes needed to make the model identiﬁable . The op - tions can be abbreviated ; the three " * . drop . cols " options all do drop columns , " stop . deficient " gives an error when the rank is smaller than the number of columns where " ignore " does no rank computation , and will typically lead to less easily understandable errors , later . check . scaleX character - check for problematic scaling of columns of ﬁxed - effect model ma - trix , e . g . parameters measured on very different scales . check . formula . LHS check whether speciﬁed formula has a left - hand side . Primarily for internal use within simulate . merMod ; use at your own risk as it may allow the generation of unstable merMod objects check . response . not . const character - check that the response is not constant . optCtrl a list of additional arguments to be passed to the nonlinear optimizer ( see Nelder _ Mead , bobyqa ) . In particular , both Nelder _ Mead and bobyqa use maxfun lmerControl 47 to specify the maximum number of function evaluations they will try before giv - ing up - in contrast to optim and optimx - wrapped optimizers , which use maxit . action character - generic choices for the severity level of any test . " ignore " : skip the test . " warning " : warn if test fails . " stop " : throw an error if test fails . tol numeric - tolerance for check relTol numeric - tolerance for checking relative variation . . . other elements to include in check speciﬁcation Details Note that ( only ! ) the pre - ﬁtting “checking options” ( i . e . , all those starting with " check . " but not including the convergence checks ( " check . conv . * " ) or rank - checking ( " check . rank * " ) options ) may also be set globally via options . In that case , ( g ) lmerControl will use them rather than the default values , but will not override values that are passed as explicit arguments . For example , options ( lmerControl = list ( check . nobs . vs . rankZ = " ignore " ) ) will suppress warnings that the number of observations is less than the rank of the random effects model matrix Z . Value The * Control functions return a list ( inheriting from class " merControl " ) containing 1 . general control parameters , such as optimizer , restart _ edge ; 2 . ( currently not for nlmerControl : ) " checkControl " , a list of data - checking speciﬁcations , e . g . , check . nobs . vs . rankZ ; 3 . parameters to be passed to the optimizer , i . e . , the optCtrl list , which may contain maxiter . . makeCC returns a list containing the check speciﬁcation ( action , tolerance , and optionally relative tolerance ) . See Also convergence Examples str ( lmerControl ( ) ) str ( glmerControl ( ) ) # # Not run : # # fit with default " bobyqa " algorithm . . . fm0 < - lmer ( Reaction ~ Days + ( 1 | Subject ) , sleepstudy ) fm1 < - lmer ( Reaction ~ Days + ( Days | Subject ) , sleepstudy ) # # or with " Nelder _ Mead " ( the previous default ) . . . fm1 _ bobyqa < - update ( fm1 , control = lmerControl ( optimizer = " Nelder _ Mead " ) ) # # or with the nlminb function used in older ( < 1 . 0 ) versions of lme4 ; # # this will usually replicate older results require ( optimx ) fm1 _ nlminb < - update ( fm1 , control = lmerControl ( optimizer = " optimx " , 48 lmList optCtrl = list ( method = " nlminb " ) ) ) # # The other option here is method = " L - BFGS - B " . # # Or we can wrap base : : optim ( ) : optimwrap < - function ( fn , par , lower , upper , control = list ( ) , . . . ) { if ( is . null ( control $ method ) ) stop ( " must specify method in optCtrl " ) method < - control $ method control $ method < - NULL # # " Brent " requires finite upper values ( lower bound will always # # be zero in this case ) if ( method = = " Brent " ) upper < - pmin ( 1e4 , upper ) res < - optim ( par = par , fn = fn , lower = lower , upper = upper , control = control , method = method , . . . ) with ( res , list ( par = par , fval = value , feval = counts [ 1 ] , conv = convergence , message = message ) ) } fm0 _ brent < - update ( fm0 , control = lmerControl ( optimizer = " optimwrap " , optCtrl = list ( method = " Brent " ) ) ) # # You can also use functions from the nloptr package . if ( require ( nloptr ) ) { defaultControl < - list ( algorithm = " NLOPT _ LN _ BOBYQA " , xtol _ abs = 1e - 6 , ftol _ abs = 1e - 6 , maxeval = 1e5 ) nloptwrap < - function ( fn , par , lower , upper , control = list ( ) , . . . ) { for ( n in names ( defaultControl ) ) if ( is . null ( control [ [ n ] ] ) ) control [ [ n ] ] < - defaultControl [ [ n ] ] res < - nloptr ( x0 = par , eval _ f = fn , lb = lower , ub = upper , opts = control , . . . ) with ( res , list ( par = solution , fval = objective , feval = iterations , conv = if ( status > 0 ) 0 else status , message = message ) ) } fm1 _ nloptr < - update ( fm1 , control = lmerControl ( optimizer = " nloptwrap " ) ) fm1 _ nloptr _ NM < - update ( fm1 , control = lmerControl ( optimizer = " nloptwrap " , optCtrl = list ( algorithm = " NLOPT _ LN _ NELDERMEAD " ) ) ) } # # other algorithm options include NLOPT _ LN _ COBYLA , NLOPT _ LN _ SBPLX # # End ( Not run ) lmList Fit List of lm Objects with a Common Model Description Fit a list of lm objects with a common model for different subgroups of the data . lmList 49 Usage lmList ( formula , data , family , subset , weights , na . action , offset , pool = TRUE , . . . ) Arguments formula a linear formula object of the form y ~ x1 + . . . + xn | g . In the formula object , y represents the response , x1 , . . . , xn the covariates , and g the grouping factor specifying the partitioning of the data according to which different lm ﬁts should be performed . family an optional family speciﬁcation for a generalized linear model . pool logical scalar , should the variance estimate pool the residual sums of squares . . . additional , optional arguments to be passed to the model function or family eval - uation . data an optional data frame containing the variables named in formula . By default the variables are taken from the environment from which lmer is called . See Details . subset an optional expression indicating the subset of the rows of data that should be used in the ﬁt . This can be a logical vector , or a numeric vector indicating which observation numbers are to be included , or a character vector of the row names to be included . All observations are included by default . weights an optional vector of ‘prior weights’ to be used in the ﬁtting process . Should be NULL or a numeric vector . na . action a function that indicates what should happen when the data contain NA s . The de - fault action ( na . omit , inherited from the ‘factory fresh’ value of getOption ( " na . action " ) ) strips any observations with any missing values in any variables . offset this can be used to specify an a priori known component to be included in the linear predictor during ﬁtting . This should be NULL or a numeric vector of length equal to the number of cases . One or more offset terms can be included in the formula instead or as well , and if more than one is speciﬁed their sum is used . See model . offset . Details • While data is optional , the package authors strongly recommend its use , especially when later applying methods such as update and drop1 to the ﬁtted model ( such methods are not guaranteed to work properly if data is omitted ) . If data is omitted , variables will be taken from the environment of formula ( if speciﬁed as a formula ) or from the parent frame ( if speciﬁed as a character vector ) . Value an object of class lmList4 ( see there , notably for the methods deﬁned ) . See Also lmList4 50 lmList4 - class Examples fm . plm < - lmList ( Reaction ~ Days | Subject , sleepstudy ) coef ( fm . plm ) fm . 2 < - update ( fm . plm , pool = FALSE ) # # coefficients are the same , " pooled or unpooled " : stopifnot ( all . equal ( coef ( fm . 2 ) , coef ( fm . plm ) ) ) ( ci < - confint ( fm . plm ) ) # print and rather * see * : plot ( ci ) # how widely they vary for the individuals lmList4 - class Class " lmList4 " of ’lm’ Objects on Common Model Description Class " lmList4 " is an S4 class with basically a list of objects of class lm with a common model ( but different data ) ; see lmList ( ) which returns these . Package nlme ’s lmList ( ) returns objects of S3 class " lmList " and provides methods for them , on which our methods partly build . Objects from the Class Objects can be created by calls of the form new ( " lmList4 " , . . . ) or , more commonly , by a call to lmList ( ) . Methods A dozen methods are provided . Currently , S4 methods for show , coercion ( as ( . , . ) ) and others inherited via " list " , and S3 methods for coef , confint , fitted , fixef , formula , logLik , pairs , plot , predict , print , qqnorm , ranef , residuals , sigma , summary , and update . sigma ( object ) returns the standard deviation ˆ σ ( of the errors in the linear models ) , assuming a common variance σ 2 by pooling ( even when pool = FALSE was used in the ﬁt ) . See Also lmList Examples if ( getRversion ( ) > = " 3 . 2 . 0 " ) { ( mm < - methods ( class = " lmList4 " ) ) # # The S3 ( " not S4 " ) ones : mm [ ! attr ( mm , " info " ) [ , " isS4 " ] ] } # # For more examples : example ( lmList ) i . e . , ? lmList lmResp 51 lmResp Generator objects for the response classes Description The generator objects for the lmResp , lmerResp , glmResp and nlsResp reference classes . Such objects are primarily used through their new methods . Usage lmResp ( . . . ) Arguments . . . List of arguments ( see Note ) . Methods new ( y = y ) : Create a new lmResp or lmerResp object . new ( family = family , y = y ) : Create a new glmResp object . new ( y = y , nlmod = nlmod , nlenv = nlenv , pnames = pnames , gam = gam ) : Create a new nlsResp ob - ject . Note Arguments to the new methods must be named arguments . • y the numeric response vector • family a family object • nlmod the nonlinear model function • nlenv an environment holding data objects for evaluation of nlmod • pnames a character vector of parameter names • gam a numeric vector - the initial linear predictor See Also lmResp , lmerResp , glmResp , nlsResp 52 lmResp - class lmResp - class Reference Classes for Response Modules , " ( lm | glm | nls | lmer ) Resp " Description Reference classes for response modules , including linear models , " lmResp " , generalized linear models , " glmResp " , nonlinear models , " nlsResp " and linear mixed - effects models , " lmerResp " . Each reference class is associated with a C + + class of the same name . As is customary , the generator object for each class has the same name as the class . Extends All reference classes extend and inherit methods from " envRefClass " . Furthermore , " glmResp " , " nlsResp " and " lmerResp " all extend the " lmResp " class . Note Objects from these reference classes correspond to objects in C + + classes . Methods are invoked on the C + + classes using the external pointer in the ptr ﬁeld . When saving such an object the external pointer is converted to a null pointer , which is why there are redundant ﬁelds containing enough information as R objects to be able to regenerate the C + + object . The convention is that a ﬁeld whose name begins with an upper - case letter is an R object and the corresponding ﬁeld whose name begins with the lower - case letter is a method . Access to the external pointer should be through the method , not through the ﬁeld . See Also lmer , glmer , nlmer , merMod . Examples showClass ( " lmResp " ) str ( lmResp $ new ( y = 1 : 4 ) ) showClass ( " glmResp " ) str ( glmResp $ new ( family = poisson ( ) , y = 1 : 4 ) ) showClass ( " nlsResp " ) showClass ( " lmerResp " ) str ( lmerResp $ new ( y = 1 : 4 ) ) merMod - class 53 merMod - class Class " merMod " of Fitted Mixed - Effect Models Description A mixed - effects model is represented as a merPredD object and a response module of a class that inherits from class lmResp . A model with a lmerResp response has class lmerMod ; a glmResp response has class glmerMod ; and a nlsResp response has class nlmerMod . Usage # # S3 method for class ’merMod’ anova ( object , . . . , refit = TRUE , model . names = NULL ) # # S3 method for class ’merMod’ coef ( object , . . . ) # # S3 method for class ’merMod’ deviance ( object , REML = NULL , . . . ) REMLcrit ( object ) # # S3 method for class ’merMod’ extractAIC ( fit , scale = 0 , k = 2 , . . . ) # # S3 method for class ’merMod’ family ( object , . . . ) # # S3 method for class ’merMod’ formula ( x , fixed . only = FALSE , random . only = FALSE , . . . ) # # S3 method for class ’merMod’ fitted ( object , . . . ) # # S3 method for class ’merMod’ logLik ( object , REML = NULL , . . . ) # # S3 method for class ’merMod’ nobs ( object , . . . ) # # S3 method for class ’merMod’ ngrps ( object , . . . ) # # S3 method for class ’merMod’ terms ( x , fixed . only = TRUE , random . only = FALSE , . . . ) # # S3 method for class ’merMod’ vcov ( object , correlation = TRUE , sigm = sigma ( object ) , use . hessian = NULL , . . . ) # # S3 method for class ’merMod’ model . frame ( formula , fixed . only = FALSE , . . . ) # # S3 method for class ’merMod’ model . matrix ( object , type = c ( " fixed " , " random " , " randomListRaw " ) , . . . ) # # S3 method for class ’merMod’ print ( x , digits = max ( 3 , getOption ( " digits " ) - 3 ) , correlation = NULL , symbolic . cor = FALSE , signif . stars = getOption ( " show . signif . stars " ) , ranef . comp = " Std . Dev . " , . . . ) # # S3 method for class ’merMod’ 54 merMod - class summary ( object , correlation = , use . hessian = NULL , . . . ) # # S3 method for class ’summary . merMod’ print ( x , digits = max ( 3 , getOption ( " digits " ) - 3 ) , correlation = NULL , symbolic . cor = FALSE , signif . stars = getOption ( " show . signif . stars " ) , ranef . comp = c ( " Variance " , " Std . Dev . " ) , show . resids = TRUE , . . . ) # # S3 method for class ’merMod’ update ( object , formula . , . . . , evaluate = TRUE ) # # S3 method for class ’merMod’ weights ( object , type = c ( " prior " , " working " ) , . . . ) Arguments object an R object of class merMod , i . e . , as resulting from lmer ( ) , or glmer ( ) , etc . x an R object of class merMod or summary . merMod , respectively , the latter result - ing from summary ( < merMod > ) . fit an R object of class merMod . formula in the case of model . frame , a merMod object . refit logical indicating if objects of class lmerMod should be reﬁtted with ML before comparing models . The default is TRUE to prevent the common mistake of inap - propriately comparing REML - ﬁtted models with different ﬁxed effects , whose likelihoods are not directly comparable . model . names character vectors of model names to be used in the anova table . scale Not currently used ( see extractAIC ) . k see extractAIC . REML Logical . If TRUE , return the restricted log - likelihood rather than the log - likelihood . If NULL ( the default ) , set REML to isREML ( object ) ( see isREML ) . fixed . only logical indicating if only the ﬁxed effects components ( terms or formula ele - ments ) are sought . If false , all components , including random ones , are returned . random . only complement of fixed . only ; indicates whether random components only are sought . ( Trying to specify fixed . only and random . only at the same time will produce an error . ) correlation ( logical ) for vcov , indicates whether the correlation matrix as well as the variance - covariance matrix is desired ; for summary . merMod , indicates whether the cor - relation matrix should be computed and stored along with the covariance ; for print . summary . merMod , indicates whether the correlation matrix of the ﬁxed - effects parameters should be printed . In the latter case , when NULL ( the default ) , the correlation matrix is printed when it has been computed by summary ( . ) , and when p < = 20 . use . hessian ( logical ) indicates whether to use the ﬁnite - difference Hessian of the deviance function to compute standard errors of the ﬁxed effects , rather estimating based on internal information about the inverse of the model matrix ( see getME ( . , " RX " ) ) . The default is to to use the Hessian whenever the ﬁxed effect parameters are ar - guments to the deviance function ( i . e . for GLMMs with nAGQ > 0 ) , and to use merMod - class 55 getME ( . , " RX " ) whenever the ﬁxed effect parameters are proﬁled out ( i . e . for GLMMs with nAGQ = = 0 or LMMs ) . use . hessian = FALSE is backward - compatible with older versions of lme4 , but may give less accurate SE estimates when the estimates of the ﬁxed - effect ( see getME ( . , " beta " ) ) and random - effect ( see getME ( . , " theta " ) ) parameters are correlated . sigm the residual standard error ; by default sigma ( object ) . digits number of signiﬁcant digits for printing symbolic . cor should a symbolic encoding of the ﬁxed - effects correlation matrix be printed ? If so , the symnum function is used . signif . stars ( logical ) should signiﬁcance stars be used ? ranef . comp character vector of length one or two , indicating if random - effects parameters should be reported on the variance and / or standard deviation scale . show . resids should the quantiles of the scaled residuals be printed ? formula . see update . formula . evaluate see update . type For weights , type of weights to be returned ; either " prior " for the initially supplied weights or " working " for the weights at the ﬁnal iteration of the pe - nalized iteratively reweighted least squares algorithm . For model . matrix , type of model matrix to return ( one of fixed giving the ﬁxed effects model matrix , random giving the random effects model matrix , or randomListRaw giving a list of the raw random effects model matrices associated with each random effects term ) . . . . potentially further arguments passed from other methods . Objects from the Class Objects of class merMod are created by calls to lmer , glmer or nlmer . S3 methods The following S3 methods with arguments given above exist ( this list is currently not complete ) : anova : returns the sequential decomposition of the contributions of ﬁxed - effects terms or , for mul - tiple arguments , model comparison statistics . For objects of class lmerMod the default behav - ior is to reﬁt the models with LM if ﬁtted with REML = TRUE , this can be controlled via the refit argument . See also anova . coef : Computes the sum of the random and ﬁxed effects coefﬁcients for each explanatory variable for each level of each grouping factor . extractAIC : Computes the ( generalized ) Akaike An Information Criterion . If isREML ( fit ) , then fit is reﬁtted using maximum likelihood . family : family of ﬁtted GLMM . ( Warning : this accessor may not work properly with customized families / link functions . ) fitted : Fitted values , given the conditional modes of the random effects . For more ﬂexible access to ﬁtted values , use predict . merMod . 56 merMod - class logLik : Log - likelihood at the ﬁtted value of the parameters . Note that for GLMMs , the returned value is only proportional to the log probability density ( or distribution ) of the response vari - able . See logLik . model . frame : returns the frame slot of merMod . model . matrix : returns the ﬁxed effects model matrix . nobs , ngrps : Number of observations and vector of the numbers of levels in each grouping factor . See ngrps . summary : Computes and returns a list of summary statistics of the ﬁtted model , the amount of output can be controlled via the print method , see also summary . print . summary : Controls the output for the summary method . vcov : Calculate variance - covariance matrix of the ﬁxed effect terms , see also vcov . update : See update . Deviance and log - likelihood of GLMMs One must be careful when deﬁning the deviance of a GLM . For example , should the deviance be deﬁned as minus twice the log - likelihood or does it involve subtracting the deviance for a saturated model ? To distinguish these two possibilities we refer to absolute deviance ( minus twice the log - likelihood ) and relative deviance ( relative to a saturated model , e . g . Section 2 . 3 . 1 in McCullagh and Nelder 1989 ) . With GLMMs however , there is an additional complication involving the distinc - tion between the likelihood and the conditional likelihood . The latter is the likelihood obtained by conditioning on the estimates of the conditional modes of the spherical random effects coefﬁcients , whereas the likelihood itself ( i . e . the unconditional likelihood ) involves integrating out these coefﬁ - cients . The following table summarizes how to extract the various types of deviance for a glmerMod object : conditional unconditional relative deviance ( object ) NA in lme4 absolute object @ resp $ aic ( ) - 2 * logLik ( object ) This table requires two caveats : • If the link function involves a scale parameter ( e . g . Gamma ) then object @ resp $ aic ( ) - 2 * getME ( object , " devcomp " ) $ dims [ " useSc " ] is required for the absolute - conditional case . • If adaptive Gauss - Hermite quadrature is used , then logLik ( object ) is currently only propor - tional to the absolute - unconditional log - likelihood . For more information about this topic see the misc / logLikGLMM directory in the package source . Slots resp : A reference class object for an lme4 response module ( lmResp - class ) . Gp : See getME . call : The matched call . frame : The model frame containing all of the variables required to parse the model formula . merPredD 57 flist : See getME . cnms : See getME . lower : See getME . theta : Covariance parameter vector . beta : Fixed effects coefﬁcients . u : Conditional model of spherical random effects coefﬁcients . devcomp : See getME . pp : A reference class object for an lme4 predictor module ( merPredD - class ) . optinfo : List containing information about the nonlinear optimization . See Also lmer , glmer , nlmer , merPredD , lmerResp , glmResp , nlsResp Other methods for merMod objects documented elsewhere include : fortify . merMod , drop1 . merMod , isLMM . merMod , isGLMM . merMod , isNLMM . merMod , isREML . merMod , plot . merMod , predict . merMod , profile . merMod , ranef . merMod , refit . merMod , refitML . merMod , residuals . merMod , sigma . merMod , simulate . merMod , summary . merMod . Examples showClass ( " merMod " ) methods ( class = " merMod " ) # # over 30 ( S3 ) methods available # # - > example ( lmer ) for an example of vcov . merMod ( ) merPredD Generator object for the merPredD class Description The generator object for the merPredD reference class . Such an object is primarily used through its new method . Usage merPredD ( . . . ) Arguments . . . List of arguments ( see Note ) . 58 merPredD - class Note merPredD ( . . . ) is a short form of new ( " merPredD " , . . . ) to create a new merPredD object and the . . . must be named arguments , ( X , Zt , Lambdat , Lind , theta , n ) : X : dense model matrix for the ﬁxed - effects parameters , to be stored in the X ﬁeld . Zt : transpose of the sparse model matrix for the random effects . It is stored in the Zt ﬁeld . Lambdat : transpose of the sparse lower triangular relative variance factor ( stored in the Lambdat ﬁeld ) . Lind : integer vector of the same length as the x slot in the Lambdat ﬁeld . Its elements should be in the range 1 to the length of the theta ﬁeld . theta : numeric vector of variance component parameters ( stored in the theta ﬁeld ) . n : sample size , usually nrow ( X ) . See Also The class deﬁnition , merPredD , also for examples . merPredD - class Class " merPredD " - a Dense Predictor Reference Class Description A reference class ( see mother class deﬁnition " envRefClass " for a mixed - effects model predictor module with a dense model matrix for the ﬁxed - effects parameters . The reference class is associated with a C + + class of the same name . As is customary , the generator object , merPredD , for the class has the same name as the class . Note Objects from this reference class correspond to objects in a C + + class . Methods are invoked on the C + + class object using the external pointer in the Ptr ﬁeld . When saving such an object the external pointer is converted to a null pointer , which is why there are redundant ﬁelds containing enough information as R objects to be able to regenerate the C + + object . The convention is that a ﬁeld whose name begins with an upper - case letter is an R object and the corresponding ﬁeld , whose name begins with the lower - case letter is a method . References to the external pointer should be through the method , not directly through the Ptr ﬁeld . See Also lmer , glmer , nlmer , merPredD , merMod . Examples showClass ( " merPredD " ) pp < - slot ( lmer ( Yield ~ 1 | Batch , Dyestuff ) , " pp " ) stopifnot ( is ( pp , " merPredD " ) ) str ( pp ) # an overview of all fields and methods’ names . mkdevfun 59 mkdevfun Create Deviance Evaluation Function from Predictor and Response Module Description From a merMod object create an R function that takes a single argument , which is the new parameter value , and returns the deviance . Usage mkdevfun ( rho , nAGQ = 1L , maxit = 100 , verbose = 0 , control = list ( ) ) Arguments rho an environment containing pp , a prediction module , typically of class merPredD and resp , a response module , e . g . , of class lmerResp . nAGQ scalar integer - the number of adaptive Gauss - Hermite quadrature points . A value of 0 indicates that both the ﬁxed - effects parameters and the random effects are optimized by the iteratively reweighted least squares algorithm . maxit scalar integer , currently only for GLMMs : the maximal number of Pwrss update iterations . verbose scalar logical : print verbose output ? control list of control parameters , a subset of those speciﬁed by lmerControl ( tolPwrss and compDev for GLMMs , tolPwrss for NLMMs ) Details The function returned by mkdevfun evaluates the deviance of the model represented by the predictor module , pp , and the response module , resp . For lmer model objects the argument of the resulting function is the variance component parameter , theta , with lower bound . For glmer or nlmer model objects with nAGQ = 0 the argument is also theta . However , when nAGQ > 0 , the argument is c ( theta , beta ) . Value A function of one numeric argument . See Also lmer , glmer and nlmer Examples ( dd < - lmer ( Yield ~ 1 | Batch , Dyestuff , devFunOnly = TRUE ) ) dd ( 0 . 8 ) minqa : : bobyqa ( 1 , dd , 0 ) 60 mkRespMod mkMerMod Create a ’merMod’ Object Description Create an object of ( a subclass of ) class merMod from the environment of the objective function and the value returned by the optimizer . Usage mkMerMod ( rho , opt , reTrms , fr , mc , lme4conv = NULL ) Arguments rho the environment of the objective function opt the optimization result returned by the optimizer ( a list : see lmerControl for required elements ) reTrms random effects structure from the calling function ( see mkReTrms for required elements ) fr model frame ( see model . frame ) mc matched call from the calling function lme4conv lme4 - speciﬁc convergence information ( results of checkConv ) Value an object from a class that inherits from merMod . mkRespMod Create an lmerResp , glmResp or nlsResp instance Description Create an lmerResp , glmResp or nlsResp instance Usage mkRespMod ( fr , REML = NULL , family = NULL , nlenv = NULL , nlmod = NULL , . . . ) mkReTrms 61 Arguments fr a model frame REML logical scalar , value of REML for an lmerResp instance family the optional glm family ( glmResp only ) nlenv the nonlinear model evaluation environment ( nlsResp only ) nlmod the nonlinear model function ( nlsResp only ) . . . where to look for response information if fr is missing . Can contain a model response , y , offset , offset , and weights , weights . Value an lmerResp or glmResp or nlsResp instance See Also Other utilities : findbars , mkReTrms , nlformula , nobars , subbars mkReTrms Make Random Effect Terms : Create Z , Lambda , Lind , etc . Description From the result of findbars applied to a model formula and the evaluation frame fr , create the model matrix Zt , etc , associated with the random - effects terms . Usage mkReTrms ( bars , fr , drop . unused . levels = TRUE ) Arguments bars a list of parsed random - effects terms fr a model frame in which to evaluate these terms drop . unused . levels ( logical ) drop unused factor levels ? ( experimental ) Value a list with components Zt transpose of the sparse model matrix for the random effects theta initial values of the covariance parameters Lind an integer vector of indices determining the mapping of the elements of the theta vector to the " x " slot of Lambdat Gp 62 mkSimulateTemplate lower lower bounds on the covariance parameters Lambdat transpose of the sparse relative covariance factor flist list of grouping factors used in the random - effects terms cnms a list of column names of the random effects according to the grouping factors Ztlist list of components of the transpose of the random - effects model matrix , sepa - rated by random - effects term See Also Other utilities : findbars , mkRespMod , nlformula , nobars , subbars . getME can retrieve these components from a ﬁtted model , although their values and / or forms may be slightly different in the ﬁnal ﬁtted model from their original values as returned from mkReTrms . Examples data ( " Pixel " , package = " nlme " ) mform < - pixel ~ day + I ( day ^ 2 ) + ( day | Dog ) + ( 1 | Side / Dog ) ( bar . f < - findbars ( mform ) ) # list with 3 terms mf < - model . frame ( subbars ( mform ) , data = Pixel ) rt < - mkReTrms ( bar . f , mf ) names ( rt ) mkSimulateTemplate Make templates suitable for guiding mixed model simulations Description Make data and parameter templates suitable for guiding mixed model simulations , by specifying a model formula and other information ( EXPERIMENTAL ) . Most useful for simulating balanced designs and for getting started on unbalanced simulations . Usage mkParsTemplate ( formula , data ) mkDataTemplate ( formula , data , nGrps = 2 , nPerGrp = 1 , rfunc = NULL , . . . ) Arguments formula A mixed model formula ( see lmer ) . data A data frame containing the names in formula . nGrps Number of levels of a grouping factor . nPerGrp Number of observations per level . rfunc Function for generating covariate data ( e . g . rnorm . . . . Additional parameters for rfunc . See Also These functions are designed to be used with simulate . merMod . mkVarCorr 63 mkVarCorr Make Variance and Correlation Matrices from theta Description Make variance and correlation matrices from theta Usage mkVarCorr ( sc , cnms , nc , theta , nms ) Arguments sc scale factor ( residual standard deviation ) . cnms component names . nc numeric vector : number of terms in each RE component . theta theta vector ( lower - triangle of Cholesky factors ) . nms component names ( FIXME : nms / cnms redundant : nms = names ( cnms ) ? ) Value A matrix See Also VarCorr modular Modular Functions for Mixed Model Fits Description Modular functions for mixed model ﬁts Usage lFormula ( formula , data = NULL , REML = TRUE , subset , weights , na . action , offset , contrasts = NULL , control = lmerControl ( ) , . . . ) mkLmerDevfun ( fr , X , reTrms , REML = TRUE , start = NULL , verbose = 0 , control = lmerControl ( ) , . . . ) optimizeLmer ( devfun , optimizer = formals ( lmerControl ) $ optimizer , 64 modular restart _ edge = formals ( lmerControl ) $ restart _ edge , boundary . tol = formals ( lmerControl ) $ boundary . tol , start = NULL , verbose = 0L , control = list ( ) , . . . ) glFormula ( formula , data = NULL , family = gaussian , subset , weights , na . action , offset , contrasts = NULL , mustart , etastart , control = glmerControl ( ) , . . . ) mkGlmerDevfun ( fr , X , reTrms , family , nAGQ = 1L , verbose = 0L , maxit = 100L , control = glmerControl ( ) , . . . ) optimizeGlmer ( devfun , optimizer = " bobyqa " , restart _ edge = FALSE , boundary . tol = formals ( glmerControl ) $ boundary . tol , verbose = 0L , control = list ( ) , nAGQ = 1L , stage = 1 , start = NULL , . . . ) updateGlmerDevfun ( devfun , reTrms , nAGQ = 1L ) Arguments formula a two - sided linear formula object describing both the ﬁxed - effects and random - effects parts of the model , with the response on the left of a ~ operator and the terms , separated by + operators , on the right . Random - effects terms are distinguished by vertical bars ( " | " ) separating expressions for design matrices from grouping factors . data an optional data frame containing the variables named in formula . By default the variables are taken from the environment from which lmer is called . While data is optional , the package authors strongly recommend its use , especially when later applying methods such as update and drop1 to the ﬁtted model ( such methods are not guaranteed to work properly if data is omitted ) . If data is omitted , variables will be taken from the environment of formula ( if speciﬁed as a formula ) or from the parent frame ( if speciﬁed as a character vector ) . REML ( logical ) indicating to ﬁt re stricted maximum likelihood model . subset an optional expression indicating the subset of the rows of data that should be used in the ﬁt . This can be a logical vector , or a numeric vector indicating which observation numbers are to be included , or a character vector of the row names to be included . All observations are included by default . weights an optional vector of ‘prior weights’ to be used in the ﬁtting process . Should be NULL or a numeric vector . na . action a function that indicates what should happen when the data contain NA s . The de - fault action ( na . omit , inherited from the ’factory fresh’ value of getOption ( " na . action " ) ) strips any observations with any missing values in any variables . offset this can be used to specify an a priori known component to be included in the linear predictor during ﬁtting . This should be NULL or a numeric vector of length equal to the number of cases . One or more offset terms can be included in the modular 65 formula instead or as well , and if more than one is speciﬁed their sum is used . See model . offset . contrasts an optional list . See the contrasts . arg of model . matrix . default . control a list giving for [ g ] lFormula : all options for running the model , see lmerControl ; for mkLmerDevfun , mkGlmerDevfun : options for the inner optimization step ; for optimizeLmer and optimizeGlmer : control parameters for nonlinear op - timizer ( typically inherited from the . . . argument to lmerControl ) . fr A model frame containing the variables needed to create an lmerResp or glmResp instance . X ﬁxed - effects design matrix reTrms information on random effects structure ( see mkReTrms ) . start starting values ( see lmer ) verbose print output ? maxit maximal number of Pwrss update iterations . devfun a deviance function , as generated by mkLmerDevfun nAGQ number of Gauss - Hermite quadrature points stage optimization stage ( 1 : nAGQ = 0 , optimize over theta only ; 2 : nAGQ possibly > 0 , optimize over theta and beta ) optimizer character - name of optimizing function ( s ) . A character vector or list of func - tions : length 1 for lmer or glmer , possibly length 2 for glmer . The built - in optimizers are " Nelder _ Mead " and " bobyqa " ( from the minqa package ) . Any minimizing function that allows box constraints can be used provided that it 1 . takes input parameters fn ( function to be optimized ) , par ( starting parame - ter values ) , lower ( lower bounds ) and control ( control parameters , passed through from the control argument ) and 2 . returns a list with ( at least ) elements par ( best - ﬁt parameters ) , fval ( best - ﬁt function value ) , conv ( convergence code ) and ( optionally ) message ( infor - mational message , or explanation of convergence failure ) . Special provisions are made for bobyqa , Nelder _ Mead , and optimizers wrapped in the optimx package ; to use optimx optimizers ( including L - BFGS - B from base optim and nlminb ) , pass the method argument to optim in the control argument . For glmer , if length ( optimizer ) = = 2 , the ﬁrst element will be used for the preliminary ( random effects parameters only ) optimization , while the second will be used for the ﬁnal ( random effects plus ﬁxed effect parameters ) phase . See modular for more information on these two phases . restart _ edge see lmerControl boundary . tol see lmerControl family a GLM family ; see glm and family . mustart optional starting values on the scale of the conditional mean ; see glm for details . 66 modular etastart optional starting values on the scale of the unbounded predictor ; see glm for details . . . . other potential arguments ; for optimizeLmer and optimizeGlmer , these are passed to internal function optwrap , which has relevant parameters calc . derivs and use . last . params ( see lmerControl ) . Details These functions make up the internal components of an [ gn ] lmer ﬁt . • [ g ] lFormula takes the arguments that would normally be passed to [ g ] lmer , checking for errors and processing the formula and data input to create a list of objects required to ﬁt a mixed model . • mk ( Gl | L ) merDevfun takes the output of the previous step ( minus the formula component ) and creates a deviance function • optimize ( Gl | L ) mer takes a deviance function and optimizes over theta ( or over theta and beta , if stage is set to 2 for optimizeGlmer • updateGlmerDevfun takes the ﬁrst stage of a GLMM optimization ( with nAGQ = 0 , optimizing over theta only ) and produces a second - stage deviance function • mkMerMod takes the environment of a deviance function , the results of an optimization , a list of random - effect terms , a model frame , and a model all and produces a [ g ] lmerMod object . Value lFormula and glFormula return a list containing components : fr model frame X ﬁxed - effect design matrix reTrms list containing information on random effects structure : result of mkReTrms REML ( lFormula only ) : logical indicating if restricted maximum likelihood was used ( Copy of argument . ) mkLmerDevfun and mkGlmerDevfun return a function to calculate deviance ( or restricted deviance ) as a function of the theta ( random - effect ) parameters . updateGlmerDevfun returns a function to calculate the deviance as a function of a concatenation of theta and beta ( ﬁxed - effect ) parameters . These deviance functions have an environment containing objects required for their evaluation . CAUTION : The environment of functions returned by mk ( Gl | L ) merDevfun contains reference class objects ( see ReferenceClasses , merPredD - class , lmResp - class ) , which behave in ways that may surprise many users . For example , if the output of mk ( Gl | L ) merDevfun is naively copied , then modiﬁcations to the original will also appear in the copy ( and vice versa ) . To avoid this behavior one must make a deep copy ( see ReferenceClasses for details ) . optimizeLmer and optimizeGlmer return the results of an optimization . NelderMead 67 Examples # # # Fitting a linear mixed model in 4 modularized steps # # 1 . Parse the data and formula : lmod < - lFormula ( Reaction ~ Days + ( Days | Subject ) , sleepstudy ) names ( lmod ) # # 2 . Create the deviance function to be optimized : ( devfun < - do . call ( mkLmerDevfun , lmod ) ) ls ( environment ( devfun ) ) # the environment of ’devfun’ contains objects # required for its evaluation # # 3 . Optimize the deviance function : opt < - optimizeLmer ( devfun ) opt [ 1 : 3 ] # # 4 . Package up the results : mkMerMod ( environment ( devfun ) , opt , lmod $ reTrms , fr = lmod $ fr ) # # # Same model in one line lmer ( Reaction ~ Days + ( Days | Subject ) , sleepstudy ) # # # Fitting a generalized linear mixed model in six modularized steps # # 1 . Parse the data and formula : glmod < - glFormula ( cbind ( incidence , size - incidence ) ~ period + ( 1 | herd ) , data = cbpp , family = binomial ) names ( glmod ) # # 2 . Create the deviance function for optimizing over theta : ( devfun < - do . call ( mkGlmerDevfun , glmod ) ) ls ( environment ( devfun ) ) # the environment of devfun contains lots of info # # 3 . Optimize over theta using a rough approximation ( i . e . nAGQ = 0 ) : ( opt < - optimizeGlmer ( devfun ) ) # # 4 . Update the deviance function for optimizing over theta and beta : ( devfun < - updateGlmerDevfun ( devfun , glmod $ reTrms ) ) # # 5 . Optimize over theta and beta : opt < - optimizeGlmer ( devfun , stage = 2 ) opt [ 1 : 3 ] # # 6 . Package up the results : mkMerMod ( environment ( devfun ) , opt , glmod $ reTrms , fr = glmod $ fr ) # # # Same model in one line glmer ( cbind ( incidence , size - incidence ) ~ period + ( 1 | herd ) , data = cbpp , family = binomial ) NelderMead Nelder - Mead Optimization of Parameters , Possibly ( Box ) Constrained Description Nelder - Mead optimization of parameters , allowing optimization subject to box constraints ( contrary to the default , method = " Nelder - Mead " , in R ’s optim ( ) ) , and using reverse communications . 68 NelderMead Usage Nelder _ Mead ( fn , par , lower = rep . int ( - Inf , n ) , upper = rep . int ( Inf , n ) , control = list ( ) ) Arguments fn a function of a single numeric vector argument returning a numeric scalar . par numeric vector of starting values for the parameters . lower numeric vector of lower bounds ( elements may be - Inf ) . upper numeric vector of upper bounds ( elements may be Inf ) . control a named list of control settings . Possible settings are iprint numeric scalar - frequency of printing evaluation information . Defaults to 0 indicating no printing . maxfun numeric scalar - maximum number of function evaluations allowed ( default : 10000 ) . FtolAbs numeric scalar - absolute tolerance on change in function values ( de - fault : 1e - 5 ) FtolRel numeric scalar - relative tolerance on change in function values ( default : 1e - 15 ) XtolRel numeric scalar - relative tolerance on change in parameter values ( de - fault : 1e - 7 ) MinfMax numeric scalar - maximum value of the minimum ( default : . Ma - chine $ double . xmin ) xst numeric vector of initial step sizes to establish the simplex - all elements must be non - zero ( default : rep ( 0 . 02 , length ( par ) ) ) xt numeric vector of tolerances on the parameters ( default : xst * 5e - 4 ) verbose numeric value : 0 = no printing , 1 = print every 20 evaluations , 2 = print every 10 evalutions , 3 = print every evaluation . Sets ‘iprint’ , if speciﬁed , but does not override it . warnOnly a logical indicating if non - convergence ( codes - 1 , - 2 , - 3 ) should not stop ( . ) , but rather only call warning and return a result which might in - spected . Defaults to FALSE , i . e . , stop on non - convergence . Value a list with components fval numeric scalar - the minimum function value achieved par numeric vector - the value of x providing the minimum convergence integer valued scalar , if not 0 , an error code : - 4 nm _ evals : maximum evaluations reached - 3 nm _ forced : ? - 2 nm _ nofeasible : cannot generate a feasible simplex - 1 nm _ x0notfeasible : initial x is not feasible ( ? ) NelderMead - class 69 0 successful convergence message a string specifying the kind of convergence . control the list of control settings after substituting for defaults . feval the number of function evaluations . See Also The NelderMead class deﬁnition and generator function . Examples fr < - function ( x ) { # # Rosenbrock Banana function x1 < - x [ 1 ] x2 < - x [ 2 ] 100 * ( x2 - x1 * x1 ) ^ 2 + ( 1 - x1 ) ^ 2 } p0 < - c ( - 1 . 2 , 1 ) oo < - optim ( p0 , fr ) # # also uses Nelder - Mead by default o . < - Nelder _ Mead ( fr , p0 ) o . 1 < - Nelder _ Mead ( fr , p0 , control = list ( verbose = 1 ) ) # - > some iteration output stopifnot ( identical ( o . [ 1 : 4 ] , o . 1 [ 1 : 4 ] ) , all . equal ( o . $ par , oo $ par , tolerance = 1e - 3 ) ) # diff : 0 . 0003865 o . 2 < - Nelder _ Mead ( fr , p0 , control = list ( verbose = 3 , XtolRel = 1e - 15 , FtolAbs = 1e - 14 ) ) all . equal ( o . 2 [ - 5 ] , o . 1 [ - 5 ] , tolerance = 1e - 15 ) # TRUE , unexpectedly NelderMead - class Class " NelderMead " of Nelder - Mead optimizers and its Generator Description Class " NelderMead " is a reference class for a Nelder - Mead simplex optimizer allowing box con - straints on the parameters and using reverse communication . The NelderMead ( ) function conveniently generates such objects . Usage NelderMead ( . . . ) Arguments . . . Argument list ( see Note below ) . Methods NelderMead $ new ( lower , upper , xst , x0 , xt ) Create a new NelderMead object 70 ngrps Extends All reference classes extend and inherit methods from " envRefClass " . Note This is the default optimizer for the second stage of glmer and nlmer ﬁts . We found that it was more reliable and often faster than more sophisticated optimizers . Arguments to NelderMead ( ) and the new method must be named arguments : lower numeric vector of lower bounds - elements may be - Inf . upper numeric vector of upper bounds - elements may be Inf . xst numeric vector of initial step sizes to establish the simplex - all elements must be non - zero . x0 numeric vector of starting values for the parameters . xt numeric vector of tolerances on the parameters . References Based on code in the NLopt collection . See Also Nelder _ Mead , the typical “constructor” . Further , glmer , nlmer Examples showClass ( " NelderMead " ) ngrps Number of Levels of a Factor or a " merMod " Model Description Returns the number of levels of a factor or a set of factors , currently e . g . , for each of the grouping factors of lmer ( ) , glmer ( ) , etc . Usage ngrps ( object , . . . ) Arguments object an R object , see Details . . . . currently ignored . nlformula 71 Details Currently there are methods for objects of class merMod , i . e . , the result of lmer ( ) etc , and factor objects . Value The number of levels ( of a factor ) or vector of number of levels for each “grouping factor” of a Examples ngrps ( factor ( seq ( 1 , 10 , 2 ) ) ) ngrps ( lmer ( Reaction ~ 1 | Subject , sleepstudy ) ) # # A named vector if there’s more than one grouping factor : ngrps ( lmer ( strength ~ ( 1 | batch / cask ) , Pastes ) ) # # cask : batch batch # # 30 10 methods ( ngrps ) # - > " factor " and " merMod " nlformula Manipulate a Nonlinear Model Formula Description Check and manipulate the formula for a nonlinear model , such as speciﬁed in nlmer . Usage nlformula ( mc ) Arguments mc matched call from the calling function , typically nlmer ( ) . Should have argu - ments named formula : a formula of the form resp ~ nlmod ~ meform where resp is an expression for the response , nlmod is the nonlinear model expression and meform is the mixed - effects model formula . resp can be omitted when , e . g . , optimizing a design . data : a data frame in which to evaluate the model function start : either a numeric vector containing initial estimates for the nonlinear model parameters or a list with components nlpars : the initial estimates of the nonlinear model parameters theta : the initial estimates of the variance component parameters 72 nlmer Details The model formula for a nonlinear mixed - effects model is of the form resp ~ nlmod ~ mixed where resp is an expression ( usually just a name ) for the response , nlmod is the call to the non - linear model function , and mixed is the mixed - effects formula deﬁning the linear predictor for the parameter matrix . If the formula is to be used for optimizing designs , the resp part can be omitted . Value a list with components " respMod " a response module of class " nlsResp " " frame " the model frame , including a terms attribute " X " the ﬁxed - effects model matrix " reTrms " the random - effects terms object See Also Other utilities : findbars , mkRespMod , mkReTrms , nobars , subbars nlmer Fitting Nonlinear Mixed - Effects Models Description Fit a nonlinear mixed - effects model ( NLMM ) to data , via maximum likelihood . Usage nlmer ( formula , data = NULL , control = nlmerControl ( ) , start = NULL , verbose = 0L , nAGQ = 1L , subset , weights , na . action , offset , contrasts = NULL , devFunOnly = FALSE , . . . ) Arguments formula a three - part “nonlinear mixed model” formula , of the form resp ~ Nonlin ( . . . ) ~ fixed + random , where the third part is similar to the RHS formula of , e . g . , lmer . Currently , the Nonlin ( . . ) formula part must not only return a numeric vector , but also must have a " gradient " attribute , a matrix . The functions SSbiexp , SSlogis , etc , see selfStart , provide this ( and more ) . Alternatively , you can use deriv ( ) to automatically produce such functions or expressions . data an optional data frame containing the variables named in formula . By default the variables are taken from the environment from which lmer is called . While data is optional , the package authors strongly recommend its use , especially when later applying methods such as update and drop1 to the ﬁtted model ( such methods are not guaranteed to work properly if data is omitted ) . If data is omitted , variables will be taken from the environment of formula ( if speciﬁed as a formula ) or from the parent frame ( if speciﬁed as a character vector ) . nlmer 73 control a list ( of correct class , resulting from lmerControl ( ) or glmerControl ( ) re - spectively ) containing control parameters , including the nonlinear optimizer to be used and parameters to be passed through to the nonlinear optimizer , see the * lmerControl documentation for details . start starting estimates for the nonlinear model parameters , as a named numeric vec - tor or as a list with components nlpars required numeric vector of starting values for the nonlinear model pa - rameters theta optional numeric vector of starting values for the covariance parameters verbose integer scalar . If > 0 verbose output is generated during the optimization of the parameter estimates . If > 1 verbose output is generated during the individual PIRLS steps . nAGQ integer scalar - the number of points per axis for evaluating the adaptive Gauss - Hermite approximation to the log - likelihood . Defaults to 1 , corresponding to the Laplace approximation . Values greater than 1 produce greater accuracy in the evaluation of the log - likelihood at the expense of speed . A value of zero uses a faster but less exact form of parameter estimation for GLMMs by optimizing the random effects and the ﬁxed - effects coefﬁcients in the penalized iteratively reweighted least squares step . subset an optional expression indicating the subset of the rows of data that should be used in the ﬁt . This can be a logical vector , or a numeric vector indicating which observation numbers are to be included , or a character vector of the row names to be included . All observations are included by default . weights an optional vector of ‘prior weights’ to be used in the ﬁtting process . Should be NULL or a numeric vector . na . action a function that indicates what should happen when the data contain NA s . The de - fault action ( na . omit , inherited from the ‘factory fresh’ value of getOption ( " na . action " ) ) strips any observations with any missing values in any variables . offset this can be used to specify an a priori known component to be included in the linear predictor during ﬁtting . This should be NULL or a numeric vector of length equal to the number of cases . One or more offset terms can be included in the formula instead or as well , and if more than one is speciﬁed their sum is used . See model . offset . contrasts an optional list . See the contrasts . arg of model . matrix . default . devFunOnly logical - return only the deviance evaluation function . Note that because the deviance function operates on variables stored in its environment , it may not return exactly the same values on subsequent calls ( but the results should always be within machine tolerance ) . . . . other potential arguments . A method argument was used in earlier versions of the package . Its functionality has been replaced by the nAGQ argument . Details Fit nonlinear mixed - effects models , such as those used in population pharmacokinetics . 74 nloptwrap Note Adaptive Gauss - Hermite quadrature ( nAGQ > 1 ) is not currently implemented for nlmer . Several other methods , such as simulation or prediction with new data , are unimplemented or very lightly tested . Examples # # nonlinear mixed models - - - 3 - part formulas - - - # # 1 . basic nonlinear fit . Use stats : : SSlogis for its # # implementation of the 3 - parameter logistic curve . # # " SS " stands for " self - starting logistic " , but the # # " self - starting " part is not currently used by nlmer . . . ’start’ is # # necessary startvec < - c ( Asym = 200 , xmid = 725 , scal = 350 ) ( nm1 < - nlmer ( circumference ~ SSlogis ( age , Asym , xmid , scal ) ~ Asym | Tree , Orange , start = startvec ) ) # # 2 . re - run with " quick and dirty " PIRLS step ( nm1a < - update ( nm1 , nAGQ = 0L ) ) # # 3 . Fit the same model with a user - built function : # # a . Define formula nform < - ~ Asym / ( 1 + exp ( ( xmid - input ) / scal ) ) # # b . Use deriv ( ) to construct function : nfun < - deriv ( nform , namevec = c ( " Asym " , " xmid " , " scal " ) , function . arg = c ( " input " , " Asym " , " xmid " , " scal " ) ) nm1b < - update ( nm1 , circumference ~ nfun ( age , Asym , xmid , scal ) ~ Asym | Tree ) # # 4 . User - built function without using derivs ( ) : # # derivatives could be computed more efficiently # # by pre - computing components , but these are essentially # # the gradients as one would derive them by hand nfun2 < - function ( input , Asym , xmid , scal ) { value < - Asym / ( 1 + exp ( ( xmid - input ) / scal ) ) grad < - cbind ( Asym = 1 / ( 1 + exp ( ( xmid - input ) / scal ) ) , xmid = - Asym / ( 1 + exp ( ( xmid - input ) / scal ) ) ^ 2 * 1 / scal * exp ( ( xmid - input ) / scal ) , scal = - Asym / ( 1 + exp ( ( xmid - input ) / scal ) ) ^ 2 * - ( xmid - input ) / scal ^ 2 * exp ( ( xmid - input ) / scal ) ) attr ( value , " gradient " ) < - grad value } stopifnot ( all . equal ( attr ( nfun ( 2 , 1 , 3 , 4 ) , " gradient " ) , attr ( nfun ( 2 , 1 , 3 , 4 ) , " gradient " ) ) ) nm1c < - update ( nm1 , circumference ~ nfun2 ( age , Asym , xmid , scal ) ~ Asym | Tree ) nloptwrap Wrappers for additional optimizers nloptwrap 75 Description Wrappers to allow use of alternative optimizers , from NLopt library or elsewhere , for nonlinear optimization stage Usage nloptwrap ( par , fn , lower , upper , control = list ( ) , . . . ) nlminbwrap ( par , fn , lower , upper , control = list ( ) , . . . ) Arguments par starting parameter vector fn objective function lower vector of lower bounds upper vector of upper bounds control list of control parameters . . . additional arguments to be passed to objective function Details Using alternative optimizers is an important trouble - shooting tool for mixed models . These wrap - pers provide convenient access to the optimizers provided by Steven Johnson’s NLopt library ( via the nloptr R package ) , and to the nlminb optimizer from base R . ( nlminb is also available via the optimx package ; this wrapper provides access to nlminb without the need to install / link the pack - age , and without the additional post - ﬁtting checks that are implemented by optimx ( see examples below ) . One important difference between the nloptr - provided implementation of BOBYQA and the minqa - provided version accessible via optimizer = " bobyqa " is that it provides simpler access to optimiza - tion tolerances . minqa : : bobyqa provides only the rhoend parameter ( " [ t ] he smallest value of the trust region radius that is allowed " ) , while nloptr provides a more standard set of tolerances for relative or absolute change in the objective function or the parameter values ( ftol _ rel , ftol _ abs , xtol _ rel , xtol _ abs ) . Value par estimated parameters fval objective function value at minimum feval number of function evaluations conv convergence code ( 0 if no error ) message convergence message Author ( s ) Gabor Grothendieck ( nlminbwrap ) 76 nobars Examples environment ( nloptwrap ) $ defaultControl library ( lme4 ) fm1 < - lmer ( Reaction ~ Days + ( Days | Subject ) , sleepstudy ) # # BOBYQA ( default ) fm1 _ nloptr < - update ( fm1 , control = lmerControl ( optimizer = " nloptwrap " ) ) # # Nelder - Mead fm1 _ nloptr _ NM < - update ( fm1 , control = lmerControl ( optimizer = " nloptwrap " , optCtrl = list ( algorithm = " NLOPT _ LN _ NELDERMEAD " ) ) ) # # other nlOpt algorithm options include NLOPT _ LN _ COBYLA , NLOPT _ LN _ SBPLX fm1 _ nlminb < - update ( fm1 , control = lmerControl ( optimizer = " nlminbwrap " ) ) if ( require ( optimx ) ) { fm1 _ nlminb2 < - update ( fm1 , control = lmerControl ( optimizer = " optimx " , optCtrl = list ( method = " nlminb " , kkt = FALSE ) ) ) } nobars Omit terms separated by vertical bars in a formula Description Remove the random - effects terms from a mixed - effects formula , thereby producing the ﬁxed - effects formula . Usage nobars ( term ) Arguments term the right - hand side of a mixed - model formula Value the ﬁxed - effects part of the formula Note This function is called recursively on individual terms in the model , which is why the argument is called term and not a name like form , indicating a formula . See Also formula , model . frame , model . matrix . Other utilities : findbars , mkRespMod , mkReTrms , nlformula , subbars Examples nobars ( Reaction ~ Days + ( Days | Subject ) ) # # = > Reaction ~ Days Pastes 77 Pastes Paste strength by batch and cask Description Strength of a chemical paste product ; its quality depending on the delivery batch , and the cask within the delivery . Format A data frame with 60 observations on the following 4 variables . strength paste strength . batch delivery batch from which the sample was sample . A factor with 10 levels : ‘A’ to ‘J’ . cask cask within the delivery batch from which the sample was chosen . A factor with 3 levels : ‘a’ to ‘c’ . sample the sample of paste whose strength was assayed , two assays per sample . A factor with 30 levels : ‘A : a’ to ‘J : c’ . Details The data are described in Davies and Goldsmith ( 1972 ) as coming from “ deliveries of a chem - ical paste product contained in casks where , in addition to sampling and testing errors , there are variations in quality between deliveries . . . As a routine , three casks selected at random from each delivery were sampled and the samples were kept for reference . . . . Ten of the delivery batches were sampled at random and two analytical tests carried out on each of the 30 samples” . Source O . L . Davies and P . L . Goldsmith ( eds ) , Statistical Methods in Research and Production , 4th ed . , Oliver and Boyd , ( 1972 ) , section 6 . 5 Examples str ( Pastes ) require ( lattice ) dotplot ( cask ~ strength | reorder ( batch , strength ) , Pastes , strip = FALSE , strip . left = TRUE , layout = c ( 1 , 10 ) , ylab = " Cask within batch " , xlab = " Paste strength " , jitter . y = TRUE ) # # Modifying the factors to enhance the plot Pastes < - within ( Pastes , batch < - reorder ( batch , strength ) ) Pastes < - within ( Pastes , sample < - reorder ( reorder ( sample , strength ) , as . numeric ( batch ) ) ) dotplot ( sample ~ strength | batch , Pastes , strip = FALSE , strip . left = TRUE , layout = c ( 1 , 10 ) , scales = list ( y = list ( relation = " free " ) ) , ylab = " Sample within batch " , 78 Penicillin xlab = " Paste strength " , jitter . y = TRUE ) # # Four equivalent models differing only in specification ( fm1 < - lmer ( strength ~ ( 1 | batch ) + ( 1 | sample ) , Pastes ) ) ( fm2 < - lmer ( strength ~ ( 1 | batch / cask ) , Pastes ) ) ( fm3 < - lmer ( strength ~ ( 1 | batch ) + ( 1 | batch : cask ) , Pastes ) ) ( fm4 < - lmer ( strength ~ ( 1 | batch / sample ) , Pastes ) ) # # fm4 results in redundant labels on the sample : batch interaction head ( ranef ( fm4 ) [ [ 1 ] ] ) # # compare to fm1 head ( ranef ( fm1 ) [ [ 1 ] ] ) # # This model is different and NOT appropriate for these data ( fm5 < - lmer ( strength ~ ( 1 | batch ) + ( 1 | cask ) , Pastes ) ) L < - getME ( fm1 , " L " ) Matrix : : image ( L , sub = " Structure of random effects interaction in pastes model " ) Penicillin Variation in penicillin testing Description Six samples of penicillin were tested using the B . subtilis plate method on each of 24 plates . The response is the diameter ( mm ) of the zone of inhibition of growth of the organism . Format A data frame with 144 observations on the following 3 variables . diameter diameter ( mm ) of the zone of inhibition of the growth of the organism . plate assay plate . A factor with levels ‘a’ to ‘x’ . sample penicillin sample . A factor with levels ‘A’ to ‘F’ . Details The data are described in Davies and Goldsmith ( 1972 ) as coming from an investigation to “assess the variability between samples of penicillin by the B . subtilis method . In this test method a bulk - inoculated nutrient agar medium is poured into a Petri dish of approximately 90 mm . diameter , known as a plate . When the medium has set , six small hollow cylinders or pots ( about 4 mm . in diameter ) are cemented onto the surface at equally spaced intervals . A few drops of the penicillin solutions to be compared are placed in the respective cylinders , and the whole plate is placed in an incubator for a given time . Penicillin diffuses from the pots into the agar , and this produces a clear circular zone of inhibition of growth of the organisms , which can be readily measured . The diameter of the zone is related in a known way to the concentration of penicillin in the solution . ” Source O . L . Davies and P . L . Goldsmith ( eds ) , Statistical Methods in Research and Production , 4th ed . , Oliver and Boyd , ( 1972 ) , section 6 . 6 plot . lmList4 79 Examples str ( Penicillin ) require ( lattice ) dotplot ( reorder ( plate , diameter ) ~ diameter , Penicillin , groups = sample , ylab = " Plate " , xlab = " Diameter of growth inhibition zone ( mm ) " , type = c ( " p " , " a " ) , auto . key = list ( columns = 3 , lines = TRUE , title = " Penicillin sample " ) ) ( fm1 < - lmer ( diameter ~ ( 1 | plate ) + ( 1 | sample ) , Penicillin ) ) L < - getME ( fm1 , " L " ) Matrix : : image ( L , main = " L " , sub = " Penicillin : Structure of random effects interaction " ) plot . lmList4 plots for lmList4 objects Description diagnostic and conﬁdence - interval plots for lmList ﬁts Usage # # S3 method for class ’lmList4’ plot ( x , form , abline , id , idLabels , grid , . . . ) # # S3 method for class ’lmList4 . confint’ plot ( x , y , order , . . . ) Arguments x an object inheriting from class lmList , representing a list of lm objects with a common model . y ignored : for agreement with generic method form an optional formula specifying the desired type of plot . Any variable present in the original data frame used to obtain x can be referenced . In addition , x itself can be referenced in the formula using the symbol " . " . Conditional expressions on the right of a | operator can be used to deﬁne separate panels in a Trellis display . Default is resid ( . , type = " pool " ) ~ fitted ( . ) , corresponding to a plot of the standardized residuals ( using a pooled estimate for the residual standard error ) versus ﬁtted values . abline an optional numeric value , or numeric vector of length two . If given as a single value , a horizontal line will be added to the plot at that coordinate ; else , if given as a vector , its values are used as the intercept and slope for a line added to the plot . If missing , no lines are added to the plot . id an optional numeric value , or one - sided formula . If given as a value , it is used as a signiﬁcance level for a two - sided outlier test for the standardized residuals . Observations with absolute standardized residuals greater than the 80 plot . merMod 1 − value / 2 quantile of the standard normal distribution are identiﬁed in the plot using idLabels . If given as a one - sided formula , its right hand side must evaluate to a logical , integer , or character vector which is used to identify obser - vations in the plot . If missing , no observations are identiﬁed . idLabels an optional vector , or one - sided formula . If given as a vector , it is converted to character and used to label the observations identiﬁed according to id . If given as a one - sided formula , its right hand side must evaluate to a vector which is converted to character and used to label the identiﬁed observations . Default is getGroups ( x ) . grid an optional logical value indicating whether a grid should be added to plot . De - fault depends on the type of Trellis plot used : if xyplot defaults to TRUE , else defaults to FALSE . order which coefﬁcient to order the results by . . . optional arguments passed to the Trellis plot function . Details The plot method for lmList4 objects is copied from that for lmList objects ; see plot . lmList for details . Author ( s ) Original versions in nlme package by Jose Pinheiro and Douglas Bates Examples fm . plm < - lmList ( Reaction ~ Days | Subject , sleepstudy ) # # diagnostic plot : standardized residuals vs . fitted plot ( fm . plm , id = 0 . 05 ) ci < - confint ( fm . plm ) # # plot CIs , ordered by slope ( coefficient 2 ) plot ( ci , order = 2 , ylab = " Subject " ) plot . merMod diagnostic plots for merMod ﬁts Description diagnostic plots for merMod ﬁts Usage # # S3 method for class ’merMod’ plot ( x , form = resid ( . , type = " pearson " ) ~ fitted ( . ) , abline , id = NULL , idLabels = NULL , grid , . . . ) # # S3 method for class ’merMod’ qqmath ( x , id = NULL , idLabels = NULL , . . . ) plot . merMod 81 Arguments x a ﬁtted [ ng ] lmer model form an optional formula specifying the desired type of plot . Any variable present in the original data frame used to obtain x can be referenced . In addition , x itself can be referenced in the formula using the symbol " . " . Conditional expressions on the right of a | operator can be used to deﬁne separate panels in a lattice dis - play . Default is resid ( . , type = " pearson " ) ~ fitted ( . ) , corresponding to a plot of the standardized residuals versus ﬁtted values . abline an optional numeric value , or numeric vector of length two . If given as a single value , a horizontal line will be added to the plot at that coordinate ; else , if given as a vector , its values are used as the intercept and slope for a line added to the plot . If missing , no lines are added to the plot . id an optional numeric value , or one - sided formula . If given as a value , it is used as a signiﬁcance level for a two - sided outlier test for the standardized , or normal - ized residuals . Observations with absolute standardized ( normalized ) residuals greater than the 1 − value / 2 quantile of the standard normal distribution are identiﬁed in the plot using idLabels . If given as a one - sided formula , its right hand side must evaluate to a logical , integer , or character vector which is used to identify observations in the plot . If missing , no observations are identiﬁed . idLabels an optional vector , or one - sided formula . If given as a vector , it is converted to character and used to label the observations identiﬁed according to id . If given as a vector , it is converted to character and used to label the observations identiﬁed according to id . If given as a one - sided formula , its right hand side must evaluate to a vector which is converted to character and used to label the identiﬁed observations . Default is the interaction of all the grouping variables in the data frame . The special formula idLabels = ~ . obs will label the observations according to observation number . grid an optional logical value indicating whether a grid should be added to plot . De - fault depends on the type of lattice plot used : if xyplot defaults to TRUE , else defaults to FALSE . . . . optional arguments passed to the lattice plot function . Details Diagnostic plots for the linear mixed - effects ﬁt are obtained . The form argument gives considerable ﬂexibility in the type of plot speciﬁcation . A conditioning expression ( on the right side of a | operator ) always implies that different panels are used for each level of the conditioning factor , according to a lattice display . If form is a one - sided formula , histograms of the variable on the right hand side of the formula , before a | operator , are displayed ( the lattice function histogram is used ) . If form is two - sided and both its left and right hand side variables are numeric , scatter plots are displayed ( the lattice function xyplot is used ) . Finally , if form is two - sided and its left had side variable is a factor , box - plots of the right hand side variable by the levels of the left hand side variable are displayed ( the lattice function bwplot is used ) . qqmath produces a Q - Q plot of the residuals ( see link { qqmath . ranef . mer } for Q - Q plots of the conditional mode values ) . 82 plots . thpr Author ( s ) original version in nlme package by Jose Pinheiro and Douglas Bates Examples data ( Orthodont , package = " nlme " ) fm1 < - lmer ( distance ~ age + ( age | Subject ) , data = Orthodont ) # # standardized residuals versus fitted values by gender plot ( fm1 , resid ( . , scaled = TRUE ) ~ fitted ( . ) | Sex , abline = 0 ) # # box - plots of residuals by Subject plot ( fm1 , Subject ~ resid ( . , scaled = TRUE ) ) # # observed versus fitted values by Subject plot ( fm1 , distance ~ fitted ( . ) | Subject , abline = c ( 0 , 1 ) ) # # residuals by age , separated by Subject plot ( fm1 , resid ( . , scaled = TRUE ) ~ age | Sex , abline = 0 ) require ( " lattice " ) qqmath ( fm1 , id = 0 . 05 ) if ( require ( " ggplot2 " ) ) { # # we can create the same plots using ggplot2 and the fortify ( ) function fm1F < - fortify ( fm1 ) ggplot ( fm1F , aes ( . fitted , . resid ) ) + geom _ point ( colour = " blue " ) + facet _ grid ( . ~ Sex ) + geom _ hline ( yintercept = 0 ) # # note : Subjects are ordered by mean distance ggplot ( fm1F , aes ( Subject , . resid ) ) + geom _ boxplot ( ) + coord _ flip ( ) ggplot ( fm1F , aes ( . fitted , distance ) ) + geom _ point ( colour = " blue " ) + facet _ wrap ( ~ Subject ) + geom _ abline ( intercept = 0 , slope = 1 ) ggplot ( fm1F , aes ( age , . resid ) ) + geom _ point ( colour = " blue " ) + facet _ grid ( . ~ Sex ) + geom _ hline ( yintercept = 0 ) + geom _ line ( aes ( group = Subject ) , alpha = 0 . 4 ) + geom _ smooth ( method = " loess " ) # # ( warnings about loess are due to having only 4 unique x values ) detach ( " package : ggplot2 " ) } plots . thpr Mixed - Effects Proﬁle Plots ( Regular / Density / Pairs ) Description Xyplot , Densityplot , and Pairs plot methods for a mixed - effects model proﬁle . xyplot ( ) draws “zeta diagrams” , also visualizing conﬁdence intervals and their asymmetry . densityplot ( ) draws the proﬁle densities . splom ( ) draws proﬁle pairs plots . Contours are for the marginal two - dimensional regions ( i . e . using df = 2 ) . Usage # # S3 method for class ’thpr’ xyplot ( x , data = NULL , levels = sqrt ( qchisq ( pmax . int ( 0 , pmin . int ( 1 , conf ) ) , df = 1 ) ) , plots . thpr 83 conf = c ( 50 , 80 , 90 , 95 , 99 ) / 100 , absVal = FALSE , scales = NULL , which = 1 : nptot , . . . ) # # S3 method for class ’thpr’ densityplot ( x , data , . . . ) # # S3 method for class ’thpr’ splom ( x , data , levels = sqrt ( qchisq ( pmax . int ( 0 , pmin . int ( 1 , conf ) ) , 2 ) ) , conf = c ( 50 , 80 , 90 , 95 , 99 ) / 100 , which = 1 : nptot , draw . lower = TRUE , draw . upper = TRUE , . . . ) Arguments x a mixed - effects proﬁle , i . e . , of class " thpr " , typically resulting from profile ( fm ) where fm is a ﬁtted model from lmer ( or its generalizations ) . data unused - only for compatibility with generic . levels the contour levels to be shown ; usually derived from conf . conf numeric vector of conﬁdence levels to be shown as contours . absVal logical indicating if abs ( . ) olute values should be plotted , often preferred for conﬁdence interval visualization . scales plotting options to be passed to xyplot which integer or character vector indicating which parameters to proﬁle : default is all parameters ( see profile - methods for details ) . draw . lower ( logical ) draw lower - triangle ( zeta scale ) panels ? draw . upper ( logical ) draw upper - triangle ( standard dev / cor scale ) panels ? . . . further arguments passed to xyplot , densityplot , or splom from package lat - tice , respectively . Value xyplot : a density plot , a " trellis " object ( lattice package ) which when print ( ) ed produces plots on the current graphic device . densityplot : a density plot , a " trellis " object , see above . splom : a pairs plot , aka s catter plo t m atrix , a " trellis " object , see above . See Also profile , notably for an example . Examples # # see example ( " profile . merMod " ) 84 predict . merMod predict . merMod Predictions from a model at new data values Description The predict method for merMod objects , i . e . results of lmer ( ) , glmer ( ) , etc . Usage # # S3 method for class ’merMod’ predict ( object , newdata = NULL , newparams = NULL , re . form = NULL , ReForm , REForm , REform , terms = NULL , type = c ( " link " , " response " ) , allow . new . levels = FALSE , na . action = na . pass , . . . ) Arguments object a ﬁtted model object newdata data frame of for which to evaluate predictions . newparams new parameters to use in evaluating predictions , speciﬁed as in the start pa - rameter for lmer or glmer – a list with components theta and / or ( for GLMMs ) beta . re . form formula for random effects to condition on . If NULL , include all random effects ; if NA or ~ 0 , include no random effects ReForm , REForm , REform allowed for backward compatibility : re . form is now the preferred argument name . terms a terms object - unused at present . type character string - either " link " , the default , or " response " indicating the type of prediction object returned . allow . new . levels logical if new levels ( or NA values ) in newdata are allowed . If FALSE ( default ) , such new values in newdata will trigger an error ; if TRUE , then the prediction will use the unconditional ( population - level ) values for data with previously un - observed levels ( or NAs ) . na . action function determining what should be done with missing values for ﬁxed effects in newdata . The default is to predict NA : see na . pass . . . . optional additional parameters . None are used at present . Value a numeric vector of predicted values proﬁle - methods 85 Note There is no option for computing standard errors of predictions because it is difﬁcult to deﬁne an efﬁcient method that incorporates uncertainty in the variance parameters ; we recommend bootMer for this task . Examples ( gm1 < - glmer ( cbind ( incidence , size - incidence ) ~ period + ( 1 | herd ) , cbpp , binomial ) ) str ( p0 < - predict ( gm1 ) ) # fitted values str ( p1 < - predict ( gm1 , re . form = NA ) ) # fitted values , unconditional ( level - 0 ) newdata < - with ( cbpp , expand . grid ( period = unique ( period ) , herd = unique ( herd ) ) ) str ( p2 < - predict ( gm1 , newdata ) ) # new data , all RE str ( p3 < - predict ( gm1 , newdata , re . form = NA ) ) # new data , level - 0 str ( p4 < - predict ( gm1 , newdata , re . form = ~ ( 1 | herd ) ) ) # explicitly specify RE stopifnot ( identical ( p2 , p4 ) ) profile - methods Proﬁle method for merMod objects Description Methods for profile ( ) of [ ng ] lmer ﬁtted models . The log ( ) method and the more ﬂexible logProf ( ) utility transform a lmer proﬁle into one where logarithms of standard deviations are used ; see Details . Usage # # S3 method for class ’merMod’ profile ( fitted , which = NULL , alphamax = 0 . 01 , maxpts = 100 , delta = NULL , delta . cutoff = 1 / 8 , verbose = 0 , devtol = 1e - 09 , maxmult = 10 , startmethod = " prev " , optimizer = NULL , control = NULL , signames = TRUE , parallel = c ( " no " , " multicore " , " snow " ) , ncpus = getOption ( " profile . ncpus " , 1L ) , cl = NULL , . . . ) # # S3 method for class ’thpr’ as . data . frame ( x , . . . ) # # S3 method for class ’thpr’ log ( x , base = exp ( 1 ) ) logProf ( x , base = exp ( 1 ) , ranef = TRUE , sigIni = if ( ranef ) " sig " else " sigma " ) 86 proﬁle - methods Arguments fitted a ﬁtted model , e . g . , the result of lmer ( . . ) . which NULL value , integer or character vector indicating which parameters to proﬁle : default ( NULL ) is all parameters . For integer , i . e . , indexing , the parameters are ordered as follows : ( 1 ) random effects ( theta ) parameters ; these are ordered as in getME ( . , " theta " ) , i . e . , as the lower triangle of a matrix with standard deviations on the diago - nal and correlations off the diagonal . ( 2 ) residual standard deviation ( or scale parameter for GLMMs where appro - priate ) . ( 3 ) ﬁxed effect ( beta ) parameters . Alternatively , which may be a character , containing " beta _ " or " theta _ " de - noting the ﬁxed or random effects parameters , respectively , or also containing parameter names , such as " . sigma " or " ( Intercept ) " . alphamax a number in ( 0 , 1 ) , such that 1 - alphamax is the maximum alpha value for likelihood ratio conﬁdence regions ; used to establish the range of values to be proﬁled . maxpts maximum number of points ( in each direction , for each parameter ) to evaluate in attempting to construct the proﬁle . delta stepping scale for deciding on next point to proﬁle . The code uses the local derivative of the proﬁle at the current step to establish a change in the focal parameter that will lead to a step of delta on the square - root - deviance scale . If NULL , the delta . cutoff parameter will be used to determine the stepping scale . delta . cutoff stepping scale ( see delta ) expressed as a fraction of the target maximum value of the proﬁle on the square - root - deviance scale . Thus a delta . cutoff setting of 1 / n will lead to a proﬁle with approximately 2 * n calculated points for each parameter ( i . e . , n points in each direction , below and above the estimate for each parameter ) . verbose level of output from internal calculations . devtol tolerance for ﬁtted deviances less than baseline ( supposedly minimum ) deviance . maxmult maximum multiplier of the original step size allowed , defaults to 10 . startmethod method for picking starting conditions for optimization ( STUB ) . optimizer ( character or function ) optimizer to use ( see lmer for details ) ; default is to use the optimizer from the original model ﬁt . control a list of options controlling the proﬁling ( see lmerControl ) : default is to use the control settings from the original model ﬁt . signames logical indicating if abbreviated names of the form . sigNN should be used ; oth - erwise , names are more meaningful ( but longer ) of the form ( sd | cor ) _ ( effects ) | ( group ) . Note that some code for proﬁle transformations ( e . g . , log ( ) or varianceProf ) depends on signames = = TRUE . . . . potential further arguments for various methods . x an object of class thpr ( i . e . , output of profile ) base the base of the logarithm . Defaults to natural logarithms . proﬁle - methods 87 ranef logical indicating if the sigmas of the random effects should be log ( ) trans - formed as well . If false , only σ ( standard deviation of errors ) is transformed . sigIni character string specifying the initial part of the sigma parameters to be log transformed . parallel The type of parallel operation to be used ( if any ) . If missing , the default is taken from the option " profile . parallel " ( and if that is not set , " no " ) . ncpus integer : number of processes to be used in parallel operation : typically one would choose this to be the number of available CPUs . cl An optional parallel or snow cluster for use if parallel = " snow " . If not sup - plied , a cluster on the local machine is created for the duration of the profile call . Details The log method and the more ﬂexible logProf ( ) function transform the proﬁle into one where log ( σ ) is used instead of σ . By default all sigmas including the standard deviations of the random effects are transformed i . e . , the methods return a proﬁle with all of the . sigNN parameters replaced by . lsigNN . If ranef is false , only " . sigma " , the standard deviation of the errors , is transformed ( as it should never be zero , whereas random effect standard deviations ( . sigNN ) can be reasonably be zero ) . The forward and backward splines for the log - transformed parameters are recalculated . Methods for function profile ( package stats ) , here for proﬁling ( ﬁtted ) mixed effect models . Value profile ( < merMod > ) returns an object of S3 class " thpr " , which is data . frame - like . Notable methods for such a proﬁle object confint ( ) , which returns the conﬁdence intervals based on the proﬁle , and three plotting methods ( which require the lattice package ) , xyplot , densityplot , and splom . In addition , the log ( ) ( see above ) and as . data . frame ( ) methods can transform " thpr " objects in useful ways . See Also The plotting methods xyplot etc , for class " thpr " ; varianceProf for transformation ( from st . dev . ) to variance scale . For ( more expensive ) alternative conﬁdence intervals : bootMer . Examples fm01ML < - lmer ( Yield ~ 1 | Batch , Dyestuff , REML = FALSE ) system . time ( tpr < - profile ( fm01ML , optimizer = " Nelder _ Mead " , which = " beta _ " ) ) # # fast ; as only * one * beta parameter is profiled over # # full profiling ( default which means ’all ) needs # # ~ 2 . 6s ( on a 2010 Macbook Pro ) system . time ( tpr < - profile ( fm01ML ) ) # # ~ 1s , + possible warning about bobyqa convergence 88 prt - utilities ( confint ( tpr ) - > CIpr ) stopifnot ( all . equal ( unname ( CIpr ) , array ( c ( 12 . 1985292 , 38 . 2299848 , 1486 . 4515 , 84 . 0630513 , 67 . 6576964 , 1568 . 54849 ) , dim = 3 : 2 ) , tol = 1e - 07 ) ) # 1 . 37e - 9 { 64b } library ( " lattice " ) xyplot ( tpr ) xyplot ( tpr , absVal = TRUE ) # easier to see conf . int . s ( and check symmetry ) xyplot ( tpr , conf = c ( 0 . 95 , 0 . 99 ) , # ( instead of all five 50 , 80 , . . . ) main = " 95 % and 99 % profile ( ) intervals " ) xyplot ( logProf ( tpr , ranef = FALSE ) , main = expression ( " lmer profile ( ) s " ~ ~ log ( sigma ) * " ( only log ) " ) ) densityplot ( tpr , main = " densityplot ( profile ( lmer ( . . ) ) ) " ) densityplot ( varianceProf ( tpr ) , main = " varianceProf ( profile ( lmer ( . . ) ) ) " ) splom ( tpr ) splom ( logProf ( tpr , ranef = FALSE ) ) doMore < - lme4 : : : testLevel ( ) > 1 if ( doMore ) { # # not typically , for time constraint reasons # # Batch and residual variance only system . time ( tpr2 < - profile ( fm01ML , which = 1 : 2 , optimizer = " Nelder _ Mead " ) ) print ( xyplot ( tpr2 ) ) print ( xyplot ( log ( tpr2 ) ) ) # log ( sigma ) is better print ( xyplot ( logProf ( tpr2 , ranef = FALSE ) ) ) # # GLMM example gm1 < - glmer ( cbind ( incidence , size - incidence ) ~ period + ( 1 | herd ) , data = cbpp , family = binomial ) # # running ~ 10 - 12 seconds on a modern machine { - > " verbose " while you wait } : print ( system . time ( pr4 < - profile ( gm1 , verbose = TRUE ) ) ) print ( xyplot ( pr4 , layout = c ( 5 , 1 ) , as . table = TRUE ) ) print ( xyplot ( log ( pr4 ) , absVal = TRUE ) ) # log ( sigma _ 1 ) print ( splom ( pr4 ) ) print ( system . time ( # quicker : only sig01 and one fixed effect pr2 < - profile ( gm1 , which = c ( " theta _ " , " period2 " ) ) ) ) print ( confint ( pr2 ) ) # # delta . . : higher underlying resolution , only for ’sigma _ 1’ : print ( system . time ( pr4 . hr < - profile ( gm1 , which = " theta _ " , delta . cutoff = 1 / 16 ) ) ) print ( xyplot ( pr4 . hr ) ) } prt - utilities Print and Summary Method Utilities for Mixed Effects Description The print , summary methods ( including the print for the summary ( ) result ) in lme4 are modular , using about ten small utility functions . Other packages , building on lme4 can use the same utilities for ease of programming and consistency of output . prt - utilities 89 Notably see the Examples . llikAIC ( ) extracts the log likelihood , AIC , and related statics from a Fitted LMM . formatVC ( ) “format ( ) ”s the VarCorr matrix of the random effects – for print ( ) ing and show ( ) ing ; it is also the “workhorse” of . prt . VC ( ) , and returns a character matrix . . prt . * ( ) all use cat and print to produce output . Usage llikAIC ( object , devianceFUN = devCrit , chkREML = TRUE , devcomp = object @ devcomp ) methTitle ( dims ) . prt . methTit ( mtit , class ) . prt . family ( famL ) . prt . resids ( resids , digits , title = " Scaled residuals : " , . . . ) . prt . call ( call , long = TRUE ) . prt . aictab ( aictab , digits = 1 ) . prt . grps ( ngrps , nobs ) . prt . warn ( optinfo , summary = FALSE , . . . ) . prt . VC ( varcor , digits , comp , formatter = format , . . . ) formatVC ( varcor , digits = max ( 3 , getOption ( " digits " ) - 2 ) , comp = " Std . Dev . " , formatter = format , useScale = attr ( varcor , " useSc " ) , . . . ) Arguments object a LMM model ﬁt devianceFUN the function to be used for computing the deviance ; should not be changed for lme4 created objects . chkREML optional logical indicating if object maybe a REML ﬁt . devcomp for lme4 always the equivalent of object @ devcomp ; here a list dims for lme4 always the equivalent of object @ devcomp $ dims , a named vector or list with components " GLMM " , " NLMM " , " REML " , and " nAGQ " of which the ﬁrst two are logical scalars , and the latter two typically are FALSE or numeric . mtit the result of methTitle ( object ) class typically class ( object ) . famL a list with components family and link , each a character string ; note that standard R family objects can be used directly , as well . resids numeric vector of model residuals . digits non - negative integer of ( signiﬁcant ) digits to print minimally . title character string . . . . optional arguments passed on , e . g . , to residuals ( ) . 90 prt - utilities call the call of the model ﬁt ; e . g . , available via ( generic ) function getCall ( ) . long logical indicating if the output may be long , e . g . , printing the control part of the call if there is one . aictab typically the AICtab component of the result of llikAIC ( ) . varcor typically the result of VarCorr ( ) . comp optional . . . formatter a function used for formatting the numbers . ngrps integer ( vector ) , typically the result of ngrps ( object ) . nobs integer ; the number of observations , e . g . , the result of nobs . optinfo typically object @ optinfo , the optimization infos , including warnings if there were . summary logical useScale ( logical ) whether the parent model estimates a scale parameter Value llikAIC ( ) returns a list with components logLik which is logLik ( object ) , and AICtab a “table” of AIC , BIC , logLik , deviance and df . residual ( ) values . Examples # # Create a few " lme4 standard " models - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - fm1 < - lmer ( Reaction ~ Days + ( Days | Subject ) , sleepstudy ) fmM < - update ( fm1 , REML = FALSE ) # - > Maximum Likelihood gm1 < - glmer ( cbind ( incidence , size - incidence ) ~ period + ( 1 | herd ) , data = cbpp , family = binomial ) gmA < - update ( gm1 , nAGQ = 5 ) ( lA1 < - llikAIC ( fm1 ) ) ( lAM < - llikAIC ( fmM ) ) ( lAg < - llikAIC ( gmA ) ) ( m1 < - methTitle ( fm1 @ devcomp $ dims ) ) ( mM < - methTitle ( fmM @ devcomp $ dims ) ) ( mG < - methTitle ( gm1 @ devcomp $ dims ) ) ( mA < - methTitle ( gmA @ devcomp $ dims ) ) . prt . methTit ( m1 , class ( fm1 ) ) . prt . methTit ( mA , class ( gmA ) ) . prt . family ( gaussian ( ) ) . prt . family ( binomial ( ) ) . prt . family ( poisson ( ) ) pvalues 91 . prt . resids ( residuals ( fm1 ) , digits = 4 ) . prt . resids ( residuals ( fmM ) , digits = 2 ) . prt . call ( getCall ( fm1 ) ) . prt . call ( getCall ( gm1 ) ) . prt . aictab ( lA1 $ AICtab ) # REML . prt . aictab ( lAM $ AICtab ) # ML - - > AIC , BIC , . . . V1 < - VarCorr ( fm1 ) m < - formatVC ( V1 ) stopifnot ( is . matrix ( m ) , is . character ( m ) , ncol ( m ) = = 4 ) print ( m , quote = FALSE ) # # prints all but the first line of . prt . VC ( ) below : . prt . VC ( V1 , digits = 4 , formatter = format ) # # Random effects : # # Groups Name Std . Dev . Corr # # Subject ( Intercept ) 24 . 740 # # Days 5 . 922 0 . 07 # # Residual 25 . 592 p1 < - capture . output ( V1 ) p2 < - capture . output ( print ( m , quote = FALSE ) ) pX < - capture . output ( . prt . VC ( V1 , digits = max ( 3 , getOption ( " digits " ) - 2 ) ) ) stopifnot ( identical ( p1 , p2 ) , identical ( p1 , pX [ - 1 ] ) ) # [ - 1 ] : dropping 1st line . prt . grps ( ngrps = ngrps ( fm1 ) , nobs = nobs ( fm1 ) ) # # - - > Number of obs : 180 , groups : Subject , 18 . prt . warn ( fm1 @ optinfo ) # nothing . . had no warnings pvalues Getting p - values for ﬁtted models Description One of the most frequently asked questions about lme4 is " how do I calculate p - values for estimated parameters ? " Previous versions of lme4 provided the mcmcsamp function , which efﬁciently gener - ated a Markov chain Monte Carlo sample from the posterior distribution of the parameters , assum - ing ﬂat ( scaled likelihood ) priors . Due to difﬁculty in constructing a version of mcmcsamp that was reliable even in cases where the estimated random effect variances were near zero ( e . g . https : / / stat . ethz . ch / pipermail / r - sig - mixed - models / 2009q4 / 003115 . html ) , mcmcsamp has been with - drawn ( or more precisely , not updated to work with lme4 versions > = 1 . 0 . 0 ) . Many users , including users of the aovlmer . fnc function from the languageR package which relies on mcmcsamp , will be deeply disappointed by this lacuna . Users who need p - values have a variety of options . In the list below , the methods marked MC provide explicit model comparisons ; CI denotes conﬁdence intervals ; and P denotes parameter - level or sequential tests of all effects in a model . The starred ( * ) suggestions provide ﬁnite - size corrections ( important when the number of groups is < 50 ) ; those marked ( + ) support GLMMs as well as LMMs . 92 ranef • likelihood ratio tests via anova or drop1 ( MC , + ) • proﬁle conﬁdence intervals via profile . merMod and confint . merMod ( CI , + ) • parametric bootstrap conﬁdence intervals and model comparisons via bootMer ( or PBmodcomp in the pbkrtest package ) ( MC / CI , * , + ) • for random effects , simulation tests via the RLRsim package ( MC , * ) • for ﬁxed effects , F tests via Kenward - Roger approximation using KRmodcomp from the pbkrtest package ( MC , * ) • car : : Anova and lmerTest : : anova provide wrappers for Kenward - Roger - corrected tests us - ing pbkrtest : lmerTest : : anova also provides t tests via the Satterthwaite approximation ( P , * ) • afex : : mixed is another wrapper for pbkrtest and anova providing " Type 3 " tests of all effects ( P , * , + ) arm : : sim , or bootMer , can be used to compute conﬁdence intervals on predictions . For glmer models , the summary output provides p - values based on asymptotic Wald tests ( P ) ; while this is standard practice for generalized linear models , these tests make assumptions both about the shape of the log - likelihood surface and about the accuracy of a chi - squared approximation to differences in log - likelihoods . When all else fails , don’t forget to keep p - values in perspective : http : / / www . phdcomics . com / comics / archive . php ? comicid = 905 ranef Extract the modes of the random effects Description A generic function to extract the conditional modes of the random effects from a ﬁtted model object . For linear mixed models the conditional modes of the random effects are also the conditional means . Usage # # S3 method for class ’merMod’ ranef ( object , condVar = FALSE , drop = FALSE , whichel = names ( ans ) , postVar = FALSE , . . . ) # # S3 method for class ’ranef . mer’ dotplot ( x , data , main = TRUE , . . . ) # # S3 method for class ’ranef . mer’ qqmath ( x , data , main = TRUE , . . . ) Arguments object an object of a class of ﬁtted models with random effects , typically a merMod object . condVar an optional logical argument indicating if the conditional variance - covariance matrices of the random effects should be added as an attribute . ranef 93 drop should components of the return value that would be data frames with a single column , usually a column called ‘ ( Intercept ) ’ , be returned as named vectors instead ? whichel character vector of names of grouping factors for which the random effects should be returned . postVar a ( deprecated ) synonym for condVar x a random - effects object ( of class ranef . mer ) produced by ranef main include a main title , indicating the grouping factor , on each sub - plot ? data This argument is required by the dotplot and qqmath generic methods , but is not actually used . . . . some methods for these generic functions require additional arguments . Details If grouping factor i has k levels and j random effects per level the ith component of the list returned by ranef is a data frame with k rows and j columns . If condVar is TRUE the " postVar " attribute is an array of dimension j by j by k . The kth face of this array is a positive deﬁnite symmetric j by j matrix . If there is only one grouping factor in the model the variance - covariance matrix for the entire random effects vector , conditional on the estimates of the model parameters and on the data will be block diagonal and this j by j matrix is the kth diagonal block . With multiple grouping factors the faces of the " postVar " attributes are still the diagonal blocks of this conditional variance - covariance matrix but the matrix itself is no longer block diagonal . Value An object of class ranef . mer composed of a list of data frames , one for each grouping factor for the random effects . The number of rows in the data frame is the number of levels of the grouping factor . The number of columns is the dimension of the random effect associated with each level of the factor . If condVar is TRUE each of the data frames has an attribute called " postVar " which is a three - dimensional array with symmetric faces ; each face contains the variance - covariance matrix for a particular level of the grouping factor . ( The name of this attribute is a historical artifact , and may be changed to condVar at some point in the future . ) When drop is TRUE any components that would be data frames of a single column are converted to named numeric vectors . Note To produce a ( list of ) “caterpillar plots” of the random effects apply dotplot to the result of a call to ranef with condVar = TRUE ; qqmath will generate a list of Q - Q plots . Examples require ( lattice ) fm1 < - lmer ( Reaction ~ Days + ( Days | Subject ) , sleepstudy ) fm2 < - lmer ( Reaction ~ Days + ( 1 | Subject ) + ( 0 + Days | Subject ) , sleepstudy ) fm3 < - lmer ( diameter ~ ( 1 | plate ) + ( 1 | sample ) , Penicillin ) 94 reﬁt ranef ( fm1 ) str ( rr1 < - ranef ( fm1 , condVar = TRUE ) ) dotplot ( rr1 ) # # default # # specify free scales in order to make Day effects more visible dotplot ( rr1 , scales = list ( x = list ( relation = ’free’ ) ) ) [ [ " Subject " ] ] if ( FALSE ) { # # - - condVar = TRUE is not yet implemented for multiple terms - - FIXME str ( ranef ( fm2 , condVar = TRUE ) ) } op < - options ( digits = 4 ) ranef ( fm3 , drop = TRUE ) options ( op ) refit Reﬁt a ( merMod ) Model with a Different Response Description Reﬁt a model , possibly after modifying the response vector . This makes use of the model represen - tation and directly goes to the optimization . Usage refit ( object , newresp , . . . ) # # S3 method for class ’merMod’ refit ( object , newresp = NULL , rename . response = FALSE , maxit = 100 , . . . ) Arguments object a ﬁtted model , usually of class lmerMod , to be reﬁt with a new response . newresp an ( optional ) numeric vector providing the new response , of the same length as the original response ( see Details for information on NA handling ) . May also be a data frame with a single numeric column , e . g . as produced by simulate ( object ) . rename . response when reﬁtting the model , should the name of the response variable in the formula and model frame be replaced with the name of newresp ? maxit scalar integer , currently only for GLMMs : the maximal number of Pwrss update iterations . . . . optional additional parameters . For the merMod method , control . Details Reﬁt a model , possibly after modifying the response vector . This could be done using update ( ) , but the refit ( ) approach should be faster because it bypasses the creation of the model representation and goes directly to the optimization step . reﬁt 95 Setting rename . response = TRUE may be necessary if one wants to do further operations ( such as update ) on the ﬁtted model . However , the reﬁtted model will still be slightly different from the equivalent model ﬁtted via update ; in particular , the terms component is not updated to reﬂect the new response variable , if it has a different name from the original . If newresp has an na . action attribute , then it is assumed that NA values have already been re - moved from the numeric vector ; this allows the results of simulate ( object ) to be used even if the original response vector contained NA values . Otherwise , the length of newresp must be the same as the original length of the response . Value an object like x , but ﬁt to a different response vector Y . See Also update . merMod for more ﬂexible and extensive model reﬁtting ; refitML for reﬁtting a REML ﬁtted model with maximum likelihood ( ‘ML’ ) . Examples # # Ex . 1 : using refit ( ) to fit each column in a matrix of responses - - - - - - - set . seed ( 101 ) Y < - matrix ( rnorm ( 1000 ) , ncol = 10 ) # # combine first column of responses with predictor variables d < - data . frame ( y = Y [ , 1 ] , x = rnorm ( 100 ) , f = rep ( 1 : 10 , 10 ) ) # # ( use check . conv . grad = " ignore " to disable convergence checks because we # # are using a fake example ) # # fit first response fit1 < - lmer ( y ~ x + ( 1 | f ) , data = d , control = lmerControl ( check . conv . grad = " ignore " , check . conv . hess = " ignore " ) ) # # combine fit to first response with fits to remaining responses res < - c ( fit1 , lapply ( as . data . frame ( Y [ , - 1 ] ) , refit , object = fit1 ) ) # # Ex . 2 : refitting simulated data using data that contain NA values - - - - - - sleepstudyNA < - sleepstudy sleepstudyNA $ Reaction [ 1 : 3 ] < - NA fm0 < - lmer ( Reaction ~ Days + ( 1 | Subject ) , sleepstudyNA ) # # the special case of refitting with a single simulation works . . . ss0 < - refit ( fm0 , simulate ( fm0 ) ) # # . . . but if simulating multiple responses ( for efficiency ) , # # need to use na . action = na . exclude in order to have proper length of data fm1 < - lmer ( Reaction ~ Days + ( 1 | Subject ) , sleepstudyNA , na . action = na . exclude ) ss < - simulate ( fm1 , 5 ) res2 < - refit ( fm1 , ss [ [ 5 ] ] ) 96 rePos refitML Reﬁt a Model by Maximum Likelihood Criterion Description Reﬁt a ( merMod ) model using the maximum likelihood criterion . Usage refitML ( x , . . . ) # # S3 method for class ’merMod’ refitML ( x , optimizer = " bobyqa " , . . . ) Arguments x a ﬁtted model , usually of class " lmerMod " , to be reﬁt according to the maximum likelihood criterion . . . . optional additional parameters . None are used at present . optimizer a string indicating the optimizer to be used . Details This function is primarily used to get a maximum likelihood ﬁt of a linear mixed - effects model for an anova comparison . Value an object like x but ﬁt by maximum likelihood See Also refit and update . merMod for more extensive reﬁtting . rePos Generator object for the rePos ( random - effects positions ) class Description The generator object for the rePos class used to determine the positions and orders of random effects associated with particular random - effects terms in the model . Usage rePos ( . . . ) rePos - class 97 Arguments . . . Argument list ( see Note ) . Methods new ( mer = mer ) Create a new rePos object . Note Arguments to the new methods must be named arguments . mer , an object of class " merMod " , is the only required / expected argument . See Also rePos rePos - class Class " rePos " Description A reference class for determining the positions in the random - effects vector that correspond to particular random - effects terms in the model formula Extends All reference classes extend and inherit methods from " envRefClass " . Examples showClass ( " rePos " ) residuals . merMod residuals of merMod objects Description residuals of merMod objects 98 sigma Usage # # S3 method for class ’merMod’ residuals ( object , type = if ( isGLMM ( object ) ) " deviance " else " response " , scaled = FALSE , . . . ) # # S3 method for class ’lmResp’ residuals ( object , type = c ( " working " , " response " , " deviance " , " pearson " , " partial " ) , . . . ) # # S3 method for class ’glmResp’ residuals ( object , type = c ( " deviance " , " pearson " , " working " , " response " , " partial " ) , . . . ) Arguments object a ﬁtted [ g ] lmer ( merMod ) object type type of residuals scaled scale residuals by residual standard deviation ( = scale parameter ) ? . . . additional arguments ( ignored : for method compatibility ) Details • The default residual type varies between lmerMod and glmerMod objects : they try to mimic residuals . lm and residuals . glm respectively . In particular , the default type is " response " , i . e . ( observed - ﬁtted ) for lmerMod objects vs . " deviance " for glmerMod objects . type = " partial " is not yet implemented for either type . • Note that the meaning of " pearson " residuals differs between residuals . lm and residuals . lme . The former returns values scaled by the square root of user - speciﬁed weights ( if any ) , but not by the residual standard deviation , while the latter returns values scaled by the estimated standard deviation ( which will include the effects of any variance structure speciﬁed in the weights argument ) . To replicate lme behaviour , use type = " pearson " , scaled = TRUE . sigma Extract Residual Standard Deviation ’Sigma’ Description Extract the estimated standard deviation of the errors , the “residual standard deviation” ( also mis - named the “residual standard error” ) , from a ﬁtted model . Usage # # S3 method for class ’merMod’ sigma ( object , . . . ) simulate . merMod 99 Arguments object a ﬁtted model . . . . additional , optional arguments , passed from or to methods . ( None currently in our two methods . ) Details Package lme4 provides methods for mixed - effects models of class merMod and lists of linear models , lmList4 . Value Typically a number , the estimated standard deviation of the errors ( “residual standard deviation” ) for Gaussian models , and - less interpretably - the square root of the residual deviance per degree of freedom in more general models . Examples methods ( sigma ) # from R 3 . 3 . 0 on , shows methods from pkgs ’stats’ * and * ’lme4’ simulate . merMod Simulate Responses From merMod Object Description Simulate responses from a " merMod " ﬁtted model object , i . e . , from the model represented by it . Usage # # S3 method for class ’merMod’ simulate ( object , nsim = 1 , seed = NULL , use . u = FALSE , re . form = NA , ReForm , REForm , REform , newdata = NULL , newparams = NULL , family = NULL , allow . new . levels = FALSE , na . action = na . pass , . . . ) # # S3 method for class ’formula’ simulate ( object , nsim = 1 , seed = NULL , family , weights = NULL , offset = NULL , . . . ) . simulateFun ( object , nsim = 1 , seed = NULL , use . u = FALSE , re . form = NA , ReForm , REForm , REform , newdata = NULL , newparams = NULL , formula = NULL , family = NULL , weights = NULL , offset = NULL , allow . new . levels = FALSE , na . action = na . pass , . . . ) 100 simulate . merMod Arguments object ( for simulate . merMod ) a ﬁtted model object or ( for simulate . formula ) a ( one - sided ) mixed model formula , as described for lmer . nsim positive integer scalar - the number of responses to simulate . seed an optional seed to be used in set . seed immediately before the simulation so as to generate a reproducible sample . use . u ( logical ) if TRUE , generate a simulation conditional on the current random - effects estimates ; if FALSE generate new Normally distributed random - effects values . ( Redundant with re . form , which is preferred : TRUE corresponds to re . form = NULL ( condition on all random effects ) , while FALSE corresponds to re . form = ~ 0 ( condition on none of the random effects ) . ) re . form formula for random effects to condition on . If NULL , condition on all random effects ; if NA or ~ 0 , condition on no random effects . See Details . ReForm , REForm , REform deprecated : re . form is now the preferred argument name . newdata data frame for which to evaluate predictions . newparams new parameters to use in evaluating predictions , speciﬁed as in the start pa - rameter for lmer or glmer – a list with components theta and beta and ( for LMMs or GLMMs that estimate a scale parameter ) sigma formula a ( one - sided ) mixed model formula , as described for lmer . family a GLM family , as in glmer . weights prior weights , as in lmer or glmer . offset offset , as in glmer . allow . new . levels ( logical ) if FALSE ( default ) , then any new levels ( or NA values ) detected in newdata will trigger an error ; if TRUE , then the prediction will use the un - conditional ( population - level ) values for data with previously unobserved levels ( or NA s ) . na . action what to do with NA values in new data : see na . fail . . . optional additional arguments : none are used at present . Details • ordinarily simulate is used to generate new values from an existing , ﬁtted model ( merMod object ) : however , if formula , newdata , and newparams are speciﬁed , simulate generates the appropriate model structure to simulate from . • The re . form argument allows the user to specify how the random effects are incorporated in the simulation . All of the random effects terms included in re . form will be conditioned on - that is , the conditional modes of those random effects will be included in the deterministic part of the simulation . ( If new levels are used ( and allow . new . levels is TRUE ) , the conditional modes for these levels will be set to the population mode , i . e . values of zero will be used for the random effects . ) Conversely , the random effect terms that are not included in re . form will be simulated from - that is , new values will be chosen for each group based on the estimated random - effects variances . sleepstudy 101 The default behaviour ( using re . form = NA ) is to condition on none of the random effects , simulating new values for all of the random effects . • For Gaussian ﬁts , sigma speciﬁes the residual standard deviation ; for Gamma ﬁts , it speciﬁes the shape parameter ( the rate parameter for each observation i is calculated as shape / mean ( i ) ) . For negative binomial ﬁts , the overdispersion parameter is speciﬁed via the family , e . g . simulate ( . . . , family = negative . binomial ( theta = 1 . 5 ) ) . See Also bootMer for “simulestimate” , i . e . , where each simulation is followed by reﬁtting the model . Examples # # test whether fitted models are consistent with the # # observed number of zeros in CBPP data set : gm1 < - glmer ( cbind ( incidence , size - incidence ) ~ period + ( 1 | herd ) , data = cbpp , family = binomial ) gg < - simulate ( gm1 , 1000 ) zeros < - sapply ( gg , function ( x ) sum ( x [ , " incidence " ] = = 0 ) ) plot ( table ( zeros ) ) abline ( v = sum ( cbpp $ incidence = = 0 ) , col = 2 ) # # # # simulate from a non - fitted model ; in this case we are just # # replicating the previous model , but params < - list ( theta = 0 . 5 , beta = c ( 2 , - 1 , - 2 , - 3 ) ) simdat < - with ( cbpp , expand . grid ( herd = levels ( herd ) , period = factor ( 1 : 4 ) ) ) simdat $ size < - 15 simdat $ incidence < - sample ( 0 : 1 , size = nrow ( simdat ) , replace = TRUE ) form < - formula ( gm1 ) [ - 2 ] simulate ( form , newdata = simdat , family = binomial , newparams = params ) sleepstudy Reaction times in a sleep deprivation study Description The average reaction time per day for subjects in a sleep deprivation study . On day 0 the subjects had their normal amount of sleep . Starting that night they were restricted to 3 hours of sleep per night . The observations represent the average reaction time on a series of tests given each day to each subject . Format A data frame with 180 observations on the following 3 variables . Reaction Average reaction time ( ms ) Days Number of days of sleep deprivation Subject Subject number on which the observation was made . 102 subbars Details These data are from the study described in Belenky et al . ( 2003 ) , for the sleep - deprived group and for the ﬁrst 10 days of the study , up to the recovery period . References Gregory Belenky , Nancy J . Wesensten , David R . Thorne , Maria L . Thomas , Helen C . Sing , Daniel P . Redmond , Michael B . Russo and Thomas J . Balkin ( 2003 ) Patterns of performance degradation and restoration during sleep restriction and subsequent recovery : a sleep dose - response study . Journal of Sleep Research 12 , 1 – 12 . Examples str ( sleepstudy ) require ( lattice ) xyplot ( Reaction ~ Days | Subject , sleepstudy , type = c ( " g " , " p " , " r " ) , index = function ( x , y ) coef ( lm ( y ~ x ) ) [ 1 ] , xlab = " Days of sleep deprivation " , ylab = " Average reaction time ( ms ) " , aspect = " xy " ) ( fm1 < - lmer ( Reaction ~ Days + ( Days | Subject ) , sleepstudy ) ) ( fm2 < - lmer ( Reaction ~ Days + ( 1 | Subject ) + ( 0 + Days | Subject ) , sleepstudy ) ) subbars " Sub [ stitute ] Bars " Description Substitute the ’ + ’ function for the ’ | ’ function in a mixed - model formula , recursively ( hence the argument name term ) . This provides a formula suitable for the current model . frame function . Usage subbars ( term ) Arguments term a mixed - model formula Value the formula with all | operators replaced by + See Also formula , model . frame , model . matrix . Other utilities : findbars , nobars , mkRespMod , mkReTrms , nlformula . troubleshooting 103 Examples subbars ( Reaction ~ Days + ( Days | Subject ) ) # # = > Reaction ~ Days + ( Days + Subject ) troubleshooting Troubleshooting Description This page attempts to summarize some of the common problems with ﬁtting [ gn ] lmer models and how to troubleshoot them . • failure to converge in ( xxxx ) evaluations The optimizer hit its maximum limit of function evaluations . To increase this , use the optControl argument of [ g ] lmerControl – for Nelder _ Mead and bobyqa the relevant parameter is maxfun ; for optim and optimx - wrapped optimizers , including nlminbwrap , it’s maxit ; for nloptwrap , it’s maxeval . • Model failed to converge with max | grad | . . . The scaled gradient at the ﬁtted ( RE ) ML estimates is worryingly large . Try – reﬁtting the parameters starting at the current estimates : getting consistent results ( with no warning ) suggests a false positive – switching optimizers : getting consistent results suggests there is not really a problem ; getting a similar log - likelihood with different parameter estimates suggests that the pa - rameters are poorly determined ( possibly the result of a misspeciﬁed or overﬁtted model ) – compute values of the deviance in the neighbourhood of the estimated parameters to double - check that lme4 has really found a local optimum . • Hessian is numerically singular : parameters are not uniquely determined The Hessian ( inverse curvature matrix ) at the maximum likelihood or REML estimates has a very large eigenvalue , indicating that ( within numerical tolerances ) the surface is com - pletely ﬂat in some direction . The model may be misspeciﬁed , or extremely badly scaled ( see " Model is nearly unidentifiable " ) . • Model is nearly unidentifiable . . . Rescale variables ? The Hessian ( inverse curva - ture matrix ) at the maximum likelihood or REML estimates has a large eigenvalue , indicating that the surface is nearly ﬂat in some direction . Consider centering and / or scaling continuous predictor variables . • Contrasts can be applied only to factors with 2 or more levels One or more of the categorical predictors in the model has fewer than two levels . This may be due to user error when converting these predictors to factors prior to modeling , or it may result from some factor levels being eliminated due to NA s in other predictors . Double - check the number of data points in each factor level to see which one is the culprit : lapply ( na . omit ( df [ , vars ] ) , table ) ( where df is the data . frame and vars are the column names of your predictor variables ) . 104 VarCorr VarCorr Extract Variance and Correlation Components Description This function calculates the estimated variances , standard deviations , and correlations between the random - effects terms in a mixed - effects model , of class merMod ( linear , generalized or nonlinear ) . The within - group error variance and standard deviation are also calculated . Usage # # S3 method for class ’merMod’ VarCorr ( x , sigma = 1 , . . . ) # # S3 method for class ’VarCorr . merMod’ as . data . frame ( x , row . names = NULL , optional = FALSE , order = c ( " cov . last " , " lower . tri " ) , . . . ) # # S3 method for class ’VarCorr . merMod’ print ( x , digits = max ( 3 , getOption ( " digits " ) - 2 ) , comp = " Std . Dev . " , formatter = format , . . . ) Arguments x for VarCorr : a ﬁtted model object , usually an object inheriting from class merMod . For as . data . frame , a VarCorr . merMod object returned from VarCorr . sigma an optional numeric value used as a multiplier for the standard deviations . digits an optional integer value specifying the number of digits order arrange data frame with variances / standard deviations ﬁrst and covariances / correlations last for each random effects term ( " cov . last " ) , or in the order of the lower tri - angle of the variance - covariance matrix ( " lower . tri " ) ? row . names , optional Ignored : necessary for the as . data . frame method . . . . Ignored for the as . data . frame method ; passed to other print ( ) methods for the print ( ) method . comp a character vector , specifying the components to be printed ; simply passed to formatVC ( ) . formatter a function for formatting the numbers ; simply passed to formatVC ( ) . Details The print method for VarCorr . merMod objects has optional arguments digits ( specify digits of precision for printing ) and comp : the latter is a character vector with any combination of " Variance " and " Std . Dev . " , to specify whether variances , standard deviations , or both should be printed . varianceProf 105 Value An object of class VarCorr . merMod . The internal structure of the object is a list of matrices , one for each random effects grouping term . For each grouping term , the standard deviations and correlation matrices for each grouping term are stored as attributes " stddev " and " correlation " , respectively , of the variance - covariance matrix , and the residual standard deviation is stored as attribute " sc " ( for glmer ﬁts , this attribute stores the scale parameter of the model ) . The as . data . frame method produces a combined data frame with one row for each variance or covariance parameter ( and a row for the residual error term where applicable ) and the following columns : grp grouping factor var1 ﬁrst variable var2 second variable ( NA for variance parameters ) vcov variances or covariances sdcor standard deviations or correlations Author ( s ) This is modeled after VarCorr from package nlme , by Jose Pinheiro and Douglas Bates . See Also lmer , nlmer Examples data ( Orthodont , package = " nlme " ) fm1 < - lmer ( distance ~ age + ( age | Subject ) , data = Orthodont ) ( vc < - VarCorr ( fm1 ) ) # # default print method : standard dev and corr # # both variance and std . dev . print ( vc , comp = c ( " Variance " , " Std . Dev . " ) , digits = 2 ) # # variance only print ( vc , comp = c ( " Variance " ) ) as . data . frame ( vc ) as . data . frame ( vc , order = " lower . tri " ) varianceProf Transform Proﬁle to the variance scale Description Transform a mixed - effects proﬁle , i . e . conceptually , x < - profile ( lmer ( . . . . ) , . . ) from standard deviation to the variance scale . Usage varianceProf ( x , ranef = TRUE ) 106 vcconv Arguments x a mixed - effects model proﬁle . ranef logical indicating if all sigmas should be transformed , see logProf . Value a transformed mixed - effects model proﬁle See Also profile and methods , notably , logProf for log transformation of the sigmas ; also for nice exam - ples including graphics . vcconv Convert between representations of ( co - ) variance structures Description Convert between representations of ( co - ) variance structures ( EXPERIMENTAL ) . See source code for details . Usage mlist2vec ( L ) vec2mlist ( v , n = NULL , symm = TRUE ) vec2STlist ( v , n = NULL ) sdcor2cov ( m ) cov2sdcor ( V ) Vv _ to _ Cv ( v , n = NULL , s = 1 ) Sv _ to _ Cv ( v , n = NULL , s = 1 ) Cv _ to _ Vv ( v , n = NULL , s = 1 ) Cv _ to _ Sv ( v , n = NULL , s = 1 ) Arguments L List of symmetric , upper - triangular , or lower - triangular square matrices . v Concatenated vector containing the elements of the lower - triangle ( including the diagonal ) of a symmetric or triangular matrix . n Number of rows ( and columns ) of the resulting matrix . symm Return symmetric matrix if TRUE or lower - triangular if FALSE . m Standard deviation - correlation matrix . V Covariance matrix . s Scale parameter . VerbAgg 107 Details • mlist2vec Convert list of matrices to concatenated vector of lower triangles with an attribute that gives the dimension of each matrix in the original list . This attribute may be used to reconstruct the matrices . Returns a concatenation of the elements in one triangle of each matrix . An attribute " clen " gives the dimension of each matrix . • vec2mlist Convert concatenated vector to list of matrices ( lower triangle or symmetric ) . These matrices could represent Cholesky factors , covariance matrices , or correlation matrices ( with standard deviations on the diagonal ) . • vec2STlist Convert concatenated vector to list of ST matrices . • sdcor2cov Standard deviation - correlation matrix to covariance matrix convert ’sdcor’ format ( std dev on diagonal , cor on off - diag ) to and from variance - covariance matrix . • cov2sdcor Covariance matrix to standard deviation - correlation matrix ( i . e . standard devia - tions on the diagonal and correlations off the diagonal ) . • Vv _ to _ Cv Variance - covariance to relative covariance factor . Returns a vector of elements from the lower triangle of a relative covariance factor . • Sv _ to _ Cv Standard - deviation - correlation to relative covariance factor . Returns a vector of el - ements from the lower triangle of a relative covariance factor . • Cv _ to _ Vv Relative covariance factor to variance - covariance . From unscaled Cholesky vector to ( possibly scaled ) variance - covariance vector . Returns a vector of elements from the lower triangle of a variance - covariance matrix . • Cv _ to _ Sv Relative covariance factor to standard - deviation - correlation . From unscaled Chol to sd - cor vector . Returns a vector of elements from the lower triangle of a standard - deviation - correlation matrix . Value ( Co - ) variance structure Examples vec2mlist ( 1 : 6 ) mlist2vec ( vec2mlist ( 1 : 6 ) ) # approximate inverse VerbAgg Verbal Aggression item responses Description These are the item responses to a questionaire on verbal aggression . These data are used throughout De Boeck and Wilson , Explanatory Item Response Models ( Springer , 2004 ) to illustrate various forms of item response models . 108 VerbAgg Format A data frame with 7584 observations on the following 13 variables . Anger the subject’s Trait Anger score as measured on the State - Trait Anger Expression Inventory ( STAXI ) Gender the subject’s gender - a factor with levels M and F item the item on the questionaire , as a factor resp the subject’s response to the item - an ordered factor with levels no < perhaps < yes id the subject identiﬁer , as a factor btype behavior type - a factor with levels curse , scold and shout situ situation type - a factor with levels other and self indicating other - to - blame and self - to - blame mode behavior mode - a factor with levels want and do r2 dichotomous version of the response - a factor with levels N and Y Source http : / / bear . soe . berkeley . edu / EIRM / References De Boeck and Wilson ( 2004 ) , Explanatory Item Response Models , Springer . Examples str ( VerbAgg ) # # Show how r2 : = h ( resp ) is defined : with ( VerbAgg , stopifnot ( identical ( r2 , { r < - factor ( resp , ordered = FALSE ) ; levels ( r ) < - c ( " N " , " Y " , " Y " ) ; r } ) ) ) xtabs ( ~ item + resp , VerbAgg ) xtabs ( ~ btype + resp , VerbAgg ) round ( 100 * ftable ( prop . table ( xtabs ( ~ situ + mode + resp , VerbAgg ) , 1 : 2 ) , 1 ) ) person < - unique ( subset ( VerbAgg , select = c ( id , Gender , Anger ) ) ) require ( lattice ) densityplot ( ~ Anger , person , groups = Gender , auto . key = list ( columns = 2 ) , xlab = " Trait Anger score ( STAXI ) " ) if ( lme4 : : : testLevel ( ) > = 3 ) { # # takes about 15 sec print ( fmVA < - glmer ( r2 ~ ( Anger + Gender + btype + situ ) ^ 2 + ( 1 | id ) + ( 1 | item ) , family = binomial , data = VerbAgg ) , corr = FALSE ) } # # much faster but less accurate print ( fmVA0 < - glmer ( r2 ~ ( Anger + Gender + btype + situ ) ^ 2 + ( 1 | id ) + ( 1 | item ) , family = binomial , data = VerbAgg , nAGQ = 0L ) , corr = FALSE ) Index ∗ Topic classes glmFamily , 33 glmFamily - class , 33 golden - class , 34 lmList4 - class , 50 lmResp , 51 lmResp - class , 52 merMod - class , 53 merPredD , 57 merPredD - class , 58 NelderMead , 67 NelderMead - class , 69 rePos , 96 rePos - class , 97 ∗ Topic datasets Arabidopsis , 5 cake , 9 cbpp , 10 Dyestuff , 18 grouseticks , 36 InstEval , 38 Pastes , 77 Penicillin , 78 sleepstudy , 101 VerbAgg , 107 ∗ Topic htest bootMer , 6 ∗ Topic methods profile - methods , 85 ranef , 92 ∗ Topic misc drop1 . merMod , 16 ∗ Topic models bootMer , 6 expandDoubleVerts , 19 factorize , 20 findbars , 21 fixef , 22 glmer , 28 glmer . nb , 31 lmer , 40 lmList , 48 mkdevfun , 59 modular , 63 nlmer , 72 nobars , 76 ranef , 92 subbars , 102 VarCorr , 104 ∗ Topic utilities expandDoubleVerts , 19 factorize , 20 findbars , 21 getME , 23 glmerLaplaceHandle , 32 mkReTrms , 61 nobars , 76 prt - utilities , 88 subbars , 102 . makeCC ( lmerControl ) , 43 . prt . VC ( prt - utilities ) , 88 . prt . aictab ( prt - utilities ) , 88 . prt . call ( prt - utilities ) , 88 . prt . family ( prt - utilities ) , 88 . prt . grps ( prt - utilities ) , 88 . prt . methTit ( prt - utilities ) , 88 . prt . resids ( prt - utilities ) , 88 . prt . warn ( prt - utilities ) , 88 . simulateFun ( simulate . merMod ) , 99 abs , 83 AIC , 90 anova , 55 , 96 anova . merMod ( merMod - class ) , 53 Arabidopsis , 5 as , 50 as . data . frame , 87 as . data . frame . thpr ( profile - methods ) , 85 109 110 INDEX as . data . frame . VarCorr . merMod ( VarCorr ) , 104 as . formula , 42 as . function . merMod ( merMod - class ) , 53 BIC , 90 bobyqa , 45 , 46 , 65 boot , 7 boot . ci , 7 , 12 bootMer , 4 , 6 , 12 , 85 , 87 , 92 , 101 cake , 9 call , 90 cat , 89 cbpp , 10 character , 11 , 89 , 104 class , 7 , 49 , 89 coef , 50 coef . merMod ( merMod - class ) , 53 confint , 50 , 87 confint . merMod , 7 , 11 , 92 convergence , 13 , 47 cov2sdcor ( vcconv ) , 106 Cv _ to _ Sv ( vcconv ) , 106 Cv _ to _ Vv ( vcconv ) , 106 data . frame , 87 densityplot , 83 densityplot . thpr ( plots . thpr ) , 82 deriv , 72 devcomp , 15 deviance . merMod ( merMod - class ) , 53 df . residual , 90 df . residual . merMod ( merMod - class ) , 53 dgCMatrix , 24 dotplot , 93 dotplot . ranef . mer ( ranef ) , 92 drop1 , 16 , 42 , 72 drop1 . merMod , 16 , 57 dummy , 18 , 20 , 41 Dyestuff , 18 Dyestuff2 ( Dyestuff ) , 18 environment , 66 envRefClass , 33 , 34 , 52 , 58 , 70 , 97 expandDoubleVerts , 19 extractAIC , 54 extractAIC . merMod ( merMod - class ) , 53 factor , 18 , 70 , 71 factorize , 20 family , 28 , 33 , 34 , 51 , 55 , 65 , 89 family . merMod ( merMod - class ) , 53 findbars , 21 , 61 , 62 , 72 , 76 , 102 fitted , 50 fitted . merMod ( merMod - class ) , 53 fixed . effects ( fixef ) , 22 fixef , 22 , 24 , 26 , 50 formatVC , 104 formatVC ( prt - utilities ) , 88 formula , 20 , 21 , 49 , 50 , 76 , 102 formula . merMod ( merMod - class ) , 53 fortify , 23 fortify . merMod , 57 function , 59 , 68 , 84 , 90 , 104 getCall , 26 , 90 getL ( getME ) , 23 getL , merMod - method ( getME ) , 23 getME , 16 , 23 , 31 , 54 – 57 , 62 getOption , 73 GHrule , 27 , 35 glFormula ( modular ) , 63 glm , 28 – 30 , 33 , 42 , 65 , 66 glmer , 3 , 4 , 6 , 7 , 24 , 26 , 28 , 31 , 32 , 42 , 52 , 54 , 55 , 57 – 59 , 70 , 84 , 100 glmer . nb , 26 , 30 , 31 glmerControl , 26 , 28 , 31 , 41 , 73 glmerControl ( lmerControl ) , 43 glmerLaplaceHandle , 32 glmerMod - class ( merMod - class ) , 53 glmFamily , 33 , 33 , 34 glmFamily - class , 33 glmResp , 51 , 53 , 57 , 65 glmResp ( lmResp ) , 51 glmResp - class ( lmResp - class ) , 52 golden ( golden - class ) , 34 golden - class , 34 GQdk , 27 , 35 , 35 GQN ( GQdk ) , 35 grouseticks , 36 grouseticks _ agg ( grouseticks ) , 36 hatvalues . merMod , 37 InstEval , 38 isGLMM ( isREML ) , 39 isGLMM . merMod , 57 isLMM ( isREML ) , 39 INDEX 111 isLMM . merMod , 57 isNested , 39 isNLMM ( isREML ) , 39 isNLMM . merMod , 57 isREML , 25 , 39 , 54 isREML . merMod , 57 lFormula ( modular ) , 63 library , 45 list , 24 – 26 , 31 , 35 , 41 , 46 , 47 , 50 , 60 , 61 , 65 , 68 , 69 , 73 , 86 , 89 , 90 llikAIC ( prt - utilities ) , 88 lm , 42 , 48 , 50 lme4 ( lme4 - package ) , 3 lme4 - package , 3 lmer , 3 , 6 , 7 , 24 , 29 , 30 , 40 , 52 , 54 , 55 , 57 – 59 , 62 , 65 , 70 – 72 , 83 – 86 , 100 , 105 lmerControl , 14 , 28 , 41 , 43 , 59 , 60 , 65 , 66 , 73 , 86 lmerMod , 94 , 96 lmerMod - class ( merMod - class ) , 53 lmerResp , 51 , 53 , 57 , 59 , 65 lmerResp ( lmResp ) , 51 lmerResp - class ( lmResp - class ) , 52 lmList , 48 , 50 lmList4 , 49 , 99 lmList4 - class , 50 lmResp , 32 , 51 , 51 , 53 lmResp - class , 52 log , 87 log . thpr ( profile - methods ) , 85 logical , 31 , 89 logLik , 50 , 56 , 90 logLik . merMod ( merMod - class ) , 53 logProf , 106 logProf ( profile - methods ) , 85 matrix , 12 , 63 , 72 mcmcsamp ( pvalues ) , 91 merMod , 4 , 11 , 15 , 23 , 24 , 30 , 37 , 40 , 42 , 52 , 54 , 56 , 58 – 60 , 71 , 84 , 92 , 97 , 99 , 104 merMod ( merMod - class ) , 53 merMod - class , 53 merPredD , 32 , 53 , 57 , 57 , 58 , 59 merPredD - class , 58 methods , 49 , 50 methTitle ( prt - utilities ) , 88 mkDataTemplate ( mkSimulateTemplate ) , 62 mkdevfun , 59 mkGlmerDevfun ( modular ) , 63 mkLmerDevfun , 65 mkLmerDevfun ( modular ) , 63 mkMerMod , 60 , 66 mkParsTemplate ( mkSimulateTemplate ) , 62 mkRespMod , 20 , 21 , 60 , 62 , 72 , 76 , 102 mkReTrms , 20 , 21 , 60 , 61 , 61 , 65 , 66 , 72 , 76 , 102 mkSimulateTemplate , 62 mkVarCorr , 63 mlist2vec ( vcconv ) , 106 model . frame , 20 , 21 , 60 , 76 , 102 model . frame . merMod ( merMod - class ) , 53 model . matrix , 18 , 20 , 21 , 76 , 102 model . matrix . default , 29 , 65 , 73 model . matrix . merMod ( merMod - class ) , 53 model . offset , 29 , 42 , 49 , 65 , 73 modular , 4 , 28 , 45 , 63 , 65 na . fail , 100 na . pass , 84 name , 26 negative . binomial , 32 negative . binomial ( glmer . nb ) , 31 Nelder _ Mead , 45 , 46 , 65 , 70 Nelder _ Mead ( NelderMead ) , 67 NelderMead , 67 , 69 NelderMead ( NelderMead - class ) , 69 NelderMead - class , 69 new , 34 , 70 ngrps , 56 , 70 , 90 ngrps . merMod ( merMod - class ) , 53 nlformula , 20 , 21 , 61 , 62 , 71 , 76 , 102 nlmer , 3 , 24 , 30 , 42 , 52 , 55 , 57 – 59 , 70 , 71 , 72 , 105 nlmerControl ( lmerControl ) , 43 nlmerMod - class ( merMod - class ) , 53 nlminb , 45 , 65 , 75 nlminbwrap ( nloptwrap ) , 74 nloptwrap , 74 nlsResp , 51 , 53 , 57 , 72 nlsResp ( lmResp ) , 51 nlsResp - class ( lmResp - class ) , 52 nobars , 20 , 21 , 61 , 62 , 72 , 76 , 102 nobs , 90 nobs ( merMod - class ) , 53 numeric , 89 offset , 29 , 41 , 49 , 64 , 73 112 INDEX optim , 45 , 47 , 65 , 67 optimize , 31 optimizeGlmer ( modular ) , 63 optimizeLmer ( modular ) , 63 options , 47 pairs , 50 Pastes , 77 PBmodcomp , 7 Penicillin , 78 plot , 50 plot . lmList , 80 plot . lmList ( lmList ) , 48 plot . lmList4 , 79 plot . merMod , 57 , 80 plots . thpr , 82 pnbinom , 32 predict , 50 , 84 predict . merMod , 55 , 57 , 84 print , 50 , 83 , 88 , 89 , 104 print . merMod ( merMod - class ) , 53 print . summary . merMod ( merMod - class ) , 53 print . VarCorr . merMod ( VarCorr ) , 104 profile , 11 , 12 , 83 , 85 , 87 , 105 , 106 profile ( . ) , 12 profile - methods , 85 profile . merMod , 12 , 57 , 92 profile . merMod ( profile - methods ) , 85 prt - utilities , 88 pvalues , 4 , 7 , 91 qqmath , 93 qqmath . merMod ( plot . merMod ) , 80 qqmath . ranef . mer ( ranef ) , 92 qqnorm , 50 ranef , 26 , 50 , 92 ranef . merMod , 57 rankMatrix , 46 ReferenceClasses , 4 , 66 refit , 7 , 31 , 94 , 96 refit . merMod , 57 refitML , 95 , 96 refitML . merMod , 57 reformulate , 42 REMLcrit ( merMod - class ) , 53 rePos , 96 , 96 , 97 rePos - class , 97 require , 45 residuals , 50 , 89 residuals . glm , 98 residuals . glmResp ( residuals . merMod ) , 97 residuals . lm , 98 residuals . lme , 98 residuals . lmResp ( residuals . merMod ) , 97 residuals . merMod , 57 , 97 rnorm , 7 , 62 scale , 14 sdcor2cov ( vcconv ) , 106 selfStart , 72 set . seed , 6 , 100 show , 50 , 89 show , lmList4 - method ( lmList4 - class ) , 50 show , merMod - method ( merMod - class ) , 53 show . merMod ( merMod - class ) , 53 show . summary . merMod ( merMod - class ) , 53 sigma , 41 , 50 , 55 , 98 sigma . merMod , 57 simulate , 95 simulate . formula ( simulate . merMod ) , 99 simulate . merMod , 6 , 7 , 57 , 62 , 99 sleepstudy , 101 splom , 83 splom . thpr ( plots . thpr ) , 82 SSbiexp , 72 SSlogis , 72 stop , 68 subbars , 20 , 21 , 61 , 62 , 72 , 76 , 102 summary , 50 , 56 , 88 summary . merMod , 57 summary . merMod ( merMod - class ) , 53 summary . summary . merMod ( merMod - class ) , 53 Sv _ to _ Cv ( vcconv ) , 106 symnum , 55 terms , 84 terms . merMod ( merMod - class ) , 53 theta . ml , 31 , 32 troubleshooting , 103 update , 42 , 50 , 55 , 56 , 72 , 94 update . formula , 55 update . merMod , 95 , 96 update . merMod ( merMod - class ) , 53 updateGlmerDevfun ( modular ) , 63 VarCorr , 63 , 89 , 90 , 104 , 105 INDEX 113 varianceProf , 86 , 87 , 105 vcconv , 106 vcov , 26 , 56 vcov . merMod ( merMod - class ) , 53 vcov . summary . merMod ( merMod - class ) , 53 vec2mlist ( vcconv ) , 106 vec2STlist ( vcconv ) , 106 VerbAgg , 107 Vv _ to _ Cv ( vcconv ) , 106 warning , 68 weights . merMod ( merMod - class ) , 53 xyplot , 83 , 87 xyplot . thpr ( plots . thpr ) , 82