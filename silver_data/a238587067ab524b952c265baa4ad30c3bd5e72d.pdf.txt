ARTIFICIAL INTELLIGENCE 41 Toward a Model of Representation Changes Richard E . Korf Department of Computer Science , Carnegie - Mellon University , Pittsburgh , PA 15213 , U . S . A . Recommended by Allen Newell ABSTRACT This paper presents the first steps in the development of a computer model of the process of changing representations in problem solving . The task of discovering representations that yield efficient solution strategies for problems is viewed as heuristic search in the space of representations . Two dimensions of this representation space are information structure and information quantity . Changes of representation are characterized as isomorphisms and homomorphisms , corresponding to changes of information structure and information quantity , respectively . A language for expressing representations is given . Also , a language for describing representation transformations and an interpreter for applying the trans - formations to representations has been developed . In addition , transformations can be automatically inverted and composed to generate new transformations . Among the example problems used to illustrate and support this model are tic - tac - toe , integer arithmetic , the Tower of Hanoi problem , the arrow puzzle , the five puzzle , the mutilated checkerboard problem , and floor plan design . The system has also been used to generate some new NP - complete problems . 1 . Introduction and Overview It is a well - known artifact of problem solving that a change in the representation of a problem often renders the problem much easier to solve . The ease of solution of a problem is relative to a particular problem solver and can depend on several factors . Two such factors are the costs of the primitive operations in the problem space and whether the problem solver has previously dealt with the problem at hand or similar problems . Our attention is not focused on domain - independent representations of know - ledge , such as predicate calculus or production systems , but rather on highly The research reported in this paper was supported by the Advanced Research Projects Agency of the Department of Defense under contract No . F44620 - 73 - C - 0074 , and by the Division of Mathematical and Computer Sciences of the National Science Foundation under grant No . MCS - 76 - 83890 . The views and conclusions contained in this document are those of the author and should not be interpreted as representing the official policies , either expressed or implied , of the Defense Research Projects Agency or the U . S . Government . Artificial Intelligence 14 ( 1980 ) , 41 78 Copyright Â© 1980 by North - Holland Publishing Company 42 R . E . KORF domain specific representations , such as the different formulations of tic - tac - toe . Among the motivations for this focus is that the well - known power vs . generality tradeoff 1 forces an expert problem solver to construct very specific representa - tions for problems . The global model being explored is that of heuristic search in a space of problem representations . If we view each alternative representation of a problem as a point , the collection of all such points forms the space of possible representations of a problem . The questions we set out to answer are : ( 1 ) How can one characterize the space of possible representations ? ( 2 ) How can one characterize the operators of this space ( changes of representation ) ? ( 3 ) How can one evaluate different repre - sentations with respect to problem solving efficiency ? and ( 4 ) How can one effectively search the space of representations to find efficient representations for problems ? Given the answers to these questions , we could write a computer program which when confronted by a problem in a given representation , could discover alternative representations in which the problem may be easier to solve . This paper primarily addresses the first two questions . The body of the paper is composed of two main sections . Section 2 consists of a collection of examples of problem solving by change of representation . These examples provide the data on which our model is based and suggest two proposi - tions : The first is that changing of representations is a very powerful problem solving strategy and that much problem solving can be viewed as changing representations . The second is that even drastic representation changes can be decomposed into a series of relatively minor representation shifts of two types : isomorphisms and homomorphisms . Section 3 deals with a preliminary computer model of representation changes . A space of representations is presented in the form of a language for expressing representations . A language for describing the operators or transformations of representation has been developed , along with an interpreter for implementing the transformations . In most cases , primitive transformations can be automatically inverted and composed to yield new and more powerful transformations . In addi - tion to using the system to implement several of the examples in Section 2 , it is used to generate several new NP - complete problems by changing the representations of known NP - complete problems . 1 . 1 . Previous work The representation problem was addressed by Newell 2 in 1965 . Newell used the mutilated checkerboard problem to illustrate his point that the greatest " limitation of the current stock of ideas about problem solving " is that " we do not yet have any useful representations of possible representations " . Most of the work on this problem was centered around a 1966 seminar at Carnegie - Mellon University which included Saul Amarel , Steven Coles , Richard Fikes , Allen Newell , Laurent Sik - TOWARD A MODEL OF REPRESENTATION CHANGES 43 lossy and Herbert Simon . Newell 3 collected " some examples of problems with several problem spaces " including numerical and symbolic representations of algebraic equations , formal , diagrammatic , and analytic representations of geometry , and descriptive and model representations of the monkey and bananas problem . In another report , Newell 4 describes several more examples . One of those examples is due to Amarel 5 and consists of three different representations for proving theorems in propositional calculus . Perhaps the best example of changes of representation is in 6 on the missionaries and cannibals problem . Amarel analyzes the problem by performing a series of about nine different changes of representation to arrive at a problem space where the solution is trivial . He also comments on the possible mechanization of these transformations . The canonical examples of changes of representation are probably the different formulations of tic - tac - toe presented by Simon 7 . In a later paper , Simon 8 suggests that representation changes are closely coupled to the discovery of " hereditary properties " , that is , properties of problem states that remain invariant under certain problem operations . In The Sciences of the Artificial , Simon 9 discusses representation in the context of design . He suggests that all of problem solving may be viewed as changes of representation ; that solving a problem can be seen as representing it so that the solution becomes transparent . He also pro - poses the development of a taxonomy of representations as a first step toward a theory of representation . More recent work has been conducted by Banerji , Ernst , and their colleagues at Temple University and at Case Western Reserve University . One of the aims of their work has been to characterize the domain of applicability for certain powerful problem solving and game playing strategies 10 . In 11 they consider two such methods , the use of Grundy functions and Koffman ' s 12 method for positional games . They exhibit a class of games that are homomorphic to these types of games , in the sense that their representatioris can be transformed to fit these methods . Goldstein 13 demonstrates how the important parameters for some problem solving strategies , such as the difference tables for GPS , can be automatically generated from problem statements . In the area of applications of representation changes , Brown 14 uses representa - tion transformations of geometry problems to obtain computationally fast geo - metric algorithms . 1 . 2 . Information content , structure , and quantity One of the themes of this paper is that two dimensions of the space of representa - tions are information structure and information quantity ; and that changes of rep - resentation can be usefully characterized as isomorphisms and homomorphisms , corresponding to transformations along the structure and quantity dimensions , respectively . At this point , we will attempt to provide the reader with an informal 44 R . E . KORF and intuitive understanding of these concepts and defer the formal treatment of these notions to Section 3 . 1 , where we define a language for expressing repre - sentations . Consider a universe consisting of the primitive elements { A B C D } . Let Set4 be the representation ( i . e . language ) which consists of all sets chosen from this universe . Any particular set would be a statement in this language . Let Char4 be the representation which is the collection of characteristic functions of such sets , in other words , functions from the universe { A B C D } to the universe { 0 1 } . For example , the characteristic function of the set { A C } is { A ~ 1 , B ~ 0 , C - - - , 1 , D - - * 0 } . Let Set2 be the representation which contains all sets chosen from the universe { X Y } . We say that the information structure of a statement from either Set4 or Set2 is a set chosen from a universe whereas the information structure of a statement from Char4 is a function from one universe to another . We say that the information quantity of both Set4 and Char4 is 4 bits since there are 16 different statements in each representation , whereas the information quantity of Set2 is 2 bits since there are 4 different statements . Set4 and Char4 are isomorphic because there exists a bijective mapping ( i . e . isomorphism ) between the two representations , namely the canonical mapping between a set and its characteristic function . Set4 and Set2 are homomorphic because they have the same structure and there exists a many - to - one mapping ( i . e . homomorphism ) between them ( e . g . A - - * X , B - - * X , C - - * Y , D ~ Y ) . If there were further structure on these representations , for example a binary operation R , any isomorphism or homomorphism T must have the property that T ( i R j ) = T ( i ) T ( R ) TO ) where T ( R ) is the isomorphic or homomorphic image of the operation R . Note that , in general , isomorphic transformations change the information struc - ture of a representation while leaving the information quantity fixed . Similarly , homomorphic transformations , as defined here , alter the information quantity while leaving the information structure unchanged . Thus , isomorphisms traverse the information structure dimension of the space of representations whereas homomorphisms move along the information quantity dimension . The entire representation space of a problem can probably be usefully charac - terized along many dimensions . What we are presenting is a projection of that space onto two orthogonal dimensions , information quantity and information structure . Each point of the space is a representation . A change of representation is a link between two points . Problem solving by change of representation is a search through this space from the initial representation of the problem to a representa - tion in which it is easy to find the solution . The result of a successful search is a path through the space or a series of changes of representation . TOWARD A MODEL OF REPRESENTATION CHANGES 45 2 . Problem Solving by Changes of Representation What follows is a discussion of examples which serve to illustrate and support the model . First , alternative formulations of tic - tac - toe and integer arithmetic are presented as examples of purely isomorphic changes of representation . The re - cursive strategy for solving the Tower of Hanoi problem is then discussed as an example of purely homomorphic changes of representation . Both isomorphic and homomorphic transformations are combined in the analyses of the arrow puzzle , the five puzzle , and the mutilated checkerboard problem . Finally , floor plan design is discussed as an example of a real problem that fits the model . 2 . 1 . Tic - tac - toe isomorphs As our first example , we examine a problem domain and several purely isomorphic or structural changes of representation associated with it . Consider the following two person game , which Simon 7 calls number scrabble : a set of cards numbered one through nine are placed face up between the players . Each player alternately selects a card . The first person to get three cards in his hand that sum to fifteen wins . If the cards are exhausted and neither player has won , the game ends in a draw . Many readers will be familiar with this example and recognize that it is iso - morphic to tic - tac - toe . The change of representation is accomplished by means of the three by three magic square in Fig . 2 . 1 . Every row , column , and diagonal sums G H o E F A 4 9 2 B 3 5 7 C 8 1 6 FIc . 2 . 1 . 3 Ã 3 magic square 4 . to fifteen and furthermore , every sum of three numbers equal to fifteen is a row , column , or diagonal . This change of representation is purely an isomorphic trans - formation . No information is added or deleted ; its form is simply changed from a set structure to a matrix structure . Michon has developed another isomorph of tic - tac - toe , called Jam 7 . Let each row , column , and diagonal be represented by a node of a graph . Let a square be represented by a link or set of contiguous links joining the row , column , and possibly diagonals that the square lies on . The middle side squares are represented 46 R . E . KORF ( 8 I 3 2 FIG . 2 . 2 . Jam graph 7 . by a single link between the row and column they lie on ; the corner squares by two links joining the row , column and diagonal they are part of ; and the center square by the three links joining the middle row and column and both diagonals . One possible such graph is shown in Fig . 2 . 2 . Play proceeds by players alternately capturing a ' road ' or set of contiguous links . The winner is the first player to ' jam ' a ' town ' by capturing all roads that enter that node . Again , note that no informa - tion has been added or deleted in this representation ; a purely isomorphic trans - formation has been made . The structure of the game was changed from a matrix game to a graph game . 2 . 2 . Integer arithmetic Another example of isomorphic changes of representation occurs in the domain of integer arithmetic . We can do addition and multiplication using either a symbol , string , or multiset representation for the numbers . This example clearly points out the tradeoff between efficiency in the computations and space economy in the representations . The representation using the least space is to use a different atomic symbol for each number ( base infinity notation ) . However , the obvious addition or multi - plication algorithm in this notation requires a lookup in a very large two dimen - sional table . An intermediate representation is the familiar radix number notation ( e . g . base ten ) . In this case a number is represented by a string of symbols where each symbol is a coefficient of a particular power of the radix . Addition is performed by adding corresponding coefficients using table lookup in a ten by ten table , plus a TOWARD A MODEL OF REPRESENTATION CHANGES 47 carry rule . The corresponding string representation for multiplication is the pro - duct of prime powers decomposition . Each symbol of the string represents the exponent of a particular prime . For example : 48 = 31 â¢ 24 = ' 14 ' . Multiplication in this notation is accomplished by adding corresponding exponents without carries . The representation using the most space is base one , unary , or the multiset notation . However , addition in this representation is very efficient . It consists of multiset union or concatenation . The multiset representation for multiplication is the prime decomposition , with each prime listed as many times as it occurs . Multiplication in this notation is also multiset union or simple concatenation . Note that each representation contains the same information and hence they are all isomorphic . However , the different representations ( the atomic symbol , and the two forms of string and multiset notations ) make a big difference in the efficiency of addition and multiplication . 2 . 3 . Tower of Hanoi problem Both of the previous examples involved only isomorphic or structural changes of representation . We now consider an example of a problem which , with the excep - tion of the first transformation , yields to purely homomorphic changes of repre - sentation which preserve the same structure . The familiar Tower of Hanoi problem 15 involves three vertical pegs and a number of doughnut shaped disks , all of different sizes . In the initial state , all the disks are stacked on one peg in decreasing order of size . The goal is to stack the pegs in the same order on one of the other pegs . The only legal move is to move the single top disk on a peg to another peg subject to the constraint that a larger disk may never be placed on top of a smaller disk . Our goal in this example is not to solve a particular instance of the problem but to discover a representation that will allow us to easily solve any instance of the problem with any number of disks . The first change of representation in our analysis is an abstraction from the physi - cal structure of disks and pegs to a state space graph , shown in Fig . 2 . 3 for the three disk problem . In this common problem solving representation a node repre - sents a state or legal configuration of the elements of the problem . An edge represents a legal operation which changes one state into another . In this example , all the operations are invertible and hence the edges in the graph are undirected . The graph in Fig . 2 . 3 actually is the result of two representation changes . The first is from the physical problem to the abstract graph and the second is from the abstract graph to the clear , symmetric , geometric embedding of the graph in the plane 16 . Since the three corner nodes represent the states where all the disks are stacked on one of the three pegs , we can easily solve the problem from this form of the graph by following one of the sides of the triangle . However , we will 48 R . E . KORF J L @ _ _ : I s ~ d - - Â© e - - - Â© d - - o d - - b FIG . 2 . 3 . Tower of Hanoi state space graph with moves of smallest disk dotted 16 . pursue a different approach and the geometric form of the graph is presented only for clarity . Note that there are three different kinds of edges in the graph , each correspond - ing to moving one of the three disks . In Fig . 2 . 3 the edges corresponding to move - ments of the smallest disk have been dotted . Note that they fall into disjoint cycles of length three . We can define the equivalence relation : " two states are equivalent if and only if they are the same state or they are separated by one move of the smallest disk " . This relation partitions the nodes into disjoint equivalence classes which correspond to the dotted triangles in Fig . 2 . 3 . If we now ignore edges within the triangles and consider only edges between equivalence classes the result is the graph in Fig . 2 . 4 , where the nodes are now equivalence classes of states . This new graph is homomorphic to the original graph . Graphically , the process can be viewed as shrinking the triangles down to single points . The edges within the tri - angles then disappear and only the edges between them remain . Semantically , the process corresponds to ignoring the smallest disk . In fact , the graph in Fig . 2 . 4 is the state space graph for the two disk Tower of Hanoi problem . What we have constructed is a higher level or more abstract search space . The higher level space contains less information than the original because the detail of the movement of the smallest disk is ignored . To solve the Tower of Hanoi prob - lem more efficiently we could search the higher level space for a solution , then work out the motion of the smallest disk in the lower level space . Since the new graph corresponds to the two disk problem , we can construct a still higher level space by exactly the same method , this time marking and collapsing the motions of the second disk . The resulting graph is a simple triangle and shows the motion of the largest disk . The strategy which is implied by these homomorphic or abstract prob - 49 FIG . 2 . 4 . Reduced state space graph . TOWARD A MODEL OF REPRESENTATION CHANGES lem spaces is as follows : The highest level goal is the solution to the most abstract problem , namely the movement of the largest disk from the initial peg to the goal peg . This generates two subproblems : getting from the initial state to the state from which the largest disk can be moved , and getting from the state resulting from the movement of the largest disk to the goal state . These subproblems are solved in the next most abstract space , that involving the motion of the second largest disk . It is an artifact of the Tower of Hanoi problem that each of the homo - morphic problem spaces are identical in form and hence an efficient solution strategy can be expressed recursively . 2 . 4 . Arrow puzzle In the first two examples we looked at isomorphic changes of representation . In the last example we looked at homomorphic transformations . In the next three examples we will examine combinations of these two types of representation changes . Consider the following problem , illustrated in Fig . 2 . 5 , which is presented and analyzed by Wickelgren 17 . There are five arrows , each of which can point up or down . There are four operators , A , B , C and D , each of which apply to the two arrows diagonally above it . The effect of an operator is to invert both of the arrows it applies to . The problem is to find a sequence of operators that converts one configuration of arrows into another . Again , our concern is not in solving a par - ticular instance of the problem , but rather in discovering an efficient algorithm to solve the general case . The given representation for a state in the problem is that shown in Fig . 2 . 5 . We 50 puzzle configuration operator application FIG . 2 . 5 . Arrow puzzle . R . E . KORF could also uniquely represent a state by giving the initial state plus the sequence of operators that was applied to it to reach the current state . The obvious representa - tion for the operator sequence is a character string over the alphabet { A , B , C , D } . This change of representation is an isomorphic or structural change since it con - tains the same information as the given representation . The first fact we notice is that the operators commute . Two non - adjacent opera - tors certainly commute . The effect of applying two adjacent operators is to leave their common arrow unchanged by flipping it twice , and inverting the other two arrows , regardless of the order in which the operators are applied . Since the order makes no difference , we define the following equivalence relation : " two operator sequences are equivalent if and only if they are permutations of each other " . This defines a homomorphic state space whose elements are the disjoint equivalence classes of the relation . This homomorphic transformation is followed by an iso - morphic transformation which represents equivalence classes of the permutation relation by multisets of the form { Ai , BJ , Ck , D ~ } . Note that these two changes of representation are closely coupled but can be viewed as distinct transformations . The next fact about the problem is that applying any operator twice leaves the state unchanged . In general , applying operator Xn times is equivalent to doing nothing if n is even . This motivates the following equivalence relation : " two multi - sets are equivalent if and only if the parities of corresponding operators are equal " . The equivalence classes of this homomorphic transformation are isomorphic to bit strings of length four , indicating the parity of each of the four operators . These bit strings in turn are isomorphic to subsets of { A , B , C , D } . In this case we have a homomorphic change followed by two isomorphic changes of representation . From this subset representation , the final transformation is motivated by notic - ing that the operators can be chosen independently if they are considered left to right ( or right to left ) . The new representation is a left to right ordered sequence of operators chosen from the set { A , B , C , D } . Since each such sequence corresponds to a unique subset and each subset translates to a unique ordered sequence , this is an isomorphic change of representation . The associated algorithm , which is a procedural representation of the solution , is to examine the operators left to right and apply an operator if the arrow on its left must be flipped . Note that the orientation of the rightmost arrow is determined and hence only half of the possible configurations can be reached from any one state . TOWARD A MODEL OF REPRESENTATION CHANGES 51 2 . 5 . Five puzzle Our next example deals with the five puzzle , a smaller version of the familiar eight puzzle 18 . There are five numbered tiles in a two by three frame . The sixth position is referred to as the blank tile . A tile adjacent to the blank can be moved horizontally or vertically into that position . The goal is to move the tiles from one configuration to another . Our problem is to discover representations for efficient solution of the puzzle . The first change of representation we make is the standard abstraction from the physical structure to the state space graph . A partial expansion of the state space graph is shown in Fig . 2 . 6 . The entire graph has 360 nodes and 420 edges . 3 ' I FIG . 2 . 6 . Partial expansion of five puzzle graph . This graph has many subgraphs of the form shown in Fig . 2 . 7 . The reason for these subgraphs is that if the blank is in one of the comer positions , it can only move to either the adjacent comer or the adjacent side position . This results in connected pairs of nodes , each of which have degree two . We can replace these nodes and FIG . 2 . 7 . Typical five puzzle subgraph . I 52 R . E . KORF their edges with a single edge or macro - operator . These macro - operators corres - pond to a sequence of three primitive operators which move the blank from one side position , through two corner positions , to the opposite side position . This transformation can be viewed as a homomorphism on the set of operators , which yields sequences of three operators , followed by an isomorphism which returns single macro - operators . In graph theoretic terms , the new graph is said to be homeomorphic to the original . The new representation has 120 nodes , 60 primitive operators , and 120 macro - operators . All nodes have the blank in one of the side positions . Each node has two macro - operators incident to it . If we follow the chain of macro - operators from any state , after ten operations we return to the same state . The reason for the cycles of length ten is that repeated application of the macro - operators results in rotation of the tile configuration and ten applications is a complete rotation . We define an equivalence relation on the states as follows : " two states are equivalent if and only if they are in the same rotation cycle " . A homomorphic state space has the equivalence classes of this relation as nodes and only the primitive operators as edges . We can label these classes by rotating the tiles until the 1 tile is in the upper left position and then reading off the other two tiles in the top row . This labeling is unique , i . e . the transformation is an isomor - phism , because the relative position of the two tiles in the bottom row is deter - mined , or alternatively , because only half the possible states are reachable from any one state 19 . The resulting state space is shown in Fig . 2 . 8 , where each node corresponds to a different cyclic order of the tiles . This space has 12 nodes and 30 edges . 15 $ 4 FIG . 2 . 8 . Abstract five puzzle state space . TOWARD A MODEL OF REPRESENTATION CHANGES 53 A final isomorphic transformation comes from the fact that the graph in Fig . 2 . 8 is a two dimensional projection of the icosahedron or twenty sided Platonic solid . We can efficiently solve any instance of the five puzzle by searching the icosa - hedron graph , where the maximum distance between any two nodes is three operations , and then mapping the solution back down through the lower level state spaces . This corresponds to the strategy of first getting the cyclic order of the tiles correct and then rotating them to the exact goal state . In each of our examples so far , we have only considered one path through the space of representations . We now consider an alternative sequence of representa - tions for the five puzzle . In the previous example , the first abstraction from the state space graph left us with states where the blank was always in one of the side positions . In this example , we choose an abstract state space where all nodes have the blank in the bottom side position . This is a homomorphic transformation on the operators . The isomorphic macro - operators correspond to a sequence of four moves which rotates the three tiles on one side of the frame . Each node has four such macro - moves incident to it : rotating the left side or the right side clockwise or counterclockwise . This space has 60 nodes and 120 macro - operators . Next we partition the operators into two types , those that rotate the leftmost tiles and those that rotate the rightmost tiles . Each type of operator falls into dis - joint cycles of length three because three rotations of the tiles returns them to their original positions . If we define two states to be equivalent iff they lie on the same cycle of right rotating moves , we get a homomorphic space where the only remain - ing operators are the left rotating moves . Since the nodes are classes of right rotations , the left two tiles remain unchanged and hence we can isomorphically label the equivalence classes by the two tiles in the left hand column . This abstract state space graph has 20 nodes and 60 edges . We can construct a physical puzzle which has this graph as its state space graph . There is a fixed section of pipe , two and a half feet long , transparent and open at both ends . There are also five cylinders , each one foot long , labeled 1 through 5 , which fit snugly into the pipe . Two cylinders are always in the pipe . The state of the pipe can only be changed by putting a cylinder in one end and pushing one out the other end . The goal is to get a particular ordered pair of cylinders in the pipe . Given this representation , we realize that if the goal state is ( A B ) , then the labels on the other cylinders are irrelevant since they are only used to manipulate the goal cylinders . If we consider all possible labelings of the non - goal cylinders to be equivalent , we arrive at the final abstract state space graph in Fig . 2 . 9 , which has seven nodes and eight edges . Again , we can efficiently solve the five puzzle by searching for a solution in this abstract space and mapping the solution down through the lower level spaces . This corresponds to the strategy of getting the left two tiles correct and then rotating the right three tiles to the exact configuration . It should be noted that neither of the two strategies developed for this puzzle will yield solutions with the minimum number of moves . 54 g . E . KORF FIG . 2 . 9 . Abstract state space for pipe game . 2 . 6 . Mutilated checkerboard problem In our next example we will develop the familiar mutilated checkerboard problem 20 and show that the solution fits our model of representation changes . First consider the following problem : Can a normal eight by eight checkerboard be covered exactly with dominoes ( one by two ) ? The answer is yes as the reader can easily verify by laying eight rows of four dominoes each . For the next problem we remove one of the comer squares and ask if this ' mutilated ' checkerboard can be covered exactly with dominoes . The perceptive reader will quickly realize that it can ' t be done because there are an odd number of squares . How can we break down this insight into a series of smaller steps ? The first representation assumes that all squares are distinguishable , say by some assignment of coordinates , and saves two sets of squares ; those that are covered by dominoes and those that remain uncovered . We could write a program to exhaus - tively search this space by trying all possible domino configurations and it would eventually fail , indicating that the board can ' t be covered . If we assume that the squares are indistinguishable , then two sets with the same number of squares become equivalent . The equivalence classes of this homo - morphic transformation can be uniquely represented by integers . This combina - tion of homomorphic and isomorphic transformations yields a new representation which is a pair of integers indicating the number of covered and uncovered squares . We can further define two integers to be equivalent iff they have the same even odd parity . The equivalence classes of this homomorphic change of representation can be isomorphically represented by binary digits . Our final representation is composed of two bits , indicating the parity of the covered and uncovered squares . In this representation , it is easy to see that a checkerboard minus one square cannot be covered by dominoes . The parity of the covered squares must always be even whereas the parity of the uncovered squares must always be odd . We arrive at the classical mutilated checkerboard problem by removing two TOWARD A MODEL OF REPRESENTATION CHANGES 55 opposite comer squares and again asking if the resulting board can be covered by dominoes . The answer is still no , but the reason is more Subtle than in the previous case . It would be reasonable to explore the same sequence of representations as in the previous example . However , when we use the parity representation in this case , the covered and uncovered squares both have even parity and hence this represen - tation doesn ' t help . We can then backtrack to the original representation in which all squares are distinguishable . The representation change that does work is to color the squares black and white in the pattern of a normal checkerboard . This is a homomorphic transformation in that 62 distinguishable squares are partitioned into two equivalence classes , black and white . Coloring the board gives rise to a representation consisting of four sets of squares , corresponding to black and white covered and uncovered squares . Since squares of the same color are indistinguishable , the equivalence classes of this representation are those sets with different numbers of elements . These can be isomorphically represented by two pairs of integers , the numbers of black and white covered squares and the numbers of black and white uncovered squares . As our final representation , we retain only two bits indicating whether or not the numbers of black and white squares are equal for the covered and uncovered cases . Again this is a combination of a homomorphic and isomorphic transforma - tion . In this representation the solution is trivial . The numbers of the black and white covered squares are always equal whereas the numbers of black and white uncovered squares are always unequal . Hence , there can be no solution . 2 . 7 . Floor plan design Up to now , most of the examples we have looked at have been puzzles or ' toy problems ' . One might justifiably ask if our model applies to any real world prob - lems . We now consider such a problem area , that of design , and in particular the design of floor plans . The following discussion of this problem will be somewhat informal . A more rigorous treatment can be found in 21 . We define a floor plan to be a connected set of labelled polygons of various sizes and shapes ( see Fig . 2 . 10 ) . A particular design problem is of the following form : given a set of constraints which dictate ( 1 ) what rooms must be present , ( 2 ) which pairs of rooms must be adjacent , ( 3 ) which rooms may be completely enclosed by sets of other rooms , ( 4 ) what size each room must be , and ( 5 ) what shape each room must be , construct a floor plan which satisfies these constraints , if one exists . We wish to derive a method which will enable the efficient solution of any design problem of this form . The major difficulties are that the design space is extremely large and the con - straints are highly interdependent . Our approach is to define a series of homomor - phisms on the design space , each coupled with an isomorphism , to allow the designer to focus his attention on only one type of constraint at a time . 56 R . E . KORF number of spaces $ 1 $ 2 F $ ( adjacency matrix ) 3 4 A B C D 0 1 0 1 1 0 1 1 0 1 0 i 1 1 1 0 5 6 $ $ F - geometries I labelled bubble diagrams t I floor plans FIG . 2 . 10 . Hierarchy for floor plan design 21 . I I I I I At the top level , we define two plans to be equivalent if they have the same num - ber of rooms . The equivalence classes induced by this homomorphism are iso - morphic to the positive integers . Thus , using an integer as a very abstract repre - sentation of a plan , the designer can select the number of rooms in the plan . At the next level , two floor plans with the same number of rooms are defined to be equivalent if they have the same adjacency matrix . An adjacency matrix for a floor plan has rows and columns labelled with rooms with a one appearing wherever two rooms are adjacent . The equivalence classes of this homomorphism are iso - morphic to abstract planar graphs where nodes correspond to rooms and links indicate adjacency . Hence , the designer can use the adjacency constraints to select a particular planar graph for the plan . At the third level , we assign X and Y coordinates to the nodes of the graphs and define two graphs to be equivalent if one can be continuously transformed into the TOWARD A MODEL OF REPRESENTATION CHANGES 57 other by moving nodes in the plane such that no node crosses an edge of the graph . The equivalence classes generated by this homomorphism are isomorphic to a set of canonically drawn geometries in which the outside perimeter is a regular polygon and each interior node is placed at the center of gravity of its neighboring nodes ( see Fig . 2 . 10 ) . The essential information in a geometry concerns the enclosure of some nodes by cycles of other nodes , and therefore the designer can select a geometry to satisfy the enclosure constraints . The final homomorphism defines two floor plans to be equivalent if they have the same geometry and corresponding rooms are the same size . The equivalence classes of this relation are isomorphic to a set of bubble diagrams , each of which is generated by expanding the nodes of a geometry until adjacent nodes touch and all nodes are the proper size . The designer selects a bubble diagram which satisfies the size constraints of the problem . Finally we come to the level of actual floor plans . The only information left to be incorporated in the design at this stage is the shapes of the rooms . This is accom - plished by assigning shapes to each of the bubbles in the bubble diagram . By making use of homomorphic and isomorphic transformations , we have re - duced the problem of designing a floor plan that satisfies five different and inter - related types of constraints , to a sequential task which considers each type of constraint independently . These representations of the problem have been success - fully used in an interactive computer program which carries a naive user through this design problem 22 . The reader who is interested in the application of this technique to design problems in general is referred to 23 . 3 . Computer Implementation of Representation Changes With the exception of computer implementation of the specific representations ~ n the floor plan design example , the foregoing discussion has described a set of paper and pencil exercises designed to show that many problems can be successfully analyzed by a series of isomorphic and homomorphic representation changes . In this section , we discuss some experiments aimed to demonstrate that these changes of representation can be simulated by a computer program . The goal of this experimentation is the development of a computer model of the process of changing representations in problem solving . Three essential components of this model are : ( 1 ) a language for expressing representations , ( 2 ) a language to describe transformations of representation , and ( 3 ) an interpreter to apply a transformation to a representation and compute the resulting representation . At this stage in the research , the above components are still in a state of flux and we make no claim that the decisions made in their design are the best possible decisions , but merely that they are adequate to handle our set of examples and we hope they will extend to new examples . 58 R . E . KORF 3 . 1 . A language for expressing representations Of the three components , this is perhaps the most difficult one to design and the driving force behind the other two . The essential difficulty is that representations are based on many different kinds of information structures , including two dimensional diagrams , three dimensional models , and time - varying processes . However , our language is only capable of directly expressing symbol structures . Following Newell and Simon 24 , a symbol structure is a set of primitive symbols connected by a set of relations . Primitive symbols are those that cannot be de - composed into component parts . A central assumption of this work is that most representations can be usefully modelled by symbol structures . An important fact that supports this assumption is that representations are only dealt with at a certain level of abstraction , which defines the primitives of the representation . For example , chess is normally played with physical pieces . However , the exact shape or exact color of a piece are irrelevant ; what is important is only which one of six types of pieces it is and which one of two colors it is . Hence , king , queen , rook , knight , bishop , pawn , and black and white would be among the primitive symbols in a symbolic representa - tion of chess . We feel that one of the most important characteristics of a representation is which relations among the primitives are explicit and which relations are left im - plicit . For example , on a physical chessboard , the relation between a piece and the square it occupies is extremely evident to a human player , whereas the relation among squares dictated by the knight ' s move is less explicit . We introduce our representation language with an example . The following list structure describes the data type of static sets , that is , sets without the addition and deletion of elements , along with several common set operations : ( ( Element ( TYPE ( PRIMITIVE ) ) ( . A B C D E ) ) ( Class ( TYPE ( SET Element ) ) NIL ) ( Member ( FUNCTION ( TUPLE Element Class ) Boolean ) ( ACCESS ) ) ( Boolean ( TYPE ( PRIMITIVE ) ) ( . 0 1 ) ) ( Const ( Class ) ( . A C E ) ) ( Var ( Class ) ( VARIABLE ) ) ( Integer ( TYPE ( PRIMITIVE ) ) NIL ) ( Cardinality ( FUNCTION Class Integer ) ( GIVEN ( ( S Class ) ) ( NUMBER ( X Element ) ( Member X S ) ) ) ) ( Subset ( FUNCTION ( TUPLE Class Class ) Boolean ) ( GIVEN ( ( A Class ) ( B Class ) ) ( All ( ( X Element ) ) ( Implies ( Member X A ) ( Member X B ) ) ) ) ) ( Intersection ( FUNCTION ( TUPLE Class Class ) Class ) ( GIVEN ( ( A Class ) ( B Class ) ) TOWARD A MODEL OF REPRESENTATION CHANGES 59 ( ALL ( ( X Element ) ) ( IFF ( Member X ( Intersection A B ) ) ( AND ( Member X A ) ( Member X B ) ) ) ) ) ) ) An expression in this language is composed of a list of object declarations , where the order is irrelevant . Each object declaratien is a triple , consisting of a name , an information structure , and an information content . Alternatively , these triples can be viewed as a name followed by a type or syntactic descriptor , followed by a value or semantic content . The name field contains an atom ( e . g . Element , Class , Member , etc . ) by which the object can be referred to elsewhere in the expression . The structure field indi - cates whether the object is primitive , or if not , how it is composed of relations among primitives . A structure or type expression consists of a constructor followed by its arguments which are , themselves structure expressions . This recursion is terminated by the constructor PRIMITIVE , which takes no arguments and is used to denote the primitive symbols of the representation ( e . g . Element ) . Other constructors are used to build more complex structures from simpler structures . These constructors include SET , which takes one argument and designates a set of objects of the argument type ( e . g . Class ) ; TUPLE which takes a variable number of arguments and denotes an ordered n - tuple of objects of the argument types ( e . g . Member ) ; UNION which specifies an object which can assume a value of any one of its argument types ; VECTOR which indicates an ordered list ( of variable length ) of elements of its single argument type ; and FUNCTION , which takes two arguments , a domain and a range , and designates a total function ( i . e . a set of ordered pairs with each domain element appearing exactly once ) from the domain to the range ( e . g . Member ) . TYPE is a constructor which takes a single argument and denotes the type of the argument . For example , Class refers to the type ' SET of Element ' whereas Const refers to a particular SET of Elements . Possible future extensions to the collection of constructors include MULTISET and STRING , but the size of the collection is intended to remain small ( e . g . less than ten ) . An important property of this paradigm is orthogonality : any con - structor can be meaningfully applied to any valid structure expression , and hence a very large number of structures can be built with a small number of constructors . The information content field of a triple gives the value or semantic definition of an object . There are two types of content expressions , extensional and intensional , and in general their interpretation depends upon the associated structure ex - pression . In addition , there are two special flags , ACCESS and VARIABLE , that may appear in the content field . An extensional expression , flagged by a ' . ' as the first item af the list , explicitly lists the value or values associated with the object . If the object is a type ( e . g . Element ) , an extensional definition enumerates the possible values that an object of that type can assume . If the object is not a type ( e . g . Const ) , an extensional expression gives the particular value associated with the object . 60 R . E . KORF An intensional content field is essentially a predicate calculus expression which defines the semantics of the object . It may express a constraint which admits a set of possible values or it may uniquely specify a particular value or function ( e . g . Cardinality , Subset , Intersection ) . Our predicate calculus expressions differ from more standard notations in several respects . The expressions are parsed into lists with connectives and quantifiers preceding their arguments . Quantified expres - sions are triples composed of the quantifier , a bound variable list consisting of pairs of variables with their types , followed by the actual body of the expression . We have also added two quantifiers to the traditional ALL and EXISTS . GIVEN is a dummy quantifier which serves to bind the arguments to functions ( e . g . Cardinality , Subset , Intersection ) . NUMBER takes the form ( NUMBER ( X 7 ) P ( X ) ) and re - turns an integer which is the number of objects X of type T which satisfy P ( X ) ( e . g . Cardinality ) . Where the special flag VARIABLE appears in the content field , it indicates that the object is a variable of the type given in the structure field ( e . g . Var ) . Note that Var is a variable of type Class whereas Const is a constant of the same type . The flag ACCESS appearing in the content field of a function object means that the function is aprimitive accessing function for the data types designated in the struc - ture field , for example Member . The Member function in a sense defines the seman - tics of the data type Class and cannot itself be further defined . Note that Cardinal - ity , Subset , and Intersection are all expressed in terms of the Member function . We will see that this technique of expressing higher level functions in terms of primitive accessing functions proves to be crucial in transforming those higher level functions as the representation of the data objects change . For more complex examples in this representation language , the reader is referred to the specifications of Tic - tac - toe and the Tower of Hanoi problem in Section 3 . 6 . It is instructive at this point to compare and contrast our language with several other specification approaches and languages . The origin of our language was in a relational data base approach 25 , 26 , wherein all structures are built from rela - tions among primitives . Sets can be represented as unary relations . Ordered n - tuples can be represented as n - ary relations that are single valued ( i . e . contain only one tuple ) . However , we feel that these structures are common enough that it is preferable to give themtheir own names rather than to stretch the pure relational formalism to accommodate them . Viewed as a data declaration language , our formalism borrows several features from the data declaration facilities of ALGOL 68 ( see 27 ) . One is the previously mentioned concept of orthogonality . Another is the ability to define new types ( modes ) . On the other hand , our language is not a programming language ; it does not allow the specification of procedures but merely declarative structures . Our approach also owes much to abstract data type specification 28 . The technique of specifying functions on data objects in terms of primitive accessing TOWARD A MODEL OF REPRESENTATION CHANGES 61 functions is very useful . In addition , we use the method of indirectly specifying a function by means of an axiom describing its behavior ( e . g . intersection ) . However , while one of the aims of abstract data specifications is to completely mask the representation of a data object , we strive to explicitly express the representation of data objects . Our representation language operationally defines the concepts of information structure , content , and quantity that were introduced in Section 1 . 2 . The informa - tion structure of a representation is composed of the structure or type fields of each of the objects in the representation . Similarly , the information content of a repre - sentation consists of the content fields of the objects it contains . Since information is only associated with a choice among possible alternatives , the only objects with non - zero information quantity are VARIABLE objects . The information quantity of a variable , measured in bits , is the logarithm to the base 2 of the number of different possible values it can assume . For example , the variable Var contains a set chosen from a 5 element universe and hence it can assume one of 32 different values , implying an information quantity of 5 bits . Types with an infinite number of values can result in transfinite information quantities , such as a set chosen from a countably infinite universe . The information quantity of a repre - sentation is the sum of the information quantities of its variables . Note that if two representations have the same information quantities , the values of their variables can be placed in a one - to - one correspondence , and hence the two representations must be isomorphic , assuming their operations are isomorphic . 3 . 2 . A language for expressing transformations The second major component of our model is a language for expressing trans - formations of representation . These transformations are applied to expressions in the representation language by an interpreter , implemented in LISP , to yield a new representation . Since the meaning of statements in the transformation language is ultimately determined by the interpreter , the two components will be discussed together . As a vehicle for describing the language , we first present a typical transformation along with a representation both before and after the application of the trans - formation . The transformation , called Distribute , applies to any function whose range consists of sets , and transforms the function to a set of ordered pairs of elements from the domain and elements from the sets which make up the range . This transformation is an isomorphism and hence has an inverse . ( In this paper , transformations are printed in italics to distinguish them from representation expressions . ) ( ( Num ( TYPE ( PRIMITIVE ) ) ( * 1 2 3 ) ) ( Let ( TYPE ( PRIMITIVE ) ) ( . A B C ) ) ( Fun ( FUNCTION Num ( SET Let ) ) ( , ( 1 ( A ) ) ( 2 ( A B ) ) ( 3 ( A B C ) ) ) ) ) 62 R . E . KORF ( ? N ( FUNCTION ? D ( SET ? R ) ) ? C ) ( # N ( FUNCTION # D ( SET # R ) ) # C ) ( # N ( SET ( TUPLE # D # R ) ) ( . tDistrib # C ) ) ( ( Num ( TYPE ( PRIMITIVE ) ) ( , 1 2 3 ) ) ( Let ( TYPE ( PRIMITIVE ) ) ( , A B C ) ) ( Fun ( SET ( TUPLE Num Let ) ) ( . ( 1 A ) ( 2 A ) ( 2 B ) ( 3 A ) ( 3 B ) ( 3 C ) ) ) ) A transformation is an ordered pair consisting of a list of required patterns followed by a list of rewrite rules . A rewrite rule consists of an ordered pair of a pattern followed by a replacement . Patterns and replacements are list structures composed of atoms , three different kinds of variables , and LISP functions . Free variables , which occur in patterns and are written ? ( atom ) , match any corres - ponding list structure and cause ( atom ) to be bound to that list structure . Bound variables are written # ( atom ) and can appear in either patterns or replacements . When appearing in patterns , they match what they have been bound to , or , if they haven ' t been bound , they prevent the pattern from matching . In a replacement , bound variables evaluate to what they have been bound to . Reapply variables ( not used in example ) occur in replacements and are written % ( atom ) . They evaluate to the result of recursively applying the rewrite rules of the transformation to what they are bound to . Unbound ' bound ' or reapply variables may not occur in replacements . LISP functions , written ! ( function ) and followed by a list of argu - ments , may occur in replacements and must be defined in the environment that the transformation is applied in . A rewrite rule whose pattern is NIL indicates that the replacement is to be added to the representation expression at the top level . Similarly , a rewrite rule with a NIL replacement designates that all expressions that match the pattern are to be deleted from the representation . The transformation interpreter is independent of the representation language , requiring only that expressions be list structures , and executes the following al - gorithm : for the transformation to be applied , each of the required patterns must match some part of the representation . A required pattern is matched to only the first ( i . e . highest level and leftmost ) occurrence of a matching expression . Once all required patterns are matched , the rewrite rules are compared sequentially to the entire expression until one matches . The expression is then replaced with the re - placement part of the matched rule and no further rules are applied , unless the replacement includes reapply variables . If none of the rules match , the entire set is recursively applied to the car and cdr of the expression . Note that ' add and delete rules are handled outside this recursion . At this point the reader may be disturbed by the inclusion of arbitrarily powerful LISP functions in transformations . The reason for allowing these functions is solely for the transformation of extensional content definitions . Whereas all other ex - pressions in our representation language , including intensional content definitions . TOWARD A MODEL OF REPRESENTATION CHANGES 63 can be easily transformed by simple rewrite rules , the transformation of extensional definitions in general requires more flexibility and greater computational power . For example , applying Distribute to the actual ordered pairs of an extensionally defined function is difficult to do with rewrite rules , so a LISP function called Distrib is used instead . 3 . 3 . Some primitive isomorphic tnms ' formatio ~ In this section we describe several relatively low level isomorphic transformations , similar to Distribute , that have been implemented in our system . In some cases , the actual transformations have been omitted due to space considerations . Note that for simplicity the representations and transformations in this section and the following section do not take into account operations on the data structures . Transformation of operations will be discussed in Section 3 . 5 . Set - to - Function is an isomorphic transformation that applies to any set chosen from some universe and transforms it to a function from the universe to booleans ( i . e . 0 or 1 ) . Those elements that belong to the set are mapped to 1 and those that are not members are mapped to 0 . The transformation , along with a representation before and after the application of the transform are shown below . ( ( Element ( TYPE ( PRIMITIVE ) ) ( , A B C D E ) ) ( Class ( TYPE ( SET Element ) ) NIL ) ( Const ( Class ) ( , A C E ) ) ) ( ? S ( TYPE ( SET ? E ) ) ? C ) ( # S ( TYPE ( SET # E ) ) # C ) ( Char ( TYPE ( FUNCTION # E Boolean ) ) NIL ) # S ~ Char ( ? N ? T ( * ? D ) ) ~ ( CAN % T ( ! Setfunc CAD CAE ) ) NIL ~ ( Boolean ( TYPE ( PRIMITIVE ) ) ( , 0 1 ) ) ( ( Element ( TYPE ( PRIMITIVE ) ) ( , A B C D E ) ) ( Char ( TYPE ( FUNCTION Element Boolean ) ) NIL ) ( Const ( Char ) ( , ( A 1 ) ( B 0 ) ( C 1 ) ( D 0 ) ( E 1 ) ) ) ( Boolean ( TYPE ( PRIMITIVE ) ) ( , 0 1 ) ) ) Function - to - Vector is an isomorphism that applies to any total function and transforms it to a vector whose elements are the successive range elements obtained by applying the function to the domain elements . Hence , elements of the domain are represented by positions in the vector and the length of the vector is the size of the domain . The transformation , along with the effect of its application to the above representation , are shown below . ( ? C ( TYPE ( FUNCTION ? E ? B ) ) ? X ) ( C A C ( TYPE ( FUNCTION # E CAB ) ) C A X ) ( Vect ( TYPE ( VECTOR # B ) ) NIL ) 64 a . E . KORF # C ~ Vect ( # E ? Y ? Z ) ~ ( Position ( TYPE ( PRIMITIVE ) ) ? Z ) # E ~ Position ( ? N ? T ( * ? D ) ) - - * ( ? N . " , T ( / Funcvect # T # D ) ) ( ( Position ( TYPE ( PRIMITIVE ) ) ( , A B C D kS ) ) ( Vect ( TYPE ( VECTOR Boolean ) ) NIL ) ( Const ( Vect ) ( , 1 0 1 0 1 ) ) ( Boolean ( TYPE ( PRIMITIVE ) ) ( , 0 1 ) ) ) Often it is useful to represent a complex object by a simple name . The Name transformation takes any type and creates a bijection between objects of the type and a collection of atomic names . For example , the type consisting of the values ( A B C D E ) could be transformed to the constant function ( 1 A ) ( 2 B ) ( 3 C ) ( 4 D ) ( 5 E ) along with the primitive type ( 1 2 3 4 5 ) . The isomorphic transformation Factor applies to any set of ordered pairs and changes it to a function from the type of the first element of the pairs to sets of ot " ects from the second element of the pairs , such that each first element maps to the set of second elements it was paired with . For example , the set of ordered pairs ( A 1 ) ( A 2 ) ( B 2 ) ( A 3 ) ( B 3 ) ( C 3 ) would be transformed to ( A ( 1 2 3 ) ) ( B ( 2 3 ) ) ( C ( 3 ) ) , a function from letters to sets of integers . Switch is an isomorphic transformation which applies to an ordered pair and reverses the order of the elements in each occurrence of the ordered pair in the representation . 3 . 4 . Inversion , Composition , and more powerful transformations In this section we demonstrate that by inverting and composing the low level transformations discussed above , we can automatically generate more powerful representation transformations . We have implemented a LISP function , Invert . which when applied to a transformation , returns the inverse of the transformation , in the sense that if the two transformations are applied sequentially to any repre - sentation , the result is the original representation . For example , the inverse of Distribute is Factor , shown below . ( ? N ( SET ( TUPLE ? D ? R ) ) ? X ) ( # N ( SET ( TUPLE CAD CAR ) ) CAX ) - - , ( # N ( FUNCTION # D ( SET # R ) ) ( / Factor C A X ) ) Another function which has been implemented is called Compose and is applied to an ordered pair of transformations to produce a third transformation which is the composition of the pair . In other words , applying the composed transformation has the same effect on any representation as applying the first transformation fol - lowed by an application of the second transformation . For example , when Corn - TOWARD A MODEL OF REPRESENTATION CHANGES 65 pose is applied to Set - to - Function and Function - to - Vector , the result is a transforma - tion , called Setbool , which maps sets directly into boolean vectors . ( ? S ( TYPE ( SET ? E ) ) . ~ X ) ( # S ( TYPE ( SET # E ) ) # X ) ( Vect ( TYPE ( VECTOR Boolean ) ) % 30 ( # E ? Y ? Z ) ~ ( Position ( TYPE ( PRIMITIVE ) ) Z ) # S ~ Vect # E - - * Position NIL - - * ( Boolean ( TYPE ( PRIMITIVE ) ) ( . 0 1 ) ) Applying Invert to Setbool yields Boolset , a transformation which maps boolean vectors directly into sets . This well - known isomorphic change of representation is at the heart of the duality between set theory and boolean algebra . An equally powerful yet much less well - known transformation on sets is one we call Set - Dual : ( ? S ( TYPE ( SET ? E ) ) ? X ) ( # E ( TYPE ( PRIMITIVE ) ) ? Y ) ( # S ( TYPE ( SET # E ) ) # X ) ~ ( # E ( TYPE ( PRIMITIVE ) ) % X ) ( # E ( TYPE ( PRIMITIVE ) ) # Y ) ~ ( # S ( TYPE ( SET # E ) ) Â° / / oY ) # E - - , # S # S ~ # E Set - Dual is applied to a universe of elements together with a collection of subsets of the universe and maps each of the subsets to an element of a new universe while each of the elements of the old universe becomes a subset of the new universe . The new subsets contain those new elements which correspond to the old subsets which contained the corresponding old element . Alternatively , if a collection of sets is viewed as a binary relation between elements and sets which indicates membership , Set - Dual corresponds to transposing the elements and sets in the relation . For example , applying Set - Dual to the collection of sets ( A ) ~ ( A B ) z ( A B C ) 3 ( ) a from the universe ( A B C ) would result in the collection of sets ( 1 2 3 ) a ( 2 3 ) B ( 3 ) c from the universe ( 1 2 3 4 ) , where the subscripts indicate the correspondence . Set - Dual is an automorphism , a special case of an isomorphism in which the repre - sentation structure , a collection of subsets , is the same before and after the trans - formation . It is also its own inverse . Set - Dual is the composition of five lower level transformations : Name , Distri - bute , Switch , Factor ( the inverse of Distribute ) , and Unname ( the inverse of Name ) . To illustrate this we show the effects of sequentially applying these transforms to a particular extensional collection of sets . Starting with the universe ( A B C ) and the collection ( A ) ( A B ) ( A B C ) ( ) , we apply Name to produce two universes , ( A B C ) and ( 1 2 3 4 ) , along with the constant function ( 1 ( A ) ) ( 2 ( A B ) ) ( 3 ( A B C ) ) ( 4 ( ) ) . Applying Distribute to this function results in the ordered pairs ( 1 A ) ( 2 A ) ( 2 B ) 66 R . E . KORF ( 3 A ) ( 3 B ) ( 3 C ) . The application of Switch to these pairs yields ( A 1 ) ( A 2 ) ( B 2 ) ( A 3 ) ( B 3 ) ( C 3 ) . By applying Factor to the ordered pairs , we generate the function ( A ( 1 2 3 ) ) ( B ( 2 3 ) ) ( C ( 3 ) ) . Finally , the application of Unname leaves us with the single universe ( 1 2 3 4 ) and the collection of subsets ( 1 2 3 ) ( 2 3 ) ( 3 ) . At this point we should note that neither Invert nor Compose work in all possible cases . For example , when a transformation includes a LISP function for handling extensional content definitions , inverting the transform involves finding the inverse of the LISP function . Automatically generating the inverse would be very difficult . The currently implemented versions of Invert and Compose are relatively weak . However , we feel that the addition of more heuristic knowledge to these programs would significantly broaden their range of applicability . 3 . 5 . Transformation of data structure operations A representation consists of a data structure plus a collection of functions or operations on the data structure . For example , the representation Class consists of the set data structure together with functions such as Member , Cardinality , Subset and Intersection . So far our examples have focused only on the transformation of the data structures . In fact , the transformations we have exhibited up to now have been incomplete in that they have not included rules for transforming operations . However , when the data structure is transformed , all of the operations must be similarly transformed . For example , when Setboolis applied to a set representation , the operation of Cardinality becomes a function from a boolean vector to an integer which returns the number of 1 elements in the vector . Transformation of the operations is accomplished by having all operations on a representation expressed in terms of a small set of primitive accessing functions . In addition , any transformation that applies to the representation must supply a rewrite rule for each primitive accessing function . Hence , the explicit transforma - tion of the accessing functions causes the transformation of all other operations on the representation . For example , the static set representation ( i . e . Class ) has one primitive accessing function , Member , which is a function from an element and a set to a boolean . The complete Setbool transformation includes the rules : ( ? M ( FUNCTION ( TUPLE C A E C A S ) Boolean ) ( ACCESS ) ) ( Test ( FUNCTION ( TUPLE Position Veer ) Boolean ) ( ACCESS ) ) C A M ~ Test Thus , in going from sets to boolean vectors via Setbool , Member is renamed Test and becomes a function from a position and a vector to a boolean . This , along with the mappings of elements to positions and sets to vectors , results in the correct transformation of Cardinality , as shown below , even though the transformation has no knowledge of the Cardinality function . Setbool maps Subset to a function from a pair of boolean vectors to a boolean , which is true if and only if the second vector TOWARD A MODEL OF REPRESENTATION CHANGES 67 contains a 1 in every position that the first vector contains a 1 ( see below ) . Inter - section is transformed to bitwise ANDing of two vectors to produce a third vector . ( Test ( FUNCTION ( TUPLE Position Vect ) Boolean ) ( ACCESS ) ) ( Cardinality ( FUNCTION Vect Integer ) ( GIVEN ( ( S Vect ) ) ( NUMBER ( X Position ) ( Test X S ) ) ) ) ( Subset ( FUNCTION ( TUPLE Vect Vect ) Boolean ) ( GIVEN ( ( A Vect ) ( B Vect ) ) ( ALL ( ( X Position ) ) ( IMPLIES ( Test X A ) ( Test X B ) ) ) ) ) ( Intersection ( FUNCTION ( TUPLE Vect Vect ) Vect ) ( GIVEN ( ( A Vect ) ( B Vect ) ) ( ALL ( ( X Position ) ) ( IFF ( Test X ( Intersection A B ) ) ( AND ( Test X A ) ( Test X B ) ) ) ) ) ) Since Set - Dual interchanges the roles of elements and sets , it leaves the definition of the Member function unchanged , but switches the order of the element and set arguments in each application of the function : ( ? M ( FUNCTION ( TUPLE # E # S ) Boolean ) ( ACCESS ) ) ( # M ( FUNCTION ( TUPLE # E # S ) Boolean ) ( ACCESS ) ) ( # g ? A ? B ) ~ ( # M % B % A ) Thus , Cardinality is transformed to a function which takes an element and returns an integer which is the number of sets the element is a member of ( see below ) . Subset becomes a function from a pair of elements to a boolean which is true if and only if the second element is a member of every set the first element is a member of . Intersection is transformed to a function of two elements which returns a third element that is a member of exactly those sets that both of the argument elements are members of . Such an element will always exist if the dual collection of sets is closed under intersection . ( Member ( FUNCTION ( TUPLE Element Class ) Boolean ) ( ACCESS ) ) ( Cardinality ( FUNCTION Element Integer ) ( GIVEN ( ( A Element ) ) ( NUMBER ( X Class ) ( Member A X ) ) ) ) ( Subset ( FUNCTION ( TUPLE Element Element ) Boolean ) ( GIVEN ( ( A Element ) ( B Element ) ) ( ALL ( ( X Class ) ) ( IMPLIES ( Member A X ) ( Member B X ) ) ) ) ) ( Intersection ( FUNCTION ( TUPLE Element Element ) Element ) ( GIVEN ( ( A Element ) ( B Element ) ) ( ALL ( ( X Class ) ) ( IFF ( Member ( Intersection A B ) X ) ( AND ( Member A X ) ( Member B X ) ) ) ) ) ) Note that the transformation rules for data structure operations are an essential 68 R . E . KORF part of a representation transformation . In some sense , they define the meaning of the transform . For example , aside from the actual values of sets and elements , the only real difference between the set representation and its dual is in the operations . 3 . 6 . Tic - tac - toe and Tower of Hanoi revisited In this section we return to our first two examples to show that the model we have developed is successful in implementing some of the changes of representation that motivated it , in particular the isomorphic transformation from Tic - tac - toe to Jam , and the homomorphic transformation from the three disk Tower of Hanoi Problem to the two disk problem . First we present a specification of Tic - tac - toe in our representation language . ( ( Point ( TYPE ( PRIMITIVE ) ) ( , 1 2 3 4 5 6 7 8 9 ) ) ( Line ( TYPE ( SET Point ) ) ( , ( 4 9 2 ) ( 3 5 7 ) ( 8 1 6 ) ( 4 3 8 ) ( 9 5 1 ) ( 2 7 6 ) ( 4 5 6 ) ( 2 5 8 ) ) ) ( Player ( TYPE ( PRIMITIVE ) ) ( , X O ) ) ( Empty ( TYPE ( PRIMITIVE ) ) ( , E ) ) ( Configuration ( TYPE ( FUNCTION Point ( UNION Player Empty ) ) ) NIL ) ( State ( TYPE ( TUPLE Configuration Player ) ) NIL ) ( Config ( FUNCTION State Configuration ) ( ACCESS ) ) ( Turn ( FUNCTION State Player ) ( ACCESS ) ) ( Init ( State ) ( , ( ( 1 E ) ( 2 E ) ( 3 E ) ( 4 E ) ( 5 E ) ( 6 E ) ( 7 E ) ( 8 E ) ( 9 E ) ) X ) ) ( Win ( FUNCTION ( TUPLE State Player ) Boolean ) ( GIVEN ( ( S State ) ( P Player ) ) ( EXISTS ( ( L Line ) ) ( ALL ( ( X Point ) ) ( IMPLIES ( Member X L ) ( EQUAL P ( ( Config S ) X ) ) ) ) ) ) ) ( Boolean ( TYPE ( PRIMITIVE ) ) ( , 0 I ) ) ( Member ( FUNCTION ( TUPLE Point Line ) Boolean ) ( ACCESS ) ) ( Move ( FUNCTION ( TUPLE State Player Point ) State ) ( GIVEN ( ( S State ) ( P Player ) ( X Point ) ) ( AND EQUAL P ( Turn S ) NEQ P ( Turn ( Move S P X ) ) ALL ( ( Y Point ) ) ( OR AND NEQ Y X EQUAL ( ( Config S ) Y ) ( ( Config ( Move S P X ) ) Y ) TOWARD A MODEL OF REPRESENTATION CHANGES 69 AND EQUAL YX EQUAL E ( ( Config S ) I0 EQUAL P ( ( Config ( Move S P X ) ) Y ) ) ) ) ) ) ) Points are the squares of the tic - tac - toe board . A Line is a row , column , or di - agonal . A board Configuration is a function which for each Point tells whether it contains an X , an 0 , or is Empty . A State in the game is a pair of a board Con - figuration and a Player whose turn it is . Config and Turn are accessing functions which extract the Configuration and Player from the State . The initial State is all Points Empty with X to move . Win is a function which takes a State and a Player and tells if that Player has won in that State . Member tells if a particular Point is on a particular Line . The Move function takes a State , a Player , and the Point he wants to mark and returns the new State under the constraints that : ( 1 ) it must be his Turn to move ; ( 2 ) it must not be his Turn in the new State ; and ( 3 ) for all Points either ( a ) it is not the Point being marked in which case it must be marked the same in the new State as in the old ; or ( b ) it is the point being marked in which case it must be Empty in the old State and marked by the moving player in the new State . The specification of Jam ( see below ) is produced by applying Set - Dual to Tic - tac - toe . Similarly , applying Set - Dual to Jam produces Tic - tac - toe . In fact , the transformation between the boards for these two games is a special case of a more general principle of duality in projective geometry . This principle states that any statement in projective geometry can be transformed to a dual statement with the same truth value by replacing points with lines , lines with points , and all other concepts by their corresponding duals , such as replacing intersection of lines with collinearity of points 29 . If lines are represented as sets of points or vice versa , then Set - Dual implements the duality transform of projective geometry . ( ( Line ( TYPE ( SET ( Point ) ) ) ( , ( C E ) ( A F H ) ( B D ) ( A D G ) ( B E G H ) ( C F G ) ( B F ) ( C O H ) ( A E ) ) ) ' ( Point ( T ~ PE ( PRIMITIVE ) ) ( , A B C O E F G H ) ) ( Player ( TYPE ( PRIMITIVE ) ) ( , X 0 ) ) ( Empty ( TYPE ( PRIMITIVE ) ) ( , E ) ) Configuration ( TYPE ( FUNCTION Line ( UNION Player Empty ) ) ) NIL ) ( State ( TYPE ( TUPLE Configuration Player ) ) NIL ) ( Config ( FUNCTION State Configuration ) ( ACCESS ) ) ( Turn ( FUNCTION State Player ) ( ACCESS ) ) ( Init ( State ) ( , ( ( ( C E ) E ) ( ( A F H ) E ) ( ( B D ) E ) ( ( A D G ) E ) ( ( B E G H ) E ) ( ( C F G ) E ) ( ( B F ) E ) ( ( C D H ) E ) ) X ) ) ( Win ( FUNCTION ( TUPLE State Player ) Boolean ) ( GIVEN ( ( S State ) ( P Player ) ) 70 R . E . KORF ( EXISTS ( ( L Point ) ) ( ALL ( ( X Line ) ) ( IMPLIES ( Member L X ) ( EQUAL e ( ( Config S ) X ) ) ) ) ) ) ) ( Boolean ( TYPE ( PRIMITIVE ) ) ( , 0 1 ) ) ( Member ( FUNCTION ( TUPLE Point Line ) Boolean ) ( ACCESS ) ) ( Move ( FUNCTION ( TUPLE State Player Line ) State ) ( GIVEN ( ( S State ) ( P Player ) X Line ) ) ( AND EQUAL P ( Turn S ) NEQ P ( Turn ( Move S e X ) ) ALL ( ( Y Line ) ) ( OR AND NEQ Y X EQUAL ( ( Config S ) Y ) ( ( Config ( Move S P X ) ) Y ) AND EQUAL YX EQUAL E ( ( Config S ) Y ) EQUAL P ( ( Config ( Move S P X ) ) 10 ) ) ) ) ) ) In the case of the Tower of Hanoi problem , the required transformation is a homomorphism which simply takes a primitive type and deletes one of the possible values , carrying out the consequences throughout the specification . In this case , the last value of type Disk is deleted , transforming the three disk problem into the two disk problem . We give below the specification of the three disk Tower of Hanoi problem . ( ( Disk ( TYPE ( PRIMITIVE ) ) ( , 1 2 3 ) ) ( Peg ( TYPE ( PRIMITIVE ) ) ( , A B C ) ) ( Order ( FUNCTION ( TUPLE Disk Disk ) Boolean ) ( , ( ( 1 1 ) 0 ) ( ( 1 2 ) 1 ) ( ( 1 3 ) 1 ) ( ( 2 1 ) 0 ) ( ( 2 2 ) 0 ) ( ( 2 3 ) 1 ) ( ( 3 1 ) 0 ) ( ( 3 2 ) 0 ) ( ( 3 3 ) 0 ) ) ) ( Boolean ( TYPE ( PRIMITIVE ) ) ( , 0 l ) ) ( State ( TYPE ( FUNCTION Disk Peg ) ) NIL ) ( Init ( State ) ( * ( 1 A ) ( 2 A ) ( 3 , 4 ) ) ) ( Goal ( State ) ( * ( 1 C ) ( 2 C ) ( 3 C ) ) ) ( Move ( FUNCTION ( TUPLE State Disk Peg ) State ) ( GIVEN ( ( S State ) ( D Disk ) ( P Peg ) ) ( ALL ( ( X Disk ) ) ( OR AND NEQ X D EQUAL ( S X ' ) ( ( Move S D P ) X ) AND EQUAL XD NOT ( EXISTS ( ( YDisk ) ) ( AND EQUAL ( s Y ) ( s x ) Order YX ) ) NOT ( EXISTS ( ( YDisk ) ) ( AND EQUAL ( S Y ) P ( Order YX ) ) ) ) ) ) ) TOWARD A MODEL OF REPRESENTATION CHANGES 71 There are three Disks and three Pegs together with an Ordering function which tells if one Disk is smaller than another . A State is a mapping of each Disk onto a Peg . The Initial State is all Disks on the A Peg and the Goal State is all Disks on the C Peg . The Move function takes a State , a Disk and the Peg it is to be moved to and returns a new State subject to the constraint that for each Disk either ( 1 ) it is not the Disk being moved in which case it must be on the same Peg in the old State and the new State ; or ( 2 ) it is the Disk being moved in which case ( a ) there must not be any smaller Disks on its current Peg and ( b ) there must not be any smaller Disks on the Peg it is going to . 3 . 7 . Theories generated by Set - Dual and Setbool Set - Dual and Setbool are completely general transformations applying to sets and collections of sets . In fact , these transformations generate entire theories parallel to set theory since each concept , axiom , and theorem in set theory can be mapped through these transforms to new concepts , axioms , and theorems . Fig . 3 . 1 is a commutative diagram showing these various theories and their relationships via the transformations . A commutative diagram is one in which all paths with the same endpoint generate the same result . ~ ET - DUAL I ISETBOOL I SETBOOL Boo , sET I 1 I I VECT - DUAL FIG . 3 . 1 . Commutative diagram for sets , boolean vectors , and their duals , The upper left corner represents traditional set theory . The lower left corres - ponds to boolean algebra . The upper right represents a dual theory to set theory in which the roles of elements and sets are reversed . This is a new theory that has not yet been explored but may prove to be mathematically interesting . 1 The bottom right is a dual theory to boolean algebra in the sense that boolean vectors i The only reference to this area that we could find in the literature was in Berge ' s book on hyper - graphs 30 . A hypergraph is a collection of subsets of a universe . Berge notes the existence of a dual hypergraph , ~ hich is a dual in the same sense as the one we discuss . 72 R . E . KORF map to positions and positions map to boolean vectors . In other words , if a collec - tion of boolean vectors is viewed as a zero - one matrix , the dual of the collection would correspond to the transpose of the matrix . This change of representation , from boolean vectors to their duals , can be accomplished directly by the iso - morphic transformation Vect - Dual . Vect - Dual is constructed by the composition of Boolset , Set - Dual , and Setbool . Additional transformations between sets and dual boolean vectors and between boolean vectors and dual sets ( i . e . diagonals in the diagram ) could be constructed using Compose and the given transforms . Those readers familiar with category theory will have noticed a strong relation - ship between parts of this work and concepts of that theory . Category theory grew out of modern abstract algebra and deals with domains of mathematical dis - course , such as groups and monoids , and mappings within and between them . Indeed , much of this research can be phrased in the language of category theory . For example , representations are related to categories , operations in a representa - tion correspond to morphisms in a category , and transformations between repre - sentations are very similar to functors which map between categories . However , since we feel that category theory offers few new results that would add directly to this work , it would be counterproductive to present this research in a language that is unfamiliar to most of our readers . For those interested in category theory , 31 contains an excellent bibliography of the subject . 3 . 8 . New NP - complete problems In this section , we demonstrate that representation transformations can be applied to known NP - complete problems to automatically produce new and previously unknown NP - complete problems . In these examples , we start with set theoretic problems and use Set - Dual , Setbool , and Vect - Dual to generate the corresponding problems in each of the other three theories shown in Fig . 3 . 1 Informally , an NP - complete problem is a problem for which ( 1 ) the best known algorithm for computing a solution takes time which is greater than any polynomial function of the size of the problem , and ( 2 ) the existence of a polynomial time algorithm for the problem would imply the existence of a polynomial time al - gorithm for all NP - complete problems 32 . For example , Setcover is NP - complete : given an arbitrary collection of sets and an integer K , does it contain a subcollection of size K such that the union of the subcollection equals the union of the entire collection ? These problems are of theoretical as well as practical importance . Garey and Johnson 32 have published a catalog of NP - complete problems , and adding to this catalog is an active area of research in computational complexity . Setcover can be expressed in our representation language as a function of a collection of sets and an integer and returning a boolean which is true if and only if there is a subcollection whose size equals the integer and which ' covers ' the collection : TOWARD A MODEL OF REPRESF ~ q ' TATION CHANGES 73 ( ( Element ( TYPE ( PRIMITIVE ) ) NIL ) ( Class ( TYPE ( SET Element ) ) NIL ) ( Collection ( TYPE ( SET Class ) ) NIL ) ( Boolean ( TYPE ( PRIMITIVE ) ) ( , 0 1 ) ) ( Integer ( TYPE ( PRIMITIVE ) ) NIL ) ( Setcover ( FUNCTION ( TUPLE Collection Integer ) Boolean ) ( GIVEN ( ( C Collection ) ( K Integer ) ) ( EXISTS ( ( S Collection ) ) ( AND ( Subcollection S C ) ( Equal ( Collection - Cardinality S ) K ) ( ALL ( ( X Element ) ) ( EXISTS ( ( A Class ) ) ( AND ( Collection - Member A S ) ( Member X A ) ) ) ) ) ) ) ) ) 2 The problem of evaluating this function is NP - complete . Thus , any representa - tion transformation applied to the function will necessarily yield a new function whose evaluation is also NP - complete . 3 For example , applying Set - Dual to Set - cover results in an NP - complete problem called Hitting Set : given a collection of sets , is there another set of size K which contains at least one element from each set in the collection ( see below ) ? Both Setcover and Hitting Set appear in Garey and Johnson ' s catalog but they are listed as being derived independently from two separate NP - complete problems . ( ( Class ( TYPE ( SET Element ) ) NIL ) ( Element ( TYPE ( PRIMITIVE ) ) NIL ) ( Collection ( TYPE ( SET Element ) ) NIL ) ( Boolean ( TYPE ( PRIMITIVE ) ) ( , 0 1 ) ) ( Integer ( TYPE ( PRIMITIVE ) ) NIL ) ( HittingSet ( FUNCTION ( TUPLE Collection Integer ) Boolean ) ( GIVEN ( ( C Collection ) ( K Integer ) ) ( EXISTS ( ( S Collection ) ) ( AND ( Subcollection S C ) ( EQUAL ( Collection - Cardinality S ) K ) ( ALL ( ( X Class ) ) ( EXISTS ( ( A Element ) ) ( AND ( Collection - Member A S ) ( Member A X ) ) ) ) ) ) ) ) ) 2 The operations Subcollection , Collection - Cardinality , and Collection - Member apply to collections or sets of sets and are completely analogous to their single level counterparts . They are used to avoid problems with generic operators ( i . e . operators that can be applied to different types of arguments ) . 3 An exception to this rule is a transformation , such as converting binary numbers to unary , which causes an increase in the size of the input which is not polynomially bounded . 74 R . E . KORF If we apply Setbool to Setcover , the resulting NP - complete problem takes a col - lection of boolean vectors and asks if there is a subcollection of vectors of size K such that the bitwise OR of all the vectors in the subcollection equals the bitwise OR of the original collection ( the formal specifications of the remaining problems have been omitted due to space considerations ) . Applying Vect - Dual to this prob - lem yields the following NP - complete problem : given a collection of bitvectors and an integer K , is there a subset of the positions of size K such that every vector contains a 1 in one of the positions of the subset ? Neither of these latter two prob - lems appear in Garey and Johnson ' s catalog . Another NP - complete problem from the catalog which deals with sets is called Setpacking : given a collection of sets , is there a subcollection of size K in which all of the sets are pairwise disjoint , in other words have no elements in common ? When we apply Set - Dualto Setpacking , the result is an NP - complete problem which takes a collection of sets and asks if there is another set of size K from the same universe in which each of the elements are pairwise disjoint , in the sense that two elements are disjoint if there is no set in the collection which contains them both . Applying Setbool to Setpacking transforms it to an NP - complete problem which takes a collection of bit vectors and an integer K and returns true if there is a sub - collection of the vectors whose size is K and whose members are all mutually orthogonal . Applying Vect - Dual to this problem yields an NP - complete problem which takes a collection of bitvectors and asks if there is a subset of the positions of size K such that no vector contains a 1 in more than one position in the subset . None of these last three problems appear in Garey and Johnson ' s catalog . 4 . Conclusions and Further Work 4 . 1 . Conclusions We have attempted to demonstrate several things in this paper . One is that chang - ing representations is a powerful problem solving strategy . Furthermore , changes of representation are not isolated ' eureka ' phenomena but rather can be decom - posed into sequences of relatively minor representation shifts . The space of problem representations can be usefully characterized along the dimensions of information structure and information quantity . Representation transformations can be classified as isomorphisms and homomorphisms , corres - ponding to changes of information structure and information quantity , respec - tively . Points in the space of representations can be described by expressions in a sym - bolic language . Similarly , the operators in the space , or transformations of repre - sentation , can be expressed symbolically . These transformations can be applied automatically to representations to generate new representations for problems . TOWARD A MODEL OF REPRESENTATION CHANGES 75 Furthermore , many representation transformations can be automatically inverted and composed to generate new transformations . This allows a potentially large number of representation changes to be derived from a small set of primitive transformations . In addition to handling several of the examples on which its design was based , our system was used to generate some new NP - complete problems . 4 . 2 . Further work The model described above provides a space of problem representations , operators in the space , and the operator application function . However , the system is driven by manual selection of the transformations to be applied to a representation . To completely automate the process of finding good representations for problems will require a method for evaluating the efficiency of a representation relative to a particular problem solver , and some heuristics to guide the search for an efficient representation for a problem . These issues form the basis of current work on this research . They have been addressed by Low 33 , Rovner 34 , and Kant 35 in somewhat different contexts . We present herewith some preliminary ideas on evaluating efficiency and select - ing transformations . Consider the sliding tile puzzles ( e . g . the five puzzle , Section 2 . 5 ) . One possible representation for a move in the puzzle is that a tile is moved in one of four directions , subject to the constraints on the boundary of the board and the constraint that the tile to be moved must be adjacent to the blank position and must be moved in that direction . An isomorphic representation for a move is that the blank position is moved in one of four directions , again subject to the boundary constraints . The difference between these two representations is that the structure of the first representation ( i . e . moving a tile ) admits a large number of illegal moves which must be filtered out by the constraint that the tile be next to the blank position . However , the second representation ( i . e . moving the blank position ) directly incorporates that constraint into the structure . We propose that the second representation may be superior to the first because more information is embodied in the information structure or syntax and less in the constraints , which are part of the information content or semantics . This would be reflected in the difference in information quantity between the structure fields of the two repre - sentations . This heuristic of moving information from constraints into the struc - ture of a representation is a well known strategy in problem solving and is variously referred to as ' moving a tester into the generator ' or ' compiling constraints ' . Another concept is relevant to the issue of finding useful homomorphisms to apply to problems . The homomorphisms applied to the arrow puzzle ( Section 2 . 4 ) and the mutilated checkerboard problem ( Section 2 . 6 ) were motivated by invariant or hereditary properties . In the case of the arrow puzzle , the state resulting from certain classes of move sequences was found to be the same regardless of which 76 R . E . KORF move sequence in the class was applied . In the mutilated checkerboard problem , certain properties of the board were found to be invariant over all possible moves . In both casesr the invariances allowed us to collapse the problem space into a smaller , more abstract space without loss of generality . Indeed , the importance of invariant or hereditary properties is well - known in problem solving 8 . Oyen 10 has developed a computer program to discover invariances in problems . His results are used by Goldstein 13 to automatically generate difference tables for GPS . Another heuristic for generating homomorphisms of state space problems is known as graph decomposition . An abstract space can be derived by partitioning the state space graph into highly intraconnected components that are only weakly interconnected ( see Fig . 4 . 1 ) . Amarel 6 refers to this as finding the ' narrows ' in a graph . This technique could be used to discover the abstract state spaces for the Tower of Hanoi problem ( Section 2 . 3 ) and the five puzzle ( Section 2 . 5 ) . In fact , mathematical algorithms exist for performing this type of graph decomposition 36 , 37 . Fig . 4 . 1 . Graph decomposition 36 . ACKNOWLEDGMENTS I would like to acknowledge many helpful discussions with Herbert Simon concerning this research . Part of this work was done while I was a consultant to the Information Sciences Institute of the University of Southern California . Robert Balzer , Allen Newell , Ranan Banerji , David Jefferson and Paul Hilfinger have provided me with many excellent ideas . In addition , Saul Amarel , Hans Berliner , Diane Detig , Mark Fox , Elaine Kant , Jack Mostow and Walter van Roggen have read and provided helpful comments on drafts of this paper . REFERENCES I . Newell , A . , Heuristic programming : ill structured problems , in : Aronofsky , J . ( Ed . ) , Progress in Operations Research ( John Wiley , New York , 1969 ) . TOWARD A MODEL OF REPRESENTATION CHANGES 77 2 . Newell , A . , Limitations of the current stock of ideas about problem solving , in : Kent , A . and Taulbee , O . ( Eds . ) , Electronic Information Handling ( Spartan Books , Washington , DC , 1965 ) . 3 . Newell , A . , Some examples of problems with several problem spaces , Seminar Notes , Carnegie Institute of Technology ( 1966 ) . 4 . Newell , A . , On the representation of problems , in : Annual research review , Department of Com - puter Science , Carnegie - Mellon University , Pittsburgh , PA ( 1966 ) . 5 . Amarcl , S . , An approach to heuristic problem solving and theorem proving in the propositional calculus , Techn . Rep . R . C . A . Laboratories and Carnegie Institute of Technology ( 1966 ) . 6 . Amarel , S . , On the representations of problems of reasoning about actions , in : Michie , D . ( Ed . ) , Machine Intelligence 3 ( American Elsevier , New York , 1968 ) . 7 . Simon , H . A . , Representations in tic - tac - toe . C . I . P . Working Paper 90 , Carnegie Institute of Technology ( 1966 ) . 8 . Simon , H . A . , On reasoning about actions , in : Simon , H . A . and Siklossy , L . ( Eds . ) , Representation and Meaning ( Prentice - Hall , Englewood Cliffs , N J , 1972 ) . 9 . Simon , H . A . , The Sciences of the Artificial ( M . I . T . Press , Cambridge , MA , 1969 ) . 10 . Oyen , R . A . , Mechanical discovery of invariances for problem solving , Report 1168 , Case Western Reserve University ( June , 1975 ) . 11 . Banerji , R . B . and Ernst , G . W . , Strategy construction using homomorphisms between games , Artificial Intelligence 3 ( 1972 ) 223 - 249 . 12 . Koffman , E . B . , Learning games through pattern recognition , IEEE Trans . Systems , Sci . , and Cybernet . SSC4 ( 1 ) ( March , 1966 ) . 13 . Goldstein , M . M . , The mechanical discovery of problem solving strategies , Report ESCI - 77 - 1 , Case Institute of Technology , Case Western Reserve University ( 1977 ) . 14 . Brown , K . Q . , Geometric transforms for fast geometric algorithms , Thesis , Carnegie - Mellon University Computer Science Department ( August , 1979 ) . 15 . Simon , H . A . , The functional equivalence of problem solving skills , Cognitive Psychol . 7 ( 1975 ) 268 - 288 . 16 . Nilsson , N . J . , Problem Solving Methods in Artificial Intelligence ( McGraw Hill , New York , 1971 ) . 17 . Wickelgren , W . A . , How to Solve Problems . ( W . H . Freeman , San Francisco , CA , 1974 ) . 18 . Schofield , P . , Complete solution of the eight puzzle , in : Collins , N . L . and Michie , D . ( Eds . ) , Machine Intelligence 1 ( American Elsevier , New York , 1967 ) . 19 . Johnson , W . A . and Storey , W . E . , Notes on the ' 15 ' puzzle , Am . J . Math . 2 ( 1879 ) 397 - 404 . 20 . McCarthy , J . , A tough nut for proof procedures , AI Project Memo 16 , Stanford University ( 1964 ) . 21 . Korf , R . E . , A shape independent theory of space allocation , Environment and Planning B 4 ( June , 1977 ) 37 - 50 . 22 . Weinzapfel , G . and Negroponte , N . , Architecture - by - yourself : An experiment with computer graphics for house design , in : Proceedings of SIGGRAPH 76 . ( Association for Computing Mach - inery , Special Interest Group on Graphics , Philadelphia , PA , ( 1976 ) . 23 . Korf R . E . , Notes on computer aided design , Thesis , Department of Electrical Engineering and Computer Science , M . I . T . ( May , 1977 ) . 24 . Newell , A . and Simon , H . A . , Human Problem Solving , ( Prentice - Hall , Englewood Cliffs , N J , 1972 ) . 25 . Codd , E . F . , A relational model of data for large shared data banks , Comm . ACM 13 ( 6 ) ( June , 1970 ) 377 - 387 . 26 . Balzer , R . M . , AP / I : A language for automatic programming , Techn . Rep . RR - 73 - 13 , University of Southern California , Information Sciences Institute ( 1973 ) . 27 . Tannenbaum , A . S . , A tutorial on ALGOL 68 , Comput . Surveys 8 ( 2 ) ( June , 1976 ) 155 - 190 . 28 . Guttag , J . V . , Horowitz , E . and Musser , D . R . , The design of abstract data type specifications , in : Yeh , R . T . ( Ed . ) , Current Trends in Programming Methodologies ( Prentice - Hall , Englewood Cliffs , NJ , 1978 ) . 29 . Fishback , W . J . , Projective and Euclidean Geometry ( John Wiley , New York , 1969 ) . 78 R . E . KORF 30 . Berge , C . , Graphs and Hyperoraphs ( North - Holland , Amsterdam , 1973 ) . 31 . Arbib , M . A . and Manes , E . G . , Arrows , Structures , and Functors : The Categorical Imperative . ( Academic Press , New York , 1975 ) 32 . Garey , M . R . and Johnson , D . S . , Computers and Intractability : A 9uide to the Theory of NP - Completeness ( W . H . Freeman , San Francisco , CA , 1979 ) . 33 . Low , J . R . , Automatic data structure selection : an example and overview , Comm . ACM 21 ( 5 ) ( May , 1978 ) . 34 . Rovner , P . , Automatic representation selection for associative data structures , in : Proceedinys of the National Computer Conference ( American Federation of Information Processing Societies , Anaheim , CA , 1978 ) 691 - 701 . 35 . Kant , E . , A knowledge based approach to using efficiency estimation in program synthesis , in : Proceedinos of the international joint conference on artificial intelligence , Tokyo ( August , 1974 ) 457 - 462 . 36 . Alexander , C . , Notes on the Synthesis of Form ( Harvard University Press , Cambridge , MA , 1964 ) . 37 . Love , S . F . , A new methodology for the hierarchical grouping of related elements of a problem . IEEE Trans . Systems , Man . and Cybernet . SMC - 2 ( January , 1972 ) 23 29 . Received 27 November 1978 ; revised version received 11 October 1979