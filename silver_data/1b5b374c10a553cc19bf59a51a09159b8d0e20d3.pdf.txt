XLWrap – Querying and Integrating Arbitrary Spreadsheets with SPARQL Andreas Langegger and Wolfram W¨oß Institute of Applied Knowledge Processing Johannes Kepler University Linz Altenberger Straße 69 , 4040 Linz , Austria { al | wolfram . woess } @ jku . at Abstract . In this paper a novel approach is presented for generating RDF graphs of arbitrary complexity from various spreadsheet layouts . Currently , none of the available spreadsheet - to - RDF wrappers supports cross tables and tables where data is not aligned in rows . Similar to RDF123 , XLWrap is based on template graphs where fragments of triples can be mapped to speciﬁc cells of a spread - sheet . Additionally , it features a full expression algebra based on the syntax of OpenO ﬃ ce Calc and various shift operations , which can be used to repeat similar mappings in order to wrap cross tables including multiple sheets and spreadsheet ﬁles . The set of available expression functions includes most of the native func - tions of OpenO ﬃ ce Calc and can be easily extended by users of XLWrap . Additionally , XLWrap is able to execute SPARQL queries , and since it is possible to deﬁne multiple virtual class extents in a mapping speciﬁcation , it can be used to integrate information from multiple spreadsheets . XLWrap supports a special identity concept which allows to link anonymous resources ( blank nodes ) – which may originate from di ﬀ erent spreadsheets – in the target graph . 1 Introduction The translation of information stored in various legacy information systems and data formats to RDF is an important requirement of many Semantic Web applications . While for the Web of Data relational database management systems ( RDBMS ) are consid - ered to be the most important legacy information systems , in case of corporate Seman - tic Web applications , spreadsheets play a similar important role . Spreadsheets are fre - quently used by people in companies , organizations , and research institutions to share , exchange , and store data . Whenever there is no database in place , spreadsheets are often the primary fall - back tool for maintaining structured information . Compared to wrapping a relational database , which has a ﬁxed schema , data types , and integrity constraints , wrapping spreadsheets is more di ﬃ cult because the implicit schema has to be captured ﬁrst when creating a formal mapping . Currently available spreadsheet wrappers treat spreadsheets as ﬂat tables like single database relations or comma - separated value ( CSV ) ﬁles . In this paper we will present a novel mapping approach for spreadsheets which is based on template graphs similar to RDF123 [ 5 ] , which we will explain in the related work part . However , the XLWrap mapping ap - proach is not based on a simple row oriented iteration of tables . It allows to deﬁne 351 template mappings as RDF graphs and to repeat them based on various shift and repeat operations in order to map arbitrary layouts including multi - dimensional cross tables and spreadsheets over multiple ﬁles . XLWrap supports expressions to reference cells and ranges from template graphs including sheet ranges and absolute references to other external spreadsheets such as supported by Microsoft Excel and OpenO ﬃ ce Calc ( the grammar is printed in Listing 1 . 1 on page 10 ) . Additionally , XLWrap features a server component called XLWrap - Server , which provides a SPARQL endpoint as well as a linked data browser similar to D2R - Server [ 3 ] . XLWrap - Server observes a conﬁgurable directory for mapping ﬁles and whenever a mapping ﬁle or one of the referred spreadsheet ﬁles of the mapping is added , modi - ﬁed , or removed , it automatically executes the translation process and caches the gen - erated RDF data . XLWrap - Server integrates Joseki [ 6 ] to provide a SPARQL endpoint and Snorql , which has been adopted from D2R - Server and allows the user to explore the wrapped information on - the - ﬂy . Together with the Semantic Web Integrator and Query Engine ( SemWIQ ) [ 7 ] , XLWrap can be used to integrate various spreadsheets and other data sources such as relational databases and ODBC data sources . A simple setup procedure and ease of use have been two major requirements for the development of XLWrap - Server . The setup procedure is a matter of starting the server and putting mapping ﬁles into the observation folder . XLWrap - Server is also considered to become a practical tool for experimenting with linked data . It can be used to quickly expose information via SPARQL while editing it in a human - friendly way . XLWrap can be downloaded from its homepage at http : / / www . langegger . at / xlwrap . In the next section we will explore di ﬀ erent spreadsheet layouts in order to create a sound mapping framework . In Section 3 related work is discussed . In Section 4 the XLWrap mapping formalism is presented and in Section 5 the transformation process is explained . In order to demonstrate XLWrap , an example is discussed as part of these sections . Section 6 concludes the contribution with some ﬁnal remarks . 2 Background In order to develop a generic mapping framework for spreadsheets , the spreadsheet paradigm has been analyzed and di ﬀ erent ways of information representation have been examined . Some of these ﬁndings are presented as part of this section before related work will be discussed . In the following , we will use the terms workbook to refer to a ﬁle of a spreadsheet application , and worksheet ( or just sheet ) to denote a single two - dimensional sheet of a workbook . 2 . 1 Information Representation in Spreadsheets Firstly , it is important to distinguish between the information model and the represen - tation model , which is used to represent information within a spreadsheet . The infor - mation model is deﬁned implicitly by the semantics of the entailed information . The resulting RDF graph should as closely as possible reﬂect the information model , as for example , expenditures by category , year , and sub - division or personal information about employees . The actual information representation as an RDF graph is a subject of 2 352 A1 B1 C1 . . . 10 . . . A1 B1 C1 . . . 12 . . . A1 B2 C1 . . . 23 . . . A1 B1 C1 . . . 21 . . . A1 B3 C2 . . . 23 . . . A2 B2 C2 . . . 12 . . . A2 B3 C1 . . . 24 . . . A1 B1 C1 . . . 34 . . . A B C . . . V1 . . . Dimensions Values typically only one value per record , but multiple values are also valid ( a ) Flat table B ( Columns ) C ( Sheets ) A ( Rows ) ( b ) Three - dimensional cross table B C A D ( Files ) . . . B C A B C A ( c ) Four - dimensional cross table C1 C2 C . . . B ( Columns ) A ( Rows ) SingleSheet ( d ) Cross table on single sheet Fig . 1 . Information representation in spreadsheets . data modeling and in fact , there are many ways how to represent expenditures in RDF . A generic wrapper should not enforce any ﬁxed rules and structures that depend on the representation of the information model in the spreadsheet . Concerning the representa - tion model , three di ﬀ erent layouts could be identiﬁed , whereas the third one is a hybrid approach of the ﬁrst two : One - dimensional ﬂat table : In this layout ( Figure 1 ( a ) ) information is represented , regardless of its dimensionality , in a ﬂat table with a single column ( or row ) head - ing . It is used to represent information such as data lists , e . g . persons with ﬁxed properties such as name , mailbox , age , etc . Except for RDF123 , all existing wrap - pers create exactly one RDF resource per row as shown in Figure 2 ( a ) . Currently available spreadsheet wrappers , which will be discussed in Section 3 , are restricted to this kind of representation . However , ﬂat tables can also be used to represent information with multiple dimen - sions ( typically > 2 ) in so - called de - normalized tables which are also the basis of pivot tables and OLAP programs . Some cells of the header represent dimensions of the information model , the other header cells represent values speciﬁc to each instance . The domain values of dimensions repeatedly occur in the instance rows as shown in Figure 1 ( a ) . Note that regarding the previous example of a person data list , no dimensions will be used and each value is regarded as speciﬁc to the person instance . Alternatively , each person property may be regarded as a dimension or facet ( for instance , the dimension ﬁrst name may have all occurring ﬁrst names as its domain ) . Cross tables : In this layout , which is shown in Figure 1 ( b ) , the representation of in - formation is organized in cross tables , which may span multiple columns , rows , 3 353 URI / bnode cell ( C , i ) cell ( A , i ) A C constant rdf : type cell ( B , i ) B cell ( X , i ) X one statement per column A , B , C , . . . one resource per row i constant statements . . . ( as URI resource ) ( a ) One RDF resource per row dimensions A , B , C , . . . as statements URI / bnode cell value A B C rdf : value constant rdf : type . . . one resource per cell constant statements . . . ( b ) One RDF resource per cell Fig . 2 . Straight - forward translation of spreadsheet data to RDF resources . sheets , and even ﬁles and directories ( Figure 1 ( c ) ) . Each cell represents a single entity or instance . In a straight - forward approach , the translation could be done as shown in Figure 2 ( b ) . Instead of a single column / row header , cross tables have multiple headers , one for each dimension . Along the sheet axis , the header is de - ﬁned either by the names of the sheets in the workbook or by text labels placed into the worksheet . Similarly , when using multiple ﬁles , the domain values of the corresponding axis are either deﬁned by ﬁle names or text labels on worksheets . Because a single sheet is already restricted to columns and rows , cross tables are often represented by repeating similar table layouts on the same sheet as depicted in Figure 1 ( d ) . Similar to pivot tables or de - normalized tables as mentioned before , a higher dimensionality is broken down into two dimensions by repeating similar structures . Hybrid layouts : Finally , there is the possibility of combining ﬂat tables with cross tables ( e . g . de - normalized tables can be repeated across several sheets or ﬁles ) . Independent of the representation model , a wrapper must be able to translate the information into an RDF graph by best reﬂecting the source information model . To give another example , revenues for di ﬀ erent products , years , and countries can either be represented in a de - normalized ﬂat table with the heading ( product , year , country , revenue ) or in a cross table with one sheet per product , each one representing revenues per year and country . 2 . 2 Deﬁnition of Spreadsheet Applications The following deﬁnition for spreadsheet applications is the basis for the mapping frame - work presented in Section 4 . Deﬁnition 1 . A spreadsheet application A is deﬁned as a set of named workbooks w i , i ∈ N 0 , where name ( w i ) is the canonical workbook ﬁlename denoted by its URI . A spreadsheet application has at least one workbook w 0 , called the base workbook and optionally a set of external workbooks w i , i ≥ 1 , which are referenced from w 0 by means of absolute cell references . 4 354 Within companies it is very common that multiple spreadsheets are interlinked by external cell references . To be able to process external references in XLWrap mappings , this deﬁnition takes external workbooks into account . The URI scheme for local ﬁles is file : / / . Workbook ﬁles on the Web can be referenced by means of HTTP URIs . Deﬁnition 2 . A workbook w i ∈ A is deﬁned as a set of named worksheets s j , j ∈ N , where name ( s j ) is the sheet name as speciﬁed in the application ( a string ) . Beside single worksheets , it is also common to use multiple worksheets . As will be shown later , XLWrap supports a special sheet shift operation , which allows to repeat - edly apply template mappings on multiple sheets . Deﬁnition 3 . A worksheet s j ∈ w i is deﬁned as a matrix of cell values V = [ v c , r ] n × m where c ∈ N 0 , c < m , is the column index and r ∈ N 0 , r < n , is the row index of the corresponding worksheet table . m , n denote the total number of columns and rows used in worksheet s j . Although there is a space limit for m and n in practice , there is no limitation enforced by this deﬁnition . The same applies to the number of worksheets in a workbook . Deﬁnition 4 . A cell value v c , r has a type annotation denoted as type ( v c , r ) → T with T = { t text , t number , t datetime , t boolean , t empty } . Additionally , a cell value may have a formatting ( e . g . for number , currency , date / time formatting ) and a formula annotation denoted as formula ( v c , r ) → E , where e ∈ E is a compositional expression according to a pre - deﬁned grammar G E . A cell formula , is not a speciﬁc type ∈ T . Instead , it is an annotation deﬁning the expression which can be evaluated to reproduce or update v c , r . Values with formula an - notations are explicitly stored in the corresponding workbook ﬁles . In our deﬁnition of spreadsheet applications , the grammar G E supports range references denoted as e ref . Range references are used to refer to other cells of the same spreadsheet , other sheets of the same workbook , or external workbooks . In Section 4 it will be described , how ex - pressions and range references are also used for XLWrap mappings to map spreadsheet cells to RDF graphs . The proper deﬁnition of a range reference is given below . Deﬁnition 5 . A range reference sub - expression e ref is generally deﬁned as a set of partial 7 - tuples of the form ( w i , s j 1 , c 1 , r 1 , s j 2 , c 2 , r 2 ) . These components specify a workbook , a start cell consisting of a sheet , column , row , as well as a target cell spec - iﬁed by a sheet , column , and row . Some tuple components are optional and may be left empty . If | e ref | > 1 , the range reference is called multi range reference , because it con - tains multiple single range references . In case of OpenO ﬃ ce Calc , the general lexical representation of a single range reference is : ( ( w i ” # $ ” ) ? s j 1 ” . ” ) ? c 1 r 1 ( ” : ” ( s j 2 ” . ” ) ? c 2 r 2 ) ? For multi range references , single range references are separated with a semicolon . The following two sub - types are deﬁned : 5 355 – Cell reference , which has the optional components w i , s j 1 , the mandatory compo - nents c 1 , r 1 , and the component s j 2 , c 2 , r 2 left empty ( e . g . A3 , ’Sheet 1’ . A3 , or file : foo . xls # $ ’Sheet 1’ . A3 ) – Box reference , which has the optional components w i , s j 1 , s j 2 and the mandatory components c 1 , r 1 , c 2 , r 2 ( e . g . A3 : B9 , or file : foo . xls # $ ’Sheet 1’ . A3 : B28 . Whenever the components w i and s j 1 , s j 2 are omitted , the range reference is inter - preted relative to the worksheet of its originating cell formula . Hence , a range reference can either be absolute or relative its base sheet or workbook ﬁle . 2 . 3 Dumping versus On - the - ﬂy Processing of SPARQL Queries Concerning the wrapping approach , a distinction can be made based on the direction of the mapping formalism , which can either be source / spreadsheet - centric , or target / RDF - centric . In general , when mapping between two di ﬀ erent data models , it is possible to deﬁne one of the data models as a view onto the other data model . Since in our case , the RDF model acts as the target model , the spreadsheet - centric variant is similar to the Local - as - View ( LaV ) approach and the RDF - centric variant is similar to the Global - as - View approach ( GaV ) in information integration [ 8 ] . Only XLWrap and RDF123 , support the GaV - approach and allow the user to deﬁne RDF - centric mappings based on graphs . All other wrappers are based on a spreadsheet - centric view deﬁnition which map columns or cells to speciﬁc properties and do not allow the deﬁnition of custom target graphs . Another distinction can be made concerning the actual transformation of spread - sheet data into RDF when executing SPARQL queries . For queries , the wrapping pro - cess can either be based on materialization involving a single data dump into a volatile or persistent RDF store , or it can be an on - the - ﬂy query execution process ( e . g . D2R - Server [ 3 ] ) . Actually , our initial motivation for developing XLWrap have been experi - ments towards a generic guideline for the generation of virtual RDF wrappers support - ing SPARQL for the Semantic Web Integrator and Query Engine ( SemWIQ ) . Based on experiences with D2R - Server while contributing some optimizations like push - down of ﬁlters into SQL , our assumption was , that simple RDF wrappers can be written based on Jena ARQ by supporting triple patterns and let ARQ process all higher level algebra operations . For instance , a wrapper providing SPARQL access to the directory structure of a ﬁle system or an FTP server can be written very easily this way . It only needs to cor - rectly interpret subsequent triple patterns and generate the necessary variable bindings which correspond to a virtual RDF graph similar to a database access plan . However , for larger information sources , low - level index structures such as hash tables or B + trees are necessary in order to achieve acceptable performance results . They may be managed by the wrapper in volatile memory caches and will have to be updated by means of a notiﬁcation mechanism or pre - deﬁned periods . Additionally , a wrapper for a large data source should provide cardinality estimations for triple patterns in order to support the re - ordering in a BGP by expected cardinalities . During the evaluation of a BGP , subse - quent joins over triple patterns are executed by ARQ based on a substitute algorithm : already obtained variable bindings of triples produced by upper triple patterns are used 6 356 as constraints for matching subsequent triple pattern . Thus , triple patterns with a lower cardinality should be executed ﬁrst . However , experiments have shown that in most situations it is still better to apply a materialized approach and dump data into an RDF store instead of maintaining separate index structures and insisting on the virtual approach . In particular , these ﬁndings apply to spreadsheets , because they are typically small in size ( compared to databases ) and there is actually no need to process queries on - the - ﬂy . In fact , the dumping process is so fast , that even if the materialized cache has to be re - generated , it is only a matter of seconds or milliseconds . XLWrap tracks any changes in mapping ﬁles and referenced workbook ﬁles and re - generates caches in the background which is hardly noticed by end - users . 3 Related Work Among the currently available spreadsheet wrappers there are two open source projects , Excel2RDF [ 4 ] and RDF123 [ 5 ] , and there is TopBraid Composer from TopQuadrant 1 , which is a commercial ontology development environment integrating support for im - porting and exporting RDF from / to spreadsheet ﬁles . We were unable to ﬁnd any further spreadsheet RDF wrapper in the literature and on the Web . There is another notable software called Anzo for Excel from Cambridge Semantics 2 , which is actually not a dedicated RDF wrapper , but which can be used to map information from spreadsheets to vocabularies for distributed , collaborative work . Because Anzo is targeted to em - ployees who typically do not know about RDF , it hides any details of the internals . Although it provides a graphical plugin for Microsoft Excel , which allows to map cells and ranges to vocabularies , it is unclear how it can be used to map spreadsheets to cus - tom graphs . As a marginally related project the Aperture 3 framework developed for the Nepomuk Semantic Desktop is mentioned , which is extracting meta data from spread - sheet ﬁles . However , the content of spreadsheets is not processed or wrapped based on a formalized mapping . Instead , Aperture tries to extract signiﬁcant features and terms from spreadsheets in order to support semantic search and interlinking of documents in the Nepomuk framework . Unfortunately , nearly all existing dedicated wrappers are rather limited in practice . The simplest one is Excel2RDF and an extended version called ConvertToRDF , which supports basic mappings for column headers . As both tools follow the spreadsheet - centric mapping approach , the output graph is ﬁxed and for each row of only a single spreadsheet table , one RDF resource is created with property / object pairs for all mapped columns . Resources as objects or typed literals are not supported . The spreadsheet im - port feature of TopBraid Composer is similarly basic . Actually , only CSV text ﬁles are supported and the mapping is similar to ConvertToRDF . Typed literals and resource objects are supported , but target types have to be speciﬁed manually . The most relevant wrapper related to our work is RDF123 [ 5 ] . Beside XLWrap , it is the only wrapper that supports an RDF - centric mapping approach . However , although 1 http : / / www . topquadrant . com 2 http : / / www . cambridgesemantics . com / 3 http : / / aperture . sourceforge . net / 7 357 with RDF123 it is possible to deﬁne arbitrary target graphs , it is restricted to a speciﬁc spreadsheet layout , like all of the other existing wrappers . It only supports ﬂat tables as shown in Figure 1 ( a ) of the previous section . The available prototype is capable of reading CSV text ﬁles but does not support Excel or OpenO ﬃ ce spreadsheets . An RDF mapping in RDF123 is described as part of the spreadsheet itself in a special meta data section starting with the speciﬁc label rdf123 : metadata . Among several Dublin Core metadata , the section speciﬁes the start row , the end row , the start column , whether there is a row header which has to be skipped , and the URI of the template graph used for producing the results . When processing a spreadsheet , the execution engine scans the sheet for the metadata section and if it cannot be found , the complete sheet ( only one worksheet is supported ) is wrapped in a similar way as with Excel2RDF . If the metadata section is found , the execution engine retrieves the template graph from the speciﬁed location . The template graph is an RDF graph which may contain references to the columns of the current row being processed to generate nodes based on values obtained from the spreadsheet . Thus , the execution process is ﬁxed to one row by row iteration . In order to refer to the columns of the active row being processed , expressions can be speciﬁed as special literals and faked URIs as for example " Ex : $ 1 " and < Ex : $ 1 > , which both refer to the ﬁrst column . Unfortunately , this approach has the following severe consequences : all other literals starting with Ex : will be matched as expressions and cause errors . Furthermore , because expressions may contain spaces and special characters , encoding them as URIs ( with Ex : as a pseudo protocol ) will cause further troubles at runtime and lead to incompatibilities with other systems . RDF123 provides a GUI which facilitates the process of creating mappings . How - ever , the tool only provides a viewer for CSV ﬁles and a basic graph designer which both are not combined in any special way . The graph designer uses a proprietary format to store graphs speciﬁc to the Open JGraph library , which has been used . Developing a powerful graphical support tool is not easy and requires a lot of e ﬀ ort . It would be desirable for a graphical mapping tool to provide features speciﬁc to the mapping pro - cess such as drag and drop , highlighting of referenced cells , and a simulation feature for debugging the wrapping process . Because XLWrap can be used to semantically integrate di ﬀ erent spreadsheets and to query the entailed information based on logical inference , it can also be compared to the system proposed by [ 9 ] which is called LESS for Logic Embedded in SpreadSheets . Instead of writing typical numerical formulas into the cells of a spreadsheet , LESS allows to logically annotate facts and use logical functions for calculations . 4 XLWrap Mapping Formalism XLWrap is based on an RDF - centric mapping approach which allows to map the in - formation stored in a spreadsheet to arbitrary RDF graphs independent from the rep - resentation model as discussed in Section 2 . Similar to RDF123 , the output graph is deﬁned by means of template graphs which are repeatedly applied during the wrapping process . With XLWrap expressions it is possible to refer to arbitrary cells and combine them with expressions like in spreadsheet applications . 8 358 4 . 1 XLWrap Mappings In the following , XLWrap mappings are deﬁned based on the deﬁnitions of Sect . 2 . Deﬁnition 6 . An XLWrap mapping M is deﬁned as a set of map templates m k , k ∈ N . Deﬁnition 7 . A map template m k = ( w k , s k , C k , G k , F k ) consists of the following com - ponents : a base workbook w k ∈ w i , a base worksheet s k ∈ s j , a constant RDF graph C k , an RDF template graph G k , and a sequence of transform operations F k = ( f l ) , l ∈ N . Deﬁnition 8 . A constant graph C k and a template graph G k are valid RDF graphs , according to the W3C speciﬁcation , which may contain literals of the custom data type xl : Expr called XLWrap expressions 4 . Deﬁnition 9 . A transform operation f l can modify the template graph G k and change range references in expressions . During the wrapping process , each map template m k ∈ M contributes a sub - graph [ [ G k ] ] to the overall result similar to RDF123 , but with the di ﬀ erence that a graph template is not moved from the ﬁrst row to the last one in a ﬁxed direction , instead , it is moved based on the transformation sequence deﬁned by ( f l ) . The bracket notation [ [ . . . ] ] is used to denote the application of a template graph including the evaluation of all XLWrap expressions . While C k is evaluated and merged into the target graph once , the template graph G k is subsequently transformed by ( f l ) and evaluated multiple times . If | F k | = 0 , no transformations are speciﬁed and G k is applied once in its initial form . Because by deﬁnition subjects and predicates cannot be literals , in order to specify XLWrap expressions for subjects or predicates , they have to be wrapped in blank nodes as part of the template graph . The special property xl : uri is then used to replace these blank nodes by URI resources in the target graph . Similarly , the property xl : id can be used to link blank nodes : XLWrap will produce blank nodes with equal local IDs in the target graph Deﬁnition 10 . An XLWrap expression is deﬁned as a compositional expression of basic expression symbols similar to spreadsheet formulas ( see Deﬁnition 4 ) . XLWrap expres - sions are parsed from the lexical representation by the custom data type implementa - tion 5 according to the grammar deﬁned in Listing 1 . 1 . Range references , including cell , box , and multi range references are supported as speciﬁed in Deﬁnition 5 . Additionally , XLWrap supports the special range types null range , full sheet range , and any range , which are lexically denoted as the empty string , ( s j ” . * ” ) , and ” * . * ” . Depending on the semantics of operations and functions , only speciﬁc range sub - types are valid 6 . Optionally , a worksheet s j can be preﬁxed with ” # ” and speciﬁed by the sheet number starting with 1 ( e . g . ” # 1 . A1” , ” # 3 . * ” ) . 4 The full namespace for the preﬁx xl : is http : / / langegger . at / xlwrap / vocab \ # . 5 In Jena it is possible to register a custom data type handler by extending BaseDatatype . 6 For example , while SUM ( ) takes any range reference and also numbers as arguments ( the number of arguments is not restricted ) , the expression " A3 : B5 " is invalid , since it is only possible to obtain values from a single cell . 9 359 XLExpression = " = " ? OrExpr < EOF > OrExpr = AndExpr ( " | | " AndExpr ) * AndExpr = Comparable ( " & & " Comparable ) * Comparable = Concatable ( CompOp Concatable ) * Concatable = Expr ( " & " Expr ) * Expr = Term ( ( " + " | " - " ) Term ) * Term = Factor ( ( " * " | " / " ) Factor ) * Factor = Atom ( " ˆ " Atom ) * Atom = ( " + " | " - " | " ! " ) ( < NUMBER > ( " % " ) ? | ( < TRUE > | < FALSE > ) | < STRING > | < CELLRANGE > | " ( " Concatable " ) " ( " % " ) ? | < FUNCIDENT > " ( " ( Concatable ( ( " , " | " ; " ) Concatable ) * ) ? " ) " ( " % " ) ? ) CompOp = " < = " | " < " | " > = " | " > " | ( " ! = " | " < > " ) | ( " = = " | " = " ) Listing 1 . 1 . Grammar of XLWrap expressions XLWrap supports all standard arithmetic and also logical operators , string concate - nation , and an extensible function library ( additional implementations can be easily added at runtime ) . The most important functions for string manipulation , including SHA - 1 hashing ( which , for instance , is required for foaf : mbox sha1sum property val - ues in FOAF applications ) , type casting ( to enforce speciﬁc literal data types in the RDF output ) , aggregate functions such as SUM ( ) , which takes cell , box , and multi ranges as arguments , have already been implemented . The following transform operations are available in the current implementation : – column shift : f ColumnShift ( d , n , z , e c ) – row shift : f RowShift ( d , n , z , e c ) – sheet shift : f SheetShift ( d , n , z , e c ) – sheet repeat : f SheetRepeat ( ( g i ) , z , e c ) – ﬁle repeat : f FileRepeat ( ( h i ) , z , e c ) Common to all operations is z , a multi range reference , which can be used to restrict the transform operation on a set of ranges ( default is AnyRange ) and e c can be a logical XLWrap expression , which is evaluated each time before the transformation is applied ( default is true ) . For all the shift operations d is the amount of columns / rows / sheets to shift ( defaults to 1 ) , n is the number of times to apply the operation ( defaults to the maximum integer value of the runtime system ) , and for the repeat operations , ( g i ) and ( h i ) , respectively , specify the set of sheets or ﬁles to apply the template for . In order to dynamically wrap evolving spreadsheets , n can be omitted and the iteration can be controlled based on the condition e c . As a consequence , the transform operation will be repeated until the condition evaluates to false . For convenience , the special function EMPTY ( e ref ) , which takes a multi range argument and returns true if all cells in e ref are empty , can be used to detect the end of a data range in the spreadsheet . 10 360 As mentioned along with Deﬁnition 5 , a range reference can be absolute or relative . Relative range references are extended during the mapping process by the base work - book w k and base worksheet s k deﬁned in the mapping M . For example , ”A3” may refer to ”ﬁle : foo . xls # $ Sheet1 . A3” at runtime . The sheet / ﬁle repeat transformations will override the sheet / ﬁle component as needed , but absolute range references are never modiﬁed by transform operations . There are special expression functions which can be used to track the origin of the generated RDF triple by obtaining the current ﬁle - name , sheet name , sheet number , row and column of a cell at runtime : FILENAME ( ) , SHEETNAME ( ) , SHEETNUM ( ) , COLUMN ( ) , and ROW ( ) . All these functions take a cell range as an argument . 4 . 2 Example Mapping The source data for the example is printed in Table 1 . The workbook w 0 used for this demonstration contains two sheets s 1 , s 2 of information on revenues of a company . For each country the company operates in , revenues are organized in a cross table containing sold items and total revenue per product and year . As can be seen , data for 2008 is missing for Germany , and there is one more product for Germany . Table 1 . Source data for the discussed example ( s 1 , s 2 ∈ w 0 ) . Austria 2007 2008 2009 product items sold revenue items sold revenue items sold revenue Product 1 342 7 , 866 . 00 376 8 , 648 . 00 490 11 , 760 . 00 Product 2 4 , 333 1 , 005 , 256 . 00 5 , 655 1 , 328 , 925 . 00 3 , 493 838 , 320 . 00 Product 3 3 , 312 1 , 136 , 016 . 00 4 , 566 1 , 598 , 100 . 00 5 , 993 1 , 917 , 760 . 00 Product 4 45 19 , 350 . 00 56 24 , 304 . 00 54 23 , 328 . 00 Totals 8 , 032 2 , 168 , 488 . 00 10 , 653 2 , 959 , 977 . 00 10 , 030 2 , 791 , 168 . 00 Germany 2007 2009 product items sold revenue items sold revenue Product1 2 , 431 55 , 913 . 00 3 , 419 82 , 056 . 00 Product2 31 , 230 7 , 339 , 050 . 00 32 , 123 7 , 709 , 520 . 00 Product3 23 , 121 8 , 092 , 350 . 00 31 , 039 9 , 932 , 480 . 00 Product4 3 , 423 1 , 198 , 050 . 00 3 , 412 1 , 091 , 840 . 00 Product5 121 52 , 514 . 00 312 134 , 784 . 00 Totals 60 , 326 16 , 737 , 877 . 00 70 , 305 18 , 950 , 680 . 00 Depending on the desired target graph , C k , G k , andF k can be speciﬁed di ﬀ erently . For instance , the target graph could be modeled as one resource per country having linked resources for all products , and years . A more direct representation of the multi - dimensional information is deﬁned in the example mapping shown in Listing 1 . 2 . We will describe the generation process for this mapping in the next section . A third rep - resentation using the Statistical Core Vocabulary 7 ( SCOVO ) is provided as part of the 7 http : / / purl . org / NET / scovo 11 361 distribution ( mappings / iswc09 - example . trig ) . In order to be able to include the template graphs in the mapping speciﬁcation , the TriG syntax 8 , which allows to de - note named graphs , is used . XLWrap searches for an instance of xl : Mapping in all graphs and starts parsing the speciﬁcation . The XLWrap mapping vocabulary , which is published at http : / / www . langegger . at / xlwrap / vocab # , corresponds to the deﬁ - nitions provided in Section 4 . 1 . @ prefix rdf : < http : / / www . w3 . org / 1999 / 02 / 22 − rdf − syntax − ns # > . @ prefix xl : < http : / / langegger . at / xlwrap / vocab # > . @ prefix ex : < http : / / example . org / > . @ prefix : < http : / / myApplication / mapping # > . { [ ] a xl : Mapping ; xl : template [ xl : fileName ” files / testing / iswc09 − example . xls ” ; xl : sheetNumber ”0” ; xl : templateGraph : Revenues ; xl : transform [ a rdf : Seq ; rdf : 1 [ a xl : RowShift ; xl : restriction ”A4 ; B4 : C4” ; xl : condition ”LEFT ( A4 , 7 ) = = ’Product ’” ; xl : steps ”1” ] ; rdf : 2 [ a xl : ColShift ; xl : restriction ”B2 ; B4 : C4”ˆˆ xl : Expr ; xl : condition ” ! EMPTY ( B4 : C4 ) ” ; xl : steps ”2” ] ; rdf : 3 [ a xl : SheetShift ; xl : restriction ” # 1 . * ”ˆˆ xl : Expr ; xl : repeat ”2” ] ; ] ] . } : Revenues { [ xl : uri ”’ http : / / example . org / revenue ’ & URLENCODE ( SHEETNAME ( A1 ) & ’ ’ & B2 & ’ ’ & A4 ) ”ˆˆ xl : Expr ] a ex : Revenue ; ex : country ”DBP COUNTRY ( SHEETNAME ( A1 ) ) ”ˆˆ xl : Expr ; ex : year ”DBP YEAR ( B2 ) ”ˆˆ xl : Expr ; ex : product ”A4”ˆˆ xl : Expr ; ex : itemsSold ”B4”ˆˆ xl : Expr ; ex : revenue ”C4”ˆˆ xl : Expr . } Listing 1 . 2 . Example mapping speciﬁed in TriG syntax In our approach , the mapping is stored separately from the actual spreadsheet ﬁles and not as part of them . It is assumed that the creator of the mapping ﬁle may not have the authorization or possibility to modify spreadsheet ﬁles to be wrapped . XL - Wrap is capable of loading local ﬁles and downloading spreadsheet ﬁles from the Web . Currently , Excel ﬁles , Open Document spreadsheets , and also CSV ﬁles are supported ( although they could also be wrapped with other tools ) . The layout of CSV ﬁles ( de - limiters , separators , white spaces ) can be speciﬁed . CSV ﬁles are streamed in order to support large data ﬁles . The implementation simulates a workbook and requests new rows from the input stream as needed by the execution engine . Because a single tem - plate graph typically refers to a small section of the whole spreadsheet , it is su ﬃ cient to keep the last n ( where n = 1000 by default ) rows in a cache . 8 http : / / www4 . wiwiss . fu - berlin . de / bizer / TriG / 12 362 5 Transformation Process To give an overview of the transformation process , a ﬂow chart is depicted in Figure 3 . For each map template m k ∈ M , C k and all generated template graphs q i are evalu - ated based on the current state of the execution context X , which contains a reference to the currently processed map template m k ( activeTmpl ) in order to retrieve w k and s k . The base workbook w k and the base worksheet s k are required for the evaluation of relative range references and obtaining values from the cells of the spreadsheets . The execution context also contains a reference to the target graph ( targetGraph ) where the generated statements are inserted . While in Section 4 we used [ [ G k ] ] to denote the evaluation of G k including the application of transform operations F k , the notation of [ [ C k ] ] X and [ [ q i ] ] X in the ﬂow chart only represents the evaluation of XLWrap expres - sions for the given graphs C k and q i . The application of F k is completely hidden by the TemplateModelGenerator , which subsequently applies the deﬁned transform opera - tions f l ∈ F k against G k and returns multiple template graphs q i . X : = new ExecutionContext ( ) M : = MappingParser . parse ( < ﬁle > ) M has more templates ? G k = templateModel ( m k ) F k = transformOperations ( m k ) Q : = new TemplateModelGenerator ( X , G k , F k ) m k : = next map template X . activeTmpl : = m k Q has more tmpl models ? true q i : = next template model addStatements ( [ [ q i ] ] X , X . targetGraph ) true C k : = constantModel ( m k ) addStatements ( [ [ C k ] ] X , X . targetGraph ) false false return X . targetGraph Fig . 3 . Overview of the wrapping process . The TemplateModelGenerator is implemented as an iterator which uses a se - quence of stacked instances of TransformationStage – one for each transform op - eration f l . Each stage transforms its current stage graph q f l i 1 , . . . , i n according to the cor - responding transform operation as depicted in Figure 4 . Initially , all stage graphs are equal to the template graph : q f l 0 , . . . , 0 = G k . The blue nodes on the bottom represent ﬁ - nal template graphs which are returned by TemplateModelGenerator . Each call to TemplateModelGenerator . hasNext ( ) results in a transformation at the lowest stage that has more transformations to apply . For example , if there are no more rows to shift by f 1 , the corresponding stage triggers its parent stage and tracks back its internal state . Likewise , if the condition deﬁned for the transform operation does not hold , it is skipped and the parent stage is triggered . 13 363 q f30 q f20 , 0 q f20 , 1 q f20 , n2 initial column q f10 , 0 , 0 q f10 , 0 , 1 q f10 , 0 , n1 initial row G k initial sheet f 3 : sheet shift f 2 : column shift f 1 : row shift shift row shift column next sheet parentstage parentstage null . . . q f10 , 1 , 0 q f10 , 1 , 1 q f10 , 1 , n1 shift row . . . . . . q f10 , n2 , n1 . . . . . . q f1n3 , n2 , n1 q f2n3 , n2 q f3n3 . . . parent . proceed ( ) parent . proceed ( ) parent . proceed ( ) parent . proceed ( ) initial row parent . proceed ( ) parent . proceed ( ) parent . proceed ( ) parentstage Fig . 4 . Transform stages for the mapping speciﬁcation of Listing 1 . 2 . When a template graph is applied , before its triples are added into the target graph , any blank node with a xl : uri property is replaced with a URI node , blank node labels with equal xl : id properties are aligned , and any xl : Expr literal is evaluated as an XLWrap expression e . The result of [ [ e ] ] is an instance of XLExprValue , which can be a URI , blank node , string , long integer , double , boolean , or date value . When obtaining cell values , the type is automatically detected based on the type annotation ( Deﬁnition 4 ) . When creating literals for the target graph , long integers and ﬂoats are automatically reduced to the required size as long as they have not been explicitly casted with a type casting function before . Depending on the type , a matching typed literal is created . For the example spreadsheet given in Table 1 , after applying the mapping in Listing 1 . 2 , the following triples are generated : ex : revenue _ Austria _ 2007 _ Product1 a ex : Revenue ; ex : country < http : / / dbpedia . org / resource / Austria > ; ex : itemsSold " 342 " ˆˆ < http : / / www . w3 . org / 2001 / XMLSchema # short > ; ex : product " Product1 " ; ex : revenue " 7866 " ˆˆ < http : / / www . w3 . org / 2001 / XMLSchema # int > ; ex : year < http : / / dbpedia . org / resource / 2007 > . ex : revenue _ Austria _ 2007 _ Product2 a ex : Revenue ; ex : country < http : / / dbpedia . org / resource / Austria > ; ex : itemsSold " 4333 " ˆˆ < http : / / www . w3 . org / 2001 / XMLSchema # short > ; ex : product " Product2 " ; ex : revenue " 1005256 " ˆˆ < http : / / www . w3 . org / 2001 / XMLSchema # int > ; ex : year < http : / / dbpedia . org / resource / 2007 > . ex : revenue _ Austria _ 2007 _ Product3 . . . ex : revenue _ Austria _ 2007 _ Product4 . . . ex : revenue _ Austria _ 2008 _ Product1 . . . . . . ex : revenue _ Austria _ 2009 _ Product1 . . . . . . ex : revenue _ Germany _ 2007 _ Product1 . . . . . . ex : revenue _ Germany _ 2009 _ Product1 . . . . . . ex : revenue _ Germany _ 2009 _ Product5 . . . Range reference sub - expressions of the stage template graph q f 10 , 0 , 0 = G k are shifted down by one row ﬁrst until the condition LEFT ( A4 , 7 ) = = ’Product’ is false , pro - 14 364 ducing resources for all products sold in Austria in 2007 . However , only those range references within the range restriction z f 1 = " A4 ; B4 : C4 " are actually transformed . For instance , the expression " A4 " ( literal for ex : product ) is subsumed by the restric - tion range and is therefore changed to " A5 " , but " DBP YEAR ( B2 ) " remains unchanged . Next , q f 20 , 1 is calculated by a 2 - step column shift of q f 20 , 0 . The stage model of the sub - stage is initialized as q f 10 , 1 , 0 : = q f 20 , 1 for the next execution of f 1 ( row shift ) . If both , f 1 and f 2 have no more transformations ( or both stage conditions do not hold ) , the sheet is shifted according to f 3 , producing similar RDF data for Germany . Transform operations are not only applied to range references in xl : Expr literals of q f l i 1 , . . . , i n , they must be applied also to the range restrictions z f l and to the conditions e f l c of the corresponding transform operations . For instance , the range restriction on the row shift " A4 ; B4 : C4 " has to be shifted to " A5 ; B5 : C5 " in the ﬁrst stage and then to " A4 ; D4 : E4 " , " A5 ; D5 : E5 " , and " A4 ; F4 : G4 " , " A5 ; F5 : G5 " , etc . in the second stage . When proceeding at the second stage , the transformation of the original f 1 - restriction is itself restricted by the current range restriction of f 2 , which is " B2 ; B4 : C4 " . As visualized in Figure 5 , thus only a subset of " A4 ; B4 : C4 " is shifted lead - ing to " A4 ; D4 : E4 " . Currently , XLWrap is not capable of automatically splitting arbi - trary box ranges based on restrict ranges . This is why , ”A4 ; B4 : C4” was not speciﬁed as ”A4 : C4” in the mapping 9 . However , intersections of box ranges are detected during the initialization of a map template in order to be corrected . 1 2 3 4 5 A B C D E shift 2 columns F 1 2 3 4 5 A B C D E F Fig . 5 . Column shift of range restriction ”A4 ; B4 : C4” restricted by ”B2 ; B4 : C4” . 6 Conclusion In this contribution we have presented XLWrap , which is an RDF - centric mapping ap - proach to support the transformation of spreadsheets with di ﬀ erent representation mod - els to arbitrary RDF graphs . The mapping concept has been formally deﬁned and im - plemented based on the Jena Semantic Web framework . The server component called XLWrap - Server was not further discussed due to the page limit . It is a stand - alone Web application based on Joseki and Snorql from the D2R - Server project including a SPARQL endpoint and a linked data interface . XLWrap is powerful enough to represent mappings for spreadsheets with di ﬀ er - ent representation models and target graphs . Because it supports external references , 9 Especially in combination with the multi sheet and any range , ranges cannot be split straight - forward and the implementation would additionally require support for exclusion ranges . 15 365 HTTP URLs , and the wrapping of multiple spreadsheets into a combined cache includ - ing OWL inference , it can be used very easily to semantically integrate multiple spread - sheets locally or in intranets and extranets . The possibility of adding custom functions – which is a matter of extending XLExprFunction and providing an implementation for eval ( ) – can be very practical for end - users . Beside adding custom mathematical and statistical functions , it is possible to access a database or Web resources by XLWrap functions . The future support for aggregate functions in SPARQL is a very important requirement in order to support typical operations on spreadsheet data . Future work will include the development of a graphical support tool including some kind of mapping debugger and auto - detection of cross - tables to facilitate the mapping speciﬁcation task . Considerable work regarding auto - detection of headers and units has already been published [ 1 , 2 ] . Acknowledgements This work is funded by the Austrian BMBWK ( Federal Ministry for Education , Science and Culture ) , contract GZ BMWF - 10 . 220 / 0002 - II / 10 / 2007 . We would like to thank Bernhard Haslhofer , Bernhard Schandl , Thomas Leitner , and Berndt Zinn ¨ ocker for the helpful inputs and discussions held during the implementation of XLWrap . References 1 . Robin Abraham and Martin Erwig . Header and unit inference for spreadsheets through spatial analyses . In VLHCC ’04 : Proceedings of the 2004 IEEE Symposium on Visual Languages - Human Centric Computing , pages 165 – 172 , Washington , DC , USA , 2004 . IEEE Computer Society . 2 . Chris Chambers and Martin Erwig . Dimension inference in spreadsheets . In VLHCC ’08 : Pro - ceedings of the 2008 IEEE Symposium on Visual Languages and Human - Centric Computing , pages 123 – 130 , Washington , DC , USA , 2008 . IEEE Computer Society . 3 . Richard Cyganiak and Christian Bizer . D2R Server – Publishing Relational Databases on the Web as SPARQL Endpoints . In Developers Track at the 15th International World Wide Web Conference ( WWW2006 ) , Edinburgh , Scotland , May 2006 . 4 . Mindswap Group and Ronald P . Reck . Excel2RDF . http : / / www . mindswap . org / ˜rreck / excel2rdf . shtml . Last visit : June 2009 . 5 . Lushan Han , Tim Finin , Cynthia Parr , Joel Sachs , and Anupam Joshi . RDF123 : From Spread - sheets to RDF . In 7th International Semantic Web Conference ( ISWC2008 ) , October 2008 . 6 . HP Labs , Bristol , UK . Joseki – A SPARQL Server for Jena . http : / / www . joseki . org / . Last visit : June 2009 . 7 . Andreas Langegger and Wolfram W¨oß . SemWIQ – Semantic Web Integrator and Query Engine . In Heinz - Gerd Hegering , Axel Lehmann , Hans - J¨urgen Ohlbach , and Christian Schei - deler , editors , Beitr¨age der 38 . Jahrestagung der Gesellschaft f¨ur Informatik e . V . ( GI ) , vol - ume 1 . Bonner K¨ollen Verlag , 2008 . 8 . Maurizio Lenzerini . Data integration : a theoretical perspective . In PODS ’02 : Proceedings of the twenty - ﬁrst ACM SIGMOD - SIGACT - SIGART symposium on Principles of database sys - tems , pages 233 – 246 , New York , NY , USA , 2002 . ACM . 9 . Andre Valente , David Van brackle , Hans Chalupsky , and Gary Edwards . Implementing logic spreadsheets in less . Knowl . Eng . Rev . , 22 ( 3 ) : 237 – 253 , 2007 . 16 366