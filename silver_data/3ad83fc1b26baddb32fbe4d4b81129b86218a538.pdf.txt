Published in the Proceedings of the 2000 ACM Conference on Computer Supported Cooperative Work ( CSCW’00 ) , Philadelphia , PA , December 2 – 6 , 2000 . Expertise Recommender : A Flexible Recommendation System and Architecture David W . McDonald and Mark S . Ackerman Department of Information and Computer Science University of California , Irvine Irvine , CA 92697 - 3425 { dmcdonal , ackerman } @ ics . uci . edu ABSTRACT Locating the expertise necessary to solve difficult problems is a nuanced social and collaborative problem . In organiza - tions , some people assist others in locating expertise by making referrals . People who make referrals fill key orga - nizational roles that have been identified by CSCW and affiliated research . Expertise locating systems are not de - signed to replace people who fill these key organizational roles . Instead , expertise locating systems attempt to de - crease workload and support people who have no other options . Recommendation systems are collaborative soft - ware that can be applied to expertise locating . This work describes a general recommendation architecture that is grounded in a field study of expertise locating . Our exper - tise recommendation system details the work necessary to fit expertise recommendation to a work setting . The archi - tecture and implementation begin to tease apart the techni - cal aspects of providing good recommendations from social and collaborative concerns . Keywords Recommendation systems , collaborative filtering , expert locators , expertise location , expertise finding , information seeking , CSCW , computer - supported cooperative work . INTRODUCTION Everyday , people face difficult problems that they cannot solve alone . In these situations the right people are the ones who have the expertise to answer a specific question or in some other way move the problem toward resolution . In organizational settings , people fill key roles that assist in solving problems or initiating important collaborations . Managers , senior employees , gurus , information mediators [ 4 ] , and expertise concierges [ 13 ] are sought because of their ability to solve problems directly or make well in - formed referrals . The ability to fill this role makes these individuals valuable to the organization and makes it ap - parent when they are unavailable . Recommendation systems are one possible technology that can augment and assist the natural expertise locating be - havior in organizations . A recommendation system that suggests people who have some expertise with a problem holds the promise to provide , in a very small way , a service similar to that provided by key people . Expertise recom - mendation systems can reduce the load on people in these roles and provide alternative recommendations when these people are unavailable . This work presents an architecture and implementation of the Expertise Recommender system ( ER ) . ER offers several advances over previously existing systems : • The architecture is open and flexible enough to address different organizational environments . If CSCW sys - tems , and specifically recommender systems , are situ - ated in their activity , organizationally specific compo - nents will be necessary within any general - purpose framework . Recommender systems , to date , have been “one size fits all” . • Organizationally specific implementations are more robust by teasing apart technical aspects of making good recommendations from the social and collabora - tive aspects of matching individuals . We do this based on findings from an earlier field study . • The work proposes an alternative approach to the creation and maintenance of user profiles than ratings . This approach uses organizationally relevant data sources to create profiles that are more suited for automated expertise location . Each of these claims will be covered below . We begin this paper with an overview of prior systems that support expertise locating . Next , we consider what it means to seek expertise socially , in order to firmly ground the requirements of our system . We follow with a description of our system , Expertise Recommender ( ER ) . A small sce - nario demonstrates how a user interacts with our system . Our last sections include the details of the architecture and of an implementation . EXPERTISE LOCATING SYSTEMS AND CSCW CSCW and adjacent literatures provide examples of sys - tems that help people find others with suitable expertise . Systems that assist with expertise location are similar to a broad class of systems known as recommendation systems . Recommendation systems are commonly used to recom - mend documents based on user preferences [ 17 ] . This defi - nition distinguishes recommendation systems from systems that are more properly characterized as information re - trieval ( IR ) or information filtering . There are a wide variety of recommender systems . In that context , the term “documents” should be broadly con - strued . Recommendation systems have been used to rec - ommend a variety of things including Usenet news [ 11 ] , web pages [ 2 , 9 ] , videos [ 8 ] , movies , music [ 18 ] and books . Some systems refer a user to other people , which is essen - tially making recommendations about people . Who Knows and Referral Web are typical examples of systems that make referrals . Who Knows [ 6 , 20 ] found people who knew something about a topic , based on a profile con - structed from exemplary work documents . In a sense , documents were seen as surrogates for people’s interests in a twist on standard IR models . On the other hand , Referral Web [ 10 ] used social networks to assist expertise location . Referral Web identified relevant individuals by their par - ticipation in co - authoring relationships and presented users with a chain of relationships that needed to be traversed from the person seeking expertise to the person who might have the desired knowledge . Yenta [ 5 ] is a hybrid of these two models , using profiles constructed from personal data as well as routing messages along a network of inferred shared interests . In our view , recommendation systems are not completely synonymous with collaborative filtering ( CF ) systems . Many CF systems rely on explicit statements of user opin - ion , such as ratings , to create user profiles . By relying on ratings , CF systems often have difficulty generating the initial user profile and , as the profiles develop , must deal with a sparseness of ratings relative to the total number of items . These are two active areas of CF research . A few successful recommendation systems rely on implicit opinions , rather than explicit ratings . Tapestry [ 7 ] , GroupLens [ 16 ] and PHOAKS [ 9 , 21 ] have all used indi - rect activity . Tapestry made recommendations based on who read or responded to a particular bulletin board mes - sage . One version of GroupLens used time - spent - reading a message as an implicit opinion . And PHOAKS relies on frequency - of - mention in a stream of discussion as a type of voting mechanism for web pages . Explicit rating schemes are unlikely to work for expertise recommendation , because people are reticent to explicitly state opinions of co - workers with out an appropriate context . Ratings may not work , but it might be possible to collect feedback . CF systems have another weakness for expertise recom - mendation . Many recommendation systems have very spe - cific architectures that are tailored to recommend their spe - cific type of artifact . As well , these architectures commonly implement a single clustering algorithm ( e . g . Pearson Cor - relation , Single - Value Decomposition , Bayesian classifier ) for all participants and all artifacts . These clustering algo - rithms , also called neighborhood - based predictive algo - rithms , implement a single collaborative model that can be described as Birds of a Feather Flock Together ( BOF ) . These systems tightly couple the architecture and the col - laborative model . In the case of PHOAKS , Referral Web , and active collabo - rative filtering [ 12 ] , different algorithms and different col - laborative models were chosen because the BOF model and clustering algorithms did not effectively fit the recommen - dation situation . In expertise recommendation , a BOF model that clusters profiles may not effectively distinguish individuals who have expertise from those who have only a small amount of knowledge . Alternatively , a BOF model that was effective at clustering the profiles of individuals who have expertise would likely not be effective at distin - guishing in which topics their expertise lay . This previous work suggests two critical improvements . First , any expertise recommendation solution should sup - port a range of collaborative recommendation models and behaviors . Below , we will show the social requirements for this , but technically , an open architecture would permit a range of potential solutions . Second , one of the most diffi - cult and perhaps most interesting problems from a CSCW perspective is how to begin untying the technical aspects of making recommendations from the social and collaborative aspects of making a recommendation to a specific user . Current recommendation approaches , especially BOF ap - proaches , do not provide this flexibility . The architecture that we will present is capable of support - ing a range of collaborative recommendation models . An organizationally specific implementation will demonstrate the flexibility in the architecture . However , before turning to the architecture and the subse - quent implementation we must describe what people want when they seek other people for their expertise . We need to show how the recommendation of expertise is in the nu - anced details of collaborative interaction . These details are the basis for our approach to the technical work . GROUNDED REQUIREMENTS Our prior work [ 13 ] describes a field study to examine ex - pertise location . The field study was motivated by two de - sires . First , we hoped to contribute to a better understand - ing of the intricacies of expertise and expertise locating in a rich work setting . Secondly , we hoped to learn how exper - tise locating systems could be improved to better assist and augment the natural expertise locating behavior that people exhibit . The issues and findings raised in the literature were not sufficiently informative or have not always been ori - ented toward the objective of informing a system architec - ture and implementation . In short , we hoped to firmly situ - ate systems development in a complex nuanced social set - ting as well as implement something useful to a group of participants . The following briefly recounts our field study and the re - sults [ 13 ] . The MSC Field Study The field site was a medium sized software company that builds , sells , and supports medical and dental practice man - agement software . Medical Software Corporation 1 ( MSC ) has about 100 employees at its headquarters where the study took place . The participants in the study worked in Technical Development , Technical Support and Technical Communications . These three departments are central to the development and support of MSC’s products . These departments comprise a little more than one third of the employees at headquarters . The following findings are based on an initial 5 months in the field . Data was collected using qualitative methods in - cluding participant observation , semi - structured formal interviews and informal interviews . The data was analyzed using standard ethnographic techniques . Our study found that people at MSC commonly engage in three behaviors that support expertise locating : expertise identification , expertise selection , and escalation . We note that identification , selection , and escalation are analytical distinctions useful for understanding the fine social and cognitive decisions which are made during expertise locat - ing and that will later be useful for technical design . It is clear that only the most self - reflective of the participants made much if any distinction among these three behaviors . Expertise identification is the problem of finding a set of candidates who are likely to have the desired expertise . Expertise identification relies on prior experience with oth - ers , key people like an expertise concierge , and historical artifacts . The expertise concierge routes people to others with the necessary knowledge and expertise . The role has much in common with Ehrlich and Cash’s information me - diator [ 4 ] , Paepke’s contact broker [ 15 ] , and Allen’s tech - nological gatekeeper [ 1 ] . Each of these roles is specialized to the organizational context . Historical artifacts are prod - ucts and byproducts of the work that other MSC employees have produced . The composition and form of historical artifacts range from unstructured to highly structured things that can exist on - line or off - line . Expertise selection is the way participants picked one per - son ( or a small number of people ) to approach for help . Expertise selection is guided by organizational criteria , the load on the potential source , and how a source reacts and interacts during a request for help . Social , organizational , and individual preference assist in narrowing a set of iden - tified candidates to one or a small number of people who can be contacted . In some cases , prior research has intertwined elements of expertise identification and selection . Allen’s [ 1 ] work with engineers demonstrated that information seeking is heavily influenced by social networks . Cicourel [ 3 ] observed that organizational and institutional factors reinforce expertise 1 Names and individual identifiers have been changed to protect the privacy of the corporation and the participants . status and can then constrain who is pursued for expertise . Lastly , Orr’s [ 14 ] work with repair technicians reveals how narrative exchange ( war stories ) serves to demonstrate ex - pertise and notions of competency which then guide re - quests for assistance with difficult problems . Escalation is the mechanism that fixes breakdowns in iden - tification and selection . Participants had difficulty with identification and selection because it requires fine judge - ments often based on incomplete and imperfect informa - tion . Escalation is an iteration of identification and selec - tion given additional knowledge and information gained from prior iterations . During escalation the individual who initially engaged the problem maintains problem owner - ship . Escalation results in a wider , spreading activation through the organization that involves more people in the eventual solution to a difficult problem . The architecture that we describe later in this paper pro - vides specific support for this model of expertise location . An implementation of this architecture , however , requires specifics of how people perform these behaviors . The next section describes two specific identification heuristics that were used by participants at MSC . Expertise Locating Heuristics The MSC field study provides a detailed understanding of the following two identification heuristics . We found this understanding essential to building a nuanced system . These heuristics , Change History and Tech Support , are behaviors and rules about interpreting implied meaning using specific historical artifacts at MSC when identifying potential expertise at MSC . These historical artifacts have many , potentially crucial , features , but the participants at - tend to only a few through specific rules of thumb . The details are quite important to the behavior of the partici - pants and the eventual behavior of a system . Change History Heuristic Change History is a single heuristic designed to augment an expertise locating behavior common to MSC’s developers . Developers called this behavior the “Line 10 Rule . ” The “Line 10 Rule” is a function of the organization that is MSC and the work practices that are enforced there . The developers follow a common work practice . For each soft - ware change , they check the appropriate module out of the version control system , make the changes , test the changes , and then check the changes back into the version control system . Each change is annotated with the module name , the module version , the developer responsible for the change , the check - in date , and a short text description of the change . Since many changes are the result of a con - tractual obligation , an administrative assistant cross - validates the changes in the version control system , the work - orders that divide up multiple changes , the time spent on changes and the total time and accounts for the contract . Developers at MSC do not specialize in any part of the system . In practice , however , there is some attempt to as - sign a developer work in an area of the code where she has worked in the past . Yet , the expanse of the system , the number of developers , and developer turnover will result in a developer being assigned work in portions of the code where she has not worked before . Developers use the “Line 10 Rule” in an attempt to overcome the problems that arise when working with unfamiliar code . On the surface the “Line 10 Rule” is a simple heuristic . Given a problem with a module a developer looks into the version control system to see who last modified the code and then approaches that person for help . Developers say that this rule works because the person who last made a change has the code “freshest” in mind . The version control system is not specifically designed to support this exact use . As a result , the rule is not strictly followed , but most developers state that the heuristic is “good enough” to often get the help they need . Tech Support Heuristic The tech support identification heuristic is not known by a specific name . The heuristic augments a behavior of tech - nical support representatives when faced with an unfamiliar or difficult support problem . The heuristic is applied to the support database . The sup - port database mediates all work performed by technical support representatives . New problems ( “calls” ) can be entered by a support rep or by customers via email . When faced with a difficult problem , a representative will perform multiple , separate queries over the support data - base using the symptoms , customer , or program module involved . The support rep then scans the records sequen - tially looking for similarities between the current problem and any past problems as returned by the different queries . In scanning records a support rep looks to identify people who have previously solved similar problems . The support database is not designed to enable this type of activity . Each query ( symptom , customer or program ) must be completed separately , so finding similarities among the three primary characteristics is mostly done in the support representative’s head . At MSC support representatives are assigned to specific customers . This benefits the customer because a single support representative can remember more details about the context of a customer’s installation . A side effect is that , while the database does not facilitate queries across the three indices , establishing the relationship be - tween an MSC customer and the support rep who works with them is relatively simple . The tech support identification heuristic consists of attach - ing the symptoms , customers , and program modules of solved problems to the person who solved them . As a sim - ple rule of thumb this scanning behavior works fairly well . However , the process can be time consuming and is only profitable when applied to more difficult support problems . In summary , prior work and our field work demonstrates several important requirements of expertise locating : • Detailed heuristics and social interaction guide an ex - pertise seeker to identify candidates who are likely to have the required expertise . • Social and organizational norms and factors guide an expertise seeker to pick a small number of candidates to pursue for help . • The details matter . The heuristics described here are extremely bound to the organizational environment . Systems that augment expertise locating must be capa - ble of handling a large number of details that vary based on the specific context and problem . The focus of this paper now shifts from the details of the requirements ( as exemplified by MSC ) to the technical design of the expertise recommendation system . THE EXPERTISE RECOMMENDER ( ER ) The Expertise Recommender ( ER ) is firmly grounded in the findings from the MSC study . ER is really two things at once , at two different levels of abstraction . At the most abstract , ER is an architecture designed to handle a range of recommendation problems . However , recommendation architectures cannot solve specific recommendation prob - lems at specific organizations ; only specific implementa - tions of an architecture can do so . Therefore , we also show how our work addresses this issue by implementing a spe - cific instantiation suitable for the expertise locating behav - ior found in the field study of MSC . To avoid confusion , for the remainder of this paper the ar - chitecture will be referred to as ER - Arch and the imple - mentation will be known simply as ER . This section first presents a simple usage scenario that pro - vides an overview of a client and how the user interacts with the system . We follow the scenario with a description of ER - Arch , and conclude with details of the MSC imple - mentation of ER . A Brief Usage Scenario This scenario provides a picture of the user interaction with the system and several key features of an ER client . The scenario describes a problem that MSC support representa - tives might encounter in the course of their day - to - day work with MSC customers . Madhu is a junior technical support representative . Support reps like Madhu are assigned to handle all incoming calls from a specific set of MSC customers . However , today Madhu is also covering for a support rep who is on vaca - tion . Madhu receives a call from a customer , PCI , who states that the system is reporting a file error in patient demographics . Even as a relatively new support rep , Madhu is fairly knowledgeable about patient demographics . How - ever , Madhu is not familiar with the specific customer , PCI , and why that customer’s system might be reporting an er - ror . Madhu recognizes that he will need help resolving this problem . He launches the ER client , logs into the system and gets the main window ( figure 1 ) . The main window contains a menu bar and a list of recent prior requests that Madhu made . Prior requests are live elements ( save sets ) that can be revisited . When revisiting a prior request , the user can review the people who were recommended or es - calate the request to gain additional recommendations . Figure 1 . Expertise Recommender Main Window Madhu has not made any prior requests for this problem , so he will have to make a new request . He chooses “New Re - quest” from the “File” menu and the client displays the expertise request dialog ( figure 2 ) . Through conversation with the person reporting the error , Madhu is able to get the specific error code and determines that the error is gener - ated in a module of the patient demographics system called M . 013 . Figure 2 . Expertise Request Dialog Madhu decides that the problem is most closely associated with the “Tech Support” topic area and picks this topic in the new request dialog . Madhu chooses the “Social Net - work” filter because he would like the results filtered based on the people whom he knows best . The dialog lists the available identification heuristics and selection techniques in the “Topic Area” and “Filter” pop - up menus respec - tively . In the “Request” text field , Madhu enters the error ( I / O Error 16 ) , the program module ( program M . 013 ) and the customer ( customer PCI ) . ( These names would be natu - ral to a support rep at MSC . ) Madhu clicks the “Recom - mend” button , sending the request to the server . After a short wait , the server responds with a list of rec - ommendations . Madhu quickly recognizes that the first few people will not work . The first recommendations include the support rep whose calls Madhu is now covering , as well as a person from training who is currently off - site . So , Madhu immediately escalates the request to get additional recommendations ( figure 3 ) . The response dialog displays the request followed by a list of recommended people . Each person is listed in a single pane containing contact information that includes office number , phone number , phone extension , and email ad - dress . Additionally , each pane contains a “Contact” button that is active only when the recommended person is logged into the ER server . The contact button , when active , estab - lishes a synchronous chat with the recommended person . Figure 3 . Recommendation Response ( Escalated ) Madhu’s escalated request returns two additional people , one from development and one from training . Madhu rec - ognizes that ER has recommended a friend in development as someone who is likely to have expertise . Madhu walks over to the development suite to look for his friend . This brief overview of a user’s interaction with ER demon - strates several key aspects of ER : • The user can pick the heuristic and the associated data that will be used to generate a recommendation . • The user can choose the mechanism that tailors the recommendations to the user . • Recommendations remain live so that they can be quickly revisited and escalated should the initial rec - ommendations prove unfruitful . Moving on from the scenario , we next turn to a description of the ER - Arch and the implementation details of an ER system for MSC . The Architecture — ER - Arch Like many recommendation systems , ER - Arch is server based , and a client is necessary to access the functionality . ER - Arch can support simple clients , like a Web based in - terface , or clients tailored to support specific features of the ER server . Regardless of the client , the important architec - tural details are in the ER server . Unless otherwise indi - cated , the components and interconnections should be as - sumed to exist in the server . At a high level , ER - Arch is a pipe and filter architecture [ 19 ] . This architecture is widely used in information re - trieval and information filtering , and it has great utility in expertise recommendation ( as will be discussed below ) . Accordingly , ER - Arch is a collection of high - level supervi - sors , easily extensible heuristic modules , and their data stores . The supervisors provide general services and con - nections that facilitate a specific implementation . They also coordinate the underlying heuristic modules to provide re - quired services ( such as identification ) to the system . The databases provide persistent storage for profiles and various preferences . The supervisors in ER - Arch support profiling , identification , selection and interaction management . An overview of ER - Arch is provided in figure 4 . N e t w o r k ProfileDB ERServer IdentificationSupervisor SelectionSupervisor InteractionManagement PrefsDB ProfilingSupervisor HTTPServer ERClient Netscape : Expertise Recommender - Madhu ' s Recent Requests N http : / / www . msc . com / cgi - bin / experthome / Madhu ' s Recent Requests Change HistorySocial NetworkReporting Labels M . 055 M . 054 Tech Support Departmental FQHC Medicare Billing Change HistorySocial Networkinsurance file maintenance m . 086 m . 087 New Request Preferences Log Out Web Browser Figure 4 . Expertise Recommender Architectural Overview The ER server logically glues together portions of ER - Arch . It also handles the details of managing connec - tions and servicing requests . The ER server implements a protocol that clients use to request and receive recommen - dations . The supervisors in ER - Arch support profiling , identification , selection and interaction management . The following sections discuss the ER - Arch supervisors , data - bases , and the interconnections among them in more detail . Profile DB ExplicitRatings P 1 Hearsay P n User Behavior P 2 ImplicitActivity P 3 Profiling Supervisor Figure 5 . Profiling Supervisor Profiling Supervisor The profiling supervisor is responsible for creating and maintaining profiles . In many recommendation systems , profiles are a list of items which an individual has rated . These ratings profiles are used in two ways . First , profiles are clustered to create groups of users who have similar likes and dislikes . Additionally , profiles are used to identify items that a user has not yet rated and are therefore good candidates for recommendation . In ER - Arch profiling is a periodic activity which is de - signed to be run off - line relative to the other activities of the server . ER - Arch can be used to maintain profiles of more than one type of thing and generate profiles from more than one single source . This is facilitated by a collec - tion of modules supervised by the profiling supervisor . Many prior recommendation systems only support one method of profiling . The profiling supervisor coordinates the profiling modules and provides access to the profile database . The profiling database stores the results of profiling and also links pro - filing to the other supervisors . Identification Supervisor Identification picks a set of items or people who are rea - sonable candidates for a recommendation . Items are picked by applying one or more heuristics and adding the identi - fied candidates to a set . In the same way that profiling in ER - Arch is designed to support multiple types of profiling , ER - Arch is also designed to support multiple identification heuristics . This is different from many prior recommenda - tion systems that support only one method of picking can - didates . The identification supervisor coordinates the appli - cation of each heuristic . The supervisor provides each heu - ristic module with access to the profile database . Profile DB User / Client Request Raw Recommendation Birds of a Feather H 1 Line 10 Rule H n OpinionLeader H 2 Identification Supervisor Figure 6 . Identification Supervisor Identification is initiated in response to a user request . Through an ER client , the user can indicate which heuristic she would like to apply and provide parameters that tailor the heuristic to her current needs or desires . The result of identification is a set of raw recommendations . Raw rec - ommendations are passed directly to the next stage . Selection Supervisor Selection takes a set of candidate recommendations , and then reorders and possibly removes items from the set to generate a refined recommendation . The selection supervi - sor receives the raw recommendations from identification and applies one or more selection modules ( such as organi - zational criteria ) . The selection supervisor in ER - Arch is designed to support many different methods of selecting and filtering the raw recommendations . The selection supervisor provides selection modules access to the preference database that maintains personal and or - ganizationally relevant data ( e . g . , departmental affiliation ) that can be used as selection criteria . The result of selection is a refined recommendation . The refined recommendation is passed into the interaction management before becoming a final recommendation . User & Org . Prefs DB Final Recommendation InteractionManagement Raw Recommendation SocialNetwork F 1 No Filter F n Workload F 2 Selection Supervisor Figure 7 . Selection Supervisor and Interaction Management Interaction Management Interaction management receives the refined recommenda - tions and processes them before releasing them as a final recommendation . Interaction management in ER - Arch tracks the users’ interaction with the system and tracks the recommendations . Interaction management also collects feedback about system performance . The specific compo - nents of interaction management depend upon the specific needs of an organization and a given implementation Interaction management serves to reintegrate and smooth out discontinuities introduced by separating expertise loca - tion into two distinct phases . In the real world , communi - cation , escalation , issue tracking , problem context , and how individuals manage their accessibility to others are the set - ting in which expertise location resides . Interaction man - agement is the architectural component that provides these components , thereby serving to tie together and serve as the setting for identification and selection . Current State of ER ER - Arch is instantiated in an implementation of ER for MSC . ER includes a server and a dedicated client . Both server and client were coded in Java , and consist of more than 20 , 000 lines in 84 classes . The code includes numer - ous base classes and abstract classes that simplify the ex - tension of ER with new identification heuristics and new selection techniques . The MSC Implementation As mentioned , much of the promise of ER - Arch lay in its flexibility . If expertise seeking really is situated within spe - cific organizational or social contexts , presumably we will need some combination of generic and organizationally specific mechanisms for finding people . This section details the work involved in creating an implementation of ER suitable for MSC’s use . For MSC , ER implements the two identification heuristics described above as well as three selection techniques . Perhaps more importantly , this section also describes the organizationally specific data processing required to effectively generate expertise recommendations . To implement the identification heuristics , real data from MSC’s change history system and support database were required . MSC provided the most recent eight years of pro - gram change history covering their medical system and a portion of the shared libraries used by both their medical and dental systems . This corresponds to a total of 7316 individual code modifications . The data from the support database cover the last four years of customer support ac - tivity . These data include all calls logged and marked as completed . The support data cover software and hardware issues for all of MSC’s products . More than 200 , 000 calls were handled during the time period covered by the data . Profiling The identification heuristics and profiling modules are strongly related through the profile database . The identifi - cation heuristics specify which features the profiling mod - ules must extract . The intricate details of implementing profiling modules for MSC demonstrate how real , messy data sources are transformed into profile records more amenable to the application of identification heuristics . The profiling supervisor controls profiling in ER . Profiling modules are extensions to a base class that provides meth - ods for interacting with the profiling supervisor and the profile database . ER supports a profiling module for each data source and corresponding identification heuristic . Pro - filing modules incrementally update each profile record . The change history profiling module crawls through each change collecting the developer responsible for the change , the module name , the version , and date . For each change , the developer’s profile is found and the slot containing code changes is searched for previous modifications to the module . If the developer has no prior changes , then a new entry is made containing the module , the date of the most recent change , and the total number of changes . If the de - veloper had previously made a change , then the date of last change is updated and the total count of changes is incre - mented . The profiling module examines dates and is careful to modify profiles only when changes are more recent . The profiling module for the tech support area is incre - mental as well . However , the tech support profiling module assumes that it will be fed unique records from the techni - cal support database . The profiling module considers four fields key : the support representative , the description of the problem ( a small amount of free form text ) , the customer , and the module that the customer reports is the problem . These four fields are used to incrementally build three vector spaces that characterize a specific person’s activity in the support database . Creating profiles with a vector space model required im - plementing additional functionality to support profiling and identification . A set of thesauri were needed , one for each of the vector spaces . These determine which terms are in the vector space , and therefore should be counted or not counted . A parser was required to separate terms , phrases , and important punctuation . This same parser is also used to parse user queries . The support database records are exceedingly messy . The entries have few restrictions and data entry conventions that are not formalized . Different support representatives have different preferred misspellings and abbreviations . These misspellings and abbreviations created two potential prob - lems that had to be solved . First , by using frequency of occurrence as a mechanism for determining which terms are entered into the thesaurus , some of the abbreviations would never be entered because they occur too infre - quently . Secondly , with many misspellings and non - uniform abbreviations , users might find it difficult to garner results when using their personal , quirky language . An ad - hoc approach addressed these problems with the data . First , a parser was built that recognized punctuation important to how MSC’s systems work . The parser was coded to recognize certain phrases which are relevant to the way customers and support reps express problems . The parser removes common stop words , but does not perform any stemming . The parser was used to parse the symptoms , customers , and program fields of all support records gener - ating a complete list of terms . For each field , terms were sorted , reviewed , and cleaned to create a thesaurus . The tech support profiling module constructs a profile in two stages . In the first stage each support database record is examined , and the support rep assigned to the problem is identified . The symptom , customer , and program module fields are parsed , and terms are validated against the appro - priate thesaurus . The support rep’s profile is then updated by incrementing the term counts in the appropriate vector space . Additionally , a master term vector is incremented representing the total number of times a term is used in the entire database . In the second stage , the profiling module visits each profile record and normalizes each vector . The profiling supervisor finishes profiling , for all profiling techniques , by automatically rebuilding all indices that are associated with the profile database . The MSC implemen - tation requires three indices : one that indexes individuals by name , one that indexes program modules , and one that indexes the vector space profiles based on the percentage of term space coverage . These indices are specifically de - signed to support identification and their use will be cov - ered in the next section . Identification The details of implementing the change history and tech support heuristics provide a clear example of how identifi - cation heuristics can be moved into ER . As well , they dem - onstrate how different modules can handle escalation in different ways . For identification , the identification supervisor manages modules that have been built to perform identification . An identification module base class provides basic functional - ity for working with the profile database , interaction with recommendation requests , and recommendation lists . Rec - ommendation requests encapsulate the user request , the system state of the request , and the recommendations that were made in an attempt to satisfy the request . Recommen - dation lists provide methods for ordering and reordering items that have been recommended . Each recommendation module is free to determine how escalation is managed and exactly what additional action is taken on an escalation . In the case of the change history , the action of the identifi - cation module is fairly straightforward . The module parses the request text to identify all of the program modules that are mentioned in the request . For each program module , a query is made of the profile database , returning a list of individuals who have modified the module . If the request contains multiple program modules then the resulting lists are intersected to find people who touched all modules mentioned . For each person identified , a recommendation list item is created that includes the most recent modifica - tion date and the total number of touches . The item is then inserted into an unfiltered recommendation list ordered from the most recent touch to least recent touch . Tech support identification is similar to change history identification . The request text is parsed and three query vectors are created , one for symptoms , one for customers and one for program modules . The profile database is then queried using the vector space index . This index groups profiles based on the percentage of terms covered by a per - son’s vector space profile . Escalation level is used to de - termine the percentage term space that must be covered before a person will be considered . As the escalation level rises , the term space that must be covered drops . For each person returned , similarity of that person’s profile is gauged relative to three query vectors determined by parsing the request text . The cosine angle of incidence is calculated for each query vector and the appropriate nor - malized vector in the profile . A weighted sum of the angles is calculated to create the overall ranking for the match . The recommendation list maintains the order from highest to lowest weighted sum . Selection When an identification module has completed , the unfil - tered recommendation lists are passed to the selection su - pervisor . The operation of the selection supervisor is simi - lar to that of the identification supervisor . Selection mod - ules transform an unfiltered recommendation list to a final recommendation list by visiting each recommendation item in the unfiltered list , and then validating or modifying the recommendation . If the item will be part of the final rec - ommendation it is inserted into the final list . The designer of a selection technique decides how escalation level modi - fies or changes each selection technique . The MSC implementation includes three selection tech - niques . The first technique is a simple “No Filter” capabil - ity . This technique removes individuals who no longer work for MSC . As each recommendation is visited , there is a lookup in the user preference and organizational database . If the person’s record indicates that she is still working for MSC , she is added to the final recommendation list . The escalation level does not modify this filter . The second technique , “Departmental , ” selects based on the organizational distance between the department of the per - son making the request and the department of each person recommended . The filter module maintains a small graph structure that represents the “distance” between each of the departments at MSC . The departmental technique relies on the current escalation level and the departmental graph to determine who will be added to the final recommendation list . The distance is calculated , and if the distance is less than a threshold , then the person is added to the final rec - ommendation list . The third selection technique , “Social Network , ” filters recommendations based on an aggregate social network of the MSC workplace . Data for the social network were ob - tained during the fieldwork at MSC . Extended interviews were conducted where the participants performed succes - sive pile sorts , which resulted in an aggregate social net - work for MSC . This social network is a graph structure where the nodes represent individuals at the workplace and the edges represent some relation that links two individuals . The social network technique calculates the distance be - tween the person making the request and the recommended person . If the distance is less than a threshold , then the rec - ommended person is added to the final recommendation . Note that while these selection mechanisms use organiza - tionally specific data for MSC , the techniques themselves would generalize to other organizations . Interaction Management The interaction management modules in the MSC imple - mentation exemplify how the specific details necessary to create a working system may lead to the creation of more general , reusable components . While these components were required by MSC in order for ER to be successful in their setting , all of the components are reusable within other organizations . For example , through our fieldwork at MSC we saw par - ticipants make specific choices with regard to how they controlled their accessibility by others and predilection to specific communicative media . One expert had a unique technique for indicating how interruptible he was depend - ing upon the importance of the problem that required his attention . He posted a sign on his already closed door . For him , the system needed a similar mechanism . Interaction management currently consists of three compo - nents , the escalation tracker , a communication tracker , and expert face management . This section will briefly cover each of these three components . The escalation tracker manages the expiration of recom - mendation requests on the server side . This includes main - taining a database of all active requests for each ER user . When a client connects , the escalation tracking component looks up the user in the request database and sends the ac - tive requests . As requests expire , escalation tracking marks the item , removes it from the database and notifies the ap - propriate client . Lastly , the escalation tracker updates the user profile and preference data . The communications tracker is responsible for routing the chat messages between users . The tracker receives all in - coming messages , validates that the recipient is still con - nected and then sends the message out . The tracker modi - fies the user preference data on each communications at - tempt . This implicit preference data contains a list of all of the other users with whom contact was attempted and the total number of communication attempts . The communica - tions tracker also provides a simple mechanism for a user to state explicit preference for any of the other users known by the system . Expert face management allows a user to have some con - trol over her availability to other users through the system . Face management allows a user to state her availability on a four step scale from “available” to “do not disturb . ” The default , unless otherwise set , is available . Face manage - ment does not require a user to attend to her level of avail - ability . Face management includes a decay system that al - lows a user to specify how quickly her current level of ac - tivity will move toward being available . Face management maintains a thread that periodically checks decay rates and modifies availability settings . In summary , the specific modules that comprise profiling , identification , selection , and interaction management differ in their level of specificity to the organizational setting . The heuristics and algorithms used for identification and pro - filing are very organizationally specific . While these identi - fication heuristics might be used in another organization , the implementation is for MSC and the specifics of their identification mechanisms are particular to that setting . The modules that make up selection appear organizationally specific because they are tailored to the social and depart - mental character of an organization . Yet , these modules have some flexibility and can be adapted to other organiza - tions given the appropriate data . Lastly , the modules in interaction management are perhaps the least organization - ally specific . The modules in interaction management have a face validity that stems from a basic understanding of the requirements of expertise location . As the MSC imple - mentation shows , ER - Arch handles this combination of organizationally specific and generic mechanisms for ex - pertise recommendation . CONCLUSIONS The Expertise Recommender , through ER - Arch and the implementation , demonstrates three key features . First , ER - Arch is a general architecture that can be tailored to many different recommendation situations . ER - Arch is capable of supporting more traditional recommendation situations by incorporating appropriate profiling and identi - fication modules . It is also highly suited for expertise rec - ommendation . Second , the implementation of ER for MSC relies on pro - filing techniques that are not common to other recommen - dation systems . ER generates profiles of people based on work products and work byproducts . This approach trades the problems of critical mass and sparse ratings for prob - lems with dirty and inconsistent organizationally specific data sources . Lastly , ER - Arch and the MSC implementation of ER begin to tease apart technical concerns involved with making recommendations from the social and collaborative con - cerns . This separation allows ER to support multiple col - laborative models and provide more adaptive recommen - dations . The ER client exposes these features allowing ER users to pick recommendation strategies appropriate for their task . Recommendation systems , such as ER , provide another approach to supporting natural expertise locating behavior . In situations where a senior employee , guru , information mediator , or expertise concierge is not available , a system like ER can suggest alternatives where previously no help would have been available . By relying on organizationally relevant sources of information and heuristics that are natu - rally used , systems like ER can assist in finding people who have expertise and who may not otherwise be identified . Acknowledgements This project has been funded , in part , by grants from Na - tional Science Foundation ( IRI - 9702904 ) , the UCI / NSF Industry / University Cooperative Research Center at the Center for Research on Information Technology and Orga - nizations ( CRITO ) , and the University of California MICRO program . Additionally , the first author was sup - ported by the University of California Regents’ Disserta - tion Fellowship . This work has benefited from conversations with Kate Ehrlich , Saul Greenberg , Joe Konstan , John Riedl , Lynn Streeter , Loren Terveen , and Clark Turner . Members of our research group , Wayne Lutters and Jack Muramatsu , contributed to our understanding of expertise . We thank the anonymous reviewers for their feedback . We would also like to thank the participants at MSC for their patience and insights over the last few years . REFERENCES 1 . Allen , T . J . Managing the Flow of Technology . MIT Press , Cambridge , 1977 . 2 . Balabanovic , M . and Shoham , Y . Fab : Content - Based , Col - laborative Recommendation . CACM , 40 ( 3 ) . 66 - 72 . 3 . Cicourel , A . V . The Integration of Distributed Knowledge in Collaborative Medical Diagnosis . in Galegher , J . , Kraut , R . E . and Egido , C . eds . Intellectual Teamwork , Lawrence Erlbaum Associates , Hillsdale , NJ , 1990 , 221 - 242 . 4 . Ehrlich , K . and Cash , D . , Turning Information into Knowl - edge : Information Finding as a Collaborative Activity . in Digital Libraries ' 94 , 119 - 125 . 5 . Foner , L . N . , Yenta : A Multi - Agent , Referral - Based Match - making System . in First International Conference on Autonomous Agents ( Agent ' 97 ) . 6 . Furnas , G . W . , Deerwester , S . , Dumais , S . T . , Landauer , T . K . , Harshman , R . A . , Streeter , L . A . and Lochbaum , K . E . , Infor - mation retrieval using a singular value decomposition model of latent semantic structure . SIGIR ' 88 , 465 - 480 . 7 . Goldberg , D . , Nichols , D . , Oki , B . M . and Terry , D . Using Collaborative Filtering to Weave an Information Tapestry . CACM , 35 ( 12 ) . 61 - 70 . 8 . Hill , W . , Stead , L . , Rosenstein , M . and Furnas , G . , Recom - mending and Evaluating Choices in a Virtual Community of Use . CHI ' 95 , 194 - 201 . 9 . Hill , W . and Terveen , L . , Using Frequency - of - mention in Public Conversations for Social Filtering . CSCW ' 96 , 106 - 112 . 10 . Kautz , H . A . , Selman , B . and Shah , M . Referral Web : Com - bining Social Networks and Collaborative Filtering . CACM , 40 ( 3 ) . 63 - 65 . 11 . Konstan , J . A . , Miller , B . N . , Maltz , D . , Herlocker , J . L . , Gordon , L . R . and Riedel , J . GroupLens : Applying Collabora - tive Filtering to Usenet News . CACM , 40 ( 3 ) . 77 - 87 . 12 . Maltz , D . and Ehrlich , K . , Pointing The Way : Active Collabo - rative Filtering . CHI ' 95 , 202 - 209 . 13 . McDonald , D . W . and Ackerman , M . S . , Just Talk to Me : A Field Study of Expertise Location . CSCW ' 98 , 315 - 324 . 14 . Orr , J . E . Talking About Machines : An Ethnography of a Mod - ern Job . Cornell University Press , Ithaca , 1996 . 15 . Paepcke , A . Information Needs in Technical Work Settings and Their Implications for the Design of Computer Tools . Computer Supported Cooperative Work : The Journal of Col - laborative Computing , 5 . 63 - 92 . 16 . Resnick , P . , Iacovou , N . , Suchak , M . , Bergstrom , P . and Riedl , J . , GroupLens : An Open Architecture for Collaborative Filtering of Netnews . CSCW ' 94 , 175 - 186 . 17 . Sarwar , B . M . , Konstan , J . A . , Borchers , A . , Herlocker , J . , Miller , B . and Riedl , J . , Using Filtering Agents to Improve Prediction Quality in the GroupLens Research Collaborative Filtering System . CSCW ' 98 , 345 - 354 . 18 . Shardanand , U . and Maes , P . , Social Information Filtering : Algorithms for Automating " Word of Mouth " . CHI ' 95 , 210 - 217 . 19 . Shaw , M . and Garlan , D . Software Architecture : Perspectives on an emerging discipline . Prentice Hall , 1996 . 20 . Streeter , L . A . and Lochbaum , K . E . , Who Knows : A System Based on Automatic Representation of Semantic Structure . RIAO ' 88 , 380 - 388 . 21 . Terveen , L . , Hill , W . , Amento , B . , McDonald , D . and Creter , J . PHOAKS : A System for Sharing Recommendations . CACM , 40 ( 3 ) . 59 - 62 .