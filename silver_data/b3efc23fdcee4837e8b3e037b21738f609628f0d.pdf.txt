Feature - based survey of model transformation approaches & K . Czarnecki S . Helsen Model transformations are touted to play a key role in Model Driven Development e . Although well - established standards for creating metamodels such as the Meta - Object Facility exist , there is currently no mature foundation for specifying transformations among models . We propose a framework for the classification of several existing and proposed model transformation approaches . The classification framework is given as a feature model that makes explicit the different design choices for model transforma - tions . Based on our analysis of model transformation approaches , we propose a few major categories in which most approaches fit . INTRODUCTION Model - driven software development is centered on the use of models . 1 Models are system abstractions that allow developers and other stakeholders to effectively address concerns , such as answering a question about the system or effecting a change . Examples of model - driven approaches are Model Driven Architecture * * ( MDA * * ) , 2 , 3 Model - Inte - grated Computing ( MIC ) , 4 and Software Factories . 5 Software Factories , with their focus on automating product development in a product - line context , can also be viewed as an instance of generative software development . 6 Model transformations are touted to play a key role in Model Driven Development * * ( MDD * * ) . Their intended applications include the following : (cid:1) Generating lower - level models , and eventually code , from higher - level models 7 (cid:1) Mapping and synchronizing among models at the same level or different levels of abstraction 8 (cid:1) Creating query - based views of a system 9 , 10 (cid:1) Model evolution tasks such as model refactor - ing 11 , 12 (cid:1) Reverse engineering of higher - level models from lower - level models or code . 13 Considerable interest in model transformations has been generated by the standardization effort of the Object Management Group , Inc . ( OMG * * ) . In April 2002 , the OMG issued a Request for Proposal ( RFP ) on Query / Views / Transformations ( QVT ) , 14 which led to the release of the ﬁnal adopted QVT speciﬁcation in November 2005 . 15 Driven by prac - tical needs and the OMG’s request , a large number of approaches to model transformation have been proposed over the last three years . However , as of (cid:1) Copyright2006byInternationalBusinessMachinesCorporation . Copyingin printedformforprivateuseispermittedwithoutpaymentofroyaltyprovidedthat ( 1 ) each reproduction is done without alteration and ( 2 ) the Journal reference and IBM copyright notice are included on the ﬁrst page . The title andabstract , butnootherportions , ofthispapermaybecopiedordistributed royalty free without further permission by computer - based and other information - servicesystems . Permissiontorepublishanyotherportionofthe paper must be obtained from the Editor . 0018 - 8670 / 06 / $ 5 . 00 (cid:1) 2006 IBM IBM SYSTEMS JOURNAL , VOL 45 , NO 3 , 2006 CZARNECKI AND HELSEN 621 this writing , industrial - strength and mature model - to - model transformation systems are still not avail - able , and the area of model transformation contin - ues to be a subject of intense research . In this paper , we propose a feature model to compare different model transformation approaches and offer a survey and categorization of a number of existing ap - proaches from four sources : 1 . Published in the literature —VIATRA ( VIsual Automated model TRAnsformations ) frame - work , 16 , 17 Kent Model Transformation lan - guage , 18 , 19 Tefkat , 20 , 21 GReAT ( Graph Rewriting and Transformation language 22 ) , ATL ( Atlas Transformation Language 23 , 24 ) , UMLX , 25 AToM3 ( A Tool for Multi - formalism and Meta - Model - ing 26 ) , BOTL ( Bidirectional Object - oriented Transformation Language 27 , 28 ) , MOLA ( MOdel transformation LAnguage 29 ) , AGG ( Attributed Graph Grammar system 30 ) , AMW ( Atlas Model - Weaver 31 ) , triple - graph grammars , 32 MTL ( Model Transformation Language 33 ) , YATL ( Yet Another Transformation Language 34 ) , Kermeta , 35 C - SAW ( Constraint - Speciﬁcation Aspect Weaver ) , 36 and MT Model Transformation Language . 37 2 . Described in the ﬁnal adopted QVT speciﬁca - tion —The Core , Relations , and Operational lan - guages . 15 Older QVT submissions are also mentioned whenever appropriate . 3 . Implemented within open - source tools —Andro - MDA , 38 openArchitectureWare , 39 Fujaba ( From UML * * to Java * * And Back Again 40 ) , Jamda ( JAva Model Driven Architecture 41 ) , JET ( Java Emitter Templates 42 ) , FUUT - je , 43 and MTF ( Model Transformation Framework 44 ) , which is a freely available prototype . 4 . Implemented within commercial tools —XMF - Mo - saic , 45 OptimalJ * * , 46 MetaEdit þ * * , 47 , 48 ArcSty - ler , 49 and Codagen Architect . 50 The feature model makes explicit the possible design choices for a model transformation approach , which is the main contribution of this paper . We do not give detailed classiﬁcation data for each individual approach mainly because these details are con - stantly changing . Instead , we give examples of approaches for each design choice . Furthermore , we propose a clustering of existing approaches into a few major categories that capture their main characteristics and design choices . We conclude with remarks on the practical applicability of the different categories . WHAT IS MODEL TRANSFORMATION ? Transformation is a fundamental theme in computer science and software engineering . After all , compu - tation can be viewed as data transformation . Computing with basic data such as numeric values and with data structures such as lists and trees is at the heart of programming . Type systems in pro - gramming languages help ensure that operations are applied compatibly to the data . However , when the subject of a transformation approach is metadata , i . e . , data representing software artifacts such as data schemas , programs , interfaces , and models , then we enter the realm of metaprogramming —writing pro - grams called metaprograms that write or manipulate other programs . One of the key challenges in this realm is that metaprograms have to respect the rich semantics of the metadata upon which they operate . Similarly , model transformation is a form of metaprogramming and , thus , must face the same challenge . Model transformation is closely related to program transformation . 51 In fact , their boundaries are not clear - cut , and both approaches overlap . Their differences occur in the mindsets and traditions of their respective transformation communities , the subjects being transformed , and the sets of require - ments being considered . Program transformation is a more mature ﬁeld with a strong programming language tradition . On the other hand , model transformation is a relatively new ﬁeld , essentially rooted in software engineering . Consequently , the transformation approaches found in both ﬁelds have quite different characteristics . While program transformation systems are typically based on mathematically oriented concepts such as term rewriting , attribute grammars , and functional pro - gramming , model transformation systems usually adopt an object - oriented approach for representing and manipulating their subject models . Because model transformations operate on models , we need to clarify what models are . A model is an abstraction of a system or its environment , or both . In software engineering , the term model is often used to refer to abstractions above program code , such as requirements and design speciﬁcations . Some authors in model - driven software develop - ment consider program code as models too . This view is consistent with the fact that program code is an abstraction of the underlying machine code produced by the compiler . Although being visual is not a deﬁning characteristic of models , requirements CZARNECKI AND HELSEN IBM SYSTEMS JOURNAL , VOL 45 , NO 3 , 2006 622 and design models are often more visual than programs . Models are frequently expressed in focused languages specialized for a particular class of software applications or a particular aspect of an application . For example , the Matlab * * Simulink * * / Stateﬂow * * environment offers notations special - ized for modeling control software , whereas inter - action diagrams in Uniﬁed Modeling Language * * ( UML * * ) are focused on representing the interaction aspect of a wide range of systems . Highly special - ized modeling languages are increasingly referred to as domain - speciﬁc modeling languages . In general , model transformations involve models ( in the sense of abstractions above program code ) or models and programs . Because the concept of models is more general than the concept of program code , model transformations tend to operate on a more diverse set of artifacts than program trans - formations . Model transformation literature consid - ers a broad range of software development artifacts as potential transformation subjects . These include UML models , interface speciﬁcations , data schemas , component descriptors , and program code . The varied nature of models further invites specialized transformation approaches that are geared to trans - forming particular kinds of models . For example , as explained later in the discussion section , most model transformation approaches based on graph transformations are better suited for transforming UML models than program code . However , there is no fundamental reason why program transforma - tion systems could not be applied to the same artifacts as model transformations . In fact , trans - formational software development , 52 which in - volves the automated reﬁnement of high - level speciﬁcations into implementations , is an old and familiar theme in the area of program transforma - tion . In summation , perhaps the most important distinc - tion between the current approaches to program transformation and model transformation is that the latter has been targeted for a particular set of requirements that include the representation of models using an object - oriented paradigm , the traceability among models at different levels of abstraction , the transformation mapping among multiple models ( i . e . , n - way transformations ) , and the multidirectionality of transformations . Although these requirements could also be the subject of program transformation approaches , they are typi - cally not considered by program transformation systems . EXAMPLES OF MODEL TRANSFORMATIONS To make our discussion more concrete , we present two examples of model transformations : one that maps models to models and another that maps models to code . Figure 1 gives an overview of the main concepts involved in model transformation . The ﬁgure shows the simple scenario of a transformation with one input ( source ) model and one output ( target ) model . Both models conform to their respective metamod - els . A metamodel typically deﬁnes the abstract syntax of a modeling notation . A transformation is deﬁned with respect to the metamodels . The deﬁnition is executed on concrete models by a transformation engine . In general , a transformation may have multiple source and target models . Furthermore , the source and target metamodels may be the same in some situations . Sample metamodels and models Figures 2A and 2B show sample metamodels expressed as UML class diagrams . Figure 2A gives a simpliﬁed metamodel for class models that includes the abstract concept of classiﬁers , which comprises classes and primitive data types . Packages contain classes , and classes contain attributes . All model elements have names , and classes can be marked as persistent . Figure 2B shows a simple metamodel for deﬁning relational database schemas for a relational database management system ( RDBMS ) . A schema Source Metamodel Figure 1 Basic concepts of model transformation Refers to Refers to Executes Reads Writes Conforms to Conforms to Source Model Target Metamodel Target Model Transformation Definition Transformation Engine IBM SYSTEMS JOURNAL , VOL 45 , NO 3 , 2006 CZARNECKI AND HELSEN 623 contains tables , and tables contain columns . The column type is represented as a string . Every table has one primary - key column , which is pointed to by pkey . Additionally , the concept of foreign keys is modeled by FKey , which relates foreign - key columns to tables . Sample instances of the metamodels using the UML object diagram notation are shown in Figures 2C and 2D . The instance in Figure 2C represents a class model with one package , App , containing two classes , Customer and Address . Customer is persis - tent , and Address is not . Figure 2D shows an instance of the schema metamodel . The instance represents a schema that can be used to make Customer objects persistent . UML - to - schema transformation As a ﬁrst example , we consider transforming class models into schema models described in the previous section . Such a transformation needs to realize the following three mappings : 1 . Package - to - schema : Every package in the class model should be mapped to a schema with the same name as the package . 2 . Class - to - table : Every persistent class should be mapped to a table with the same name as the class . Furthermore , the table should have a primary - key column with the type NUMBER and the name being the class name with _ tid appended . 3 . Attribute - to - column —The class attributes have to be appropriately mapped to columns , and some columns may need to be related to other tables by foreign key deﬁnitions . For simplicity , the attri - bute mapping is not further considered in this paper . The above transformation would map the class model in Figure 2C to the schema model in Figure 2D . The part of the result in Figure 2D shown in green ( lefthand and middle boxes ) is handled by the ﬁrst two mappings . The blue part ( righthand boxes ) corresponds to the result of the attribute - to - column mapping . Transformations expressed in QVT Relations language Example 1 shows how this transformation can be expressed using the QVT Relations language , which is a declarative language for model - to - model trans - formations . The language has both a textual and a graphical representation , but only the textual representation is shown here . The transformation 1 fkeys cols * tbls * * * * refs 0 . . 1 Table name : String B Simple RDBMS metamodel Schema name : String Column name : String type : String pkey cols : Class name = ' Customer ' isPersistent = true : Class name = ' Address ' isPersistent = false C UML sample model : Package name = ' App ' : Attribute name = ' addr ' : Attribute name = ' name ' : Attribute name = ' addln ' type type : PrimitiveDataType name = ' STRING ' type pkey : Table name = ' Customer ' : Column name = ' Customer _ tid ' type = ' NUMBER ' D RDBMS sample model : Schema name = ' App ' : Column name = ' addrln ' type = ' STRING ' : Column name = ' name ' type = ' STRING ' Figure 2 UML - to - RDBMS example and sample models : ( A ) Simple UML metamodel , ( B ) Simple RDBMS metamodel , ( C ) UML sample model , and ( D ) RDBMS sample model Classifier name : String * type * 1 elems attrs A Simple UML metamodel PrimitiveDataType Class isPersistent : Bool Attribute name : String Package name : String * FKey CZARNECKI AND HELSEN IBM SYSTEMS JOURNAL , VOL 45 , NO 3 , 2006 624 declaration speciﬁes two parameters for holding the models involved in the transformation . The param - eters are typed over the appropriate metamodels . The execution direction is not ﬁxed at transforma - tion deﬁnition time , which means that both uml and rdbms could be source and target models and vice versa . The user specifies the direction in which the transformation has to be executed only upon invoking the transformation . Example 1 transformation umlRdbms f uml : SimpleUML , rdbms : SimpleRDBMS ) f key Table ( name , schema ) ; key Column ( name , table ) ; top relation PackageToSchema f domain uml p : Package f name ¼ pn g domain rdbms s : Schema f name ¼ pn g g top relation ClassToTable f domain uml c : Class f package ¼ p : Package fg , isPersistent ¼ true , name ¼ cn g domain rdbms t : Table f schema ¼ s : Schema fg , name ¼ cn , cols ¼ cl : Column f name ¼ cn þ 0 _ tid 0 , type ¼ 0 NUMBER 0 g , pkey ¼ cl g when f PackageToSchema ( p , s ) ; g where f AttributeToColumn ( c , t ) ; g g relation AttributeToColumn f . . . g . . . g Each mapping is represented as a relation . A relation has as many domain declarations as there are models involved in the transformation . A domain is bound to a model ( e . g . , uml ) and declares a pattern , which will be bound with elements from the model to which the domain is bound . Such patterns consist of a variable and a type declaration , which itself may specify some of the properties of that type . When the transformation is executed , the relations are verified and , if necessary , enforced by manipu - lating the target model . If the target model is empty , its content is freshly created ; otherwise , the existing content is updated . A relation may specify a condition under which it applies by using a when clause . The where clause speciﬁes additional constraints among the involved elements , which may need to be enforced . The key deﬁnitions are used by the transformation engine to identify objects that need to be updated during a transformation execution . There is much more to say about the execution semantics of QVT Relations , and the interested reader is invited to explore the QVT speciﬁcation document . 15 UML - to - Java transformation In this example , we consider the generation of Java code from class models conforming to the meta - model in Figure 2A . In particular , a Java class with the appropriate attribute deﬁnitions and getters and setters should be generated for each class in the class model . Example 2 shows the desired output for the input model from Figure 2C . Example 2 public class Customer f private String name ; private Address addr ; public void setName ( String name ) f this . name ¼ name ; g public String getName ( ) f return this . name ; g public void setAddr ( String addr ) f this . addr ¼ addr ; g public String getAddr ( ) f return this . addr ; g g IBM SYSTEMS JOURNAL , VOL 45 , NO 3 , 2006 CZARNECKI AND HELSEN 625 The code can conveniently be generated using a textual template approach , such as the openArchi - tectureWare template language demonstrated in Example 3 . A template can be thought of as the target text with holes for variable parts . The holes contain metacode which is run at template instan - tiation time to compute the variable parts . The metacode in Example 3 is underlined . It has facilities to iterate over the elements of the input model ( FOREACH ) , access the properties of the elements , and call other templates ( EXPAND ) . Example 3 , , DEFINE Root FOR Class . . public class , , name . . f , , FOREACH attrs AS a . . private , , a . type . name . . , , a . name . . ; , , ENDFOREACH . . , , EXPAND AccessorMethodsFOREACH attribute . . g , , ENDDEFINE . . , , DEFINE AccessorMethods FOR Attribute . . public , , type . name . . get , , name . toFirstUpper . . ( ) f return this . , , name . . ; g public void set , , name . toFirstUpper . . ( , , type . name . . , , name . . ) f this . , , name . . ¼ , , name . . g , , ENDDEFINE . . FEATURES OF MODEL TRANSFORMATION APPROACHES This section presents the results of applying domain analysis to existing model transformation ap - proaches . Domain analysis is concerned with analyzing and modeling the variabilities and com - monalities of systems or concepts in a given domain . 53 We document our results using feature diagrams . 54 , 55 Essentially , a feature diagram is a hierarchy of common and variable features charac - terizing the set of instances of a concept . In our case , the features provide a terminology and representa - tion of the design choices for model transformation approaches . We do not aim for this terminology to be normative . Unfortunately , the relatively new area of model transformation has many overloaded terms , and many of the terms we use in our terminology are often used with different meanings in the original descriptions of the different ap - proaches . Consequently , we provide the deﬁnitions of the terms as we use them . Furthermore , we expect the terminology to evolve as our under - standing of model transformation matures . Our main goal is to show the vast range of available choices as represented by the current approaches . Figure 3 shows the top - level feature diagram , where each subnode represents a major point of variation . The fragment of the cardinality - based feature modeling notation 56 , 57 used in this paper is further explained in Table 1 . Note that our feature diagrams treat model - to - model and model - to - text approaches uniformly . We will distinguish between these categories later in the ‘‘ Major Categories ’’ section . The description of the top - level features in Figure 3 follows . (cid:1) Speciﬁcation —Some transformation approaches provide a dedicated speciﬁcation mechanism , such as preconditions and postconditions ex - pressed in Object Constraint Language ( OCL ) . 58 A particular transformation speciﬁcation may rep - resent a function between source and target Figure 3 Top - level feature diagram Specification Incremen - tality Direction - ality Tracing Transform - ation Rules RuleOrganization Source - Target Relationship RuleApplicationControl Scheduling LocationDeterminaton Model Transformation CZARNECKI AND HELSEN IBM SYSTEMS JOURNAL , VOL 45 , NO 3 , 2006 626 models and be executable ; however , in general , speciﬁcations describe relations and are not executable . The QVT - Partners 59 submission dis - tinguished between relations as potentially non - executable speciﬁcations of transformations and their executable implementations . The QVT spec - iﬁcation 15 still keeps this distinction , although the Relations language is now meant to be used primarily for expressing executable transforma - tions . (cid:1) Transformation rules —In this paper , transforma - tion rules are understood as a broad term describing the smallest units of transformation . Rewrite rules with a lefthand side ( LHS ) and a righthand side ( RHS ) are obvious examples of transformation rules ; however , we also consider a function or a procedure implementing some transformation step as a transformation rule . In fact , the boundary between rules and functions is not so clear - cut ; for example , function deﬁnitions in modern functional languages such as Haskell resemble rules with patterns on the left and expressions on the right . Templates can be considered as a degenerate form of rules , as discussed later in the ‘‘ Template - Based Ap - proaches ’’ section . (cid:1) Rule application control —This has two aspects : location determination and scheduling . Location determination is the strategy for determining the model locations to which transformation rules are applied . Scheduling determines the order in which transformation rules are executed . Although con - trol mechanisms usually address both aspects at the same time , for presentation purposes , we discuss them separately . (cid:1) Rule organization —This comprises general struc - turing issues , such as modularization and reuse mechanisms . (cid:1) Source - target relationship —This is concerned with issues such as whether source and target are one and the same model or two different models . (cid:1) Incrementality —This refers to the ability to update existing target models based on changes in the source models . (cid:1) Directionality —This describes whether a trans - formation can be executed in only one direction ( unidirectional transformation ) or multiple direc - tions ( multidirectional transformation ) . (cid:1) Tracing —This is concerned with the mechanisms for recording different aspects of transformation execution , such as creating and maintaining trace links between source and target model elements . Each of the following subsections elaborates on one major area of variation represented as a reference in Figure 3 by giving its feature diagram , describing the different choices , and providing examples of ap - proaches supporting a given feature . The diagrams remain at a certain level of detail to ﬁt the available space ; however , each feature could be further analyzed uncovering additional subfeatures . Also , the feature groups in the presented diagrams usually express typical rather than all possible feature combinations . For example , different language paradigms ( see Figure 5B later ) are organized into an xor - group rather than an or - group ( Table 1 ) . Hybrid approaches may always provide any combi - nations of these features , which would correspond to an or - group . Transformation rules The features of transformation rules are given in Figure 4A . Their descriptions follow . Domains A domain is the part of a rule responsible for accessing one of the models on which the rule operates . Rules usually have a source and a target domain , but they may also involve more than two domains . Transformations involving n domains are sometimes referred to as n - way transformations . Examples are model merging or model weaving , 31 which are transformations with more than one input domain . In general , a set of domains can also be seen as one large composite domain ; however , it is [ n . . m ] Symbol F F F F F Table 1 Symbols used in cardinality - based feature modeling Explanation Solitary feature with cardinality [ 1 . . 1 ] , i . e . , mandatory feature Solitary feature with cardinality [ 0 . . 1 ] , i . e . , optional feature Solitary feature with cardinality [ n . . m ] , n 0 m n m > 1 , i . e . , mandatory clonable feature Grouped feature Reference to feature model F xor - group or - group > _ > _ > > IBM SYSTEMS JOURNAL , VOL 45 , NO 3 , 2006 CZARNECKI AND HELSEN 627 useful to distinguish among individual domains when writing transformations . Domains can have different forms . In QVT Rela - tions , a domain is a distinguished typed variable with an associated pattern that can be matched in a model of a given model type ( Example 1 ) . In a rewrite rule , each side of the rule represents a domain . In an implementation of a rule as an imperative procedure , a domain corresponds to a parameter and the code that navigates or creates model elements by using the parameter as an entry point . Furthermore , a rule may combine domains of different forms . For example , the source domain of the templates in Example 3 is captured by the metacode , whereas the target domain has the form of string patterns . The features of a domain are shown in Figure 4B and described in the following subsections : Domain languages . A domain has an associated domain language speciﬁcation that describes the possible structures of the models for that domain . In the context of MDA , that speciﬁcation has the form of a metamodel expressed in the Meta Object Facility ( MOF * * ) . 60 Transformations with source and target domains conforming to a single metamodel are referred to as endogenous or rephrasings , whereas transformations with different source and target metamodels are referred to as exogenous or translations . 61 , 62 Static modes . Similar to the parameters of a proce - dure , domains have explicitly declared or implicitly assumed static modes , such as in , out , or in / out . Classical unidirectional rewrite rules with an LHS and RHS can be thought of as having an in - domain ( source ) and an out - domain ( target ) , or a single in / out - domain for in - place transformations . Multidi - rectional rules , such as in MTF , assume all domains to be in / out . Dynamic mode restriction . Some approaches allow dynamic mode restriction —restricting the static modes at execution time . For example , MTF allows marking any of the participating in / out - domains as read - only , that is , restricting them to in for a particular execution of a transformation . Essentially , such restrictions deﬁne the execution direction . Body . There are three subcategories under Body , variables , patterns , and logic : (cid:1) Variables may hold elements from the source and / or target models ( or some intermediate elements ) . They are sometimes referred to as metavariables to distinguish them from variables that may be part of the models being transformed ( e . g . , Java variables in transformed Java programs ) . (cid:1) Patterns are model fragments with zero or more variables . Sometimes , such as in the case of templates , patterns can have not only variables embedded in their body , but also expressions and statements of the metalanguage . Depending on the Figure 4 Features of transformation rules : ( A ) rules and ( B ) domains DomainLanguage StaticMode Body Domain [ 1 . . * ] SyntacticSeparation Multidirection - ality ApplicationConditions IntermediateStructures Parameterization Reflection Aspects Transformation Rules Domain A B Typing In Out In / Out Variables Patterns Logic Dynamic Mode Restriction CZARNECKI AND HELSEN IBM SYSTEMS JOURNAL , VOL 45 , NO 3 , 2006 628 internal representation of the models being trans - formed , we can have string , term , or graph patterns ( Figure 5A ) . String patterns are used in textual templates , as discussed later in the ‘‘ Template - Based Approaches ’’ section . Model - to - model transformations usually apply term or graph patterns . Patterns can be represented using the abstract or concrete syntax of the corre - sponding source or target model language , and the syntax can be textual or graphical . (cid:1) Logic expresses computations and constraints on model elements ( Figure 5B ) . Logic may follow different programming paradigms such as object - oriented or functional and be nonexecutable or executable . Nonexecutable logic is used to specify relationships among models . Executable logic can take a declarative or imperative form . Examples of the declarative form include OCL queries to retrieve elements from the source model and the implicit creation of target elements through con - straints , as in the QVT Relations and Core languages . Imperative logic often has the form of program code calling repository application pro - gramming interfaces ( APIs ) to manipulate models directly . For instance , the Java Metadata Interface ( JMI ) 63 provides a Java API to access models in a MOF repository . Imperative code uses imperative assignment , whereas declarative approaches may bind values to variables , as in functional pro - gramming , or specify values through constraints . Typing . The typing of variables , logic , and patterns can be untyped , syntactically typed , or semantically typed ( Figure 6 ) . Textual templates are examples of untyped patterns ( see the ‘‘ Template - Based Ap - proaches ’’ section ) . In the case of syntactic typing , a variable is associated with a metamodel element whose instances it can hold . Semantic typing allows stronger properties to be asserted , such as well - formedness rules ( static semantics ) and behavioral properties ( dynamic semantics ) . A type system for a transformation language could statically ensure for a transformation that the models produced by the transformation will satisfy a certain set of syntactic and semantic properties , provided the input models satisfy some syntactic and semantic properties . Syntactic separation Some approaches offer syntactic separation ( see Figure 4A ) . They clearly separate the parts of a rule A B Textual Graphical Patterns Structure Strings Terms Graphs Syntax Abstract Concrete Figure 5 Features of the body of a domain : ( A ) patterns and ( B ) logic LanguageParadigm Value Specification Element Creation Implicit Explicit Logic Constraint Object - Oriented Functional Procedural Logic ValueBinding ImperativeAssignment IBM SYSTEMS JOURNAL , VOL 45 , NO 3 , 2006 CZARNECKI AND HELSEN 629 operating on one model from the parts operating on other models . For example , classical rewrite rules have an LHS operating on the source model and an RHS operating on the target model . In other approaches , such as a rule implemented as a Java program , there might not be any such syntactic distinction . Multidirectionality Multidirectionality refers to the ability to execute a rule in different directions ( see Figure 4A ) . Rules supporting multidirectionality are usually deﬁned over in / out - domains . Multidirectional rules are available in MTF and QVT Relations . Application condition Transformation rules in some approaches may have an application condition ( see Figure 4A ) that must be true in order for the rule to be executed . An example is the when - clause in QVT Relations ( Example 1 ) . Intermediate structure The execution of a rule may require the creation of some additional intermediate structures ( see Figure 4A ) which are not part of the models being trans - formed . These structures are often temporary and require their own metamodel . A particular example of intermediate structures are traceability links . In contrast to other intermediate structures , trace - ability links are usually persisted . Even if trace - ability links are not persisted , some approaches , such as AGG and VIATRA , rely on them to prevent multiple ‘‘ ﬁrings ’’ of a rule for the same input element . Parameterization The simplest kind of parameterization is the use of control parameters that allow passing values as control ﬂags ( Figure 7 ) . Control parameters are useful for implementing policies . For example , a transformation from class models to relational schemas could have a control parameter specifying which of the alternative patterns of object - relational mapping should be used in a given execution . 7 Generics allow passing data types , including model element types , as parameters . Generics can help make transformation rules more reusable . Generic transformations have been described by Varro´ and Pataricza . 17 Finally , higher - order rules take other rules as parameters and may provide even higher levels of reuse and abstraction . Stratego 64 is an example of a term rewriting language for program transformation supporting higher - order rules . We are currently not aware of any model transformation approaches with a ﬁrst class support for higher - order rules . Reﬂection and aspects Some authors advocate the support for reﬂection and aspects ( Figure 4 ) in transformation languages . Reﬂection is supported in ATL by allowing reﬂective access to transformation rules during the execution of transformations . An aspect - oriented extension of MTL was proposed by Silaghi et al . 65 Reﬂection and aspects can be used to express concerns that crosscut several rules , such as custom traceability management policies . 66 Rule application control : Location determination A rule needs to be applied to a speciﬁc location within its source scope . As there may be more than one match for a rule within a given source scope , we need a strategy for determining the application locations ( Figure 8A ) . The strategy could be deterministic , nondeterministic , or interactive . For example , a deterministic strategy could exploit some standard traversal strategy ( such as depth ﬁrst ) over the containment hierarchy in the source . Stratego 64 is an example of a term rewriting language with a rich mechanism for expressing traversal in tree structures . Examples of nondeterministic strategies include one - point application , where a rule is applied to one nondeterministically selected loca - tion , and concurrent application , where one rule is Figure 6 Typing Untyped Syntactically Typed Semantically Typed Typing Figure 7 Parameterization Control Parameters Generics Higher - Order Rules Parameterization CZARNECKI AND HELSEN IBM SYSTEMS JOURNAL , VOL 45 , NO 3 , 2006 630 Figure 8 Model transformation approach features : ( A ) location determination , ( B ) rule scheduling , ( C ) rule organization , ( D ) source - target relationship , ( E ) incrementality , ( F ) directionality , and ( G ) tracing Concurrent One - Point Non - Deterministic Deterministic Interactive Rule Application Strategy A B Form Rule Iteration Rule Selection Phasing Rule Scheduling Looping Implicit ExplicitCondition Interactive ConflictResolution FixpointIteration Recursion Non - Deterministic Explicit Internal External G Source Target Tunable Dedicated Support Creation Manual Automatic StorageLocation Model Separate Tracing D Destructive Extension Only Source - Target Relationship New Target Existing Target Update In - Place c Inheritance LogicalComposition Rule Organization ModularityMechanisms ReuseMechanisms OrganizationalStructure Source - Oriented Target - Oriented Independent F Unidirectional Multidirectional Directionality E Target - Incrementality Source - Incrementality Incrementality Preservation of User Edits in the Target IBM SYSTEMS JOURNAL , VOL 45 , NO 3 , 2006 CZARNECKI AND HELSEN 631 applied concurrently to all matching locations in the source . Concurrent application is supported in AToM3 , AGG , and VIATRA . AGG offers critical pair analysis to verify for a set of rules that there will be no rules competing for the same source location . Some tools , such as AToM3 , allow the user to determine the location for rule application inter - actively . The target location for a rule is usually determin - istic . In an approach with separate source and target models , traceability links can be used to determine the target : A rule may follow the traceability link to a target element that was created by another rule and use the element as its own target . In the case of in - place update , the source location becomes the target location , although traceability links can also be used ( as later illustrated in Figure 10 ) . Rule application control : Rule scheduling Scheduling mechanisms determine the order in which individual rules are applied . Scheduling mechanisms can vary in four main areas ( Figure 8B ) . 1 . Form —The scheduling aspect can be expressed implicitly or explicitly . Implicit scheduling implies that the user has no explicit control over the scheduling algorithm deﬁned by the tool , as in BOTL . The only way a user can inﬂuence the system - deﬁned scheduling algorithm is by de - signing the patterns and logic of the rules to ensure certain execution orders . For example , a given rule could check for some information that only some other rule would produce . Explicit scheduling has dedicated constructs to explicitly control the execution order . Explicit scheduling can be internal or external . In external schedul - ing , there is a clear separation between the rules and the scheduling logic . For example , VIATRA offers rule scheduling by an external ﬁnite state machine . In contrast , internal scheduling is a mechanism allowing a transformation rule to directly invoke other rules , as in ATL or the code template shown in Example 3 . 2 . Rule selection —Rules can be selected by an explicit condition , as in MOLA . Some ap - proaches , such as BOTL , offer a nondeterministic choice . Alternatively , a conﬂict resolution mech - anism based on priorities can be provided . Interactive rule selection is also possible . Both priorities and interactive selection are supported in AToM3 . 3 . Rule iteration —Rule iteration mechanisms in - clude recursion , looping , and ﬁxpoint iteration ( i . e . , repeated application until no changes are detected ) . For example , ATL supports recursion , MOLA has a looping construct , and VIATRA supports ﬁxpoint iteration . 4 . Phasing —The transformation process may be organized into several phases , with each phase having a speciﬁc purpose , and only certain rules can be invoked in a given phase . For example , structure - oriented approaches , such as OptimalJ and the QVT submission by Interactive Objects and partners , 67 have a separate phase to create the containment hierarchy of the target model and a separate phase to set the attributes and references in the target ( see the ‘‘ Structure - driven approaches ’’ section ) . Rule organization Rule organization is concerned with composing and structuring multiple transformation rules . We con - sider three areas of variation in this context ( Figure 8C ) : 1 . Modularity mechanisms —Some approaches ( e . g . , QVT , ATL , MTL , and VIATRA ) allow packaging rules into modules . A module can import another module to access its content . 2 . Reuse mechanisms —Reuse mechanisms offer a way to deﬁne a rule based on one or more other rules . In general , scheduling mechanisms , such as calling one rule from another , can be used to deﬁne composite transformation rules . However , some approaches offer dedicated reuse mecha - nisms , such as inheritance between rules ( e . g . , rule inheritance , 68 derivation , 67 extension , 69 and specialization 59 ) , inheritance between modules ( e . g . , unit inheritance 68 ) , and logical composi - tion . 59 3 . Organizational structure —Rules may be orga - nized according to the structure of the source language ( as in attribute grammars , where actions are attached to the elements of the source language ) or the target language , or they may have their own independent organization . An example of the organization according to the structure of the target is the QVT submission by Interactive Objects and partners . 67 In this ap - proach , there is one rule for each target element type and the rules are nested according to the CZARNECKI AND HELSEN IBM SYSTEMS JOURNAL , VOL 45 , NO 3 , 2006 632 containment hierarchy in the target metamodel . For example , if the target language has a package construct in which classes can be nested , the rule for creating packages will contain the rule for creating classes ( which will contain rules for creating attributes and methods ) . Source - target relationship Some approaches , such as ATL , mandate the creation of a new target model that has to be separate from the source ( Figure 8D ) . However , in - place transformation can be simulated in ATL through an automatic copy mechanism . In some other approaches , such as VIATRA and AGG , source and target are always the same model ; that is , they only support in - place update . Yet other approaches , for example , QVT Relations and MTF , allow creating a new model or updating an existing one . QVT Relations also support in - place update . Further - more , an approach could allow a destructive update of the existing target or an update by extension only , that is , where existing model elements cannot be removed . Approaches using nondeterministic selec - tion and ﬁxpoint iteration scheduling ( see ‘‘ Rule Scheduling ’’ section earlier ) may restrict in - place update to extension in order to ensure termination . Alternatively , transformation rules may be orga - nized into an expansion phase followed by a contraction phase , which is often done in graph transformation systems such as AGG . Incrementality Incrementality involves three different features ( Figure 8E ) : 1 . Target incrementality —The basic feature of all incremental transformations is target - incremen - tality , that is , the ability to update existing target models based on changes in the source models . This basic feature is also referred to as change propagation in the QVT ﬁnal adopted speciﬁca - tion . 15 Obviously , target incrementality corre - sponds to the feature update in Figure 8D , but it is now seen from the change - propagation per - spective . A target - incremental transformation creates the target models if they are missing on the ﬁrst execution . A subsequent execution with the same source models as in the previous execution has to detect that the needed target elements already exist . This detection can be achieved , for example , by using traceability links . When any of the source models are modiﬁed and the transformation is executed again , the neces - sary changes to the target are determined and applied . At the same time , the target elements that can be preserved are preserved . 2 . Source incrementality —Source incrementality is about minimizing the amount of source that needs to be reexamined by a transformation when the source is changed . Source incremen - tality corresponds to incremental compilation : A change impact analysis determines the total set of source modules that need to be recompiled based on the list of source modules that were changed . Source incrementality is useful for working with large source models . 3 . Preservation of user edits in the target —Practical scenarios in the context of model synchronization require the ability to rerun a transformation on an existing user - modiﬁed target to resynchronize the target with a changed source while preserving the user edits in the target . The dimensions of model synchronization , such as the degree of preserva - tion of user - provided input in the target models , the degree of automation , and the frequency of triggering , are discussed elsewhere . 57 Directionality Transformations may be unidirectional or multi - directional ( Figure 8F ) . Unidirectional transforma - tions can be executed in one direction only , in which case a target model is computed ( or updated ) based on a source model . Multidirectional transformations can be executed in multiple directions , which is particularly useful in the context of model synchro - nization . Multidirectional transformations can be achieved using multidirectional rules or by deﬁning several separate complementary unidirectional rules , one for each direction . Transformation rules usually have a functional character : Given some input in the source model , they produce a concrete result in the target model . A declarative rule ( i . e . , one that only uses declarative logic or patterns ) can often be applied in the inverse direction , too . However , as different inputs may lead to the same output , the inverse of a rule may not be a function . In this case , the inversion could enumerate a number of possible solutions ( this could theoretically be inﬁnite ) , or just establish a part of the result in a concrete way ( because the part is the same for all solutions ) and use variables , defaults , or values already present in the result for the rest of it . The invertibility of a transformation IBM SYSTEMS JOURNAL , VOL 45 , NO 3 , 2006 CZARNECKI AND HELSEN 633 depends not only on the invertibility of the trans - formation rules , but also on the invertibility of the scheduling logic . In general , inverting a set of rules may fail to produce any result due to nontermina - tion . Tracing Tracing can be understood as the runtime footprint of transformation execution ( Figure 8G ) . Trace - ability links are a common form of trace information in model transformation , connecting source and target elements , which are essentially instances of the mapping between the source and target do - mains . Traceability links can be established by recoding the transformation rule and the source elements that were involved in creating a given target element . Trace information can be useful in performing impact analysis ( i . e . , analyzing how changing one model would affect other related models ) , determining the target of a transformation as in model synchronization , model - based debug - ging ( i . e . , mapping the stepwise execution of an implementation back to its high - level model ) , and in debugging model transformations themselves . Some approaches , such as QVT , ATL , and Tefkat , provide dedicated support for tracing . Even without dedicated support , as in the case of AGG , VIATRA and GReAT , tracing information can always be created just as any other target elements . Some approaches with dedicated support , Tefkat for example , require developers to manually encode the creation of traceability links in the transformation rules , while other approaches , such as QVT and ATL , create traceability links automatically . In the case of automated support , the approach may still provide some control over what gets recorded . In general , we might want to control ( 1 ) the kind of information recorded ( e . g . , the links between source and target elements , the rules that created them , and a time stamp for the creation ) , ( 2 ) the abstraction level of the recorded information ( e . g . , links for top - level transformations only ) , and ( 3 ) the scope for which the information is recorded ( e . g . , tracing for particular rules or parts of the source only ) . Finally , there is the choice of location where the links are stored ( e . g . , in the source or target , or separately ) . MAJOR CATEGORIES At the top level , we distinguish between model - to - text and model - to - model transformation approaches . The distinction between the two categories is that , while a model - to - model transformation creates its target as an instance of the target metamodel , the target of a model - to - text transformation is just strings . For completeness , we mention the concept of text - to - model transformation , but it essentially comprises parsing and reverse - engineering technol - ogies , which are beyond the scope of this paper . Model - to - text transformation corresponds to the concept of ‘‘ pretty printing ’’ in program transfor - mation . Model - to - text approaches are useful for generating both code and noncode artifacts such as documents . In general , we can view transforming models to code as a special case of model - to - model transformations ; we only need to provide a meta - model for the target programming language . How - ever , for practical reasons of reusing existing compiler technology and for simplicity , code is often generated simply as text , which is then fed into a compiler . OMG issued an RFP for a MOF 2 . 0 Model - to - Text Transformation Language in April 2004 , 70 which will eventually lead to a standard for mapping MOF - based models to text . Model - to - text approaches In the model - to - text category , we distinguish be - tween visitor - based and template - based approaches . Visitor - based approach A very basic code - generation approach consists in providing some visitor mechanism to traverse the internal representation of a model and write text to a text stream . An example of this approach is Jamda— an object - oriented framework providing a set of classes to represent UML models , an API for manipulating models , and a visitor mechanism ( CodeWriters ) to generate code . Jamda does not support the MOF standard to deﬁne new meta - models ; however , new model element types can be introduced by subclassing the existing Java classes that represent the predeﬁned model element types . Template - based approach The majority of currently available MDA tools support template - based model - to - text generation ( e . g . , openArchitectureWare , JET , FUUT - je , Coda - gen Architect , AndroMDA , ArcStyler , MetaEdit þ , and OptimalJ ) . AndroMDA reuses existing open - source template - based generation technology : Ve - locity 71 and XDoclet . 72 An example of the template - based approach is shown in Example 3 . A template usually consists of the target text containing splices of metacode to access information CZARNECKI AND HELSEN IBM SYSTEMS JOURNAL , VOL 45 , NO 3 , 2006 634 from the source and to perform code selection and iterative expansion . ( For an introduction to tem - plate - based code generation , see Cleaveland . 73 ) According to our terminology , the LHS uses ex - ecutable logic to access source , and the RHS combines untyped string patterns with executable logic for code selection and iterative expansion . Furthermore , there is no clear syntactic separation between the LHS and RHS . Template approaches usually offer user - deﬁned scheduling in the internal form of calling a template from within another template . The LHS logic accessing the source model may have different forms . The logic could be simply Java code accessing the API provided by the internal repre - sentation of the source model such as JMI , or it could be declarative queries , for example , in OCL or XPath . 74 The openArchitectureWare Generator Framework propagates the idea of separating more complex source access logic—which might need to navigate and gather information from different places of the source model—from templates by moving the logic into user - deﬁned operations of the source - model elements . Compared with a visitor - based transformation , the structure of a template resembles more closely the code to be generated . Templates lend themselves to iterative development as they can be easily derived from examples . Because the template approaches discussed in this section operate on text , the patterns they contain are untyped and can represent syntac - tically or semantically incorrect code fragments . On the other hand , textual templates are independent of the target language and simplify the generation of any textual artifacts , including documentation . A related technology is frame processing , which extends templates with more sophisticated adapta - tion and structuring mechanisms ( Bassett’s frames , 75 XVCL , 76 XFramer , 77 ANGIE * * 78 ) . To our knowledge , XFramer and ANGIE have been applied to generate code from models . Model - to - model approaches In the model - to - model category , we distinguish among direct - manipulation , structure - driven , op - erational , template - based , relational , graph - trans - formation - based , and hybrid approaches . Direct manipulation approach This category of approach offers an internal model representation and some APIs to manipulate it , such as JMI . It is usually implemented as an object - oriented framework , which may also provide some minimal infrastructure to organize the transforma - tions ( e . g . , abstract class for transformations ) . However , users usually have to implement trans - formation rules , scheduling , tracing , and other facilities , mostly from the beginning , in a program - ming language such as Java . Structure - driven approach Approaches in this category have two distinct phases : The ﬁrst phase is concerned with creating the hierarchical structure of the target model ; whereas , the second phase sets the attributes and references in the target . The overall framework determines the scheduling and application strategy ; users are only concerned with providing the trans - formation rules . An example of the structure - driven approach is the model - to - model transformation framework provided by OptimalJ . The framework is implemented in Java and provides incremental copiers that users have to subclass to deﬁne their own transformation rules . The basic metaphor is the idea of copying model elements from the source to the target , which can then be adapted to achieve the desired transforma - tion effect . The framework uses reﬂection to provide a declarative interface . A transformation rule is implemented as a method with an input parameter whose type determines the source type of the rule , and the method returns a Java object representing the class of the target model element . Rules are not allowed to have side effects , and scheduling is completely determined by the framework . Another structure - driven approach is the QVT submission by Interactive Objects and Project Technology . 67 A special property of this approach is the target - oriented rule organization , where there is one rule per target element type and the nesting of the rules corresponds to the containment hierarchy in the target metamodel . The execution of this model can be viewed as a top - down conﬁguration of the target model . Operational approach Approaches that are similar to direct manipulation but offer more dedicated support for model trans - formation are grouped in this category . A typical solution in this category is to extend the utilized metamodeling formalism with facilities for express - ing computations . An example would be to extend a IBM SYSTEMS JOURNAL , VOL 45 , NO 3 , 2006 CZARNECKI AND HELSEN 635 query language such as OCL with imperative constructs . The combination of MOF with such extended executable OCL becomes a fully - ﬂedged object - oriented programming system . Examples of systems in this category are QVT Operational mappings , XMF - Mosaic’s executable MOF , MTL , C - SAW , and Kermeta . Specialized facilities such as tracing may be offered through dedicated libraries . Example 4 shows our sample transformation from class models to schemas expressed in the QVT Operational language . In contrast to the QVT Relations solution from Example 1 , the transforma - tion declaration speciﬁes the parameter modes ; that is , the transformation is executed only in one direction from uml to rdbms . The entry point for the execution is the function main ( ) , which invokes the packageToSchema mapping on all packages and then the attributeToColumn mapping on all attributes contained in the input model uml . The mappings are defined by using an imperative extension of OCL . A mapping is defined as an operation on a model element . For example , packageToSchema is an operation of Package with Schema as its return type . The body of the mapping populates the properties of the return object , while self refers to the object on which the mapping was invoked . QVT Operations is a quite feature - rich language . The interested reader is invited to explore the QVT specification document . 15 Example 4 transformation umlRdbms ( in uml : SimpleUML , out rdbms : SimpleRDBMS ) ; main ( ) f uml . objectsOfType ( Package ) - . mappackageToSchema ( ) ; uml . objectsOfType ( Attribute ) - . map attributeToColumn ( ) ; g mapping Package : : packageToSchema ( ) : Schema f - - population section for the schema name : ¼ self . name ; tbls : ¼ self . elems - . map classToTable ( ) ; g mapping Class : : classToTable ( ) : Table when f self . isPersistent ¼ true ; g f name : ¼ self . name ; key : ¼ object Column f name : ¼ self . name þ 0 _ tid 0 ; type : ¼ 0 NUMBER 0 ; g ; cols : ¼ key ; g mapping Attributes : : attributeToColumn ( ) : Column f . . . g . . . Template - based approach Model templates are models with embedded meta - code that compute the variable parts of the resulting template instances . Model templates are usually expressed in the concrete syntax of the target language , which helps the developer to predict the result of template instantiation . The metacode can have the form of annotations on model elements . Typical annotations are conditions , iterations , and expressions , all being part of the metalanguage . An obvious choice for the expression language to be used in the metalanguage is OCL . A concrete model - template approach is given by Czarnecki and Antkiewicz . 79 In that approach , a template of a UML model , such as a class or activity diagram , is created by annotating model elements with conditions or expressions represented as stereotypes . A very simple example is shown in Figure 9 , which reuses the class model from Figure 2C . This time , however , the model is shown in its UML concrete syntax . The class Address and the addr attribute of Customer are annotated with the presence condition addrFeature . When the tem - plate is instantiated with addrFeature being true , the resulting model is the same as the template . If the condition is false , the annotated elements , which are blue in the figure , are removed . Relational approach This category groups declarative approaches in which the main concept is mathematical relations . In general , relational approaches can be seen as a form of constraint solving . Examples of relational approaches are QVT Relations , MTF , Kent Model Transformation Language , Tefkat , AMW , and map - pings in XMF - Mosaic . The basic idea is to specify the relations among source and target element types using constraints . In CZARNECKI AND HELSEN IBM SYSTEMS JOURNAL , VOL 45 , NO 3 , 2006 636 its pure form , such a speciﬁcation is nonexecutable ( e . g . , relations 18 , 59 and mapping rules 68 ) . However , declarative constraints can be given executable semantics , such as in logic programming . In fact , logic programming with its uniﬁcation - based matching , search , and backtracking seems a natural choice to implement the relational approach , where predicates can be used to describe the relations . Gerber et al . 20 explore the application of logic programming , in particular Mercury , a typed dialect of Prolog , and F - logic , an object - oriented logic paradigm , to implement transformations . An exam - ple of the relational approach is shown in Example 1 . All of the relational approaches are side - effect - free and , in contrast to the imperative direct manipu - lation approaches , create target elements implicitly . Relational approaches can naturally support multi - directional rules . They sometimes also provide backtracking . Most relational approaches require strict separation between source and target models ; that is , they do not allow in - place update . Graph - transformation - based approach This category of model transformation approaches draws on the theoretical work on graph trans - formations . In particular , this category operates on typed , attributed , labeled graphs , 80 which can be thought of as formal representations of simpliﬁed class models . Examples include AGG , AToM3 , VIATRA , GReAT , UMLX , BOTL , MOLA , and Fujaba . Graph transformation rules have an LHS and an RHS graph pattern . The LHS pattern is matched in the model being transformed and replaced by the RHS pattern in place . The LHS often contains conditions in addition to the LHS pattern , for example , negative conditions . Some additional logic , for example , in string and numeric domains , is needed to compute target attribute values such as element names . GReAT offers an extended form of patterns with multiplicities on edges and nodes . Graph patterns can be rendered in the concrete syntax of their respective source or target language ( e . g . , in VIATRA ) or in the MOF abstract syntax ( e . g . , in BOTL and AGG ) . The advantage of the concrete syntax is that it is more familiar to developers working with a given modeling language than the abstract syntax . Also , for complex lan - guages like UML , patterns in a concrete syntax tend to be much more concise than patterns in the corresponding abstract syntax ( compare Figures 3C and 9 and also see the work by Marschall and Braun 28 for examples ) . On the other hand , it is easy to provide a default rendering for abstract syntax that will work for any metamodel , which is useful when no specialized concrete syntax is available . AGG and AToM3 are systems directly implementing the theoretical approach to attributed graphs and transformations on such graphs . They have built - in ﬁxpoint scheduling with nondeterministic rule selection and concurrent application to all matching locations , and they rely on implicit scheduling by the user . The transformation rules are unidirectional and in - place . Figure 10 illustrates how the transformation from class models to schemas can be expressed in AGG . Only two rules are shown . The rule in Figure 10A maps packages to schemas . The mapping from classes to tables is given in Figure 10B . The mapping of attributes to columns is not shown . The RHS of an AGG rule contains a mixture of the new elements and elements from the LHS , as indicated by the indexes preﬁxing their names . When the LHS is matched , new elements are created . The implicit scheduling is achieved through correspondence objects connecting source and target elements ( which are an example of intermediate structures ) and negative conditions . For example , the package - to - schema rule matches packages and creates the corresponding schemas and the package - to - schema correspondence objects ( i . e . , instances of P2S ) . Each rule has a negative application condition , which is implicitly assumed to be its RHS . Because of the negative application condition , no additional sche - ma objects will be created for a package that is already connected to a schema by a P2S object . Figure 9 Example of a model template App < < addrFeature > > Address { isPersistent = false } addln : String Customer { isPersistent = true } name : String < < addrFeature > > addr : Address IBM SYSTEMS JOURNAL , VOL 45 , NO 3 , 2006 CZARNECKI AND HELSEN 637 Systems such as VIATRA , GReAT , MOLA , and Fujaba extend the basic functionality of AGG and AToM3 by adding explicit scheduling . For example , VIATRA users can build state machines to schedule transformation rules . The explicit representation of scheduling in GReAT is a data - ﬂow graph . MOLA and Fujaba use control - ﬂow graphs for that purpose . The class - model - to - schema transformation ex - pressed in MOLA is shown in Figure 11 . Each enclosing rectangular box represents a looping construct . Boxes with rounded corners represent looping conditions . The elements to be matched are drawn using solid lines ; dashed lines are used for the elements to be created . The top condition matches package objects . When a package object is matched , the corresponding schema is created and the body of the loop , which is another loop , is executed . The latter loop iterates over all classes in the package that was matched in the current iteration of the outer loop and creates the corre - sponding classes and primary - key columns . The ﬁnal step is a call to ProcessClassAttributes , which is a subprogram mapping attributes to columns . Relational - style , multidirectional approaches based on graph transformations are also possible . For example , Ko¨nigs 32 discusses using a transformation approach based on triple - graph grammars to simu - late QVT Relations . Hybrid approach Hybrid approaches combine different techniques from the previous categories . The different ap - proaches can be combined as separate components or , in a more ﬁne - grained fashion , at the level of individual rules . QVT is an example of a hybrid approach with three separate components , namely Relations , Operational mappings , and Core . Exam - ples of the ﬁne - grained combination are ATL and YATL . A transformation rule in ATL may be fully declar - ative , hybrid , or fully imperative . The LHS of a fully declarative rule ( so - called source pattern ) consists of a set of syntactically typed variables with an optional OCL constraint as a ﬁlter or navigation logic . The RHS of a fully declarative rule ( so - called target pattern ) contains a set of variables and some declarative logic to bind the values of the attributes in the target elements . In a hybrid rule , the source or target patterns are complemented with a block of imperative logic , which is run after the application of the target pattern . A fully imperative rule ( so - called procedure ) has a name , a set of formal parameters , and an imperative block , but no patterns . Rules are unidirectional and support rule inheritance . Other approaches Two more approaches are mentioned for complete - ness : transformation implemented using Extensible Stylesheet Language Transformation ( XSLT 81 ) and Figure 10 Graph transformation in AGG : ( A ) package - to - schema rule and ( B ) class - to - table rule cols pkey A tar src 1 : Class name = cn isPersistent = true 4 : Schema 3 : P2S B tar src 1 : Class name = cn isPersistent = true 4 : Schema tar src Table name = cn Column name = cn + ' _ tid ' type = ' NUMBER ' 3 : P2S C2T 2 : Package 2 : Package 1 : Package name = pn 1 : Package name = pn Schema name = pn src tar P2S CZARNECKI AND HELSEN IBM SYSTEMS JOURNAL , VOL 45 , NO 3 , 2006 638 the application of metaprogramming to model transformation . Because models can be serialized as Extensible Markup Language ( XML ) using the XML Metadata Interchange ( XMI * * ) , 82 implementing model trans - formations using XSLT , which is a standard tech - nology for transforming XML , seems very attractive . Such an approach can be classiﬁed as term rewriting using a functional language . Unfortunately , the use of XMI and XSLT has scalability limitations . Manual implementation of model transformations in XSLT quickly leads to non - maintainable implementations because of the verbosity and poor readability of XMI and XSLT . A solution is to generate the XSLT rules from some more declarative rule descriptions , as demonstrated in the work by Peltier et al . 83 , 84 ; however , even this approach suffers from poor efﬁciency because of the copying required by the pass - by - value semantics of XSLT and the poor compactness of XMI . A more promising direction in applying traditional metaprogramming techniques to model transforma - tions has been proposed by Tratt . 37 His solution is a domain - speciﬁc language for model transformations embedded in a metaprogramming language . DISCUSSION In this section , we comment on the practical applicability of the different types of model trans - formation . These comments are based on our intuition and the application examples published together with the approaches . Because of the lack of controlled experiments and extensive practical experience , these comments are not fully validated , but we hope that they will stimulate discussion and further evaluation . Direct manipulation is obviously the most low - level approach . In its basic form , it offers the user little or no support or guidance in implementing trans - formations . Essentially , all work has to be done by the user . The approach can be improved by adding Figure 11 Graph transformation in MOLA ProcessClassAttributes ( ) # packageToSchema p : Package s : Schema name : = @ p . name pkey cols # packageToSchema @ p : Package @ s : Schema # classToTable c : Class { isPersistent = true } t : Table name = @ c . name cl : Column name : = @ c . name + ' _ tid ' type = ' NUMBER ' IBM SYSTEMS JOURNAL , VOL 45 , NO 3 , 2006 CZARNECKI AND HELSEN 639 specialized libraries and frameworks implementing facilities such as pattern matching and tracing . Operational approaches are similar to direct ones except that they offer an executable metamodeling formalism through a dedicated language . Providing specialized facilities through libraries and frame - works seems to be an attractive way to improve the support for model transformations in an evolu - tionary way . The structure - driven category covers pragmatic approaches that were developed in the context of ( and seem to apply particularly well to ) certain kinds of applications such as generating Enterprise JavaBeans * * ( EJB * * ) implementations and database schemas from UML models . These applications require strong support for transforming models with a 1 - to - 1 and 1 - to - n ( and sometimes n - to - 1 ) corre - spondence between source and target elements . Also , in this application context , there is typically no need for iteration ( and in particular ﬁxpointing ) in scheduling , which can be system - deﬁned . It is unclear how well these approaches can support other kinds of applications . Template - based approaches make it easy for the developer to predict the resulting code or models just by looking at the templates . They also support iterative development in which the developer can start with a sample model or code and turn it into a template . Current template - based approaches do not have built - in support for tracing , although trace information can be easily encoded in the templates . Templates are particularly useful in code generation and model compilation scenarios . Relational approaches seem to strike a good balance between ﬂexibility and declarative expression . They can provide multidirectionality and incrementality , including the update of a manually modiﬁed target . On the other hand , their power is contingent on the sophistication of the underlying constraint - solving facilities . As a result , performance strongly depends on the kinds of constraints that need to be solved , which may limit their applicability . In any case , relational approaches seem to be most applicable to model synchronization scenarios . Graph - transformation - based approaches are in - spired by theoretical work in graph transformations . In their pure form , graph transformations are declarative and also seem intuitive ; however , the usual ﬁxpoint scheduling with concurrent applica - tion makes them rather difﬁcult to use due to the possible lack of conﬂuence and termination . Exist - ing theories for detecting such problems are not general enough to cover the wide range of trans - formations found in practice . As a result , tools such as GReAT , VIATRA , and MOLA provide mecha - nisms for explicit scheduling . It is often argued that graph transformations are a natural choice for model transformations because models are graphs . As Batory points out , 85 there are plenty of examples of graph structures in practice , including the objects in a Java program whose processing is usually not understood as graph transformations . In our opin - ion , a particular weakness of existing graph trans - formation theories and tools is that they do not consider ordered graphs , that is , graphs with ordered edges . As a consequence , they are appli - cable to models that contain predominantly un - ordered collections , such as class diagrams with classes having unordered collections of attributes and methods . However , they do not apply well to method bodies , where ordering is important , such as in a list of statements . Ordering can be represented by additional edges , but this approach leads to more complex transformations . It is interesting to note that ordering is well handled by classical program transformation , which uses term rewriting on abstract syntax trees ( ASTs ) . Terms and ASTs are ordered trees , and the order of child nodes is used to encode lists of program elements such as state - ments . Edge ordering can be modeled in graph transformations by using edge attributes to attach an index to each edge ; however , current tools based on graph transformation do not exploit this information for more efﬁcient pattern matching . Nevertheless , graph transformation theory might turn out to be useful for ensuring correctness in some application scenarios . Fujaba is probably the largest and most signiﬁcant example of applying graph transforma - tions to models to date . It remains to be seen what impact these approaches will have on systems used in practice . Hybrid approaches allow the user to mix and match different concepts and paradigms depending on the application . Given the wide range of practical scenarios , a comprehensive approach is likely to be hybrid . A point in case is the QVT speciﬁcation , which also offers a hybrid solution . RELATED WORK The feature model and categorization presented in this paper is based on our earlier paper . 86 The CZARNECKI AND HELSEN IBM SYSTEMS JOURNAL , VOL 45 , NO 3 , 2006 640 previous feature model has been widely discussed in workshops and in personal communications . It has also been used by other authors . For example , Jouault and Kurtev 24 give a classiﬁcation of ATL and AMW using the earlier version of the model . The current feature model and categories take into account the feedback that we have received based on the original paper . They were also revised to cover approaches that were proposed after 2003 , most prominently , the ﬁnal adopted QVT speciﬁca - tion . Introducing domains into transformation rules was one of the most important changes to the feature model based on that speciﬁcation . Only ﬁve out of the 14 presented feature diagrams remained unchanged compared with the original model , namely , those in Figures 5A , 6 , and 8A – 8C . We also added two new categories of model - to - model ap - proaches , namely , operational and template - based approaches . In their review of the different QVT submissions , Gardner et al . 87 propose a uniﬁed terminology to enable a comparison of the different proposals . As their scope of comparison is considerably different from ours , there is not much overlap in terminology . While Gardner et al . focus on the eight initial QVT submissions , we discuss a wider range of ap - proaches : In addition to the revised QVT submis - sions , we also discuss other approaches published in the literature and available in tools . Another differ - ence is that Gardner et al . discuss model queries , views , and transformations , whereas we focus on transformations in more detail . The terms deﬁned by Gardner et al . that are also relevant for our classiﬁcation are model transformation , unidirec - tional , bidirectional , declarative , imperative , and rules . In addition to providing the basic unifying termi - nology , Gardner et al . discuss practical requirements on model transformations such as requirements scalability , simplicity , and ease of adoption . Among others , they discuss the need to handle trans - formation scenarios of different complexities , such as transformations with different origin relation - ships between source and target model elements , for example , 1 - to - 1 , 1 - to - n , n - to - 1 , and n - to - m . Finally , they make some recommendations for the ﬁnal QVT standard . In particular , they recommend a hybrid approach , supporting declarative speciﬁcation of simpler transformations , but allowing for an im - perative implementation of more complex ones . Another account of requirements for model trans - formation approaches is given by Sendall and Kozaczynski . 88 Mens and Van Gorp 60 have also proposed a classiﬁcation of model transformations , which they apply to graph transformation systems . 89 That work has been signiﬁcantly inﬂuenced by our earlier classiﬁcation . The main difference is that their classiﬁcation is broader as it also covers different aspects of model transformation tools such as usability , extensibility , interoperability , and stan - dards . In contrast , our feature model offers a more detailed treatment of model transformation ap - proaches . Another difference is that Mens and Van Gorp present a ﬂat list of dimensions , whereas our dimensions are organized hierarchically . An exten - sive comparison of graph transformation ap - proaches using a common example is given by Taentzer et al . 90 CONCLUSIONS Model transformation is a relatively young area . Although it is related to and builds upon the more established ﬁelds of program transformation and metaprogramming , the use of graphical modeling languages and the application of object - oriented metamodeling to language deﬁnitions set a new context . In this paper , we presented a feature model offering a terminology for describing model transformation approaches and making the different design choices for such approaches explicit . We also surveyed and classiﬁed existing approaches into visitor - based and template - based model - to - text categories and direct - manipulation , structure - driven , operational , tem - plate - based , relational , graph - transformation - based , and hybrid model - to - model categories . Although there are satisfactory solutions for trans - forming models to text ( such as template - based approaches ) , this is not the case for transforming models to models . Many new approaches to model - to - model transformation have been proposed over the last three years , but relatively little experience is available to assess their effectiveness in practical applications . In this respect , we are still at the stage of exploring possibilities and eliciting requirements . Modeling tools available on the market are just starting to offer some model - to - model transforma - tion capabilities , but these are still very limited and IBM SYSTEMS JOURNAL , VOL 45 , NO 3 , 2006 CZARNECKI AND HELSEN 641 often ad hoc , that is , without proper theoretical foundation . Evaluation of the different design options for a model transformation approach will require more experiments and practical experience . ACKNOWLEDGMENTS The authors thank Karl - Trygve Kalleberg for his extensive feedback on earlier versions of the feature model , Markus Vo¨lter for providing the template examples in Examples 2 and 3 , and Ulrich Eisenecker , Don Batory , Jeff Gray , Laurence Tratt , Gabriele Taentzer and the anonymous reviewers for their valuable comments on a previous draft of the paper . * Trademark , service mark , or registered trademark of International Business Machines Corporation . * * Trademark , service mark , or registered trademark of Object Management Group , Inc . , Sun Microsystems Inc . , Compuware Corporation , MetaCase Consulting , Interactive Objects Soft - ware GmbH Corporation , The MathWorks , Inc . , or Delta Software Technology GmbH , in the United States , other countries , or both . CITED REFERENCES 1 . T . Stahl and M . Vo¨lter , Model - Driven Software Develop - ment—Technology , Engineering , Management , John Wi - ley and Sons , Ltd . , Chichester , England ( in press June 2006 ) , ISBN : 0470025700 . 2 . Object Management Group , MDA Guide , Version 1 . 0 . 1 , OMG Document omg / 2003 - 06 - 01 ( 2003 ) . 3 . D . S . Frankel , Model Driven Architecture : Applying MDA to Enterprise Computing , Wiley Press , Hoboken , NJ ( 2003 ) . 4 . J . Sztipanovits and G . Karsai , ‘‘ Model - Integrated Com - puting , ’’ Computer 30 , No . 4 , 110 – 111 ( 1997 ) . 5 . J . Greenﬁeld and K . Short , Software Factories : Assembling Applications with Patterns , Models , Frameworks , and Tools , John Wiley and Sons , Indianapolis , IN ( 2004 ) . 6 . K . Czarnecki , ‘‘ Overview of Generative Software Devel - opment , ’’ Proceedings of Unconventional Programming Paradigms , Mont Saint - Michel , France ( 2004 ) , pp . 313 – 328 . 7 . A . Kleppe , J . Warmer , and W . Bast , MDA Explained , The Model Driven Architecture : Practice and Promise , Addi - son - Wesley , Boston , MA ( 2003 ) . 8 . I . Ivkovic and K . Kontogiannis , ‘‘ Tracing Evolution Changes of Software Artifacts through Model Synchroni - zation , ’’ Proceedings of the 20th IEEE International Conference on Software Maintenance , Washington , DC ( 2004 ) , pp . 252 – 261 . 9 . R . I . Bull and J . - M . Favre , ‘‘ Visualization in the Context of Model Driven Engineering , ’’ Proceedings of the Workshop on Model Driven Development of Advanced User Inter - faces , Montego Bay , Jamaica ( 2005 ) , http : / / sunsite . informatik . rwth - aachen . de / Publications / CEUR - WS / / Vol - 159 / paper8 . pdf . 10 . A . Solberg , R . France , and R . Reddy , ‘‘ Navigating the MetaMuddle , ’’ Proceedings of the 4th Workshop in Software Model Engineering , Montego Bay , Jamaica ( 2005 ) , http : / / www . planetmde . org / wisme - 2005 / NavigatingTheMetaMuddle . pdf . 11 . G . Sunye´ , D . Pollet , Y . Le Traon , and J . - M . Je´ze´quel , ‘‘ Refactoring UML Models , ’’ Proceedings of the 4th International Conference , Uniﬁed Modeling Language Conference , Toronto , Canada ( 2001 ) , pp . 134 – 148 . 12 . J . Zhang , Y . Lin , and J . Gray , ‘‘ Generic and Domain - Speciﬁc Model Refactoring Using a Model Transformation Engine , ’’ Chapter 9 in Model - Driven Software Develop - ment , S . Beydeda , M . Book , and V . Gruhn , Editors , Springer - Verlag , Heidelberg , Germany ( 2005 ) , pp . 199 – 218 . 13 . J . - M . Favre , ‘‘ Ca c Oph o Ny : Metamodel - Driven Architec - ture Reconstruction , ’’ Proceedings of the Working Con - ference on Reverse Engineering , Delft , The Netherlands ( 2004 ) , pp . 204 – 213 . 14 . Object Management Group , MOF 2 . 0 Query / Views / Transformations RFP , OMG Document ad / 2002 - 04 - 10 ( revised on April 24 , 2002 ) . 15 . Object Management Group , MOF QVT Final Adopted Speciﬁcation , OMG Adopted Speciﬁcation ptc / 05 - 11 - 01 ( 2005 ) . 16 . D . Varro´ , G . Varro´ , and A . Pataricza , ‘‘ Designing the Automatic Transformation of Visual Languages , ’’ Science of Computer Programming 44 , No . 2 , 205 – 227 ( 2002 ) . 17 . D . Varro´ and A . Pataricza , ‘‘ Generic and Meta - Trans - formations for Model Transformation Engineering , ’’ Proceedings of the 7th International Conference on the Uniﬁed Modeling Language , Lisbon , Portugal ( 2004 ) , pp . 290 – 304 . 18 . D . H . AkehurstandS . J . H . Kent , ‘‘ ARelationalApproachto Deﬁning Transformations ina Metamodel , ’’ Proceedings of the 5th International Conference on the Uniﬁed Modeling Language , Dresden , Germany ( 2002 ) , pp . 243 – 258 . 19 . D . H . Akehurst , W . G . Howells , and K . D . McDonald - Maier , ‘‘ Kent Model Transformation Language , ’’ Pro - ceedings of Model Transformations in Practice Workshop , MoDELS Conference , Montego Bay , Jamaica ( 2005 ) , http : / / sosym . dcs . kcl . ac . uk / events / mtip05 / submissions / akehurst _ howells _ mcdonald - maier _ _ kent _ model _ transformation _ language . pdf . 20 . A . Gerber , M . Lawley , K . Raymond , J . Steel , and A . Wood , ‘‘ Transformation : The Missing Link of MDA , ’’ Proceedings of the 1st International Conference on Graph Transformation , Barcelona , Spain ( 2002 ) , pp . 90 – 105 . 21 . M . Lawley and J . Steel , ‘‘ Practical Declarative Model Transformation with Tefkat , ’’ Proceedings of Model Transformations in Practice Workshop , MoDELS Confer - ence , Montego Bay , Jamaica ( 2005 ) , http : / / sosym . dcs . kcl . ac . uk / events / mtip05 / submissions / lawley _ steel _ _ practical _ declarative _ model _ transformation _ with _ tefkat . pdf . 22 . A . Agrawal , G . Karsai , and F . Shi , Graph Transformations on Domain - Speciﬁc Models , Technical Report ISIS - 03 - 403 , Institute for Software Integrated Systems , Vanderbilt University , Nashville , TN 37203 ( 2003 ) . 23 . J . Be´zivin , G . Dupe´ , F . Jouault , G . Pitette , and J . E . Rougui , ‘‘ First Experiments with the ATL Model Trans - formation Language : Transforming XSLT into XQuery , ’’ Proceedings of the Workshop on Generative Techniques in the Context of Model Driven Architecture , Anaheim , CA CZARNECKI AND HELSEN IBM SYSTEMS JOURNAL , VOL 45 , NO 3 , 2006 642 ( 2003 ) , http : / / www . softmetaware . com / oopsla2003 / bezivin . pdf . 24 . F . Jouault and I . Kurtev , ‘‘ Transforming Models with ATL , ’’ Proceedings of Model Transformations in Practice Workshop ( MTIP ) , MoDELS Conference , Montego Bay , Jamaica ( 2005 ) , http : / / sosym . dcs . kcl . ac . uk / events / mtip05 / submissions / jouault _ kurtev _ _ transforming _ models _ with _ atl . pdf . 25 . E . D . Willink , ‘‘ UMLX : A Graphical Transformation Language for MDA , ’’ Proceedings of the 18th Annual ACM SIGPLAN Conference on Object - Oriented Programming , Systems , Languages , and Applications , Anaheim , CA ( 2003 ) , pp . 13 – 24 ( 2003 ) . 26 . J . de Lara and H . Vangheluwe , ‘‘ AToM : A Tool for Multi - Formalism and Meta - Modeling , ’’ Proceedings of the 5th International Conference on Fundamental Approaches to SoftwareEngineering , Grenoble , France ( 2002 ) , pp . 174 – 188 . 27 . P . Braun and F . Marschall , The Bi - directional Object - Oriented Transformation Language , Technical Report TUM - I0307 , Technische Universita¨t Mu¨nchen 85748 , Mu¨nchen , Germany ( May 2003 ) . 28 . F . Marschall and P . Braun , ‘‘ Model Transformations for the MDA with BOTL , ’’ Proceedings of the Workshop on Model Driven Architecture : Foundations and Applica - tions , Enschede , The Netherlands ( 2003 ) , pp . 25 – 36 . 29 . A . Kalnins , J . Barzdins , and E . Celms , ‘‘ Model Trans - formation Language MOLA , ’’ Proceedings of Model Driven Architecture : Foundations and Applications , Linkoeping , Sweden ( 2004 ) , pp . 14 – 28 . 30 . G . Taentzer , ‘‘ AGG : A Graph Transformation Environ - ment for Modeling and Validation of Software , ’’ Appli - cation of Graph Transformations with Industrial Relevance ( AGTIVE’03 ) 3062 , pp . 446 – 453 ( 2003 ) . 31 . J . Be´zivin , F . Jouault , P . Rosenthal , and P . Valduriez , ‘‘ Modeling in the Large and Modeling in the Small , ’’ Proceedings of the European MDA Workshops : Founda - tions and Applications , Twente , The Netherlands ( 2003 ) , and Linkoeping , Sweden ( 2004 ) , pp . 33 – 46 . 32 . A . Ko¨nigs , ‘‘ Model Transformation with Triple Graph Grammars , ’’ Proceedings of Model Transformations in Practice Workshop at MoDELS Conference , Montego Bay , Jamaica ( 2005 ) , http : / / www . es . tu - darmstadt . de / download / publications / koenigs / model _ transformation _ with _ triple _ graph _ grammars . pdf . 33 . D . Vojtisek and J . - M . Je´ze´quel , ‘‘ MTL and Umlaut NG : Engine and Framework for Model Transformation , ’’ http : / / www . ercim . org / publication / Ercim _ News / enw58 / vojtisek . html . 34 . O . Patrascoiu , ‘‘ YATL : Yet Another Transformation Language , ’’ Proceedings of the 1st European MDA Work - shop , Twente , The Netherlands ( 2004 ) , pp . 83 – 90 . 35 . P . - A . Muller , F . Fleurey , and J . - M . Je´ze´quel , ‘‘ Weaving Executability into Object - Oriented Metalanguages , ’’ ACM / IEEE 8th International Conference on Model Driven Engineering Languages and Systems , Montego Bay , Jamaica ( 2005 ) , pp . 264 – 278 . 36 . J . Gray , Y . Lin , and J . Zhang , ‘‘ Automating Change Evolution in Model - Driven Engineering , ’’ IEEE Computer ( Special issue on Model - Driven Engineering ) 36 , No . 2 , 51 – 58 ( February 2006 ) , http : / / www . cis . uab . edu / gray / Pubs / computer . pdf . 37 . L . Tratt , ‘‘ The MT Model Transformation Language , ’’ Proceedings of ACM SIGAPP Symposium on Applied Computing , Dijon , France ( 2006 ) , http : / / portal . acm . org / afﬁliated / citation . cfm ? id ¼ 1141277 . 1141577 & coll ¼ ACM & dl ¼ ACM & type ¼ series & idx ¼ 1141277 & part ¼ Proceedings & WantType ¼ Proceedings & title ¼ Symposium % 20on % 20Applied % 20Computing & CFID ¼ 15151515 & CFTOKEN ¼ 6184618 . 38 . AndroMDA 2 . 0 . 3 , http : / / www . andromda . org . 39 . openArchitectureWare ( oAW ) , http : / / www . openarchitectureware . org / . 40 . Fujaba Tool Suite 4 , University of Paderborn Software Engineering , http : / / www . fujaba . de . 41 . JAMDA , Java Model Driven Architecture 0 . 2 , http : / / sourceforge . net / projects / jamda . 42 . R . Pompa , Java Emitter Templates ( JET ) Tutorial , Azzurri Ltd . ( June 2005 ) , http : / / www . eclipse . org / articles / Article - JET / jet _ tutorial1 . html . 43 . G . van Emde Boas , The Fantastic , Unique , UML Tool for the Java Environment ( FUUT - je ) , http : / / www . bronstee . com / index . php ? id ¼ FUUT - je . 44 . Model Transformation Framework ( MTF ) , IBM United Kingdom Laboratories Ltd . , IBM alphaWorks ( 2004 ) , http : / / www . alphaworks . ibm . com / tech / mtf . 45 . XMF - Mosaic , Xactium , http : / / xactium . com . 46 . OptimalJ 4 . 0 , User’s Guide , Compuware ( June 2005 ) , http : / / www . compuware . com / products / optimalj . 47 . J . - P . Tolvanen , ‘‘ Making Model - Based Code Generation Work , ’’ Embedded Systems Europe , pp . 36 – 38 ( August / September 2004 ) , http : / / i . cmpnet . com / embedded / europe / esesep04 / esesep04p36 . pdf . 48 . Domain - Speciﬁc Modeling with MetaEdit þ , MetaCase , http : / / www . metacase . com / . 49 . ArcStyler 5 . 1 , Interactive Objects Software GmbH , http : / / www . arcstyler . com . 50 . Codagen Architect 3 . 0 , Codagen Technologies Corp . , http : / / www . codagen . com / products / architect / default . htm . 51 . H . Partsch and R . Steinbru¨ggen , ‘‘ Program Transforma - tion Systems , ’’ ACM Computing Surveys 15 , No . 3 , 199 – 236 ( 1983 ) . 52 . H . Partsch , Speciﬁcation and Transformation of Pro - grams—a Formal Approach to Software Development , Springer - Verlag , Berlin , Germany ( 1990 ) . 53 . K . Czarnecki , ‘‘ Domain Engineering , ’’ in Encyclopedia of Software Engineering Second Edition , J . J . Marciniak , Editor , John Wiley and Sons , Inc . , Hoboken , NJ ( 2002 ) , pp . 433 – 444 . 54 . K . C . Kang , S . G . Cohen , J . A . Hess , W . E . Nowak , and A . S . Peterson , Feature - Oriented Domain Analysis ( FODA ) Feasibility Study , Technical Report CMU / SEI - 90 - TR - 21 , Software Engineereing Institute , Carnegie Mellon University , Pittsburgh , PA 15213 ( 1990 ) . 55 . K . Czarnecki and U . W . Eisenecker , Generative Program - ming : Methods , Tools , and Applications , Addison - Wesley Professional , Boston , MA ( 2000 ) . 56 . K . Czarnecki , S . Helsen , and U . Eisenecker , ‘‘ Formalizing Cardinality - Based Feature Models and Their Special - ization , ’’ Software Process : Improvement and Practice 10 , No . 1 , 7 – 29 ( 2005 ) . 57 . C . H . P . Kim and K . Czarnecki , ‘‘ Synchronizing Cardin - ality - Based Feature Models and their Specializations , ’’ Proceedings of the European Conference on Model Driven Architecture , Nuremberg , Germany ( 2005 ) , swen . uwaterloo . ca / ; kczarnec / ecmda05 . pdf . 58 . E . Cariou , R . Marvie , L . Seinturier , and L . Duchien , Model Transformation Contracts and Their Deﬁnition in UML and OCL , Technical Report LIFL 2004 - n 8 08 , Laboratoire d’Informatique Fondamentale de Lille , Universite´ des Sciences et Technologies de Lille , 59655 Villeneuve d’Ascq Cedex , France ( 2004 ) . 59 . MOF Query / Views / Transformations , OMG Document ad / 03 - 08 - 08 , Object Management Group , Inc . , ( revised in August 2003 ) . IBM SYSTEMS JOURNAL , VOL 45 , NO 3 , 2006 CZARNECKI AND HELSEN 643 60 . Meta Object Facility ( MOF ) 2 . 0 Core Speciﬁcation , OMG Adopted Speciﬁcation ptc / 03 - 10 - 04 , Object Management Group , Inc . , ( 2003 ) . 61 . T . Mens and P . Van Gorp , ‘‘ A Taxonomy of Model Transformation and Its Application to Graph Trans - formation , ’’ Proceedings of the International Workshop on Graph and Model Transformation , Tallinn , Estonia ( 2005 ) , pp . 7 – 23 . 62 . E . Visser , Program - Transformation . Org : The Program Transformation Wiki , http : / / www . program - transformation . org / Transform / ProgramTransformation . 63 . Java Metadata Interface 1 . 0 ( JMI ) , Sun Microsystems , Inc . ( June 2002 ) , http : / / java . sun . com / products / jmi . 64 . E . Visser , ‘‘ Program Transformation with Stratego / XT : Rules , Strategies , Tools , and Systems in StrategoXT - 0 . 9 , ’’ Proceedings of the International Domain - Speciﬁc Program Generation Seminar , Dagstuhl , Germany ( 2003 ) , pp . 216 – 238 . 65 . R . Silaghi , F . Fondement , and A . Strohmeier , ‘‘ ‘Weaving’ MTL Model Transformations , ’’ Proceedings of the Euro - pean MDA Workshops : Foundations and Applications , Twente , The Netherlands ( 2003 ) , and Linkoeping , Sweden ( 2004 ) , pp . 123 – 138 . 66 . I . Kurtev , Adaptability of Model Transformations , PhD thesis , University of Twente , Enschede , The Netherlands ( 2005 ) , http : / / wwwhome . cs . utwente . nl / ; kurtev / ﬁles / thesis . pdf . 67 . Object Management Group , Interactive Objects and Project Technology , MOF Query / Views / Transformations , OMG Document ad / 03 - 08 - 11 , ad / 03 - 08 - 12 , and ad / 03 - 08 - 13 ( revised submission , 2003 ) . 68 . Object Management Group , Response to the MOF 2 . 0 Query / Views / Transformations RFP ( ad / 2002 - 04 - 10 ) , OMG Document ad / 2003 - 08 - 05 ( 2003 ) . 69 . Object Management Group , MOF Query / Views / Trans - formations , First Revised Submission , OMG Document ad / 03 - 08 - 03 ( 2003 ) . 70 . Object Management Group , MOF Model to Text Trans - formation Language RFP , OMG Document ad / 2004 - 04 - 07 ( 2004 ) . 71 . Velocity 1 . 4 , The Apache Jakarta Project , The Apache Software Foundation , http : / / jakarta . apache . org / velocity . 72 . XDoclet—Attribute Oriented Programming , http : / / xdoclet . sourceforge . net / xdoclet / index . html . 73 . J . C . Cleaveland , Program Generators with XML and Java , Prentice - Hall , Upper Saddle River , NJ ( 2001 ) . 74 . XML Path Language ( XPath ) 2 . 0 , A . Berglund , S . Boag , D . Chamberlin , M . F . Ferna´ndez , M . Kay , J . Robie , and J . Sime´on , Editors , W3C Candidate Recommendation ( No - vember 3 , 2005 ) , http : / / www . w3 . org / TR / xpath20 / . 75 . P . G . Bassett , Framing Software Reuse : Lessons from the Real World , Prentice - Hall , Inc . , Upper Saddle River , NJ ( 1997 ) . 76 . S . Jarzabek , P . Bassett , H . Zhang , and W . Zhang , ‘‘ XVCL : XML - Based Variant Conﬁguration Language , ’’ Proceed - ings of the International Conference on Software Engi - neering , Portland , OR ( 2003 ) , pp . 810 – 811 . 77 . M . Emrich , Generative Programming Using Frame Tech - nology , Diploma thesis , University of Applied Sciences , Department of Computer Science and Micro - System Engineering , Kaiserslautern , Germany ( 2003 ) . 78 . Frame Processor ANGIE , Delta Software Technology , http : / / www . d - s - t - g . com / neu / media / pdf / facts _ e / DLT21474 . pdf . 79 . K . Czarnecki and M . Antkiewicz , ‘‘ Mapping Features to Models : A Template Approach Based on Superimposed Variants , ’’ Proceedings of the 4th International Conference on Generative Programming and Component Engineering , Tallinn , Estonia ( 2005 ) , pp . 422 – 437 . 80 . M . Andries , G . Engels , A . Habel , B . Hoffmann , H . - J . Kreowski , S . Kuske , D . Plump , A . Schu¨rr , and G . Taentzer , Graph Transformation for Speciﬁcation and Programming , Technical Report 7 / 96 , University of Bremen , 1 - D - 28359 Bremen , Germany ( 1996 ) . 81 . XSL Transformations ( XSLT ) , Version 1 . 0 , James Clark , Editor , W3C Recommendation ( November 16 , 1999 ) , http : / / www . w3 . org / TR / xslt . 82 . MOF 2 . 0 / XMI Mapping Speciﬁcation , Version 2 . 1 , OMG Document formal / 05 - 09 - 01 , Object Management Group , Inc . ( 2005 ) . 83 . M . Peltier , F . Ziserman , and J . Be´zivin , ‘‘ On Levels of Model Transformation , ’’ XML Europe , Paris , France ( 2000 ) , pp . 1 – 17 . Graphic Communications Association , 2000 . 84 . M . Peltier , J . Be´zivin , and G . Guillaume , ‘‘ MTRANS : A General Framework , Based on XSLT , for Model Trans - formations , ’’ Proceedings of the Workshop on Trans - formations in UML , Genova , Italy ( April 2001 ) , http : / / www . sciences . univ - nantes . fr / lina / atl / www / papers / peltier - bezivin - guillaume . pdf . 85 . D . Batory , ‘‘ Multilevel Models in Model - Driven Engi - neering , Product Lines , and Metaprogramming , ’’ IBM Systems Journal 45 , No . 3 , 527 – 540 ( 2006 , this issue ) . 86 . K . Czarnecki and S . Helsen , ‘‘ Classiﬁcation of Model Transformation Approaches , ’’ Proceedings of the 2nd Workshop on Generative Techniques in the Context of MDA , Anaheim , CA ( 2003 ) , http : / / www . swen . uwaterloo . ca / ; kczarnec / ECE750T7 / czarnecki _ helsen . pdf . 87 . T . Gardner , C . Grifﬁn , J . Koehler , and R . Hauser , ‘‘ A Review of OMG MOF 2 . 0 Query / Views / Transformations Submissions and Recommendations Toward the Final Standard , ’’ Object Management Group , OMG Document ad / 03 - 08 - 02 ( 2003 ) , http : / / www . omg . org / cgi - bin / doc ? ad / 03 - 08 - 02 . 88 . S . Sendall and W . Kozaczynski , ‘‘ Model Transformation : The Heart and Soul of Model - Driven Software Develop - ment , ’’ IEEE Software 20 , No . 5 , 42 – 45 ( 2003 ) . 89 . T . Mens , P . Van Gorp , D . Varro´ , and G . Karsai , ‘‘ Applying a Model Transformation Taxonomy to Graph Trans - formation Technology , ’’ Proceedings of the International Workshop on Graph and Model Transformation , Tallinn , Estonia ( 2005 ) , pp . 24 – 39 . 90 . K . Ehrig , E . Guerra , J . de Lara , L . Lengyel , T . Leven - dovszky , U . Prange , G . Taentzer , D . Varro´ , and S . Varro´ - Gyapay , ‘‘ Model Transformation by Graph Transforma - tion : A Comparative Study , ’’ Proceedings of Model Transformations in Practice Workshop , MoDELS Confer - ence , Montego Bay , Jamaica ( 2005 ) , http : / / www . inf . mit . bme . hu / FTSRG / Publications / varro / 2005 / mtip05 . pdf . Accepted for publication January 25 , 2006 . Krzysztof Czarnecki University of Waterloo , Department of Electrical & Computer Engineering , 200 University Avenue West , Waterloo , ON N2L 3G1 , Canada ( kczarnec @ swen . uwaterloo . ca ) . Dr . Czarnecki is an Assistant Professor at the University of Waterloo . He is a coauthor of Generative Programming : Methods , Tools , and Applications ( Addison - Wesley , 2000 ) , regarded as a foundational work in its area and used as a CZARNECKI AND HELSEN IBM SYSTEMS JOURNAL , VOL 45 , NO 3 , 2006 644 Published online July 25 , 2006 . graduate text at universities around the world . Dr . Czarnecki’s current work focuses on realizing the synergies between generative and model - driven software development . Simon Helsen SAP AG , Dietmar - Hopp - Allee 16 , 69190 Walldorf , Germany ( simon . helsen @ sap . com ) . Dr . Helsen is a senior developer at SAP AG , where he works on modeling infrastructure software for SAP NetWeaver t development tools . He has an Informatics degree from the University of Leuven ( Belgium ) and a Ph . D . degree in computer science from the University of Freiburg ( Germany ) . Dr . Helsen’s current interests are in scalable model - driven software engineering , domain - speciﬁc languages , and model transformations . & IBM SYSTEMS JOURNAL , VOL 45 , NO 3 , 2006 CZARNECKI AND HELSEN 645