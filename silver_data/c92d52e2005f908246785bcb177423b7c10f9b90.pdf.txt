New Facets and a Branch - and - Cut Algorithm for the Weighted Clique Problem Michael M . Sørensen Dept . of Management Science and Logistics The Aarhus School of Business Fuglesangs All´e 4 DK - 8210 Aarhus V Denmark July 19 , 2001 Abstract We consider a polyhedral approach to the weighted maximal b - clique problem . Given a node - and edge - weighted complete graph the problem is to find a complete subgraph ( clique ) with no more than b nodes such that the sum of the weights of all nodes and edges in the clique is maximal . We introduce four new classes of facet defining inequalities for the associated b - clique polytope . One of these inequality classes constitutes a generalization of the well known tree inequalities ; the other classes are associated with multistars . We utilize these inequalities together with other classes of facet defining inequalities in a branch - and - cut algorithm for the problem . We give a description of this algorithm , including some separation procedures , and present the computational results for different sets of test problems . The computation times that are obtained indicate that this algorithm is more efficient than previously described algorithms for the problem . Keywords : Combinatorial Optimization ; Boolean quadratic problem ; Edge - weighted clique problem ; Maximum dispersion problem ; Polyhedra . 1 Introduction The weighted maximal b - clique problem ( WCP ) consists in finding a maximum weight clique with no more than b nodes in a node - and edge - weighted complete graph . The weight of the clique is the sum of the weights of all its nodes and edges . In the absence of the node weights this problem is also known as the edge - weighted clique problem . In this paper we pursue a polyhedral approach to the problem which has been founded by other researchers . The results we describe are of two kinds : we introduce new classes of facet defining inequalities for the associated b - clique polytope , and we present a branch - and - cut algorithm that performs better than previously considered exact algorithms for the problem . The WCP generalizes the Boolean quadratic programming and maximal clique problems . So it is an NP - hard problem . Hunting et al . [ 5 ] give references to several applications of the WCP , for example to facility location and - dispersion problems . The problem also arises as the subproblem in a column generation approach to graph partitioning . The first attempt to solve the edge - weighted version of the WCP by an exact algorithm is described in Dijkhuizen and Faigle [ 1 ] . They take a cutting - plane approach which is based on a “natural” edge variable formulation of the problem , but they are only able to solve small problem instances . Subsequently different formulations of the closely related problem of finding a maximal weight clique with exactly b nodes are examined by Faigle et al . [ 2 ] . They conclude that a formulation which also includes node variables is much tighter . In a contem - porary work on the edge - weighted version of the WCP Park et al . [ 11 ] draw the same conclusion . Furthermore , by utilizing results of Johnson et al . [ 6 ] and Padberg [ 10 ] they provide the first polyhedral results for the b - clique polytope . They are also successful in solving problem instances involving graphs with up to 30 nodes by a cut - and - branch algorithm . Macambira and de Souza [ 8 ] follow this line of research by introducing further classes of facet defining inequali - ties . They examine different cutting strategies for a branch - and - cut algorithm and manage to solve problem instances with up to 48 nodes . Hunting [ 4 ] and Hunting et al . [ 5 ] also provide several new classes of facet defining inequalities for the b - clique polytope . They utilize some of the inequality classes in a La - grangian relax - and - cut algorithm by which they solve the same problem instances as in [ 8 ] . In all the above studies a “complete graph formulation” of the WCP is used . Mehrotra [ 9 ] considers the cardinality constrained Boolean quadratic polytope which is the same as the b - clique polytope , except that edge variables are only 1 defined for edges of the graph with nonzero weights . Using branch - and - cut he is able to solve problem instances that are associated with a graph on 30 nodes . Below we define some notation that is used in this paper . Then , in section 2 we state the WCP as a mixed integer linear programming problem using the complete graph formulation and summarize some polyhedral results for the b - clique polytope . We also introduce four new classes of inequalities , cut - tree inequalities and three inequality classes that are associated with multistars , and prove that they are facet defining for the b - clique polytope . Section 3 describes the branch - and - cut algorithm we have designed for the WCP . This algorithm utilizes the new classes of facet defining inequalities together with α - and clique inequalities , and some of the separation procedures it employs are explained . Finally , in section 4 we present the computational results that have been obtained by the algorithm . The problem instances that are solved range in size from 30 to 61 nodes . We consider the complete graph K n = ( V n , E n ) on n nodes with node set V n and edge set E n . For any subset of nodes S ⊆ V n we denote by E n ( S ) the set of all edges with both endnodes in S . So the subgraph ( S , E n ( S ) ) is a clique in K n . For two disjoint subsets of nodes S , T ⊂ V n we define δ ( S , T ) to be the set of edges with one endnode in S and the other endnode in T . In the special case where S = { v } and T = V n \ { v } we use the shorthand notation δ ( v ) to refer to the star of node v . Let ( x , y ) ∈ IR n ( n + 1 ) / 2 be a vector with an entry x v for each node v ∈ V n and an entry y e for each edge e ∈ E n . Then for every subset S ⊆ V n we denote by x ( S ) the sum (cid:0) v∈S x v . Similarly , if σ is a scalar σx ( S ) denotes (cid:0) v∈S σx v , and for every subset of edges F ⊆ E n we use σy ( F ) to denote (cid:0) e∈F σy e in the obvious way . Every subset of nodes C ⊆ V n with | C | ≤ b induces a feasible clique in K n . We use the notation (cid:1) x C , y C (cid:2) to refer to the incidence vector of the clique . That is , x Cv = 1 for all v ∈ C , y Ce = 1 for all e ∈ E n ( C ) , and x Cv = 0 and y Ce = 0 otherwise . 2 Facets of the b - clique polytope We denote the b - clique polytope by P n ( b ) . This is the convex hull of all incidence vectors of cliques in K n with no more than b nodes . In this section we consider a partial description of P n ( b ) in terms of facet defining inequalities . The facets of 2 P n ( b ) are faces (cid:3) ( x , y ) ∈ P n ( b ) | a T ( x , y ) = a 0 (cid:4) , defined by valid inequalities a T ( x , y ) ≤ a 0 , that are maximal in the sense that they are not contained in any other face of P n ( b ) . It is well known that the b - clique polytope is full - dimensional . This means that all facets of P n ( b ) are unique up to multiplication by a scalar . We first give a mixed integer LP formulation of the WCP . Given node weights ω v for all v ∈ V n and edge weights c e for all e ∈ E n and a maximal clique size b the weighted b - clique problem can be stated as follows . m a x (cid:5) v∈V n ω v x v + (cid:5) e∈E n c e y e s . t . y uv − x u ≤ 0 and y uv − x v ≤ 0 for all uv ∈ E n x u + x v − y uv ≤ 1 for all uv ∈ E n y ( δ ( v ) ) − ( b − 1 ) x v ≤ 0 for all v ∈ V n y e ≥ 0 for all e ∈ E n x v integer for all v ∈ V n . ( 1 ) The first two sets of constraints guarantee that an edge is in the clique if and only if both of its endnodes are in the clique . The third constraint set , called star inequalities , imposes the size restriction of the clique ; without this con - straint set we have the Boolean quadratic programming problem considered by Padberg [ 10 ] . Although the WCP is stated here as a MILP we remark that ( 1 ) implies that all variables are indeed 0 – 1 variables . The following proposition states that ( 1 ) is a tight formulation of the WCP , because all inequalities define facets of P n ( b ) under mild conditions ; see Pad - berg [ 10 ] and Park et al . [ 11 ] for a proof . Proposition 1 Let n ≥ 3 and b ≥ 2 . 1 . For every edge e ∈ E n the nonnegativity constraint y e ≥ 0 defines a facet of P n ( b ) . 2 . For every edge uv ∈ E n the inequalities y uv −x u ≤ 0 and x u + x v −y uv ≤ 1 define facets of P n ( b ) if and only if b ≥ 3 . 3 . For every node v ∈ V n the star inequality y ( δ ( v ) ) − ( b − 1 ) x v ≤ 0 defines a facet of P n ( b ) if and only if b ≤ n − 1 . 2 3 In order to obtain a tighter approximation to P n ( b ) we shall utilize several other classes of facet defining inequalities . The following class of α - inequalities is introduced in Macambira and de Souza [ 8 ] . It generalizes the classes of clique - , cut - , and generalized cut inequalities originally obtained by Padberg [ 10 ] for the Boolean quadric polytope P n ( n ) . Proposition 2 Let S , T ⊂ V n be two disjoint subsets of nodes . For every integer α the α - inequality induced by S and T y ( δ ( S , T ) ) − y ( E n ( S ) ) − y ( E n ( T ) ) − αx ( S ) + ( α − 1 ) x ( T ) ≤ α ( α − 1 ) / 2 ( 2 ) is valid for P n ( b ) . For every positive integer α the inequality defines a facet of P n ( b ) if | S | ≥ 1 , | T | ≥ α + 1 , and b ≥ (cid:6) α + 2 , when | S | = 1 α + 3 , when | S | ≥ 2 . 2 The conditions stated in this proposition are not necessary conditions in general . They are necessary conditions with respect to b when S (cid:5) = ∅ and α = 1 , and in this case the inequality is called a cut inequality . When S = ∅ the α - inequality specializes to a clique inequality . In the next proposition we consider this inequality class with coefficient β = α − 1 . Proposition 3 For every subset of nodes T ⊆ V n with | T | ≥ 3 and every positive integer β ≤ | T | − 2 the clique inequality βx ( T ) − y ( E n ( T ) ) ≤ β ( β + 1 ) / 2 ( 3 ) defines a facet of P n ( b ) if and only if b ≥ (cid:6) β + 2 , when T ⊂ V n β + 1 , when T = V n . 2 The clique inequalities are introduced in Padberg [ 10 ] for P n ( n ) , and except for a minor correction cf . Hunting [ 4 ] the above conditions with respect to b are obtained in Park et al . [ 11 ] . The next inequalities are described in Hunting et al . [ 5 ] . 4 Proposition 4 For every v ∈ V n the inequality bx v + x ( V n \ { v } ) − y ( δ ( v ) ) ≤ b ( 4 ) defines a facet of P n ( b ) if and only if 3 ≤ b ≤ n − 2 . 2 Hunting [ 4 ] also introduces the following inequalities . Proposition 5 For all distinct s , t ∈ V n the inequality ( b − 1 ) y st − ( b − 1 ) x s + (cid:5) v∈V n \ { s , t } ( y sv − y tv ) ≤ 0 ( 5 ) defines a facet of P n ( b ) if and only if 3 ≤ b ≤ n − 2 . 2 In sections 2 . 2 . 1 and 2 . 2 . 2 we provide new classes of facet defining inequalities that contain inequalities ( 4 ) and ( 5 ) as special cases . The tree inequalities of the next proposition are introduced in Johnson et al . [ 6 ] for the quadratic knapsack polytope ; this polytope is defined in Hunting et al . [ 5 ] as a generalization of P n ( b ) . The following closed - form result for P n ( b ) is stated in Park et al . [ 11 ] . Proposition 6 Let G T = ( V T , E T ) ⊂ K n be a tree such that | V T | = b + 1 . Denote by d v = | δ ( v ) ∩ E T | the degree of node v in the tree . Then the tree inequality y ( E T ) − (cid:5) v∈V T ( d v − 1 ) x v ≤ 0 ( 6 ) defines a facet of P n ( b ) , for b ≥ 3 , if and only if T is not a star or V T = V n . 2 Further classes of facet defining inequalities for P n ( b ) are known . Since , however , we do not utilize any of these inequalities here , we refer the interested reader to Hunting et al . [ 5 ] , Macambira and de Souza [ 8 ] , Mehrotra [ 9 ] , and Sherali et al . [ 12 ] . Below we introduce new classes of inequalities that are facet defining for P n ( b ) . 5 2 . 1 Cut - tree inequalities The first class we consider is a generalization of the tree inequalities ( 6 ) . This inequality class originates from a study of the closely related simple graph par - tioning polytope cf . Sørensen [ 13 ] . In that study we have modified tree inequal - ities by superimposing so - called S , T - inequalities on the tree inequalities . The S , T - inequalities are very similar in structure to the cut inequalities ( 2 ) , and it turns out that we can modify the tree inequalities ( 6 ) by superimposing cut in - equalities in an identical manner to obtain a much larger class of inequalities . We call them cut - tree inequalities . First we need to define some sets of nodes and edges that will be used to describe the cut - tree inequalities . Let G T = ( V T , E T ) ⊂ K n be any tree such that | V T | = b + 1 . For each v ∈ V T let N v = { u ∈ V T \ { v } | uv ∈ E T } be the set of neighbor nodes of v in the tree . Let L = { v ∈ V T | | N v | = 1 } and I = V T \ L be the sets of leaf nodes and inner nodes , respectively , of the tree . We shall distinguish between leaf neighbors and inner neighbors of the inner nodes . So for each inner node i ∈ I denote by L i = N i ∩ L and I i = N i ∩ I the two sets of neighbor nodes . Furthermore , we shall also need a so - called neighbor tree for each inner node . For each i ∈ I let T i ⊆ E n ( I i ) be any tree that spans all nodes in I i . That is , T i is a spanning tree of the complete subgraph induced by the inner neighbors of i . Now we associate additional nodes with the tree . We associate one or more ( possibly empty ) node sets with each inner node as follows : associate with all i ∈ I and every (cid:5) ∈ L i , uv ∈ T i mutually disjoint node sets R (cid:0) , R uv ⊂ V n \ V T . That is , every pair of these sets has an empty intersection . Given these node sets we define appropriate edge sets : Q (cid:0) : = δ ( { i } , R (cid:0) ) , ¯Q (cid:0) : = δ ( { (cid:5) } , R (cid:0) ) ∪ E n ( R (cid:0) ) ∀(cid:5) ∈ L i , i ∈ I , 6 and Q uv : = δ ( { i } , R uv ) , ¯Q uv : = δ ( { u , v } , R uv ) ∪ E n ( R uv ) ∀uv ∈ T i , i ∈ I . Then the cut - tree inequality is y ( E T ) − (cid:5) v∈V T ( d v − 1 ) x v + (cid:5) i∈I  (cid:5) (cid:0)∈L i ( ( y ( Q (cid:0) ) − y ( ¯Q (cid:0) ) ) + (cid:5) uv∈T i ( ( y ( Q uv ) − y ( ¯Q uv ) )   ≤ 0 . ( 7 ) This inequality is clearly much more complex in structure than ( 6 ) . So let us consider an example which will demonstrate the above concepts . Example Suppose that b = 8 . Figure 1 shows the support graph of a cut - tree inequality that is obtained in the following way . Consider the tree with edge set u u u u u u u u u e e e e e e ¡ ¡ ¡ ¡¡ ¡ ¡ ¡ ¡¡ @ @ @ @ @ ¡ ¡ ¡ ¡¡ £££££¡¡ ¡ ¡¡ P P P P P P P P ³ ³ ³ ³ £££££ P P P P BBBBB @ @ @ @ @ BBBBB v 1 v 2 v 3 v 4 v 5 v 6 v 7 v 8 v 9 v 10 v 11 v 12 v 13 v 14 v 15 Figure 1 : Support graph of a cut - tree inequality . E T = { v 1 v 2 , v 2 v 5 , v 3 v 4 , v 4 v 5 , v 5 v 6 , v 5 v 9 , v 6 v 7 , v 7 v 8 } , 7 leaf nodes L = { v 1 , v 3 , v 8 , v 9 } and inner nodes I = { v 2 , v 4 , v 5 , v 6 , v 7 } . The neighbor sets are : N v 1 = { v 2 } , N v 2 = { v 1 , v 5 } , L v 2 = { v 1 } , I v 2 = { v 5 } , N v 3 = { v 4 } , N v 4 = { v 3 , v 5 } , L v 4 = { v 3 } , I v 4 = { v 5 } , N v 5 = { v 2 , v 4 , v 6 , v 9 } , L v 5 = { v 9 } , I v 5 = { v 2 , v 4 , v 6 } , N v 6 = { v 5 , v 7 } , L v 6 = ∅ , I v 6 = { v 5 , v 7 } N v 7 = { v 6 , v 8 } , L v 7 = { v 8 } , I v 7 = { v 6 } , N v 8 = { v 7 } , N v 9 = { v 5 } , and a possible choice of neighbor trees is : T i = ∅ for all i ∈ I \ { v 5 , v 6 } , T v 5 = { v 2 v 4 , v 2 v 6 } , T v 6 = { v 5 v 7 } . By associating the following node sets with the leaf neighbors and edges of the neighbor trees of the inner nodes : R v 1 = { v 10 } , R v 3 = ∅ , R v 9 = { v 11 } , R v 2 v 4 = { v 12 } , R v 2 v 6 = { v 13 } , R v 5 v 7 = ∅ , and R v 8 = { v 14 , v 15 } we obtain the cut - tree inequality y v 1 v 2 + y v 2 v 5 + y v 3 v 4 + y v 4 v 5 + y v 5 v 6 + y v 5 v 9 + y v 6 v 7 + y v 7 v 8 − x v 2 − x v 4 − 3 x v 5 − x v 6 − x v 7 + y v 2 v 10 − y v 1 v 10 + y v 5 v 11 − y v 9 v 11 + y v 5 v 12 − y v 2 v 12 − y v 4 v 12 + y v 5 v 13 − y v 2 v 13 − y v 6 v 13 + y v 7 v 14 + y v 7 v 15 − y v 8 v 14 − y v 8 v 15 − y v 14 v 15 ≤ 0 . 2 We have the following result . Theorem 1 The cut - tree inequality ( 7 ) is valid for P n ( b ) . It defines a facet of P n ( b ) , for b ≥ 3 , if and only if the tree is not a star or V T = V n . 8 Proof . We denote the cut - tree inequality by a T ( x , y ) ≤ 0 and first prove validity . Let C ⊂ V n with | C | ≤ b be the node set of a feasible clique . We consider the intersection of the clique ( C , E n ( C ) ) with the support graph of ( 7 ) which may consist of several connected components . Let ( U , F ) be any such connected com - ponent . We shall show that a T (cid:1) x U , y U (cid:2) ≤ 0 , because then validity immediately follows by adding these inequalities for all connected components . In the special case of a tree inequality ( 6 ) where all node sets R (cid:0) , R uv are empty it follows from arguments similar to those in the proof provided in Johnson et al . [ 6 ] that a T (cid:1) x U , y U (cid:2) = (cid:5) v∈U (cid:0) ( | δ (cid:1) ( v ) | − d v ) + 1 , ( 8 ) where U (cid:1) = U ∩ V T and δ (cid:1) ( v ) = δ ( v ) ∩ F ∩ E T . Furthermore , U (cid:1) ⊂ V T because | V T | > b , so there exists an edge st ∈ E T \ F , s ∈ U (cid:1) , such that | δ (cid:1) ( s ) | < d s . Hence , a T (cid:1) x U , y U (cid:2) ≤ 0 in this case . In the general case , where some node sets R (cid:0) , R uv are nonempty , the right - hand side value of ( 8 ) is still nonpositive . So it suffices to show that the right - hand side of ( 8 ) plus the contribution from any additional nodes in U \ U (cid:1) is nonpositive . Here we only consider contributions from nodes in the sets R uv that are associated with the edges of the neighbor trees of the inner nodes . The possible contributions from nodes in the sets R (cid:0) that are associated with the leaf nodes are easy to establish by similar arguments . Let i ∈ I ∩U . We consider three cases . i ) First suppose that R uv ∩U (cid:5) = ∅ for some uv ∈ T i and such that { u , v } ∩ U (cid:5) = ∅ . Then , for each node w ∈ R uv ∩ U , we get a + 1 contribution from the edge iw and a −1 contribution from each of the edges uw , vw for which u , v ∈ U . This yields a net contribution of no more than 0 so that a T (cid:1) x U , y U (cid:2) ≤ 0 . ii ) Next suppose that there is one uv ∈ T i for which { u , v } ∩ U = ∅ and R uv ∩ U (cid:5) = ∅ . Since u , v (cid:5)∈ U , | δ (cid:1) ( i ) | − d i ≤ − 2 . This implies that the right - hand side of ( 8 ) is negative . On the other hand we get a + 1 contribution from the edge iw for each node w ∈ R uv ∩ U . Furthermore , if | R uv ∩ U | ≥ 2 we get contributions of −1 for each edge e ∈ ¯Q uv ∩ F . It follows that a T (cid:1) x U , y U (cid:2) ≤ 0 in this case , too . iii ) Finally suppose that there are k distinct node sets R uv , uv ∈ T i , for which R uv ∩ U (cid:5) = ∅ and { u , v } ∩ U = ∅ . We note that k ≤ d i − 1 . Since T i spans all inner neighbors of node i , we have | δ (cid:1) ( i ) | ≤ d i − k − 1 , and it follows that the right - hand side value of ( 8 ) is less than or equal to −k . Using the arguments 9 in ii ) above for each node set R uv it follows that a T (cid:1) x U , y U (cid:2) ≤ 0 . This proves that the cut - tree inequality is valid for P n ( b ) . Facet : When G T is a star there is only one inner node in the tree : I = { i } . In this case the inequality ( 7 ) is dominated by the star inequality y ( δ ( i ) ) − ( b−1 ) x i ≤ 0 if V T ⊂ V n . This proves the only if statement of the theorem . In order to prove sufficiency we assume throughout the remainder of this proof that G T is not a star . Denote by F a = (cid:3) ( x , y ) ∈ P n ( b ) | a T ( x , y ) = 0 (cid:4) the face of the b - clique polytope that is defined by the cut - tree inequality . Let π T ( x , y ) ≤ π 0 be a facet defining inequality for P n ( b ) such that F a ⊆ F π = (cid:3) ( x , y ) ∈ P n ( b ) | π T ( x , y ) = π 0 (cid:4) . We shall show that π = σa and π 0 = 0 for some positive scalar σ ∈ IR + , since this implies that F a = F π . We make extensive use of cliques that are constructed in the following way . Let i ∈ I and j ∈ N i be two adjacent nodes of the tree . By deleting the edge ij from E T we obtain two subtrees ( connected components ) of G T . We denote by C ( i ) ⊂ V T ( respectively C ( j ) ⊂ V T ) the set of nodes of the subtree that contains node i ( respectively node j ) . It is quite easy to see that the incidence vectors of the two corresponding cliques are both members of the face F a . ( a ) First we note that (cid:1) x ∅ , y ∅ (cid:2) ∈ F a ⊆ F π implies π 0 = 0 . ( b ) Furthermore , because the tree inequality ( 6 ) is facet defining , it follows that π v = − ( d v − 1 ) σ for all v ∈ V T , π e = σ for all e ∈ E T , and π e = 0 for all e ∈ E n ( V T ) \ E T . ( c ) Consider any node s ∈ R uv , uv ∈ T i , or s ∈ R u , u ∈ L i , for some i ∈ I . From (cid:1) x { s } , y { s } (cid:2) ∈ F a we get π s = 0 . ( d ) Let i , s , u , v be as in ( c ) , and let t ∈ V T \ { i , u , v } . We shall show that π st = 0 . Let j ∈ I t be the unique inner neighbor of node t that lies on the path in G T from t to i and consider the partition C ( j ) , C ( t ) of V T . Let D = C ( t ) ∪ { s } . Then the incidence vectors of C ( t ) and D are contained in F a , and from the relation π T (cid:1) x D , y D (cid:2) − π T (cid:1) x C ( t ) , y C ( t ) (cid:2) = 0 we get π s + (cid:5) w∈C ( t ) π sw = 0 . ( 9 ) When t is a leaf node of the tree equation ( 9 ) reduces to π s + π st = 0 such that π st = 0 . Choosing t by successively moving inwards in G T from the leaf nodes we obtain that π st = 0 for all t ∈ V T \ { i , u , v } . ( e ) Next we shall show that π is = σ , where node s is a member of R u , u ∈ L i , or R uv , uv ∈ T i , as above . If s ∈ R u let v ∈ I i be any inner neighbor of node i . Consider the partitions C ( i ) , C ( u ) and C (cid:1) ( i ) , C (cid:1) ( v ) of V T that result from 10 deleting the edges iu , iv from E T , respectively . Let D ( i ) = V T \ ( C ( u ) ∪ C (cid:1) ( v ) ) and let D ( i , s ) = D ( i ) ∪ { s } . It is easy to verify that the incidence vectors of the cliques induced by D ( i , s ) , as well as C ( u ) and C (cid:1) ( i ) , are contained in F a . From the relation π T (cid:1) x D ( i , s ) , y D ( i , s ) (cid:2) − π T (cid:1) x C (cid:0) ( i ) , y C (cid:0) ( i ) (cid:2) = 0 we get π s + (cid:5) w∈D ( i ) π sw − π T (cid:1) x C ( u ) , y C ( u ) (cid:2) − (cid:5) e∈δ ( C ( u ) , D ( i ) ) π e = 0 . By ( c ) , ( d ) , and ( b ) this reduces to π si − π iu = 0 . So π is = π iu = σ . This proves that π is = σ for all s ∈ R uv , uv ∈ T i , and all s ∈ R u , u ∈ L i . ( f ) Let i , s , u , v be distinct nodes defined as above . We shall show that π su = −σ for all s ∈ R uv , uv ∈ T i , and s ∈ R u , u ∈ L i . If s ∈ R u let v ∈ I i be an inner neighbor of node i . Deleting the edge iv from E T we obtain the node set C ( i ) which contains nodes i and u . Let D = C ( i ) ∪ { s } . Then the incidence vectors of the cliques induced by C ( i ) and D are members of F a , and it follows that π s + (cid:5) w∈C ( i ) π sw = 0 . This reduces to π si + π su = 0 , and from ( e ) we get π su = −π is = −σ . ( g ) Let s , t ∈ R uv , uv ∈ T i , or s , t ∈ R u , u ∈ L i , be two distinct nodes . If s , t ∈ R u , let v ∈ I i . Consider the node set D ( i , s ) which is obtained as in ( e ) above by adding node s to the set D ( i ) = V T \ ( C ( u ) ∪ C (cid:1) ( v ) ) . Now let D ( i , s , t ) = D ( i , s ) ∪ { t } . Then F a contains both incidence vectors of the cliques induced by D ( i , s ) and D ( i , s , t ) , and it follows that π t + (cid:5) w∈D ( i , s ) π tw = 0 . This reduces to π it + π st = 0 , and then we obtain π st = −π it = −σ . This proves that π e = −σ for all e ∈ E n ( R uv ) ∪ E n ( R u ) . ( h ) Denote by Z the union of the nodes in all the sets R uv , R (cid:0) . It is trivial to establish that π st = 0 for all node pairs s and t that belong to different node sets , e . g . s ∈ R e and t ∈ R f for e (cid:5) = f . This establishes that π v = σa v for all v ∈ V T ∪ Z and π e = σa e for all e ∈ E n ( V T ∪Z ) . Furthermore , it is easy to verify that π v = 0 for all v ∈ V n \ ( V T ∪Z ) and π e = 0 for all e ∈ E n \ E n ( V T ∪ Z ) . This completes the proof . 2 11 2 . 2 Multistar inequalities A multistar in K n consists of two disjoint sets of nodes U , V and edge set δ ( U , V ) ∪E n ( V ) . The node set V constitutes the nucleus of the multistar and the nodes in U are called satellites . We have found some new classes of facet defining inequalities for P n ( b ) whose support graphs are multistars . These inequality classes have been discovered by means of the same technique , and therefore we open this section with an outline of this approach . The structure of a particular class of the multistar inequalities is obtained by adding together clique - or cut inequalities that are partially overlapping . More specifically , let U (cid:1) and V be disjoint sets of nodes and , for each u ∈ U (cid:1) , consider the clique inequality , respectively a cut inequality , on nodes V ∪ { u } . Adding together these inequalities we get a valid inequality whose support is the multistar with nucleus V and satellites U (cid:1) . This multistar inequality is clearly not facet defining for P n ( b ) , but in some cases — when | U (cid:1) | is sufficiently large with respect to b — it provides a basic structure that can be utilized with an augmented set of satellites U ⊃ U (cid:1) . This simple modification frequently yields a facet defining multistar inequality . We have found one class of facet defining multistar inequalities by applying this approach to clique inequalities and two further inequality classes by different applications of the approach to cut inequalities . These inequality classes are the subjects of the following sections . 2 . 2 . 1 Clique - star inequalities The structure of the clique - star inequalities that we consider in this section has been derived from b partially overlapping clique inequalities ( using β = 1 ) . These inequalities are not completely new , since Hunting et al . [ 5 ] have provided the subclass of the inequalities ( 4 ) where the nucleus consists of a single node . Theorem 2 Let S , T ⊂ V n be two disjoint , nonempty subsets of nodes . Then the clique - star inequality bx ( T ) + x ( S ) − by ( E n ( T ) ) − y ( δ ( S , T ) ) ≤ b ( 10 ) is valid for P n ( b ) . It defines a facet of P n ( b ) , for b ≥ 3 , if and only if | S | ≥ b + 1 , and S = V n \ T when | T | = 1 . 12 Proof . We denote the inequality by a T ( x , y ) ≤ b . Let C ⊂ V n be any subset of nodes such that | C | ≤ b , and let s C = | S ∩ C | and t C = | T ∩ C | . In order to prove validity we shall show that a T (cid:1) x C , y C (cid:2) − b ≤ 0 . From ( 10 ) we get a T (cid:1) x C , y C (cid:2) − b = b (cid:11) t C − 1 2 t C ( t C − 1 ) (cid:12) + s C − s C t C − b = b (cid:11) t C − 1 2 t C ( t C − 1 ) − 1 (cid:12) + s C ( 1 − t C ) . Suppose that t C = 0 . Then a T (cid:1) x C , y C (cid:2) − b = −b + s C ≤ 0 , because s C ≤ b . Alternatively , we have t C ≥ 1 . Then s C ( 1 − t C ) ≤ 0 , and a T (cid:1) x C , y C (cid:2) − b ≤ b (cid:11) t C − 1 2 t C ( t C − 1 ) − 1 (cid:12) = −12 b (cid:1) t 2 C − 3 t C + 2 (cid:2) = −12 b ( t C − 1 ) ( t C − 2 ) ≤ 0 . This proves that the clique - star inequalities are valid for P n ( b ) . Facet : We first prove the necessary conditions . We require | S | > b because otherwise the inequality can be obtained as the sum of other valid inequalities . Suppose that T = { v } and S ⊂ V n \ { v } . In this latter case the inequality can be obtained as the sum of the inequality ( 4 ) and the inequalities y uv − x u ≤ 0 for all u ∈ V n \ ( S ∪ T ) . This proves necessity . In order to prove sufficiency assume that the conditions of the theorem are satisfied . Let π T ( x , y ) ≤ π 0 be a facet defining inequality for P n ( b ) such that π T ( x , y ) = π 0 for all ( x , y ) ∈ P n ( b ) that satisfy ( 10 ) with equality . We shall show that ( π , π 0 ) = ( σa , σb ) for some σ ∈ IR + . We do this by exhibiting node sets C of feasible cliques such that a T (cid:1) x C , y C (cid:2) = b . Then we use the relations π T (cid:1) x C , y C (cid:2) = π 0 to derive the desired result . ( a ) From C = { t } , t ∈ T , we get π t = π 0 for all t ∈ T . ( b ) From C = { t , u } , t , u ∈ T , we then get π tu = −π 0 for all tu ∈ E n ( T ) . ( c ) From C = { s , t } , s ∈ S , t ∈ T , it follows that π s = −π st . Furthermore , this relation is independent of the particular node t ∈ T . So for every s ∈ S we get π s = −π st = σ s for all t ∈ T . ( d ) Then , from C = { t , u , v } , u , v ∈ S , t ∈ T , it follows that π uv = 0 for all uv ∈ E n ( S ) . 13 ( e ) Let S (cid:1) ⊂ S such that | S (cid:1) | = b − 1 , and let u , v ∈ S \ S (cid:1) be two distinct nodes . Let C = { u } ∪ S (cid:1) and D = { v } ∪ S (cid:1) . Then from π T (cid:1) x C , y C (cid:2) − π T (cid:1) x D , y D (cid:2) = 0 we get π u − π v + (cid:5) s∈S (cid:0) ( π su − π sv ) = π u − π v = 0 such that π u = π v = σ v . It follows that π s = σ for all s ∈ S and π e = −σ for all e ∈ δ ( S , T ) . ( f ) From C = { u } ∪ S (cid:1) as in ( e ) it then follows that π 0 = bσ . This proves that ( 10 ) defines a facet of P n ( b ) when S ∪ T = V n . So now we consider zero lifting for the cases where ¯V = V n \ ( S ∪ T ) (cid:5) = ∅ . Note that | T | ≥ 2 in these cases by assumption . ( g ) From C = { t , v } , t ∈ T , v ∈ ¯V , we get π v + π tv = 0 . Similarly , π v + π uv = 0 for u ∈ T . Now , from D = { t , u , v } we get π v + π tv + π uv = 0 . It follows that π v = π tv = 0 for all t ∈ T and all v ∈ ¯V . ( h ) From C = { t , u , v } , t ∈ T , u , v ∈ ¯V , it then follows that π uv = 0 for all uv ∈ E n ( ¯V ) . ( i ) From C = { s , t , v } , s ∈ S , t ∈ T , v ∈ ¯V , it follows that π sv = 0 for all s ∈ S and all v ∈ ¯V . We have now shown that π = σa and π 0 = σb . This completes the proof that the clique - star inequality defines a facet of P n ( b ) . 2 2 . 2 . 2 Cut - star inequalities The cut - star inequalities considered in this section are derived from b−1 partially overlapping cut inequalities . Let R , S , T be three mutually disjoint node sets , and for each r ∈ R consider the cut inequality induced by node sets S and T ∪ { r } . Combining these inequalities we obtain an inequality whose support is a multistar with nucleus S ∪ T and satellites R . Theorem 3 Let R , S , T ⊂ V n be three mutually disjoint , nonempty subsets of nodes . Then the cut - star inequality ( b − 1 ) [ y ( δ ( S , T ) ) − x ( S ) − y ( E n ( S ) ) − y ( E n ( T ) ) ] + y ( δ ( R , S ) ) − y ( δ ( R , T ) ≤ 0 ( 11 ) is valid for P n ( b ) . It defines a facet of P n ( b ) , for b ≥ 3 , if and only if i ) | R | ≥ b and ii ) b ≥ 4 and | T | ≥ 2 when | S | ≥ 2 . 14 Proof . For simplicity we denote the inequality by a T ( x , y ) ≤ 0 . Let C ⊂ V n with | C | ≤ b be the node set of any feasible clique in K n . In order to prove that the cut - star inequality is valid for P n ( b ) we shall show that a T (cid:1) x C , y C (cid:2) ≤ 0 . Let r C = | R ∩ C | , s C = | S ∩ C | , and t C = | T ∩ C | . From ( 11 ) we get a T (cid:1) x C , y C (cid:2) = ( b − 1 ) (cid:13) s C t C − s C − 1 2 s C ( s C − 1 ) − 1 2 t C ( t C − 1 ) (cid:14) + r C s C − r C t C = ( b − 1 ) (cid:13) s C t C − 1 2 s C ( s C + 1 ) − 1 2 t C ( t C − 1 ) (cid:14) + r C ( s C − t C ) . It immediately follows that a T (cid:1) x C , y C (cid:2) ≤ 0 when s C = 0 . So we may assume that s C ≥ 1 , which in turn implies r C ≤ b − 1 . Suppose that s C − t C ≥ 0 . Then r C ( s C − t C ) ≤ ( b − 1 ) ( s C − t C ) , and a T (cid:1) x C , y C (cid:2) ≤ ( b − 1 ) (cid:13) s C t C − 1 2 s C ( s C + 1 ) − 1 2 t C ( t C − 1 ) + s C − t C (cid:14) = −12 ( b − 1 ) (cid:15) t 2C − ( 2 s C − 1 ) t C + s C ( s C − 1 ) (cid:16) = −12 ( b − 1 ) ( t C − s C + 1 ) ( t C − s C ) ≤ 0 . On the other hand , suppose that s C −t C ≤ 0 . This implies that r C ( s C −t C ) ≤ 0 , and a T (cid:1) x C , y C (cid:2) ≤ ( b − 1 ) (cid:13) s C t C − 1 2 s C ( s C + 1 ) − 1 2 t C ( t C − 1 ) (cid:14) = −1 2 ( b − 1 ) (cid:15) t 2 C − ( 2 s C + 1 ) t C + s C ( s C + 1 ) (cid:16) = −12 ( b − 1 ) ( t C − s C ) ( t C − s C − 1 ) ≤ 0 . Hence , the cut - star inequality is valid for P n ( b ) . Facet : The condition | R | ≥ b is necessary , because otherwise the cut - star inequality can be obtained as the sum of other valid inequalities . When | S | ≥ 2 and b ≤ 3 or | T | = 1 we have y e = 0 for all e ∈ E n ( S ) in every incidence vector of a feasible clique . This implies that the face of P n ( b ) defined by the cut - star 15 inequality is properly contained in the face that is defined by the nonnegativity constraint y e ≥ 0 , e ∈ E n ( S ) . See also the proof of [ 11 , Theorem 3 . 2 ] . We now assume that the conditions of the theorem are satisfied . As in the previous proof we shall show that there exists σ ∈ IR + such that ( π , π 0 ) = ( σa , 0 ) , where π T ( x , y ) ≤ π 0 is a facet defining inequality for P n ( b ) with the property that a T ( x , y ) = 0 ⇒ π T ( x , y ) = π 0 . ( a ) Since a T (cid:1) x C , y C (cid:2) = 0 for C = ∅ , we immediately get π 0 = 0 . ( b ) From C = { v } , v ∈ R ∪ T , it follows that π v = 0 for all v ∈ R ∪ T . ( c ) From C = { u , v } , u , v ∈ R , we then get π uv = 0 for all uv ∈ E n ( R ) . ( d ) Let R (cid:1) ⊂ R such that | R (cid:1) | = b − 2 , let u , v ∈ R \ R (cid:1) be distinct nodes , and let s ∈ S . Set C = { s , u } ∪ R (cid:1) and D = { s , v } ∪ R (cid:1) . From the relation π T (cid:1) x C , y C (cid:2) − π T (cid:1) x D , y D (cid:2) = 0 we get π u − π v + π su − π sv + (cid:5) r∈R (cid:0) ( π ru − π rv ) = π su − π sv = 0 , which shows that π su = π sv . This implies that for every s ∈ S we have π sv = σ s for all v ∈ R . ( e ) From C = { s , u } ∪ R (cid:1) as in ( d ) it then follows that π s + ( b − 1 ) σ s = 0 . Hence , π s = − ( b − 1 ) σ s for all s ∈ S . ( f ) Now , from C = { s , t } , s ∈ S , t ∈ T , we get π s + π st = 0 . So , for every s ∈ S , π st = ( b − 1 ) σ s for all t ∈ T . ( g ) From C = { s , u , v } , s ∈ S , u , v ∈ T , it follows that π uv = − ( b − 1 ) σ s for all uv ∈ E n ( T ) . ( h ) The relation in ( g ) is clearly independent of any particular node s ∈ S . This implies that σ s = σ for all s ∈ S . ( i ) From C = { r , s , t } , r ∈ R , s ∈ S , t ∈ T , we get π rt = −π rs = −σ for all rt ∈ δ ( R , T ) . ( j ) Suppose that | S | ≥ 2 and let C = { i , j , u , v } , i , j ∈ S , u , v ∈ T . Then it follows that ( b − 1 ) σ + π ij = 0 . Hence , π e = − ( b − 1 ) σ for all e ∈ E n ( S ) . We have now proven that the cut - star inequality defines a facet of P n ( b ) when R∪S∪T = V n . In order to obtain the result when ¯V = V n \ ( R∪S∪T ) (cid:5) = ∅ it must be shown that π v = 0 for all v ∈ ¯V and π e = 0 for all e ∈ E n ( ¯V ) ∪δ ( ¯V , R∪S∪T ) . Since this is very easy to establish , we leave out this part of the proof . 2 We note that ( 5 ) is the special case of the cut - star inequality where S = { s } , T = { t } , and R = V n \ { s , t } . 16 2 . 2 . 3 T - star inequalities We have derived one further inequality class from partially overlapping cut in - equalities . The structure of the following T - star inequalities has been obtained by adding b − 2 cut inequalities that overlap in node set T and may also overlap in node set S . Let R , S and T be mutually disjoint node sets where S may be empty . For each r ∈ R consider the cut inequality induced by node sets { r } ∪ S and T . Combining these inequalities we get an inequality whose support graph is a multistar with nucleus S ∪ T and satellites R . Theorem 4 Let R , S , T ⊂ V n be three mutually disjoint subsets of nodes with | T | ≥ 2 . Then the T - star inequality ( b − 2 ) [ y ( δ ( S , T ) ) − x ( S ) − y ( E n ( S ) ) − y ( E n ( T ) ) ] − x ( R ) − y ( δ ( R , S ) ) + y ( δ ( R , T ) ) ≤ 0 ( 12 ) is valid for P n ( b ) . It defines a facet of P n ( b ) , for b ≥ 3 , if and only if | R | ≥ b−1 , and b ≥ 4 when | S | ≥ 1 . Proof . Denote the inequality by a T ( x , y ) ≤ 0 . We first show that the inequality is valid . Let C ⊂ V n be any feasible subset of nodes , and let r C = | R ∩ C | , s C = | S ∩ C | and t C = | T ∩ C | . From the structure of ( 12 ) we have a T (cid:1) x C , y C (cid:2) = ( b − 2 ) (cid:13) s C t C − s C − 1 2 s C ( s C − 1 ) − 1 2 t C ( t C − 1 ) (cid:14) − r C − r C s C + r C t C = ( b − 2 ) (cid:13) s C t C − 1 2 s C ( s C + 1 ) − 1 2 t C ( t C − 1 ) (cid:14) + r C ( t C − s C − 1 ) . Since a T (cid:1) x C , y C (cid:2) ≤ 0 when t C = 0 , we assume that t C ≥ 1 . First suppose that s C ≥ 1 . When t C − s C − 1 ≥ 0 we have r C ( t C − s C − 1 ) ≤ ( b − 2 ) ( t C − s C − 1 ) such that a T (cid:1) x C , y C (cid:2) ≤ ( b − 2 ) (cid:13) s C t C − 1 2 s C ( s C + 1 ) − 1 2 t C ( t C − 1 ) + t C − s C − 1 (cid:14) = −12 ( b − 2 ) (cid:15) t 2C − ( 2 s C + 3 ) t C + s C ( s C + 3 ) + 2 (cid:16) = −12 ( b − 2 ) ( t C − s C − 1 ) ( t C − s C − 2 ) ≤ 0 . 17 On the other hand , when t C − s C − 1 ≤ 0 we have r C ( t C − s C − 1 ) ≤ 0 such that a T (cid:1) x C , y C (cid:2) ≤ ( b − 2 ) (cid:13) s C t C − 1 2 s C ( s C + 1 ) − 1 2 t C ( t C − 1 ) (cid:14) = −12 ( b − 2 ) (cid:15) t 2C − ( 2 s C + 1 ) t C + s C ( s C + 1 ) (cid:16) = −12 ( b − 2 ) ( t C − s C ) ( t C − s C − 1 ) ≤ 0 . Finally , suppose that s C = 0 . Then r C ( t C − 1 ) ≤ ( b − t C ) ( t C − 1 ) because r C ≤ b − t C . Therefore , a T (cid:1) x C , y C (cid:2) ≤ −12 ( b − 2 ) t C ( t C − 1 ) + ( b − t C ) ( t C − 1 ) = −12 b ( t C − 2 ) ( t C − 1 ) ≤ 0 . This proves validity . Facet : The T - star inequality can be obtained as the sum of other valid in - equalities when | R | ≤ b − 2 . When b = 3 the T - star inequality with coefficients a e = 0 for all e ∈ δ ( R , S ) is valid for P n ( b ) ; it is the T - star inequality obtained by setting R : = R ∪ S and S : = ∅ . This proves necessity . In order to prove sufficiency we assume that the conditions of the theorem are satisfied . Let π T ( x , y ) ≤ π 0 be a facet defining inequality such that a T ( x , y ) = 0 ⇒ π T ( x , y ) = π 0 . As usual we shall prove that π = σa for some σ ∈ IR + . ( a ) Since a T (cid:1) x C , y C (cid:2) = 0 for C = ∅ , we get π 0 = 0 . ( b ) From C = { t } , t ∈ T , we get π t = 0 for all t ∈ T . ( c ) Let C = { r , t } , r ∈ R , t ∈ T . Then it follows that , for every r ∈ R , we have π rt = −π r for all t ∈ T . ( d ) From C = { i , j , t } , i , j ∈ R , t ∈ T , it follows that π ij = 0 for all ij ∈ E n ( R ) . ( e ) Let R (cid:1) ⊂ R such that | R (cid:1) | = b − 3 , and let i , j ∈ R \ R (cid:1) and t , u ∈ T be distinct nodes . Let C = { i , t , u } ∪ R (cid:1) and D = { j , t , u } ∪ R (cid:1) . From the relation π T (cid:1) x C , y C (cid:2) − π T (cid:1) x D , y D (cid:2) = 0 we get π i − π j + π it + π iu − π jt − π ju + (cid:5) r∈R (cid:0) ( π ir − π jr ) = 0 , 18 which reduces to −π i + π j = 0 by ( c ) and ( d ) . So −π j = −π i = π it : = σ . Hence , π e = σ for all e ∈ δ ( R , T ) and π r = −σ for all r ∈ R . ( f ) Let C = { i , t , u } ∪R (cid:1) as in ( e ) . Then it follows that ( b−2 ) ( 2 σ−σ ) + π tu = 0 , which implies that π e = − ( b − 2 ) σ for all e ∈ E n ( T ) . Now we assume that S in nonempty . ( g ) From C = { s , t } , s ∈ S , t ∈ T , we get π st = −π s for all t ∈ T . ( h ) From C = { s , t , u } , s ∈ S , t , u ∈ T , it then follows that π s = π tu = − ( b − 2 ) σ . Hence , π s = − ( b − 2 ) σ for all s ∈ S and π e = ( b − 2 ) σ for all e ∈ δ ( S , T ) . ( i ) From C = { i , j , t , u } , i , j ∈ S , t , u ∈ T , it follows that π ij + ( b−2 ) σ = 0 . This implies that π e = − ( b − 2 ) σ for all e ∈ E n ( S ) . ( j ) From C = { r , s , t , u } , r ∈ R , s ∈ S , t , u ∈ T , it follows that π rs + σ = 0 . So π e = −σ for all e ∈ δ ( R , S ) . We have established so far that π v = σa v for all v ∈ U = R ∪ S ∪ T and π e = σa e for all e ∈ E n ( U ) . It still remains to be shown that π v = 0 for all v ∈ V n \ U and π e = 0 for all e ∈ E n \ E n ( U ) . However , these latter relations are easily established . So we immediately jump to conclude that ( π , π 0 ) = ( σa , 0 ) . This completes the proof . 2 3 A branch - and - cut algorithm We utilize the above classes of inequalities in a branch - and - cut algorithm for the WCP . A branch - and - cut algorithm is a branch - and - bound algorithm that incor - porates a fractional cutting - plane algorithm for the solution of the subproblem LPs of the branch - and - bound enumeration . We also use a heuristic in order to obtain an initial feasible clique . In this section we describe the most important components of our branch - and - cut algorithm . 3 . 1 A heuristic for the WCP The purpose of the heuristic is to provide a lower bound on the value of an optimal clique in K n . This value is used to prune branches of the branch - and - cut enumeration tree such that the optimization process at a branch is terminated as soon as the LP objective value falls below this bound . The heuristic is a two phase heuristic composed of a construction heuristic and an improvement heuristic . 19 The construction heuristic starts with a single node and successively builds a clique by adding further nodes , one node at a time . This is done in a greedy manner by including the next node that gives the largest contribution to the current clique , where the contribution is the weight of the node plus the sum of the weights of the edges between this node and the nodes in the clique . We have designed this heuristic to take into account that some or all of the node weights may be negative . For this reason a node may be included in the clique although the partial contribution from this node is negative ; it is hoped that the contribution becomes positive subsequently after the inclusion of further nodes . So further nodes are included in the clique until it consists of b nodes . Finally , the clique values for the first p nodes included are compared for p = 1 , . . . , b , and only the first k of these b nodes that give the highest clique value are kept in the clique . In this way the heuristic may provide cliques with fewer than b nodes . The improvement heuristic is an exchange heuristic like the one described in Sp¨ath [ 14 ] . Given a clique on node set C it calculates , for all node pairs u ∈ C and v ∈ V n \ C , the gain that results from replacing u by v in C . An exchange of the node pair that gives the largest gain is made if the gain is positive . This is repeated until no positive gain can be obtained by exchanging two nodes . We use each node of the graph as a starting node for the construction heuristic , and for each clique found in this manner we also apply the improvement heuristic . So we find n cliques ( some of which may turn out to be identical ) and use the one with the largest value as a candidate optimal clique . 3 . 2 Fractional cutting plane algorithm The fractional cutting plane algorithm ( FCPA ) calls a collection of separation procedures in order to identify facet defining inequalities that cut off the current fractional LP solution , adds such inequalities to the LP , reoptimizes the revised LP , and removes from the LP inequalities that have become nonbinding . This section deals with the management of the inequalities that are generated by the separation procedures and the control of constraint generation . In section 3 . 3 we give detailed descriptions of some of the separation procedures . The FCPA uses three lists to keep track of the generated inequalities according to their status of being either violated , active , or removed : • A list of candidate inequalities that are violated by the current LP solution . 20 • A list of active inequalities of the current LP . • A constraint pool containing inequalities that have been removed from the LP , but are kept to be used again . A particular inequality is only contained in one of these lists , and it is represented by a class identifier and an array consisting of one or more ordered sets of node indices . The separation procedures are very often able to find a lot of violated inequal - ities . So in order to keep the number of candidate inequalities at a manageable level the constraint identification is terminated whenever 4 0 n inequalities have been found . All newly generated inequalities are placed in the list of candidate inequalities . This list consists of 10 “buckets” each of which contains inequali - ties with similar degrees of violation ( this approach is taken from Gr¨otschel and Wakabayashi [ 3 ] ) . The addition of violated inequalities to the LP and LP reoptimization are performed iteratively . A maximum number of 400 inequalities are added to the LP at a time . So up to 400 inequalities are taken from the most violated buckets of the candidate list and are appended to the list of active inequalities . After the augmented LP has been reoptimized any still violated inequalities in the candidate list are sorted anew into the appropriate buckets ; the rest of the inequalities are discarded from further consideration . As long as any inequalities in the candidate list remain violated the addition of inequalities and LP reoptimization are repeated . We shall refer to this iterative process as the reoptimization loop . In order to keep the LPs small — and make reoptimizations fast — non - binding inequalities are removed from the LP . This is done every time the LP has been reoptimized , unless only a few inequalities have been added since the previous deletion of constraints . The nonbinding inequalities are removed from the list of active inequalities , and some of them are placed in the constraint pool as explained below . We consider an inequality nonbinding when the associated slack variable is in the LP basis , irrespective of its value . The constraint pool is used to store inequalities for which a heuristic sepa - ration procedure is used . The main purpose of the constraint pool is to have a place to save currently inactive inequalities that may be needed to re - establish the upper bound at a node of the branch - and - cut enumeration tree . Whenever branching takes place we make a list of pointers to the currently binding in - equalities that are not separated by an exact procedure . This list is saved at the branching node such that any necessary inequalities can easily be retrieved from 21 the pool , or they can be generated when needed . However , to the extent that there is idle space , the pool is also used for temporary storage of inequalities that have been active recently . In this way we get easy access to some inequalities that cannot be guaranteed to be identified otherwise . Now we describe the control of constraint identification . The very first LP that is constructed only includes some of the constraints of the formulation ( 1 ) of the WCP , namely the | E n | inequalities x u + x v − y uv ≤ 1 and the n star inequalities together with the nonnegativity bounds y e ≥ 0 . After the solution of this LP has been obtained further inequalities that are violated by the LP solution are generated and added to the LP . The generation of different classes or subclasses of violated inequalities is controlled in a hierarchical manner . This hierarchy consists of three levels : At Level 1 we identify any violated inequalities that belong to the formula - tion ( 1 ) of the WCP and any violated inequalities ( 4 ) . At this level constraint identification and LP reoptimizations are repeated until all inequalities are satis - fied by the current LP solution . Then we go to Level 2 if any node variables x v take on fractional values ; otherwise the FCPA terminates with a feasible integer LP solution . At Level 2 we identify any violated triangle cut inequalities y uv + y uw − y vw − x u ≤ 0 and triangle clique inequalities x u + x v + x w − y uv − y uw − y vw ≤ 1 . Whenever branching has taken place we also check the violation of the inequalities in the pool that were binding at the parent node of the enumeration tree . If any violated inequalities are identified at this level we complete the reoptimization loop and then immediately return to Level 1 ; otherwise we go to Level 3 . At Level 3 we attempt to identify violated α - inequalities , clique inequalities , various multistar inequalities , and cut - tree inequalities . We also make a full scan of the constraint pool . In case any violated inequalities are found the reoptimization loop is completed and then we return to Level 1 . Otherwise the FCPA terminates . We have implemented one further termination mechanism for the FCPA . This is when tailing off occurs , i . e . when several successive LP objective values only decrease little . In order to determine when tailing off occurs we use a pre - specified tolerance (cid:7) and an iteration limit (cid:5) . Tailing off detection begins at Level 2 of the FCPA , where LP objective values at the end of successive reopti - mization loops are compared . If the relative difference between two successive LP objective values does not exceed the tolerance (cid:7) a tailing off indicator is turned on . This indicator is turned off subsequently whenever this difference 22 exceeds (cid:7) . If the indicator is still on after (cid:5) successive reoptimization loops the optimization process at Level 2 of the FCPA is terminated . At Level 3 the tail - ing off detection continues in a similar manner . After the reoptimization loop at Level 3 has been completed the tailing off indicator is turned off if the reduction rate of the LP objective value exceeds (cid:7) . In any case the FCPA returns to levels 1 and 2 , but now Level 2 terminates sooner . If the tailing off indicator is still on after the first reoptimization loop at Level 2 control is passed back to Level 3 . This process is repeated as long as the tailing off indicator remains turned on , except that after (cid:5) successive Level 3 entries the FCPA gives up and terminates due to tailing off . We have experienced that the choice of the numerical values that are assigned to the parameters (cid:7) and (cid:5) are critical for the overall performance of the branch - and - cut algorithm . In fact , our computational experiments show that highly different values of (cid:7) should be used for different sets of test problems . We shall explain the particular settings of the parameters we have used when we present the computational results . 3 . 3 Separation procedures This section describes the separation procedures that are used in the FCPA to identify violated inequalities . Because some of the procedures are rather trivial , a detailed description of these separation procedures will not be given here . We just note that the inequalities in ( 1 ) and ( 4 ) that are used at Level 1 of the FCPA can be separated exactly by complete enumeration with complexity O ( n 2 ) . Similarly , the triangle cut - and clique inequalities that are used at Level 2 can be separated exactly with complexity O ( n 3 ) . The input to the separation procedures is the current LP solution ( ¯x , ¯y ) . The output is a number of inequalities that are violated by this solution and which are placed in the list of candidate inequalities . Since some of the separation procedures may find identical inequalities , any particular violated inequality is only saved in the candidate list if it is not already contained in the appropriate bucket . In this way we avoid the use of several identical inequalities . 3 . 3 . 1 Separation of α - inequalities Besides the exact procedure for generating triangle cut inequalities that is used at Level 2 in the FCPA we have implemented a heuristic separation procedure 23 for the identification of violated α - inequalities ( 2 ) with | T | ≥ 3 or | S | ≥ 2 . This separation procedure is called by the FCPA at Level 3 . We utilize an easy method to calculate the integer value of the α coefficient that gives maximal violation of the inequality for any given node sets S and T . The best α is obtained by setting α = (cid:12)¯x ( T ) − ¯x ( S ) (cid:13) . ( 13 ) This result can be derived by a marginal analysis of the violation . The violation of the α - inequality is viol ( α ) = α ( ¯x ( T ) − ¯x ( S ) ) − α ( α − 1 ) / 2 + k , where k = ¯y ( δ ( S , T ) ) − ¯y ( E n ( S ) ) − ¯y ( E n ( T ) ) − ¯x ( T ) . As noted by Macambira and de Souza [ 8 ] viol ( α ) is a second - degree polynomial function in α . Now we note that the violation of the inequality can be increased by incrementing α by 1 if viol ( α + 1 ) > viol ( α ) . This is equivalent to ¯x ( T ) − ¯x ( S ) > α . Alternatively , the violation can be increased by decrementing α by 1 if viol ( α − 1 ) > viol ( α ) . This is equivalent to ¯x ( T ) − ¯x ( S ) + 1 < α . It follows that the coefficient α that gives maximal violation satisfies ¯x ( T ) − ¯x ( S ) ≤ α ≤ ¯x ( T ) − ¯x ( S ) + 1 for given S and T . The separation procedure works on the currently active α - inequalities , and the idea is to make minor modifications of these inequalities that result in new violated inequalities . Since active inequalities are satisfied with equality , it is relatively easy to identify such attractive modifications . We consider any active α - inequality given by the triple ( S , T , ¯α ) . The first modification involves calculating the currently best α using ( 13 ) . If α (cid:5) = ¯α we obtain a new violated inequality by using this coefficient . It should be noted , however , that α ≤ 0 implies that the roles of node sets S and T should be interchanged . In this latter case we simply generate a new violated inequality given by ( T , S , 1 ) , but only when | S | ≥ 2 . The second modification that is attempted is to augment one of the node sets S and T by a single node that is not already contained in these sets . When an attractive augmentation is considered the best α is recalculated such that ¯α may be incremented when T is augmented or decremented when S is augmented . It is possible in many cases to identify several new violated inequalities from a single active inequality by these modifications . However , we have chosen to generate only one new inequality for each active α - inequality . So as soon as a violated inequality has been found we stop considering any other modifications of the current inequality . 24 3 . 3 . 2 Separation of clique inequalities As mentioned above we use an exact procedure to identify any violated triangle clique inequalities at Level 2 of the FCPA . At Level 3 we use a heuristic sep - aration procedure that modifies currently active clique inequalities in a manner that is very similar to the modification of α - inequalities . For any given node set T there is a closed - form formula for the value of β that gives maximal violation . This is β = (cid:14)¯x ( T ) (cid:15) , which follows directly from ( 13 ) with β = α − 1 and ¯x ( S ) = 0 . So the first modification that is considered is to calculate the currently best β using this formula . This is done for all active clique inequalities with | T | ≥ 4 . If the best β differs from the one used we obtain a new violated inequality by using this coefficient . Whenever the first modification is not successful we attempt to augment node set T by one node . We consider every node v ∈ V n \ T for which ¯x v > 0 and use β = (cid:14)¯x ( T ) + ¯x v (cid:15) . Every violated clique inequality that is found in this way is saved in the list of candidate inequalities ( if not already present ) . So we may generate several new inequalities from one active clique inequality . 3 . 3 . 3 Separation of cut - tree inequalities We have implemented two separation procedures for the class of cut - tree inequal - ities that are used at Level 3 of the FCPA . One procedure is a greedy construction heuristic , while the other one attempts to modify currently active cut - tree inequal - ities . The procedures are very similar in that they only differ in the identification of a tree G T = ( V T , E T ) . The modification procedure simply uses the tree in the support of a currently active inequality , whereas the construction heuristic builds a new tree . The construction heuristic builds a tree in the following way . We start with an initial tree that is an edge of the graph , V T = { u , v } and E T = { uv } . Subsequently this tree is augmented iteratively by adding a node w ∈ V n \ V T and an edge vw such that v ∈ V T and ¯y vw − ¯x v is maximal . This continues until V T has b + 1 nodes . We use each edge uv ∈ E n with ¯y uv > 0 as an initial tree such that several distinct trees may be generated in this manner . Any trees that turn out to be stars are discarded from further consideration . Once a tree is available we determine what additional node sets should be associated with the tree and the nodes to be included in these sets . Both the modification procedure and the construction heuristic do this in the same way . For every inner node i ∈ I of the tree we have an ( initially empty ) node set 25 R (cid:0) for each leaf neighbor (cid:5) ∈ L i and a node set R uv for each edge uv of the neighbor tree T i that spans the inner neighbors I i of i . However , when | I i | ≥ 3 we have a choice as to which edges should be included in T i . We determine T i as a maximal spanning tree in E n ( I i ) based on weights for the edges uv ∈ E n ( I i ) that are calculated as follows . Any single node w ∈ V n \ V T that is included in R uv contributes with γ ( w ) : = ¯y iw − ¯y uw − ¯y vw to the left - hand side value of the cut - tree inequality . So we simply use the sum of all positive γ ( w ) as weights for the edges uv , although this sum actually overestimates the potential contribution from node set R uv to the violation of the inequality . After the neighbor trees of the inner nodes have been determined we assign nodes to the sets R (cid:0) , R uv which are empty initially . This is done in a greedy manner , one node at a time . First we identify the best node set for each node w ∈ V n \ V T ; this is the set for which γ ( w ) is maximal ( in the case of a leaf neighbor set R (cid:0) we calculate γ ( w ) : = ¯y iw − ¯y (cid:0)w ) . In this way we tentatively assign every node to a particular node set , provided that the corresponding γ contribution is positive . If γ ( w ) is nonpositive for all node sets , node w will not be assigned to any set . Subsequently some of the nodes are permanently assigned to their node set . Among all tentatively assigned nodes we select the one that has maximal γ contribution . Suppose that this is node s . Then s is permanently assigned to its node set R , meaning that the set is augmented , R : = R ∪ { s } . This assignment changes the contributions from the remaining nodes that are tentatively assigned to set R . So we update γ ( w ) : = γ ( w ) − ¯y sw for all these nodes , and if γ ( w ) becomes nonpositive we delete w from the list of tentatively assigned nodes . The permanent assignments are continued in this manner as long as there are any tentatively assigned nodes left . Upon completion of the above node set augmentations the left - hand side value of the corresponding cut - tree inequality is tested . If it is positive we have a violated inequality which is placed in the list of candidate inequalities , provided that we do not find an inequality with the same description in the appropriate bucket of the list . 3 . 3 . 4 Separation of multistar inequalities The separation procedures for the three classes of multistar inequalities are quite similar . So here we shall only describe the separation of cut - star inequalities ( 11 ) ; the separation of clique - star inequalities and T - star inequalities works analo - gously . However , we remark that in the present algorithm we only utilize T - star inequalities ( 12 ) with an empty node set S . The multistar inequalities are used 26 at Level 3 in the FCPA . First we note that for a given nucleus a most violated cut - star inequality can be identified with complexity O ( n ) simply by using all satellites that give positive contributions to the left - hand side value of the inequality ( in fact , this is true for all multistar inequalities ) . We utilize this property in all separation procedures that are described here . We make exact separation of cut - star inequalities with | S | = | T | = 1 . This is a very simple procedure where we consider all edges uv ∈ E n for which ¯y uv > 0 and identify the best set of satellites R for each of the two choices S = { u } , T = { v } and S = { v } , T = { u } , respectively . We have also implemented two heuristic separation procedures that work on the currently active inequalities . These procedures identify cut - star inequalities with | S | ≥ 2 or | T | ≥ 2 . In one procedure we use the currently binding α - inequalities . The nodes in the support of the α - inequality are used as the nucleus for the cut - star inequality with nodes sets S and T keeping their respective roles . In the other separation procedure we try to modify currently active cut - star inequalities . The first modification consists in identifying a new best set of satellites . The second modification is to augment node set T by the satellite node with largest contribution , while the last modification that is attempted is to augment node set S by one node ( under the condition that | T | ≥ 2 ) . 3 . 4 Branching Branching is performed whenever the FCPA terminates with a noninteger LP solution whose objective value exceeds the value of the candidate optimal clique . Branching is based on variable dichotomy . We select a node variable x v with fractional value and create two branches : the down - branch where we create a subproblem with the additional restriction that x v = 0 , and the up - branch where we require x v = 1 . In the presence of several fractional valued node variables we choose one which is expected to harm the LP objective value most . We identify the most fractional valued node variables , i . e . the variables whose values are closest to 0 . 5 . For all these variables we calculate the sum of the weight of the corresponding node and the weights of all edges incident to the node . We choose the node variable for which this sum is largest . In a more pure form this method of branching variable selection is referred to as enhanced branching in Linderoth and Savelsbergh [ 7 ] . 27 We use the best - bound search strategy in the selection of the next branch to process . Furthermore , whenever b > n / 2 we first solve the subproblem at the up - branch ; otherwise we first solve the problem at the down - branch . This rule is based on the likelihood of finding an optimal integer solution at the branch in question ; in the former case we expect to find an optimal solution at an up - branch more often than not . Identifying an optimal solution at an early stage of the branch - and - cut enumeration saves work in the FCPA , because it can be terminated as soon as the LP objective value reaches the lower bound . 4 Computational results In this section we summarize the computational results we have obtained by applying the branch - and - cut algorithm to two sets of test problems . The first set of test problems has been provided by Macambira and de Souza [ 8 ] and has also been used in Hunting et al . [ 5 ] . We provide a second set of test problems . These are instances of a column generation problem in the context of graph partitioning . The algorithm has been implemented in a C program using CPLEX 5 . 0 as the LP solver . All computational results have been obtained by running our program under Windows 95 on a 350 MHz PC . 4 . 1 Macambira’s and de Souza’s test problems This set of test problems consists of 60 problem instances . The problems are associated with ( complete ) graphs on n ∈ { 4 0 , 4 2 , 4 4 , 4 5 , 4 6 , 4 8 } nodes , and the maximal clique size is fixed at b = (cid:14)n / 2 (cid:15) . The edge weights are randomly generated ; half of the problem instances have positive weights in the interval [ 1 , 1 0 0 0 ] , and the other half of the instances have positive and negative weights in the interval [ − 1 0 0 0 , 1 0 0 0 ] . The sizes of the edge weights are controled by a parameter k ∈ { 1 , . . . , 5 } . All node weights are zero . Table 1 shows the computational results for the problem instances with pos - itive edge weights , and table 2 shows the results for the instances with negative and positive weights . The tables are to be read as follows . The first three columns state the values of n , b , and k . The next three columns state the value of the clique found by the heuristic , the final LP objective value obtained by the FCPA at the root ( first ) node of the enumeration tree , and the optimal clique value . The seventh column gives the number of branches considered during the 28 n b k Heuristic First node Optimal Branches Time ( s ) 40 20 1 109346 109346 . 0 109346 1 103 40 20 2 82451 82451 . 0 82451 1 46 40 20 3 68759 68759 . 0 68759 1 131 40 20 4 60782 60782 . 0 60782 1 114 40 20 5 60513 60513 . 0 60513 1 51 42 21 1 120299 120299 . 0 120299 1 201 42 21 2 87810 87810 . 0 87810 1 215 42 21 3 76554 76554 . 0 76554 1 163 42 21 4 69482 69482 . 0 69482 1 102 42 21 5 67383 67383 . 0 67383 1 52 44 22 1 136525 136525 . 0 136525 1 133 44 22 2 98186 98186 . 0 98186 1 284 44 22 3 84675 84675 . 0 84675 1 169 44 22 4 75274 75274 . 0 75274 1 214 44 22 5 69540 69540 . 0 69549 1 110 45 22 1 138694 138694 . 0 138694 1 245 45 22 2 98321 98321 . 0 98321 1 369 45 22 3 82644 82743 . 0 82743 1 312 45 22 4 77500 77500 . 0 77500 1 225 45 22 5 69563 69563 . 0 69563 1 291 46 23 1 142985 142985 . 0 142985 1 415 46 23 2 108243 108243 . 0 108243 1 439 46 23 3 94859 94859 . 0 94859 1 232 46 23 4 78747 78747 . 0 78747 1 419 46 23 5 72290 72431 . 0 72431 1 370 48 24 1 163397 163397 . 0 163397 1 386 48 24 2 115471 115475 . 4 115471 3 1135 48 24 3 96567 96666 . 0 96666 1 517 48 24 4 88728 88728 . 0 88728 1 272 48 24 5 82117 82117 . 0 82117 1 262 Table 1 : Macambira and de Souza problems : positive weights . 29 branch - and - cut enumeration . A 1 in this column means that branching was not necessary . The last column states the total computation time in seconds . The tailing off parameters ( cf . page 23 ) used to obtain these results were set to a tolerance of (cid:7) = 0 . 0 0 1 and (cid:5) = 4 iterations . These settings of the parameters were chosen in order to avoid branching for the large majority of the problem instances . Extensive experimentation clearly suggests that this is the most efficient approach for these problem instances . A direct comparision with the computation times quoted in Hunting et al . [ 5 ] and Macambira and de Souza [ 8 ] is not possible because different computer systems have been used . Nevertheless , we feel confident about claiming that our branch - and - cut algorithm performs better than the algorithms presented in these papers . Hunting et al . have used a computer with a 125 MHz processor . Using the MHz - figures as a measure of relative speed we estimate that our computer is approximately 3 times faster . So we have divided the computation times in [ 5 ] by 3 and compared them with the above results . For the problem instances in table 1 our algorithm is about 5 times faster on the average , ranging from 2 to 12 times ; and for the problem instances in table 2 we get a factor of 10 in our favor , ranging from 3 to 26 . Although Macambira and de Souza have also used a branch - and - cut approach , the computation times they obtain do not appear to be better than those of Hunting et al . We think that the relatively poor performance of their algorithm has two explanations . One explanation is that they only utilize cut - and α - inequalities in their FCPA . This is indeed a very strong and useful class of inequalities ; together with the constraints in ( 1 ) they are sufficient to solve the above problem instances without branching . However , we have found that the subclass ( 4 ) of the clique - star inequalities is also extremely useful . Utilizing these few inequalities , as we do at Level 1 , considerably speeds up the convergence of our FCPA . The other explanation is that they do not delete unbinding inequalities from the LPs . It is apparent from the computational results in [ 8 ] that the LPs grow very large in terms of the number constraints . This has an adverse effect on the reoptimization speed of the LP solver . In our FCPA we solve many , many more LPs , but they are also much smaller , and reoptimizations are faster . 4 . 2 Column generation problems for graph partitioning In this section we present the computatinal results for some instances of a column generation problem for graph partitioning . The framework for solving graph 30 n b k Heuristic First node Optimal Branches Time ( s ) 40 20 1 70348 70348 . 0 70348 1 223 40 20 2 45404 45404 . 0 45404 1 68 40 20 3 34091 34091 . 0 34091 1 64 40 20 4 27758 27758 . 0 27758 1 84 40 20 5 27967 27967 . 0 27967 1 44 42 21 1 81633 81633 . 0 81633 1 269 42 21 2 46828 46828 . 0 46828 1 193 42 21 3 36689 36689 . 0 36689 1 84 42 21 4 35987 35987 . 0 35987 1 58 42 21 5 35460 35460 . 0 35460 1 59 44 22 1 90620 90620 . 0 90620 1 347 44 22 2 56960 56960 . 0 56960 1 195 44 22 3 40697 40697 . 0 40697 1 151 44 22 4 32601 32601 . 0 32601 1 169 44 22 5 29407 29407 . 0 29407 1 129 45 22 1 102295 102295 . 0 102295 1 252 45 22 2 55103 55103 . 0 55103 1 353 45 22 3 43914 43914 . 0 43914 1 84 45 22 4 33543 33990 . 0 33990 1 140 45 22 5 30974 30974 . 0 30974 1 237 46 23 1 99550 99550 . 0 99550 1 383 46 23 2 58361 58361 . 0 58361 1 358 46 23 3 43915 43915 . 0 43915 1 242 46 23 4 32968 32968 . 0 32968 1 344 46 23 5 31000 31000 . 0 31000 1 144 48 24 1 113478 113478 . 0 113478 1 800 48 24 2 61768 61768 . 0 61768 1 840 48 24 3 45941 45941 . 0 45941 1 290 48 24 4 36903 36903 . 0 36903 1 206 48 24 5 31351 31351 . 0 31351 1 307 Table 2 : Macambira and de Souza problems : negative and positive weights . 31 partitioning problems via column generation is described in Johnson et al . [ 6 ] . Mehrotra [ 9 ] studies a special case of the column generation problem that he formulates as a cardinality constrained Boolean quadratic problem ( CBQP ) . This problem is the same as the WCP , except that edge variables are only defined for edges with nonzero weights . The instances of the CBQP that are considered in [ 9 ] are interesting from a computational point of view , because Mehrotra states that “Our experience . . . indicates that these problems are very difficult to solve . ” Unfortunately , the data from that study is no longer available . Instead we have chosen to generate some new problem instances that are based on the same graphs which are from [ 6 ] . For this reason the problem instances we obtain should be quite similar to the original problem instances . However , we treat these problems as instances of the WCP by assigning zero weights to all edges that are missing in the graphs . The problem we consider is to generate columns for the LP relaxation of a set packing problem ( SPP ) . This SPP has n rows , and each column corresponds to a clique such that the coefficient in the i th row is 1 if and only if the i th node is in the clique ; otherwise it is 0 . The objective coefficient of the column is the sum of the weights of all edges in the clique . We must generate a column with maximal reduced cost . This problem is a WCP with edge weights as described and a weight for every node which is the negative of the dual variable for the corresponding row of the SPP . We have obtained our instances of this problem in the following way . For each graph and each maximal clique size b ∈ { 1 0 , 1 5 , 2 0 , 2 5 } we used our heuristic for the WCP to find an intial clique and then constructed the LP relaxation of the SPP with the correspondig column . At subsequent iterations the SPP was reoptimized , the new dual solution was used to provide new node weights , and the heuristic was applied again ( actually , this heuristic was extended by also applying the exchange heuristic to the existing columns of the SPP ) . As long as the heuristic was capable of finding a clique with positive value the corresponding column was added to the SPP , and this process continued . At the stages in the process , where the heuristic failed to find a positive valued clique , we have saved the dual solution and thus obtained a new instance of the WCP . This new problem instance was solved by the branch - and - cut algorithm . In case a positive valued clique was found the corresponding column was added to the SPP , and the whole process was repeated by reapplying the heuristic . Only when the optimal clique value was zero the whole process stopped . The computational results for the problem instances that were solved by 32 branch - and - cut are shown in table 3 . The column ‘Graph’ refers to the graph number used in [ 6 ] . ‘Instance’ gives the order in which a problem instance was obtained for any given graph and b . The other columns are as in tables 1 and 2 , except that the heuristic clique values are omitted ; they are all 0 by virtue of the above process . In order to get the results in table 3 we had to change the settings of the tailing off parameters . We have used a much larger tolerance (cid:7) = 0 . 0 5 and the same iteration limit (cid:5) = 4 . This means that the FCPA terminates due to tailing off much earlier than otherwise , that the LP objective values provided by the FCPA are larger , and that branching becomes more extensive . However , for the majority of these problem instances this is advantageous . The larger computational efforts of the FCPA that result from a small value of (cid:7) do not pay off in terms of smaller computation times due to less extensive branching . This is very likely because some other classes of facet defining inequalities are needed for these problem instances , or because the separation procedures currently employed are too simple to identify the right inequalities . On the other hand , we would like to emphasize that the above problem instances probably are some of the most difficult ones in this context . It has been pointed out in [ 6 ] and [ 9 ] that as the reduced costs approach zero the column generation problems become harder , because the gap between the the LP value ( at the root node ) and the optimal value tends to get larger . In accordance with this observation the problem instances that have large optimal values ( reduced costs ) are relatively easy to solve . We have also solved the column generation problems for the above graphs with zero node weights using our branch - and - cut algorithm . This corresponds to the problem of finding a best first column to add to the SPP . All these latter problem instances were easily solved without branching . The longest computation time was 9 seconds for the Graph 6 instance with b = 2 5 . As a final remark we think it is worth noting that these graphs are sparse in the sense that only about ten percent of the edges have nonzero weights . Despite this fact the utilization of the complete graph formulation ( 1 ) of the problem seems very appropriate . The overhead that is incurred by the definition and use of additional edge variables with zero weights appears to be compensated for by the tightness of the formulation . 33 Graph n b Instance First node Optimal Branches Time ( s ) 2 30 10 1 1 . 0 1 . 0 1 4 2 30 10 2 0 . 0 0 . 0 1 6 2 30 15 1 5 . 6 0 . 0 3 69 2 30 20 1 6 . 2 0 . 0 9 113 2 30 25 1 5 . 4 0 . 0 9 151 1 45 10 1 11 . 5 0 . 0 7 235 1 45 15 1 8 . 4 0 . 0 3 196 1 45 20 1 33 . 9 0 . 0 3 156 1 45 25 1 14 . 0 9 . 1 5 428 1 45 25 2 13 . 7 0 . 0 7 578 3 47 10 1 3 . 7 0 . 0 7 537 3 47 15 1 7 . 3 5 . 3 3 316 3 47 15 2 8 . 0 0 . 0 9 683 3 47 20 1 31 . 7 0 . 0 11 900 3 47 25 1 38 . 8 0 . 0 11 1773 4 47 10 1 4 . 6 0 . 0 7 294 4 47 15 1 6 . 7 0 . 0 7 617 4 47 20 1 11 . 1 0 . 0 7 809 4 47 25 1 20 . 3 0 . 0 13 1084 6 61 10 1 37 . 5 0 . 0 9 908 6 61 15 1 94 . 8 0 . 0 15 1829 6 61 20 1 70 . 4 0 . 0 11 2772 6 61 25 1 243 . 5 0 . 0 15 3553 Table 3 : Column generation problems for Johnson et al . graphs . 34 Acknowledgements I kindly thank Professor Cid de Souza for providing his and Dr . Macambira’s test problems for me . References [ 1 ] G . Dijkhuizen , U . Faigle , A cutting - plane approach to the edge - weighted maximal clique problem , European Journal of Operational Research 69 ( 1993 ) 121 – 130 . [ 2 ] U . Faigle , R . Garbe , K . Heerink , B . Spieker , LP - relaxations for the edge - weighted subclique problem , in : A . Bachem , U . Derigs , M . J¨unger , R . Schrader ( Eds . ) , Operations Research ’93 , Physica - Verlag , Heidelberg , 1994 , pp . 157 – 160 . [ 3 ] M . Gr¨otschel , Y . Wakabayashi , A cutting plane algorithm for a clustering problem , Mathematical Programming 45 ( 1989 ) 59 – 96 . [ 4 ] M . Hunting , Relaxation Techniques for Discrete Optimization Problems — Theory and Algorithms , Ph . D . thesis , University of Twente , 1998 . [ 5 ] M . Hunting , U . Faigle , W . Kern , A Lagrangian relaxation approach to the edge - weighted clique problem , European Journal of Operational Research 131 ( 2001 ) 119 – 131 . [ 6 ] E . L . Johnson , A . Mehrotra , G . L . Nemhauser , Min - cut clustering , Mathe - matical Programming 62 ( 1993 ) 133 – 151 . [ 7 ] J . T . Linderoth , M . W . P . Savelsbergh , A computational study of search strate - gies for mixed integer programming , INFORMS Journal on Computing 11 ( 1999 ) 173 – 187 . [ 8 ] E . M . Macambira , C . C . de Souza , The edge - weighted clique problem : Valid inequalities , facets and polyhedral computations , European Journal of Op - erational Research 123 ( 2000 ) 346 – 371 . [ 9 ] A . Mehrotra , Cardinality constrained Boolean quadratic polytope , Discrete Applied Mathematics 79 ( 1997 ) 137 – 154 . 35 [ 10 ] M . Padberg , The Boolean quadric polytope : Some characteristics , facets and relatives , Mathematical Programming 45 ( 1989 ) 139 – 172 . [ 11 ] K . Park , K . Lee , S . Park , An extended formulation approach to the edge - weighted maximal clique problem , European Journal of Operational Re - search 95 ( 1996 ) 671 – 682 . [ 12 ] H . D . Sherali , Y . Lee , W . P . Adams , A simultaneous lifting strategy for iden - tifying new classes of facets for the Boolean quadric polytope , Operations Research Letters 17 ( 1995 ) 19 – 26 . [ 13 ] M . M . Sørensen , b - tree facets for the simple graph partitioning polytope , Working paper 00 - 4 , Dept . of Management Science and Logistics , The Aarhus School of Business , 2000 . [ 14 ] H . Sp¨ath , Heuristically determining cliques of given cardinality and with minimal cost within weighted complete graphs , Zeitschrift f¨ur Operations Research 29 ( 1985 ) 125 – 131 . 36