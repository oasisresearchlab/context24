Clocks , Event Ordering , and Global Predicate Computa : on Distributed Make • Distributed ﬁle servers holds source and object ﬁles • Clients specify modiﬁca : on : me on uploaded ﬁles • Use : mestamps to decide what needs to be rebuilt • if object O depends on source S , and • O . : me < S . : me , rebuild O • What can go wrong ? Two Approaches • Synchronize physical clocks • Logical clocks • Design a scheme that synchronizes physical clocks • What do you think are the sources of inaccuracy ? • Why is clock synchroniza : on hard ? Varia : ons in Network Latency • Latency can be unpredictable and has a lower bound • Simple approach : Designated server broadcasts : me , Clients receive broadcast , set their clock to the value in the message + minimum delay Interroga : on Based Approach • Client sends a roundtrip message to query server’s : me • Set’s client’s clock to server’s clock + half of RTT • Worst case error ( if we know the min latency ) : ( T2 - T0 ) / 2 - min Logical Clocks • another way to keep track of : me • based on the idea of causal rela : onships between events • doesn’t require any physical clocks Events and Histories • Processes execute sequences of events • Events can be of 3 types : local , send , and receive • The local history of a process is the sequence of events executed by process Ordering events • Observa : on 1 : • Events in a local history are totally ordered • Observa : on 2 : • For every message , send precedes receive time p i time p i time m p j Lamport Clock : Increment Rules e ip e i + 1 p p e ip e jq p q LC ( e i + 1 p ) = LC ( e ip ) + 1 LC ( e j q ) = max ( LC ( e j − 1 q ) , LC ( e i p ) ) + 1 Timestamp with m T S ( m ) = LC ( send ( m ) ) Discussion • What are the strengths and limita : ons of Lamport clocks ? Example of Global Predicate • Sebng : Locks in distributed system • Objects locked by nodes and moved to the node that is currently modifying it • Nodes reques : ng the object / lock , send a message to the current node locking it and blocks for a response • Global predicate : detect deadlocks Global States & Clocks • Need to reason about global states of a distributed system • Global state : processor state + communica : on channel state • Consistent global state : causal dependencies are captured • Use virtual clocks to reason about the : ming rela : onships between events on diﬀerent nodes Space - Time diagrams A graphic representa : on of a distributed execu : on time p 1 p 2 p 3 p 1 p 2 p 3 H and impose a partial order → Cuts A cut C is a subset of the global history of H The fron : er of C is the set of events p 1 p 2 p 3 e c 1 1 , e c 2 2 , . . . e c n n Consistent cuts and consistent global states • A cut is consistent if • A consistent global state is one corresponding to a consistent cut ∀ e i , e j : e j ∈ C ∧ e i → e j ⇒ e i ∈ C What sees Not a consistent global state : the cut contains the event corresponding to the receipt of the last message by but not the corresponding send event p 1 p 2 p 3 p 3 p 0 Global Consistent States • Can we use Lamport Clocks as part of a mechanism to get globally consistent states ? • Develop a simple global snapshot protocol • Reﬁne protocol as we relax assump : ons • Record : 1 . processor states 2 . channel states • Assump : ons : 1 . FIFO channels 2 . Each : mestamped with Global Snapshot m T ( send ( m ) ) Snapshot I i . selects ii . sends “take a snapshot at ” to all processes iii . when clock of reads then records its local state sends an empty message along its outgoing channels starts recording messages received on each of incoming channels stops recording a channel when it receives first message with timestamp greater than or equal to p 0 t ss p 0 t ss t ss t ss p i σ i p Snapshot II processor selects sends “take a snapshot at ” to all processes ; it waits for all of them to reply and then sets its logical clock to when clock of reads then records its local state sends an empty message along its outgoing channels starts recording messages received on each incoming channel stops recording a channel when receives ﬁrst message with timestamp greater than or equal to Ω p 0 σ i p 0 Ω Ω Ω Ω p i p i Relaxing synchrony Process does nothing for the protocol during this time ! p i take a snapshot at Ω empty message : T S ( m ) ≥ Ω monitors channels records local state σ i sends empty message : T S ( m ) ≥ Ω Snapshot III processor sends itself “take a snapshot “ when receives “take a snapshot” for the ﬁrst time from : records its local state sends “take a snapshot” along its outgoing channels sets channel from to empty starts recording messages received over each of its other incoming channels when receives “take a snapshot” beyond the ﬁrst time from : stops recording channel from when has received “take a snapshot” on all channels , it sends collected state to and stops . p 0 p i p j σ i p k p i p i p j p k p 0 Same problem , diﬀerent approach • Monitor process does not query explicitly • Instead , it passively collects informa : on and uses it to build an observa : on . ( reactive architectures , Harel and Pnueli [ 1985 ] ) An observa : on is an ordering of events of the distributed computa : on based on the order in which the receiver is no : ﬁed of the events . Update rules p i p i e i m e i Message is timestamped with m T S ( m ) = V C ( send ( m ) ) V C ( e i ) [ i ] : = V C [ i ] + 1 V C ( e i ) : = max ( V C , T S ( m ) ) V C ( e i ) [ i ] : = V C [ i ] + 1 Example [ 1 , 0 , 0 ] [ 0 , 1 , 0 ] [ 2 , 1 , 0 ] [ 1 , 0 , 1 ] [ 1 , 0 , 2 ] [ 1 , 0 , 3 ] [ 3 , 1 , 2 ] [ 1 , 2 , 3 ] [ 4 , 1 , 2 ] [ 5 , 1 , 2 ] [ 4 , 3 , 3 ] [ 5 , 1 , 4 ] p 1 p 2 p 3 Opera : onal interpreta : on = no . of events executed by up to and including = no . of events executed by that happen before of [ 1 , 0 , 0 ] [ 0 , 1 , 0 ] [ 2 , 1 , 0 ] [ 1 , 0 , 1 ] [ 1 , 0 , 2 ] [ 1 , 0 , 3 ] [ 3 , 1 , 2 ] [ 1 , 2 , 3 ] [ 4 , 1 , 2 ] [ 5 , 1 , 2 ] [ 4 , 3 , 3 ] [ 5 , 1 , 4 ] p 1 p 2 p 3 p i V C ( e i ) [ i ] V C ( e i ) [ j ] e i p j p i e i VC proper : es : event ordering Given two vectors and , less than is deﬁned as : Strong Clock Condition : Simple Strong Clock Condition : Given of and of , where Concurrency Given of and of , where V V ′ V < V ′ ≡ ( V ̸ = V ′ ) ∧ ( ∀ k : 1 ≤ k ≤ n : V [ k ] ≤ V ′ [ k ] ) e i → e j ≡ V C ( e i ) [ i ] ≤ V C ( e j ) [ i ] e i ∥ e j ≡ ( V C ( e i ) [ i ] > V C ( e j ) [ i ] ) ∧ ( V C ( e j ) [ j ] > V C ( e i ) [ j ] ) e i p i p j e j i ̸ = j e i p i p j e j i ̸ = j e → e ′ ≡ V C ( e ) < V C ( e ′ ) The protocol maintains an array of counters where is the last message delivered from Rule : Deliver from as soon as both of the following conditions are satisﬁed : p 0 D [ 1 , . . . , n ] D [ i ] = TS ( m i ) [ i ] m i p i D [ j ] = TS ( m ) [ j ] − 1 D [ k ] ≥ TS ( m ) [ k ] , ∀ k ̸ = j m p j Summary • Lamport clocks and vector clocks provide us with good tools to reason about : ming of events in a distributed system • Global snapshot algorithm provides us with an eﬃcient mechanism for obtaining consistent global states