Virtual Compass : Relative Positioning To Sense Mobile Social Interactions Nilanjan Banerjee + , Sharad Agarwal ∗ , Paramvir Bahl ∗ , Ranveer Chandra ∗ Alec Wolman ∗ , and Mark Corner + + + University of Arkansas Fayetteville , ∗ Microsoft Research Redmond , and + + University of Massachusetts Amherst . nilanb @ uark . edu , { sagarwal , bahl , ranveer , alecw } @ microsoft . com mcorner @ cs . umass . edu Abstract . There are endless possibilities for the next generation of mo - bile social applications that automatically determine your social context . A key element of such applications is ubiquitous and precise sensing of the people you interact with . Existing techniques that rely on deployed infrastructure to determine proximity are limited in availability and ac - curacy . Virtual Compass is a peer - based relative positioning system that relies solely on the hardware and operating system support available on commodity mobile handhelds . It uses multiple radios to detect nearby mobile devices and places them in a two - dimensional plane . It uses adap - tive scanning and out - of - band coordination to explore trade - oﬀs between energy consumption and the latency in detecting movement . We have im - plemented Virtual Compass on mobile phones and laptops , and we eval - uate it using a sample application that senses social interactions between Facebook friends . 1 Introduction Imagine a suite of social applications running on your mobile phone which senses your precise social context , predicts future context , and logs and recalls social interactions . The possibilities for such applications are myriad [ 1 ] , from alerting you about an impending contact with a business associate and reminding you of their personal details , to a game that utilizes the relative physical positioning of its players , or a service that tracks the frequency and tenor of interactions among colleagues and friends . These next generation applications will use continual sensing of social context at an extremely ﬁne granularity . Recent examples of mobile social applications include Loopt [ 2 ] which displays the location of a user’s friends and Dodgeball [ 3 ] which ﬁnds friends of friends within a 10 block radius . Unfortunately , these and other widely deployed technologies that implement localization on mobile handhelds are limited by accuracy , coverage and energy consumption . The most widely used localization technology in mobile handsets is GPS , but it rarely works indoors . Furthermore , its accuracy degrades in urban envi - ronments , and the energy consumed by GPS devices is a signiﬁcant deterrent . Cell - tower based localization [ 4 ] is widely available but can provide very poor accuracy without a ﬁngerprint proﬁle , or outside city centers . Wi - Fi localization , when available , provides reasonable accuracy in dense urban environments , but is also much less eﬀective in other areas [ 5 ] . People spend the majority of their time indoors . As a result , many of the most common opportunities for social interaction occur in indoor environments such as oﬃces , hotels , malls , restaurants , music and sports venues , and conferences . In these environments , to detect the interaction with , or even the opportunity to interact with someone requires relatively ﬁne - grained location accuracy . Even in environments where indoor Wi - Fi based localization schemes [ 6 ] could provide the needed coverage and accuracy , most of today’s environments do not have this infrastructure deployed and the barriers to deployment lead us to believe that this will be the case for some time to come . Techniques that rely on ultrasound or detecting the phase oﬀset of transmitted radio waves [ 7 ] are diﬃcult to implement using the hardware and APIs available on commodity mobile phones . We present the design and implementation of Virtual Compass , a peer - based localization system for mobile phones . Virtual Compass does not require any infrastructure support , but instead uses multiple , common radio technologies to create a neighbor graph : a ﬁne grained map of the relative spatial relationships between nearby peers . Virtual Compass allows nearby devices to communicate directly , and provides multi - hop relaying so that the neighbor graph can include others who are not within direct communication range . Virtual Compass leverages short - range radio technologies , such as Bluetooth and Wi - Fi , available in today’s mobile handhelds . These radios consume a signif - icant amount of energy during scanning , and we consider energy management as a fundamental design pillar . Hence , Virtual Compass includes three techniques to reduce energy consumption : 1 ) use of adaptive scanning triggered on topology changes to update the neighbor graph ; 2 ) selection of the appropriate radio based on its energy consumption characteristics ; and 3 ) using the wide - area wireless network when available with a cloud - based service to assist with coordination and notiﬁcation of potential changes to the neighbor graph . Mobile social applications are heavily driven by the relative positioning of people , and less by absolute location . Sensing the precise placement of individ - uals relative to one another yields the social context needed for many useful applications , and the quality of location information produced by Virtual Com - pass increases as the density of devices increases . We have implemented Virtual Compass on Windows based mobile phones and laptops . Through extensive experimentation we evaluate the latency , loca - tion accuracy , and energy consumption characteristics of Virtual Compass as a function of system scale . In a typical experiment we found the average error in spatial placement of nine nodes in a 100 m 2 area was 1 . 9 meters . We show signiﬁcant accuracy gains in simultaneously using multiple radios for distance estimation , and our algorithm for spatial placement . Additionally , we are able to locate a new device within 25 seconds of its arrival . Applying our energy conservation techniques yields four - fold to nine - fold improvements in battery lifetime over a naive scheme that does not use any energy management . We also present the design and evaluation of a sample application built on top of Virtual Compass . 2 Related Work As a key ingredient for sensing , localization has been the subject of extensive work , both core technologies , and systems that leverage and reason about loca - tion . A comprehensive review of localization research is in [ 8 ] . Here , we compare and contrast our work by broadly dividing the corpus of prior work into two categories : infrastructure - based and peer - based , and review the most relevant . Infrastructure - based localization techniques can be broadly classiﬁed by their core technology : GSM [ 9 , 10 , 5 ] , Wi - Fi [ 11 , 12 , 6 ] , GPS , ultrasound with RF [ 13 , 14 ] , Infrared [ 15 ] , RFID [ 16 ] , and UWB [ 17 ] . The most successful techniques have leveraged infrastructure that was put in place for other reasons ( GSM and Wi - Fi localization ) and it seems likely that peer - based localization will follow a similar trend relying on technologies such as Wi - Fi and Bluetooth . GPS is the only exception , but it is unique in that it only works outdoors . Several industrial startups [ 3 , 2 , 18 , 19 ] have cropped up which use localization to support social applications , relying on the infrastructure - based localization support in mobile phones which is typically Wi - Fi - , GSM - or GPS - based . However , such schemes are limited in coverage and accuracy , making it impossible to support the full range of social applications—especially in situations that require ﬁne - grained proximity information . For example , Wi - Fi localization requires a dense deployment of access points and accurate proﬁling ( not available in many indoor scenarios ) , and GSM localization can exhibit poor accuracy without a detailed proﬁle or away from dense urban areas . Peer - based localization techniques attempt to either infer the proximity of a pair of devices , or infer the actual distances between multiple devices and place them in a virtual map . Proximity - based placement schemes such as Humming - bird [ 20 ] and NearMe [ 21 ] detect if two devices are within 30 to 100 meters of each other . Beep Beep [ 22 ] achieves high accuracy using sound , but does not spa - tially place more than two nodes , nor nodes that are out of earshot . BlueHoo [ 23 ] uses Bluetooth discovery to detect friends within Bluetooth range and People - Tones [ 24 ] uses GSM - based relative positioning . Virtual Compass measures the distances between multiple nearby nodes , uses multi - hop communication to ex - pand coverage , and spatially places them relative to each other on a 2D plane . Moreover , our system uses algorithms which balance energy consumption with low - latency and accurate localization . Relate [ 25 ] and DOLPHIN [ 26 ] rely on cus - tom ultrasound hardware which is typically unavailable in commodity devices . RIPS [ 7 ] requires signal processing of received radio waves , which is possible on custom hardware such as MICA2 motes but hard to do with oﬀ the shelf mobile phones and standard SDKs . MSP [ 27 ] uses sensor event distribution to locate nodes in a static sensor network . Bulusu [ 28 ] , Sextant [ 29 ] and Calibree [ 30 ] use the location of a subset of nodes ( e . g . equipped with GPS units ) to derive the locations of a larger set of nodes . LOCALE [ 31 ] also uses GPS equipped nodes to locate other nodes using dead reckoning . Our goal is to design a peer - based localization system that works in the absence of ﬁxed infrastructure or reference points , which can be hard to obtain using GPS in indoor settings . Moore et al . [ 32 ] , Spotlight [ 33 ] , and Vivaldi [ 34 ] address the problem of plac - ing nodes relative to each other in a multi - dimensional plane . Moore et al . [ 32 ] and Spotlight [ 33 ] use custom sensors for relative localization while Virtual Com - pass focuses on commodity cellular phones . While their algorithms can be used in Virtual Compass , we use a simpler Vivaldi [ 34 ] variant in our implementation . 8 meters 3 m e t e r s 4 m e t e r s 12 meters radio link 1 2 m e t e r s A 9 m e t e r s 1 meter D B C E Fig . 1 : Each line represents a mobile node’s abil - ity to directly communicate between the two end - points using a radio such as Bluetooth or Wi - Fi . A , B , C and D are in communication range of each other , while E is only in range of C . Wi - Fi error Bluetooth error force inversely proportional to error receiver displacement estimated sender position mid - point of distance estimates Fig . 2 : An example of using RSSI measurements from multiple radios ( Bluetooth and Wi - Fi ) to re - duce the error in computing distance . 3 Peer Localization The goal of Virtual Compass is to generate a two - dimensional layout of nearby mobile devices . It uses radios that allow peer - to - peer communication , such as Wi - Fi and Bluetooth , to exchange messages directly between devices . This exchange serves two purposes . Each pair of devices that are in communication range uses the received signal strength of these messages to estimate the distance between them . The message itself contains the list of neighbors and their distances , which allows nodes that are further away to map devices that are not in their immediate communication range . Virtual Compass leverages the collective knowledge of distances between peers learned in this way to calculate the 2D layout . Figure 1 shows an example . Mobile node A periodically sends messages to its neighbors B , C , and D . Each of these nodes uses the received signal strength indication ( RSSI ) of these messages to calculate its distance to A , as described in § 3 . 1 . The nodes exchange these messages on multiple radios to reduce the inherent error of distance estimation via RSSI , as described in § 3 . 2 . They embed these distances in the messages that are exchanged between neighbors so that each node discovers the distances between other nodes . So in this way , C learns of the distance between A and D . Furthermore , nodes such as E that are far away can learn where A , B and D are . Virtual Compass solves the constraints imposed by these distances to create a relative map using the technique in § 3 . 3 . Note that the underlying RSSI - based mechanism detects distance but not direction . 3 . 1 Estimating Distance In Virtual Compass , nodes periodically exchange messages on radios with omni - directional antennas . § 5 describes these messages in detail . We use the RSSI of these messages to estimate the distance between sender and receiver . Even though we rely on RSSI , if techniques such as propagation time become feasible , Virtual Compass can easily use them instead . While translating RSSI to distance has been studied in prior work [ 35 , 36 ] , Virtual Compass enhances that work by incorporating the uncertainty in distance measurements to provide two beneﬁts . First , as Virtual Compass is meant to be used in a broad range of unknown environments , modeling the uncertainty reduces the dependence on the environ - ment in which the measurements were taken . Secondly , and more importantly , the error model provides a basis for composing information from diﬀerent radios . To translate each RSSI reading to a distance estimate with an error bound , we use empirical models that we built by running several propagation experiments in two indoor oﬃce environments at Microsoft Research Redmond , and Univer - sity of Massachusetts Amherst ( details of the experiments can be found in our technical report [ 37 ] ) . We have evaluated our distance estimation scheme in § 6 . 3 . 2 Using Multiple Radios To reduce the error in estimating distance from RSSI , Virtual Compass uses multiple peer - to - peer radios simultaneously . For ease of exposition , we describe how our scheme works for two radios , Wi - Fi and Bluetooth . This approach works for any radio with an RSSI to distance conversion , or when using more than two radios . Consider Figure 2 where a node receives a message from the sender over Bluetooth and one over Wi - Fi and attempts to calculate the distance between the two nodes . Let RSSI 1 be the RSSI of the message received over Bluetooth , and RSSI 2 be the RSSI of the message received over Wi - Fi . We obtain a distance estimate for each , x 1 and x 2 ( see [ 37 ] for details ) . We also obtain the uncertainties ( error ) , u 1 and u 2 , each of which is the distance between the 10 th and 90 th percentiles for the measured model . The goal of the composition is to combine the two sources of information in order to reduce uncertainty in measurement . The mid - point of the two RSSI distance estimates is P = ( x 1 + x 2 ) / 2 . We apply a displacement from P for each measurement , which are F 1 = ( P − x 1 ) ∗ u 1 / 2 and F 2 = ( P − x 2 ) ∗ u 2 / 2 . Intuitively , the sum of the forces should push the node in the direction of a source which has a smaller uncertainty in measurement . The ﬁnal estimate of the distance is given by the midpoint displaced by a normalized sum of displacements D = P + 2 ( F 1 + F 2 ) / ( u 1 + u 2 ) . The normalization ensures that the estimate of distance always falls within the range of estimates given by the two RSSI readings . In the rare case where the uncertainties from the two readings do not intersect , we simply use P as the ﬁnal distance . We have evaluated our multi - radio composition scheme in § 6 . In this way , each pair of nodes that can directly communicate with each other estimate the distances between them , while reducing error . These distances are embedded in the messages that are exchanged between them so that ultimately , each node knows the distances between any two nodes that can communicate in the vicinity . The next step in Virtual Compass is to calculate a 2D spatial placement of these nodes that satisﬁes these distance constraints . 3 . 3 Spatial Placement Consider a 2D Euclidean space where each node’s position is determined by its ( x , y ) coordinates . Each distance estimate r ij between nodes i and j forms a con - straint : ( x i − x j ) 2 + ( y i − y j ) 2 = r 2 ij . An optimal algorithm would simultaneously solve this set of non - linear ( quadratic ) constraints to calculate coordinates for peer nodes . However , this is known to be NP - Hard [ 38 ] . Furthermore , since the distances between nodes are measured independently and are subject to error , it is possible in some cases that there is no solution that satisﬁes all the distance constraints . We instead use the Vivaldi [ 34 ] method to calculate node positions . Vivaldi uses estimates of distances between nodes to calculate a force vector , and then Algorithm 1 Spatial placement for calculating rough 2D coordinates during Phase 1 for a node Input : Set of constraints C = { C 1 , . . . , C n } , C i = ( x − x i ) 2 + ( y − y i ) 2 = r 2 i loop For every pair of constraints ( C i , C j ) , ﬁnd intersection points ( x 1 , y 1 ) and ( x 2 , y 2 ) end loop P = { { ( x 11 , y 11 ) , ( x 12 , y 12 ) } , . . . , { ( x k 1 , y k 1 ) , ( x k 2 , y k 2 ) } } ( set of intersection coordinates ) . Initialize solution set S = { ( x 11 , y 11 ) } loop For each element E = { ( x j 1 , y j 1 ) , ( x j 2 , y j 2 ) } ∈ P S = S ∪ argmin { (cid:88) ( xj , yj ) ∈ S (cid:112) ( x j 1 − x j ) 2 + ( y j 1 − y j ) 2 , (cid:88) ( xj , yj ) ∈ S (cid:112) ( x j 2 − x j ) 2 + ( y j 2 − y j ) 2 } end loop return Node coordinate : ( ( 1 / | S | ) · (cid:80) xi ∈ S x i , ( 1 / | S | ) · (cid:80) yi ∈ S y i ) iteratively improves each node’s coordinates by moving it along the resulting force . Vivaldi has been shown to produce good results with little computation overhead . However , the choice of starting all nodes at the origin can sometimes lead to local minima or a large number of iterations to converge . Hence , to pro - duce a relative map of all nodes , we ﬁrst calculate a very approximate but quick placement in phase 1 , and then feed that to a simple Vivaldi implementation in phase 2 for iterative reﬁnement . Phase 1 calculates an approximate set of coordinates that will help Vivaldi converge faster and to more accurate results in phase 2 . Consider the example where node A is calculating a placement for itself with respect to 2 other nodes B and C and begins by placing itself at the origin . It ﬁnds the peer , B , that is the smallest distance ( r 1 ) away , and places it at ( 0 , r 1 ) . Next , we choose node C that is constrained by both A and B . The algorithm Virtual Compass uses to place C is deﬁned in Algorithm 1 . We run this algorithm multiple times with diﬀerent constraint orderings and we use an average of the coordinates from each iteration as the starting placement for phase 2 . Experimentally , we determined that 10 iterations produces a suﬃciently accurate initial placement with little impact on run time . While we could have used other algorithms , the goal of this phase is to produce a starting point for Vivaldi that is more reasonable than the origin for all nodes . Phase 2 uses the coordinates from phase 1 as the starting placement and uses a simple implementation of Vivaldi [ 34 ] to iteratively reﬁne the coordinates to reduce the error between the placement and the measured pairwise distances . In each iteration , Vivaldi calculates forces that are applied between nodes – each force represents the diﬀerence between the measured distance between a pair of nodes and their distance in the virtual coordinate space . The resulting force on each node then determines the direction and amount of movement for the node in the virtual coordinate space . This process is repeated in each iteration . We have experimentally determined that 100 iterations produces accurate results with extremely marginal beneﬁt from additional iterations . In § 6 , we present the latency overhead of this computation , and it is dwarfed by the network communication time . As an example , consider node A at ( x 1 , y 1 ) with a neighbor B whose coordi - nates are ( x 2 , y 2 ) . The measured distance between them is r 12 . The magnitude of the force F between them as applied on A is r 12 − (cid:112) ( x 1 − x 2 ) 2 + ( y 1 − y 2 ) 2 Radio Power ( mW ) Lifetime ( hours ) GSM ( idle ) 24 . 4 203 . 0 Bluetooth ( idle ) 45 . 5 109 . 8 Bluetooth ( scanning ) 507 . 6 9 . 8 Wi - Fi ( idle ) 849 . 9 5 . 9 Wi - Fi ( scanning ) 1305 . 4 3 . 8 GPS ( idle ) 859 . 9 5 . 8 GPRS ( transfers ) 1031 . 2 4 . 8 HSDPA ( transfers ) 1099 . 6 4 . 5 Table 1 : Energy consumption of radios on fully - charged HTC Touch Cruise phones . and its direction is given by the unit vector ( ( x 1 − x 2 ) , ( y 1 − y 2 ) ) . There may be other forces applied on A ( due to measured distances to other neighbors ) , and we calculate the resulting single force [ 34 ] . The coordinates for A are then changed in this iteration to ( x 1 + F x ∗ t , y 1 + F y ∗ t ) , where F x and F y are the components of F in the x and y direction and t is a constant . For Virtual Com - pass we experimented with diﬀerent values of t and found t = 0 . 1 works best in our environment . Applying a force at each node that is proportional to the error minimizes the mean - square error and converges to a set of coordinates which satisfy the distance constraints ( see [ 34 ] for proof ) . 4 Energy - Eﬃcient Peer Localization As with any system targeted at mobile devices , energy consumption is a critical concern . If the lifetime of the device is severely impacted , users will eschew appli - cations that rely on our system . Virtual Compass depends on frequent commu - nication between peers to provide timely updates to changes in the social graph . As has been observed in prior work [ 39 ] , communication consumes a signiﬁcant portion of a mobile phone’s energy budget . To place our work in a common frame of reference , we include Table 1 which shows the energy consumption of our implementation platform . With no communication , a typical phone will last for 203 hours on a single battery charge . However , if it continuously scans for other peer devices , the battery is completely exhausted within 10 hours when using Bluetooth , and under 4 hours using Wi - Fi . To mitigate this , Virtual Compass must balance the energy devoted to sensing and maintaining the social graph against the accuracy of the system . Scans that are too frequent will drain energy , and scans that are too infrequent will increase the latency for peer localization – device arrival or departure will go undetected until the next scan interval . Virtual Compass uses three techniques to reduce the number of scans without signiﬁcantly degrading localization accuracy . 4 . 1 Adaptive Bluetooth Scanning We observe that repeated scans are unnecessary in a static environment , such as when there are no other devices around , or when none are moving . Virtual Compass uses this observation to adapt the scan interval . Every device keeps track of changes in its neighbor graph and accordingly adjusts its scan interval – aggressively scanning the environment when the neighbor graph changes , and increasing the scan interval otherwise . To track the change in its neighbor graph , a device calculates the number of one hop , N 1 ( 2 paths in Figure 3 ) , and two hop paths , N 2 ( 1 path in Figure 3 ) , that have changed between successive scans . time T 1 time T 2 A B C D A B D Fig . 3 : An example illustrating the calculation of the change metric for adapting the Bluetooth scan interval . In this example , the change metric be - tween T 1 and T 2 is 1 . 9 , which is high enough to trigger a reduction in the scan interval . 0 1 2 3 4 020406080100120 0 10 20 30 nu m b e r o f p ee r s s c a n i n t e r v a l ( s e c o nd s ) time ( minutes ) scan interval Fig . 4 : This graph shows the Bluetooth scan in - terval for a device over time . After 10 minutes , we introduced a second peer device , and at 12 minutes a third peer device . At 18 minutes we removed one device , and then a second one at 20 minutes . We compute a change metric as p ∗ N 1 + ( 1 − p ) ∗ N 2 , where p is a constant . When this metric is less than a threshold x , we increase the inter - scan interval by 10 seconds . If the metric is above a threshold y , we halve the scan interval . We do not scan more frequently than once every 10 seconds and we do not allow the scan interval to increase beyond 10 minutes . We use values of 0 . 9 , 1 and 1 for p , x and y respectively . While these values are arbitrary and could be tied to an application , they work well in our experiments . The results of a simple experiment showing the behavior of this technique are shown in Figure 4 . The scan interval additively increases until new devices are introduced or removed in the neighbor graph , at which point the scan interval is halved . This method can be easily extended to other metrics . For instance , an application may care about sensing small changes in the distance between peers or may want to weight diﬀerent peers based on their signiﬁcance in the social network . Between two successive scans , which can be as long as 10 minutes , we leave the Bluetooth radio on since the idle energy consumption of Bluetooth is small ( see Table 1 ) . Moreover , with the Bluetooth radio on , it can respond to its peer’s scans and the corresponding neighborhood graph is always complete . In contrast , the idle power consumption for Wi - Fi is comparable to scanning . Therefore , the radio needs to be turned oﬀ between scans . However , this implies that adaptive scanning for Wi - Fi is infeasible—if diﬀerent peers wake up at diﬀerent times , their scans will result in incomplete neighbor graphs . Therefore , for Wi - Fi we periodically ( every 1 minute at wall clock time ) turn on the radio and put it in scan mode . Mobile phones synchronize their wall clock time with the cellular infrastructure . Even if disconnected from the cellular network , clock drift in the order of one or two seconds is not a signiﬁcant issue since Wi - Fi scanning takes several seconds ( see § 6 ) . 4 . 2 Cloud Coordination There are signiﬁcant periods of time when a device is completely alone . Figure 5 shows how often Bluetooth scans by 150 participants [ 40 ] found other devices . On average , each mobile phone found no other Bluetooth devices 41 % of the time . While it is possible that other devices were present but did not have Bluetooth discovery enabled , or were discoverable over the longer range of Wi - Fi , this ﬁnding fuels our belief that there are periods of time when a device is completely alone . Hence we can save energy on devices during these periods by keeping Wi - Fi oﬀ and not initiating Bluetooth scans until a new device arrives . However , 0 0 . 2 0 . 4 0 . 6 0 . 8 1 0 10 20 30 p r o b a b ili t y # of Bluetooth devices seen per inquiry scan Fig . 5 : CDF of the number of Bluetooth devices seen in periodic scans from 150 Nokia N95s [ 40 ] . Peer localization service ( RSSI based distance estimation , spatial placement , infrastructure composition , energy management ) native radio modules applications SQL data services mobile device cloud services GPS Bluetooth Wi - Fi GSM FriendMeter notification service Fig . 6 : Architecture of Virtual Compass the primary challenge is to detect device arrival without using Bluetooth and Wi - Fi . We observe that many mobile devices are almost always connected to the Internet via a cellular data connection such as 3G . Hence , a simple service running on the Internet can inform the device when there are other devices in the vicinity . In Virtual Compass , each mobile device uploads its approximate geographic location to this service . This location is calculated using low - energy , coarse grained GSM localization . The list of GSM cellular towers that are in the vicinity and the RSSI values are used to compute a rough geographic location . Each time its location changes , the device updates the service . When the device believes it is alone ( no neighbors in Bluetooth and Wi - Fi scans ) , it will periodically ask this Web service whether there are any other devices in the vicinity running Virtual Compass . If there are no peers around it , the device will keep its Wi - Fi radio oﬀ and not scan on Bluetooth . Otherwise , it adjusts its scan interval and Wi - Fi wakeup interval as described previously . Since periodic polling on a radio such as 3G consumes a considerable amount of energy , Virtual Compass uses a push - based technique to notify the device when other nodes are around . Inspired by Cell2Notify [ 41 ] , a Virtual Compass device uploads a Request - for - Notiﬁcation ( RFN ) bit to the Web service when it thinks it is alone . For each device with the RFN bit set , the Web service keeps track of other device arrivals in the vicinity of the sleeping device and will notify it , which then resumes Wi - Fi and Bluetooth scanning . We describe our implementation of this notiﬁcation in the next section . 4 . 3 Leveraging Application Behavior In addition to exploiting user mobility to reduce energy consumption , a cloud service allows us to also exploit application behavior . Some applications that use peer localization may not need the neighbor graph maintained all the time , even though the applications are still running . For example , an application that shows the user a map of nearby friends and how to get to them does not need the neighbor graph if the user is not interacting with the phone . Scanning in this scenario wastes energy . However , not scanning , and hence not participating in multi - hop discovery , could degrade localization accuracy for other devices where their users are actively interacting with the phone . We suspect that there are signiﬁcant periods of time when every phone in the vicinity is simultaneously not in use . To detect this scenario , Virtual Compass detects when the back - light 2048 bytes 32 bytes device id neighbor id distance device id ………… . . …… . . neighbor id distance Bluetooth device name Wi - Fi SSID 6 bytes 6 bytes 6 bytes 4 bytes 4 bytes 6 bytes Fig . 7 : Packet format for beacons in Virtual Com - pass Fig . 8 : Screen shots of the simple UI in Friend - Meter . for the screen on a mobile device turns oﬀ . We then assume that the user is not using the application and upload this bit of information to the Web service along with the device’s rough geographic location . When Virtual Compass polls the Web service to ﬁnd out how many devices are in the vicinity or uses the notiﬁcation service , it also learns how many of them have the back - light on . If no devices are actively being used , then it keeps the Wi - Fi radio oﬀ and does not scan on Bluetooth . If any one device in the vicinity has the back - light on , then it resumes normal discovery behavior . Unfortunately , if an application uses peer localization to log social interaction in the background , instead of displaying an interactive map , then this technique cannot be used . 5 Implementation We have implemented Virtual Compass on the Windows Mobile 6 . 0 operating system that runs on a variety of mobile phones . While we have also ported Virtual Compass to the Windows Vista operating system , we focus on the mobile phone version in this section . Virtual Compass runs entirely at the application layer , and does not require modiﬁcations to the Bluetooth and Wi - Fi drivers , nor to the network stack . Our software architecture , depicted in Figure 6 , consists of four main components : native radio modules , cloud services , peer localization service and applications . Native radio modules : Virtual Compass interacts with many radios ( GPS , Bluetooth , Wi - Fi , and GSM ) using native APIs exposed by the Windows Mobile OS . To access the Wi - Fi radio when the device is in suspension state S3 , we use a PPN UNATTENDED state . This consumes slightly more energy than S3 , but allows us to access the Wi - Fi radio . For device discovery and propagating the neighbor graph , as described in § 3 , Virtual Compass requires every device to periodically broadcast its ID and the IDs of and distance to each of its peers . The application layer provides the ID to be used in Virtual Compass . To broadcast this information without the additional latency of explicitly forming a network , we use the Beacon - Stuﬃng approach [ 42 ] for Wi - Fi , and a similar technique for Bluetooth . Our beacon for - mats for Bluetooth and Wi - Fi are in Figure 7 . For Bluetooth beacons we modify the 2048 bytes available for the device name , while for Wi - Fi beacons we embed this information in the 32 byte SSID . The small size of the Wi - Fi SSID limits the size of the neighbor graph that can be encoded in the beacon . To solve this problem , we could use two techniques proposed by Beacon - Stuﬃng [ 42 ] : use 256 byte IE blobs , or fragment large strings across beacons that are then reassem - bled at the receiver . We have not implemented either solution , and in our current implementation , we limit the neighbor graph embedded in beacons to immedi - ate one - hop peers , thus eﬀectively limiting peer localization to a maximum of two - hops . One problem with using the Bluetooth radio for peer localization is that it may interfere with Bluetooth headset usage during phone conversations . A scan in the middle of a conversation will disrupt the phone call . To avoid this problem , we trap the incoming phone call and phone call talking events from the Windows Mobile OS and stop Bluetooth scanning if either event is active . We resume scanning once these events have ended . Cloud services : Virtual Compass uses the SQL Server Database Service ( SSDS ) [ 43 ] over the Internet for coordinating Wi - Fi radio wake - ups and Blue - tooth scans , as described in § 4 . 2 . SSDS has the following components : ( a ) Au - thority : this is the top - most level of containment hierarchy under which all the data for a particular SSDS login is stored . ( b ) Container : an authority is a collec - tion of containers . ( c ) Entities : each entity inside a container stores any number of user - deﬁned properties and values . Virtual Compass uses a single author - ity , under which there is a separate container for each geographic region , under which there is a separate entity for each device . The peer localization service moves the device’s entity to the appropriate container based on cellular tower IDs and RSSIs from the GSM radio and updates a bit indicating whether the screen back - light is on . Virtual Compass can use a push ( notiﬁcation - based ) and polling scheme to download information on neighbor positions . For polling it periodically downloads the contents of the containers to determine if it is alone . When using the notiﬁcation scheme , each Virtual Compass device uploads its current position based on cell tower IDs and RSSIs . When a device does not ﬁnd any neighbors on a Bluetooth and Wi - Fi scan it uploads a RFN ( Request for Notiﬁcation ) bit and the device’s phone number to the cloud and stops scanning on Bluetooth and switches oﬀ Wi - Fi . A notiﬁcation service runs on an Internet server which constantly downloads the location of all Virtual Compass devices using SSDS . It calculates whether any Virtual Compass device is near a node with its RFN bit set . If so , it uses a Skype client on the server to make a phone call to the device using a special caller ID number . The device traps the incoming phone call event , and if it recognizes the special caller ID number , it ends the call and resumes scanning on Bluetooth and Wi - Fi . Peer localization service : The location service runs the distance estimation and spatial placement algorithms from § 3 to produce a 2D map of where peer devices are . The distance estimation model that we use to convert a RSSI mea - surement to distance and uncertainty is described in our technical report [ 37 ] . We used extensive measurements in two oﬃce environments at Microsoft Research Redmond , and University of Massachusetts Amherst to derive these models . The service also manages the Wi - Fi radio sleep and scan schedule , Bluetooth scan - ning interval and interfaces with the cloud services to reduce energy consumption as described in § 4 . It feeds the entire map to the application layer . Applications : We have implemented the FriendMeter application using Vir - tual Compass . FriendMeter uses Virtual Compass to sense the distances between the user and her friends who are in the vicinity . Several applications such as gam - ing and ﬁle transfer amongst friends can be considered as instances of Friend - Meter . FriendMeter is designed with two purposes in mind – a short - term use and a long - term use for the sensed information . In the short - term , the results from Virtual Compass are used to show the user a map that can be used to ﬁnd and meet her friends . In the long - term , the time - varying distances measured be - tween the user and her friends can be used to infer social interactions . These inferences can be used to cluster friends in social applications , such as Facebook , based on proximity . Each friend can be metered by the amount of physical social interaction . Our implementation shows the user a map and records a history of the map , but currently does not alter their friends list . FriendMeter uses the Facebook API to connect to Facebook , authenticate the user and get her list of friends . It uses a unique numerical Facebook login id—provided by Facebook as the mobile device’s ID . This facilitates identifying the user on each peer device , but as we note in § 7 , there are some privacy im - plications . FriendMeter displays a map of all the user’s friends in the vicinity . It also displays the photographs of the nearby users and their interests , hob - bies , and other information . Screen shots from the application are in Figure 8 . Even though the underlying peer localization service provides a map with many devices , FriendMeter ﬁlters out those that are not in the user’s friend list . 6 System Evaluation We evaluate the performance of Virtual Compass by focusing on the following three key questions : ( 1 ) How accurate are Virtual Compass’s distance estimates and spatial placement ? ( 2 ) How much energy does Virtual Compass consume ? ( 3 ) How quickly does Virtual Compass adapt to changes ( e . g . , when a new device arrives , or one departs ) ? In answering these questions , we also examine the impact of scale : how does the number of devices aﬀect Virtual Compass ? Experimental Setup : We evaluate Virtual Compass on the Windows Mobile and Windows Vista operating systems . Our testbed consists of ten devices – an HTC TyTNII mobile phone , an HTC Touch Cruise mobile phone , four laptops , and four desktops . All ten devices have IEEE 802 . 11b and Bluetooth interfaces , and are connected to the Internet via 3G cellular on the phones or Ethernet on the laptops and desktops . In most experiments , we deploy the devices in a 100 m 2 indoor oﬃce area , but we also evaluate larger areas of 900 m 2 and 2500 m 2 where indicated . Many experiments involve statically - placed nodes , but in those evaluating latency , we move a device into or out of the deployment area . When evaluating energy consumption , we measure the lifetime of the fully charged mobile phones while running Virtual Compass and leaving the GSM radio on . Accuracy of Localization : The primary goal of Virtual Compass is to accu - rately localize nearby peers . We evaluate this accuracy in two ways – ( 1 ) error in pairwise distance between nodes – what is the diﬀerence between the physical distance and the distance that Virtual Compass predicts ? ( 2 ) spatial placement : for a number of nodes , how diﬀerent is the 2D placement that Virtual Com - pass presents from their actual placement ? Pairwise distance accuracy : Figure 9 shows how well Virtual Compass esti - mates the distance between two nodes as their physical distance is varied . Virtual 0 5 10 15 0 2 4 6 8 10 12 14 p r e d i c t e d d i s t a n c e ( m e t e r s ) actual distance ( meters ) virtual compass perfect distance Fig . 9 : Distance and deviation predicted by Vir - tual Compass . 00 . 10 . 20 . 30 . 40 . 50 . 60 . 70 . 80 . 91 0 2 4 6 p r o b a b ilii t y error ( meters ) median error = 0 . 86 meters 90 th percentile error = 3 . 19 meters Fig . 10 : CDF of the error in distance . System Average Error ( meters ) Bluetooth 3 . 40 Wi - Fi 3 . 91 Virtual Compass 1 . 41 Table 2 : Average error for nine devices in a 100 m 2 indoor area reported by the diﬀerent systems . Compass comes very close to perfectly estimating distance . When Virtual Com - pass does deviate from the actual distance , it does so by a small amount as the error bars indicate . Figure 10 shows the CDF of this error over a large number of placements . The median error is only 0 . 9 meters , and over 90 % of the time , the error is under 2 . 7 meters . To examine why Virtual Compass is so accurate in pairwise distance estimation , we present Table 2 , which shows the advantage of our multi - radio approach . If Virtual Compass were to use only Bluetooth radios , the average error would be quite high at 3 . 40 meters , or 3 . 91 with just Wi - Fi radios . However , by simultaneously using both Bluetooth and Wi - Fi , Virtual Compass reduces the average error to 1 . 41 meters . 6 m e t e r s 12 meters Fig . 11 : This ﬁgure shows a map of 9 devices us - ing light dots . We overlay the spatial placement map from Virtual Compass on this ﬁgure using dark dots . The spatial placement was generated at the node on the desk between “3” and “4” . 0 1 2 3 4 2 3 5 7 9 a v e r a g e e rr o r ( m e t e r s ) number of devices Fig . 12 : Using multiple experiments similar to Figure 11 , we calculate the average error in 2D placement as we vary the number of devices . Spatial placement accuracy : We evaluate spatial placement in Figure 11 . Virtual Compass’s 2D spatial placement ( dark dots ) almost exactly matches the actual placement ( light dots ) – the average distance between a light dot and the corresponding dark dot is 1 . 9 meters . Our accuracy is dependent on two factors : our multi - radio RSSI - based distance estimation , and our 2D spatial placement algorithm . To tease apart these two factors , we applied our 2D spatial placement to the actual pairwise distances between these nodes ( as opposed to the RSSI - based estimates ) and the average error is 0 . 6 meters . 0 5 10 15 20 0 1 3 7 9 s y s t e m li f e ti m e ( hou r s ) number of peers adaptive scan + cloud no energy mgmnt adaptive scan Fig . 13 : This graph shows the lifetime of Vir - tual Compass on a fully - charged stationary mobile phone , with diﬀerent energy conservation tech - niques and diﬀerent numbers of nearby peer de - vices in a 100 m 2 area . In this experiment , the de - vices did not move . 05101520253035 0 1 3 7 9 s y s t e m li f e ti m e ( hou r s ) number of peers polling notification Fig . 14 : The lifetime of Virtual Compass on a fully - charged mobile phone for the same setup as Figure 13 . In the “polling” bars , Virtual Com - pass periodically queries the cloud service for node arrivals and in the “notiﬁcation” bars , Virtual Compass uses the push - based technique . The accuracy of our 2D placement algorithm also depends on the density of devices – the more devices we have , the more constraints we have that al - low the placement to converge faster . In Figure 12 , we repeat our placement experiments while varying the number of devices , and the placement of these devices . As the number of devices is lowered , the error increases because every node is constrained by fewer neighbors . With just 2 nodes ( with one placed at the origin ) , the average error is purely a reﬂection of the RSSI - based distance estimation error . Energy Consumption : While accuracy in localization is the primary goal of Virtual Compass , energy consumption is a critical concern for mobile devices . We now evaluate the beneﬁts of the energy saving techniques from § 4 . Figure 13 shows the lifetime as the number of nearby peers is varied . The “no energy mgmnt” bars , the lifetime of a mobile phone with Wi - Fi and Bluetooth always on and scanning every 1 minute and 10 seconds respectively is dismal , at 4 . 8 hours with no peers and 3 . 8 hours with 9 peers . The slight drop in lifetime with the number of peers is because Virtual Compass has to connect over Bluetooth to every peer to get the RSSI value ( this is a limitation of the Windows Mobile Bluetooth API ) . However , when we turn Wi - Fi on and oﬀ every 1 minute and adaptively change the Bluetooth scan interval , we see signiﬁcant energy savings in the “adaptive scan” bars , from 18 . 0 hours with no peers to 14 . 8 hours with 9 peers . Even though the devices do not move , there is a drop in lifetime with the number of peers because of the Bluetooth connect issue and because with more devices , variations in the environment can temporarily appear as slight neighbor graph changes . When we include the cloud coordination scheme in the “adaptive scan + cloud” bars , the lifetime actually reduces . Periodically polling the Web service when alone ( 0 peers ) is a signiﬁcant drain on the battery . Even when not alone , our devices keep uploading their location to the Web service because of variations in the RSSI from GSM cell towers and re - association with a diﬀerent GSM cell tower , despite the nodes being static in this experiment . GSM localization that is more robust to such variations should help . In Figure 14 , we show the advantage of using a notiﬁcation system instead of polling . When there are no other devices around , the savings are tremendous – lifetime increases from 15 . 7 hours to 35 hours . Since there are no devices around , the device keeps Wi - Fi oﬀ and does not scan over Bluetooth , and does not need to poll the service over 3G . back - light optimization lifetime ( hours ) oﬀ 12 . 07 on 15 . 42 Table 3 : This ﬁgure shows the lifetime of Virtual Compass on a fully - charged mobile phone , with the back - light optimization from § 4 . 3 turned oﬀ or on . We used a synthetic workload based on the Reality Mining data [ 44 ] to emulate phone usage . Density Lifetime 1 - hop 2 - hop 3 - hop ( meter 2 ) ( hours ) peers peers peers 100 11 . 19 9 0 0 900 11 . 92 5 4 0 2500 12 . 05 5 3 1 Table 4 : This Figure shows the lifetime of Virtual Compass on a fully - charged mobile phone , with 9 peers nearby , across diﬀerent sizes of regions . In each experiment , the devices did not move . We now evaluate the improvement oﬀered by the back - light optimization from § 4 . 3 . The previous experiments do not use this optimization because we lack accurate usage models of our application . Hence in Table 3 , we present an evaluation of this optimization based on emulation of the Reality Mining data [ 44 ] . The data covers a large number of users across many days and indicates when their phones are idle versus in use . We pick 10 users at random and focus on their behavior for a random day . For periods of time when all the devices are idle , we follow our technique from § 4 . 3 and keep Wi - Fi oﬀ and do not scan on Bluetooth . We repeat these emulations multiple times by picking 3 diﬀerent days at random , and 3 diﬀerent sets of 10 users , and present average numbers in Table 3 . While this emulation may not perfectly match real usage , these results show that this optimization has the potential to increase lifetime by 30 % . Finally , we present Table 4 where we evaluate the energy consumption of Virtual Compass as we vary the density of deployment . The lifetime does not signiﬁcantly vary with density . There is a slight increase in lifetime as density decreases , and this is because there are fewer peers that are directly reachable over Bluetooth , and hence fewer connections need to be setup to measure RSSI . Latency : Latency is another important metric – Virtual Compass should sense changes in the neighbor graph fast enough for applications that want to de - tect social interactions , and for those that provide maps in real - time to users . Figure 15 shows the overhead of diﬀerent components of Virtual Compass . Blue - tooth scanning is particularly slow , and we discuss this in more detail in § 7 . Bluetooth pairing is needed to work around a limitation of the Bluetooth in - terface in Windows Mobile . The Windows Vista Bluetooth stack does pass up RSSI values from a Bluetooth scan without having to pair and connect , and so we are conﬁdent that this problem is not inherent to Bluetooth . The time taken to detect the arrival of a new peer depends not only on the latency of Wi - Fi and Bluetooth scans , but also on how reliable scanning is . In Table 5 , we present the probability of ﬁnding a peer device with a Bluetooth scan , Wi - Fi scan and both . Bluetooth is particularly poor because when two adjacent devices are scanning ( and hence frequency - hopping ) simultaneously , the probability of both being on the same channel and hence discovering each other is very low . This problem is speciﬁc to Bluetooth , as the stability of Wi - Fi is much higher . Since Virtual Compass uses both radios , it can detect the presence of a peer device more reliably than either alone . We now evaluate how quickly Virtual Compass detects peer movement . In particular , we consider : ( 1 ) time elapsed between a peer entering the vicinity of a device and the peer showing up on the map , and ( 2 ) time elapsed between a peer leaving the vicinity and it disappearing from the map . We evaluate both 0 20 40 60 80 100 app initialization Bluetooth scan Bluetooth pair Wi - Fi scan spatial placement l a t e n c y ( s ec ond s ) Fig . 15 : This graph shows the latency of various tasks in Virtual Compass , along with error bars indicating variance across several runs . A total of 10 stationary devices were placed in a 100 m 2 area . “app initialization” is dominated by communica - tion with the Facebook Web site . System Neighbor graph stability Bluetooth 14 % Wi - Fi 90 % Virtual Compass 94 % Table 5 : This ﬁgure shows the stability of the neighbor graph when using just Bluetooth , just Wi - Fi , or both . We placed 2 devices 10m apart , and ran experiments for 2 hours . 0 20 40 60 80 100 120 2 3 5 9 l a t e n c y ( s ec ond s ) number of peers peer entering vicinity peer exiting vicinity Fig . 16 : This graph shows the latency of Virtual Compass detecting a peer moving into or mov - ing out of the vicinity , with diﬀerent numbers of nearby , stationary peer devices . 0 50 100 150 200 250 6 . 35 11 . 36 15 . 2 23 . 28 l a t e n c y ( s ec ond s ) system lifetime ( hours ) peer entering vicinity peer leaving vicinity Fig . 17 : This graph shows the trade - oﬀ between the latency of detecting a peer moving into or mov - ing out of the vicinity , against the lifetime of Vir - tual Compass . We varied the Wi - Fi scan interval between 30 seconds and 4 minutes . latencies in Figure 16 . The latency of detecting a new peer is dominated by the frequency of scanning – in steady state , Bluetooth scanning occurs once every 10 minutes , but Wi - Fi occurs every minute . Since the graph shows the average across many runs , the average latency for detecting a new peer is 30 seconds , because of Wi - Fi scanning . Peer departure can be a higher latency operation as the number of peers increases because all peers have to remove the exiting peer from their neighbor graph , else it will still appear in the map due to multi - hop discovery . Hence Bluetooth’s slower scan time dominates peer departure latency . Reducing the scan interval of Wi - Fi and Bluetooth can reduce latency , but it comes at the cost of energy . Figure 17 explores this trade - oﬀ . The second set of bars at 11 . 36 hours corresponds to the 5 peers bars from Figure 16 . We can double the lifetime to 23 . 28 hours at the cost of doubling latency . However , halving the lifetime to 6 . 35 hours does not signiﬁcantly reduce latency . Hence we believe that our choice of the Wi - Fi wake - up and scan interval of 1 minute and the Bluetooth limits of 10 seconds to 10 minutes oﬀer the best trade - oﬀ . 7 Discussion We now discuss performance optimizations for Virtual Compass . Improving accuracy : While Virtual Compass uses a single RSSI - distance pro - ﬁle , we could use diﬀerent proﬁles for diﬀerent environments , such as outdoors versus indoors . This would require a mobile device to determine if it is outdoors , and then apply the corresponding RSSI - distance proﬁle . We are exploring two ways to solve the problem of detecting that the user is outdoors . First , if a GPS signal is available , then we can assume the user is outdoors . Second , we can use user feedback . Reducing Latency : Virtual Compass’s latency in detecting node movement is signiﬁcantly impacted by Bluetooth scanning . Two devices that simultaneously scan over Bluetooth can miss each other because each may use a diﬀerent fre - quency hopping sequence such that the two devices never end up on the same channel at the same time . To alleviate this problem , we are investigating certain Bluetooth 1 . 2 chipsets that allows enhanced inquiry which is supposed to make discovery reliable and fast ( less than 5 seconds ) . Reducing energy consumption : Not all mobile devices have similar energy budgets . A laptop has a larger battery than a mobile phone . Furthermore , some environments may have desktops with wireless interfaces . We posit that it is ben - eﬁcial for mobile phones to oﬄoad the task of aggressively scanning for device movement to nomadic infrastructure that is energy rich . The nomadic infras - tructure can scan very frequently , and if it detects that a new device has come into range , or a device has moved or left , then it can signal other devices to scan and re - compute the neighbor graph . We are presently investigating schemes for eﬃciently oﬄoading computation to more powerful infrastructure . Privacy and security : There are privacy and security issues that we have not addressed in Virtual Compass . In our current implementation , a user’s numeric Facebook ID is her mobile device’s ID in peer localization . In our application , she only sees her Facebook friends . However , our underlying peer localization component has a complete map of all the devices in the vicinity . A wily user could potentially misuse this information . As a solution , we could use a periodically changing random number for the device ID . Each device would register this ID with an applet on Facebook . Any device that wants to discover the user identity will have to query the applet , which can verify if that user is a friend . 8 Conclusion Most of today’s mobile social applications use absolute location to locate nearby peers , which is often diﬃcult to obtain with reasonable accuracy in indoor envi - ronments . In this paper , we describe Virtual Compass , a peer - based localization system for mobile phones , which provides relative positioning by placing peers in a 2D plane without requiring any infrastructure support . Virtual Compass enables many emerging mobile applications that want the ability to sense social interactions : it provides the distance between diﬀerent people which can then be combined with external information about those people’s social relationships . A key area of future work is to use this information to build applications that automatically infer of social context of such interactions . Virtual Compass leverages the multiple radios available on today’s smart - phones to provide the accuracy needed for the above applications . It uses several energy management techniques that frugally use radios without compromising location accuracy . We have implemented Virtual Compass for Windows Mobile phones . We have implemented a simple application , FriendMeter , which uses Virtual Compass to sense the distances between a user and her Facebook friends who are in the vicinity . We evaluate Virtual Compass on a nine node testbed , and our results show that it places a device with an average distance error of only 1 . 9 meters . Virtual Compass’s energy management algorithms produce a battery lifetime that is four to nine times that of a device that does not use sophisticated energy management to provide peer localization . Acknowledgements : We would like to thank our shepherd , Alexander Var - shavsky , and the anonymous reviewers for their useful feedback . Part of this work was supported under awards NSF CNS - 0519881 , NSF CNS - 0447877 , and DARPA HR0011 - 09 - 1 - 0020 . References [ 1 ] Miluzzo , E . , Lane , N . D . , Fodor , K . , Peterson , R . A . , Lu , H . , Musolesi , M . , Eisen - man , S . B . , Zheng , X . , Campbell , A . T . : Sensing meets mobile social networks : The design , implementation and evaluation of the CenceMe application . In : SenSys . ( 2008 ) [ 2 ] : Loopt http : / / loopt . com . [ 3 ] : Dodgeball Social Networking http : / / dodgeball . com / . [ 4 ] Varshavsky , A . , de Lara , E . , Hightower , J . , LaMarca , A . , Otsason , V . : GSM indoor localization . In : Pervasive and Mobile Computing journal . ( December 2007 ) [ 5 ] LaMarca , A . , Chawathe , Y . , Consolvo , S . , Hightower , J . , Smith , I . , Scott , J . , Sohn , T . , Howard , J . , Hughes , J . , Potter , F . , Tabert , J . , Powledge , P . , Borriello , G . , Schilit , B . : Place Lab : Device Positioning using radio beacons in the Wild . In : Pervasive . ( 2005 ) [ 6 ] Haeberlen , A . , Flannery , E . , Ladd , A . , Rudys , A . , Wallach , D . , Kavraki , L . : Prac - tical robust localization over large - scale 802 . 11 wireless networks . In : MobiCom . ( 2004 ) [ 7 ] Maroti , M . , Kusy , B . , Balogh , G . , Volgyesi , P . , Nadas , A . , Molnar , K . , Dora , S . , Ledeczi , A . : Radio interferometric geolocation . In : SenSys . ( 2005 ) [ 8 ] LaMarca , A . , de Lara , E . : Location systems : An introduction to the technology behind location awareness . Synthesis Lectures on Mobile and Pervasive Computing ( 2008 ) [ 9 ] Laasonen , K . , Raento , M . , Toivonen , H . : Adaptive on - device Location Recogni - tion . In : Pervasive . ( 2004 ) [ 10 ] Laitinen , H . , Lahteenmaki , J . , Nordstrom , T . : Database Correlation method for GSM Location . In : VTC . ( 2001 ) [ 11 ] : Ekahau Wi - Fi - based Real - time Tracking and Site Survey Solutions http : / / ekahau . com . [ 12 ] Bahl , P . , Padmanabhan , V . N . : RADAR : An in - building RF - based User Location and Tracking System User Location and Tracking System . In : INFOCOM . ( 2000 ) [ 13 ] Borriello , G . , Liu , A . , Oﬀer , T . , Palistrant , C . , Sharp , R . : WALRUS : Wireless Acoustic Location with Room - Level Resolution Using Ultrasound . In : MobiSys . ( 2005 ) [ 14 ] Priyantha , N . B . , Chakraborty , A . , Balakrishnan , H . : The Cricket Location - Support System . In : MOBICOM . ( 2000 ) [ 15 ] Hopper , A . , Harter , A . , Blackie , T . : The Active Badge System . In : InterCHI . ( 1993 ) [ 16 ] : Versus Technologies http : / / versustech . com . [ 17 ] : Ubisense http : / / ubisense . net . [ 18 ] : Pantopic Social Networking http : / / pantopic . com / . [ 19 ] : Rummble Social Networking http : / / rummble . com / . [ 20 ] Holmquist , L . E . , Falk , J . , Wigstr¨om , J . : Supporting group collaboration with inter - personal awareness devices . Journal of Personal Technologies 3 ( 1999 ) 13 – 21 [ 21 ] Krumm , J . , Hinckley , K . : The NearMe Wireless Proximity Server . In : Ubicomp . ( 2004 ) [ 22 ] Peng , C . , Shen , G . , Zhang , Y . , Li , Y . , Tan , K . : Beep Beep : A High Accuracy Acoustic Ranging System Using COTS Mobile Devices . In : SenSys . ( 2007 ) [ 23 ] : Bluehoo . http : / / bluehoo . com [ 24 ] Li , K . A . , Sohn , T . Y . , Huang , S . , Griswold , W . G . : Peopletones : A system for the detection and notiﬁcation of buddy proximity on mobile phones . In : MobiSys . ( 2008 ) [ 25 ] Hazas , M . , Kray , C . , Gellersen , H . , Agbota , H . , Kortuem , G . , Krohn , A . : A Relative Positioning System for Co - located Mobile Devices . In : MobiSys . ( 2005 ) [ 26 ] Holmquist , L . , Falk , J . , Wigstrom , J . : DOLPHIN : A Practical Approach for Imple - menting a fully Distributed indoor Ultrasonic Poisitioning System . In : Ubicomp . ( 2004 ) [ 27 ] Zhong , Z . , He , T . : MSP : Multi - Sequence Positioning of Wireless Sensor Nodes . In : SenSys . ( 2007 ) [ 28 ] Bulusu , N . , Heidemann , J . , Estrin , D . : GPS - Less Low - Cost Outdoor Localization for Very Small Devices . IEEE Personal Communications ( 2000 ) [ 29 ] Guha , S . , Murty , R . , Sirer , E . G . : Sextant : a uniﬁed node and event localization framework using non - convex constraints . In : MobiHoc . ( 2005 ) [ 30 ] Varshavsky , A . , Pankratov , D . , Krumm , J . , Lara , E . D . : Calibree : Calibration - free Localization using Relative Distance Estimation . In : Pervasive . ( 2008 ) [ 31 ] Zhang , P . , Martonosi , M . : Locale : Collaborative localization estimation for sparse mobile sensor networks . In : IPSN . ( 2008 ) [ 32 ] Moore , D . , Leonard , J . , Rus , D . , Teller , S . : Robust distributed network localization with noisy range measurements . In : SenSys . ( 2004 ) [ 33 ] Stoleru , R . , He , T . , Stankovic , J . A . , Luebke , D . : High - accuracy , low - cost localiza - tion system for wireless sensor network . In : SenSys . ( 2005 ) [ 34 ] Dabek , F . , Cox , R . , Kaashoek , F . , Morris , R . : Vivaldi : A decentralized network coordinate system . In : SigComm . ( 2004 ) [ 35 ] Zanca , G . , Zorzi , F . , Zanella , A . , Zorzi , M . : Experimental comparison of rssi - based localization algorithms for indoor wireless sensor networks . In : REALWSN . ( 2008 ) [ 36 ] Chandra , R . , Padhye , J . , Wolman , A . , Zill , B . : A Location - based Management System for Enterprise Wireless LANs . In : NSDI . ( 2007 ) [ 37 ] Banerjee , N . , Agarwal , S . , Bahl , P . , Chandra , R . , Alec Wolman , M . C . : Virtual compass : relative positioning to sense mobile social interactions . Technical report ( 2009 ) [ 38 ] McAllester , D . : The Rise of Nonlinear Mathematical Programming . In : ACM Computing Surveys . ( 1996 ) [ 39 ] Gaonkar , S . , Li , J . , Choudhary , R . R . , Cox , L . , Schmidt , A . : Micro - Blog : Shar - ing and Querying Content Through Mobile Phones and Social Participation . In : MobiSys . ( 2008 ) [ 40 ] : Nokia Nokoscope Data obtained via private communication . [ 41 ] Agarwal , Y . , Chandra , R . , Wolman , A . , Bahl , P . , Chin , K . , Gupta , R . : Wireless wakeups revisited : energy management for VoIP over Wi - Fi smartphones . In : MobiSys . ( 2007 ) [ 42 ] Chandra , R . , Padhye , J . , Ravindranath , L . , Wolman , A . : Beacon - Stuﬃng : Wi - Fi without Associations . In : HotMobile . ( 2007 ) [ 43 ] : Microsoft Azure SQL Data Service http : / / microsoft . com / azure / data . mspx . [ 44 ] : Reality Mining Dataset http : / / reality . media . mit . edu / .