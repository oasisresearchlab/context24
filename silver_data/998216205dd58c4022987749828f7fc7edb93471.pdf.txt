Analogy - Making as a Core Primitive in the Software Engineering Toolbox Matthew Sotoudeh masotoudeh @ ucdavis . edu University of California , Davis Aditya V . Thakur avthakur @ ucdavis . edu University of California , Davis Abstract An analogy is an identification of structural similarities and correspondences between two objects . Computational mod - els of analogy making have been studied extensively in the field of cognitive science to better understand high - level hu - man cognition . For instance , Melanie Mitchell and Douglas Hofstadter sought to better understand high - level perception by developing the Copycat algorithm for completing analo - gies between letter sequences . In this paper , we argue that analogy making should be seen as a core primitive in soft - ware engineering . We motivate this argument by showing how complex software engineering problems such as pro - gram understanding and source - code transformation learn - ing can be reduced to an instance of the analogy - making problem . We demonstrate this idea using Sifter , a new analogy - making algorithm suitable for software engineering applications that adapts and extends ideas from Copycat . In particular , Sifter reduces analogy - making to searching for a sequence of update rule applications . Sifter uses a novel representation for mathematical structures capable of effectively representing the wide variety of information embedded in software . We conclude by listing major areas of future work for Sifter and analogy - making in software engineering . ACM Reference format : Matthew Sotoudeh and Aditya V . Thakur . 2020 . Analogy - Making as a Core Primitive in the Software Engineering Toolbox . In Proceed - ings of Proceedings of the 2020 ACMSIGPLAN International Sympo - sium on New Ideas , New Paradigms , and Reflections on Programming and Software ( Onward ! ’20 ) , Chicago , IL , November 15 – 20 , 2020 ( Onward ! ’20 ) , 21 pages . DOI : 10 . 1145 / nnnnnnn . nnnnnnn Permission to make digital or hard copies of all or part of this work for personalorclassroomuseisgrantedwithoutfeeprovidedthatcopiesarenotmadeordistributedforprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitationonthefirstpage . Copyrights for components of this work owned by others than ACM must be honored . Abstracting with credit is permitted . To copy otherwise , or republish , to post on servers or to redistribute to lists , requires prior specific permission and / or a fee . Request permissions from permissions @ acm . org . Onward ! ’20 , Chicago , IL © 2020 ACM . 978 - x - xxxx - xxxx - x / YY / MM . . . $ 15 . 00 DOI : 10 . 1145 / nnnnnnn . nnnnnnn 1 Introduction An analogy is defined as “a comparison between two objects , or systems of objects , that highlights respects in which they are thought to be similar” [ 5 ] . Humans make complex , fluid analogies in everyday communication . For example , a recent CNN headline [ 10 ] states that “the ‘beating hearts’ of these pulsating stars create music to astronomers’ ears , ” noting correspondences between pulsation of stars , the beating of a heart , and the rhythm of music . In fact , analogy - making is such a fundamental skill that a major portion of the origi - nal SAT exam was dedicated to having test - takers complete analogies such as “Paltry is to significance as X is to Y . ” Analogies have been shown to be a useful instructional tool for improving student learning [ 25 ] . For instance , analo - gies are frequently used to explain concepts in physics [ 9 , 64 ] , geography [ 54 ] , mathematics [ 69 , 70 ] , and computer sci - ence [ 17 , 18 , 21 , 26 , 32 , 46 , 75 ] . For example , a professor of an introductory computer science course might explain the concept of a program by forming an analogy between the execution of a program by a computer and the following of a recipe by a cook , likening steps in a recipe to statements in a computer program , ingredients in a recipe to resources in a program or user inputs — analogies are not always un - ambiguous . The important role of analogy - making in high - level cog - nition has been argued by many researchers in both cog - nitive science and computer science [ 19 , 20 , 52 ] . Profes - sor Douglas Hofstadter and his Fluid Analogies Reasoning Group ( FARG ) [ 33 , 34 ] argue that humans are constantly making analogies , comparing features of their current situa - tion with previously - encountered scenarios to decide what to do next . To study the analogy - making process in more detail , they have developed computational models of analogy making . One such algorithm , Copycat [ 35 ] , can complete analogies over strings ( Section 2 ) . Copycat can answer ques - tions such as “ abc is to abd as efg is to what ? ” This paper explores the role of analogy - making in software engineering ( SE ) . We argue that a number of SE problems can be framed as analogy - making . We introduce a dedicated analogy - making algorithm , Sifter , which can be used as a core primitive to solve such SE problems . We believe that fu - ture research on analogy - making algorithms like Sifter will solidify analogy - making as a core primitive in the software engineering toolbox . a r X i v : 2009 . 06592v1 [ c s . S E ] 14 S e p 2020 Onward ! ’20 , November 15 – 20 , 2020 , Chicago , IL Sotoudeh and Thakur The first application of analogy - making we consider is the problem of program understanding ( Section 3 . 1 ) . One fundamental way that humans understand new source code is by analogy to source code that they already understand . As an example , consider a programmer who has become familiar with the source code of the Bourne - Again Shell ( bash ) [ 7 ] and now wishes to add a new feature to the Friendly Interactive Shell ( fish ) [ 6 ] . A reasonable first step would be to read the source code of fish and attempt to identify functions in its implementation that play a similar role to more familiar functions in the implementation of bash . In other words , the programmer will form an analogy between the two source code repositories and use the analogy to determine where to make the desired modification . The second application of analogy - making we consider is the problem of generalizing a source code optimization ( Sec - tion 3 . 2 ) . As an example , consider a scenario where an opti - mized matrix multiplication implementation should be used when the matrix sizes satisfy certain conditions . After seeing a small number of code corrections replacing the sub - optimal multiplication routine with the optimized one , most trained programmers would begin to internalize the pattern . Con - sequently , when they come across new code that can be optimized they would be able to form an analogy to those corrections and modify the code to use the optimized version . Here , the programmer needs to form an analogy between pairs of programs , before and after the transformation , for example stating that “all of the sub - optimal code calls matrix multiplication routine X with inputs like Y , and the corre - sponding optimized code replaces X with Z . ” Finally , the third application of analogy - making we con - sider is the problem of API migration ( Section 3 . 3 ) . As an ex - ample , consider the scenario where a library that has updated its public interface to change its error codes and remove a now - redundant parameter from each relevant function . Af - ter updating a small number of functions to use the new API , a programmer might quickly realize that all of the changes they need to make are “fundamentally the same : ” lookup the new error code in the documentation , switch the old error code for the new wherever it is checked for , and then remove the redundant parameter . The programmer has , thus , formed an analogy between the different edits , which they can use to quickly migrate similar code elsewhere in the project . In all of these examples , and many more discussed in Sec - tion 3 . 4 , the programmer reasons about the source code and relations between different parts of the source code to form an analogy highlighting the fundamental similarities between a set of examples . Motivated by this , we developed Sifter , an analogy - making algorithm suitable for analogy - making on source code ( Sec - tion 4 ) . Sifter takes as input a description of the source code in a mathematical format using arbitrary relations . This description is expressive enough to represent syntactic as well as semantic information about the source code . Sifter can also take as input and reference in its analogies non - code sources like documentation . The design of Sifter is princi - pled and ultimately reduced the analogy - making problem to that of a search over possible rule applications for rewriting a workspace described as a triplet structure . We believe that Sifter can form a powerful primitive in the SE toolbox . Sifter is general enough to handle ar - bitrary relations , and , hence , can make analogies synthe - sizing semantic , syntactic , and natural - language informa - tion . Sifter’s output is explainable , as it internally solves analogies by symbolic manipulation and identifying corre - sponding facts . Finally , by reducing many distinct problems to Sifter , improvements to it will directly pay dividends across a wide number of applications . The implementation of Sifter is available at https : / / github . com / 95616ARG / sifter . 2 Analogy Making over Strings This section explains the notion of analogy making . Follow - ing Hofstadter , we focus first on analogies between letter strings , sequences of letters and symbols . Section 2 . 1 then describes analogy completion . We end by describing Copy - cat ( Section 2 . 2 ) , a system from prior work for completing analogies involving such letter strings , which influenced the design of the Sifter system introduced in this paper . Informally , analogy making over strings entails determin - ing in what respects two given strings are similar . For in - stance , consider the strings abc and efg . For the string abc , we have that the second letter is the successor in alphabetical order of the first , and the third is the successor of the second . The exact same property holds for the string efg . More formally , analogy making entails inferring proper - ties that hold for both strings . Consider the binary relation NextTo , where NextTo ( x , y ) implies that the letter x is the left of the letter y in a given string . For the string abc , we have NextTo ( a , b ) and NextTo ( b , c ) . Furthermore , consider the binary relation LetterSuccessor where LetterSuccessor ( x , y ) holds if the letter y is the successor of letter x in alphabet - ical order . In this example , we have LetterSuccessor ( a , b ) , LetterSuccessor ( b , c ) , LetterSuccessor ( e , f ) , and so on . Us - ing these two relations , we can state that the elements S = { a , b , c } of the string abc satisfy the following property φ : ∀ x , y ∈ S . NextTo ( x , y ) = ⇒ LetterSuccessor ( x , y ) . We see that the elements of the string efg satisfy this same property . Hence we have formed a meaningful analogy between abc and efg . However , not all analogies can be succinctly expressed via a first - order logic formula such as φ . Consider mak - ing an analogy between the strings abc and gfe . In this case , the elements of abc satisfy φ , but the elements of gfe satisfy the property φ (cid:48) : ∀ x , y ∈ S . NextTo ( x , y ) = ⇒ LetterSuccessor ( y , x ) . In particular , the order of the argu - ments to LetterSuccessor in φ and φ (cid:48) are different . Intuitively , the property φ (cid:48) reads the string from right to left , instead of left to right . Consequently , the analogy maker needs to be Analogy - Making as a Core Primitive in the Software Engineering Toolbox Onward ! ’20 , November 15 – 20 , 2020 , Chicago , IL able to express such “slips : ” the strings abc and gfe satisfy almost the same property , except that one reads the string from left to right and the other from right to left . Such properties can become even more difficult to state in a first - order logic notation when grouping is involved . Con - sider making an analogy between the strings aaabbc and ddddcccbba . There are many reasonable analogies between these strings . For example , we might associate the group of letters aaa in the first string with a in the second string , not - ing that all of the letters in the first and the one letter in the second satisfy the unary IsLetterA predicate . Alternatively , we might associate aaa in the first string with dddd in the second string , as they are both groups of a single repeated letter occurring at the start of their corresponding string . In particular , the strength of an analogy lies less in the num - ber of features the two strings have in common than in the overlap of relational structure between the two strings [ 24 ] . Regardless , it is not clear how one might naturally express the fundamental properties that these two strings share in a standard logic notation . Instead , as humans we might be tempted to communicate the shared property via a drawing like the following : G 1 G 2 . . . G n x 1 x 2 . . . x m LetterSame r 1 r 1 r 1 In this drawing , G 1 through G n represent the groups of letters in each string . Each group is made up of letters x 1 , . . . , x m , which all satisfy the LetterSame relation with each other . The groups themselves then have some shared binary relation r 1 relating them . For example , in aaabbc , we might have aaa take the place of G 1 and r 1 ( x , y ) = LetterSuccessor ( x , y ) ∧ NextTo ( x , y ) , while in ddddcccbba we might have a take the place of G 1 with r 1 ( x , y ) = LetterSuccessor ( x , y ) ∧ NextTo ( y , x ) . Note again that we have flipped the order in the latter NextTo , intuitively to read the second string from right - to - left . Such drawings motivate an alternate way of thinking about analogy making . In this interpretation , analogy - making involves defining an abstract string description that can be instantiated to produce the given strings . As we have seen , such an abstract string description needs to be general enough to handle all of the complex grouping and slipping that can occur in such letter string analogies . 2 . 1 Analogy Completion on Transformations One particularly interesting use - case for analogy - making is to make analogies between pairs of objects , such as a state before and after some transformation . For example , given the pairs abc → abd and efg → efh , we can compare the two pairs , forming an analogy which might be represented by an abstraction like : x 1 x 2 x 3 → y 1 y 2 y 3 LetterSame LetterSuccessor LetterSuccessor LetterSuccessor LetterSuccessor In this scenario , the analogy - making process involves learn - ing an abstract representation of the transformation per - formed in each pair of strings . We have said that both pairs of strings correspond to each other because they both share the properties shown in this diagram . With such a representation of a transformation , one can also perform Analogy Completion , like in the original SAT exam . For example , given two example pairs of strings abc → abd and efg → efh and a prompt ijk → ? , we can ask for a completion of the analogy , a value which can replace the ? to make all three pairs form a strong analogy . In this case , one completion would be the string ijl . We can find such a completion by first constructing an analogy between the examples abc → abd and efg → efh to form the abstract string drawn above , then we can start to form an analogy with the examples and the prompt ijk , from which we might infer that i is an instance of x 1 , j an instance of x 2 , and k an instance of x 3 in the abstract string . We can then infer that there should be some letters corresponding to y 1 , y 2 , y 3 , and that they should satisfy the properties in the drawing . From the drawing , then , we have LetterSame ( i , y 1 ) , hence we should have y 1 = i ; then LetterSuccessor ( y 1 = i , y 2 ) to get y 2 = j ; and finally LetterSuccessor ( k , y 3 ) to get y 3 = l , completing the analogy with the desired string ijl . 2 . 2 The Copycat Algorithm The Copycat algorithm [ 35 ] was developed to solve such string analogy - completion problems . Copycat’s architecture is similar to that of a blackboard - based automated theorem prover . It consists of a workspace , or blackboard , which ini - tially contains only the example pairs ( such as abc → abd ) and a prompt ( such as ijk → ? ) . This workspace is modified by a set of codelets , which are small programs that operate on the workspace . These codelets can make a variety of mod - ifications to the workspace . Some codelets may group letters together , like the aaa in aaabbc . Other codelets identify bonds , or relational facts about symbols , for example noting that LetterSuccessor ( a , b ) is true . Still further codelets can build bridges between symbols , representing the determined correspondences in the analogy . Once a consistent analogy among the examples and prompt is made , a purpose - built solver is used to construct the corresponding completion . The resulting analogy is determined by the order and type of codelets used , along with where each one “focuses . ” The behavior of the codelets is controlled by what is essentially a sophisticated set of heuristics wrapped into a structure known as a Slipnet . Onward ! ’20 , November 15 – 20 , 2020 , Chicago , IL Sotoudeh and Thakur 3 Applications of Analogy Makers in SE In this section , we demonstrate the use of our analogy maker Sifter by applying it to three SE problems and list specific challenges addressed by Sifter . A large number of further applications are then discussed in Section 3 . 4 . We defer the description of the design of Sifter to Section 4 . 3 . 1 Comparative Program Understanding Suppose you are a programmer who is quite familiar with the implementation ( source code ) of bash [ 7 ] , and you would like to add a new feature to a different shell , such as fish [ 6 ] . Because you have been adding features to the bash shell for many years , you may know exactly which function ( s ) to modify in the source code of bash to add the desired feature . However , being new to the source code of fish , you face a significant challenge understanding the implementation of fish before you can even begin writing your new feature . You might start by reading the source code of fish , looking for functions and objects that play similar roles to ones you are more familiar with in bash . This is fundamentally an analogy - making problem , where we are attempting to form an analogy between the source code of bash ( which we are familiar with ) and that of fish ( which we are not ) . This problem is similar to that of forming letter analogies in Section 2 , where , given the strings abc and efg , we found that b and f corresponded to each other . Here , abc is instead the source code of bash , while efg is the source code of fish . b and f are likewise functions in bash and that which play similar roles . Sifter is designed to make such analogies on programs . We first load both source repositories into Sifter , then ask it to identify an analogy between the two . This analogy will effectively be a mapping between the repositories , identifying functions , classes , and statements in the source code of bash with those in the source code of fish . Such an analogy can form an invaluable guide , allowing you to look up , for exam - ple , the function in fish which Sifter thinks plays the most similar role to the one you would have modified in bash . Challenge 1 : Compositional Structure of Programs Program source - code relies heavily on compositional struc - ture . For example , the meaning and interpretation of any function depends not only on its immediate body , but also on the body of all functions that it calls , and the functions they call , and so forth . On the other hand , the role a function plays in a large piece of software usually depends on the functions that call it . Sifter can make use of this compositional structure , by building on top of analogies it has already made . For exam - ple , in Figure 1 we have provided snippets of the source code of the bash and fish shells . Sifter begins by associating the functions cd _ builtin ( B1 ) and builtin _ cd ( F1 ) because of their similar names and signatures . Then , once it has de - cided that these two functions correspond , Sifter can start to make inferences that the places where they are used are likely to correspond as well . For example , it might note that both shell _ builtins ( B3 ) and builtin _ datas ( F2 ) contain a struct with a field of cd _ builtin or builtin _ cd respec - tively , and mark those two objects as corresponding in the analogy . It can similarly infer that functions using those objects , such as builtin _ address _ internal ( B4 ) in bash and builtin _ lookup ( F3 ) in fish , correspond . In this way , Sifter can build up analogies made about parts of the program to begin to make stronger and stronger inferences about how the rest of the source code corre - sponds . Although we have not demonstrated it in this exam - ple , Sifter can also make analogies in a top - down fashion , e . g . , by starting at the main function in both programs , or by alternating between such top - down and bottom - up strate - gies . Notably , such compositional structure was not needed to find analogies between the letter groups in Section 2 , demonstrating how analogy - making on programs can be richer and more challenging than on letter strings . Challenge 2 : Multiple Syntactic Representations of Programs Another challenge with analogy - making on programs is that semantically equivalent programs can have multiple syntac - tic representations . For example , functions can be inlined or if / else conditionals can be inverted . Sifter can han - dle such scenarios by applying transformation rules , such as function inlining , to transform either source repository it is given . Sifter searches through different representations of each source repository until it finds ones that are amenable to forming strong analogies . Because letter strings do not have an assumed seman - tics , there is no equivalent notion of semantics - preserving transformation rules for the examples in Section 2 . How - ever , operationally , the process of grouping letters , e . g . , in aaabbc , can be seen as such a transformation , where the internal representation of the individual letters a , a , and a are transformed into a single group of letters aaa . 3 . 2 Generalizing Program Transformations from Examples Suppose we have a linear algebra library with multiple Gen - eral Matrix Multiply ( GEMM ) routines for computing matrix multiplications . Some routines , such as gemm _ large , are optimized for the case where the input matrices are rela - tively large , say with over 1 , 000 rows each , while others like gemm _ skinny are optimized for “skinny” inputs , e . g . , where the inner dimension is half the size of either of the outer dimensions . For a particular team working on a particular codebase , it may be the case that most matrices are usually quite large and so gemm _ large might become the de - facto routine that developers use in new code without thinking too deeply about matrix sizes , or simply used due to copy and paste Analogy - Making as a Core Primitive in the Software Engineering Toolbox Onward ! ’20 , November 15 – 20 , 2020 , Chicago , IL 1 int cd _ builtin ( list ) WORD _ LIST * list ; { . . . } / / B1 23 struct builtin static _ shell _ builtins [ ] = { . . . 4 { " cd " , cd _ builtin , . . . } , / / B2 5 . . . } 6 struct builtin * shell _ builtins = static _ shell _ builtins ; / / B3 78 struct builtin * builtin _ address _ internal 9 ( name , disabled _ okay ) 10 char * name ; int disabled _ okay ; { . . . / / B4 11 j = shell _ builtins [ mid ] . name [ 0 ] - name [ 0 ] ; 12 . . . } ( a ) Bash source 1 int builtin _ cd ( parser _ t & parser , io _ streams _ t & streams , wchar _ t * * argv ) { . . . } / / F1 23 static const builtin _ data _ t builtin _ datas [ ] = { 4 . . . 5 { L " cd " , & builtin _ cd , . . . } , / / F2 6 . . . } 78 static const builtin _ data _ t * builtin _ lookup ( const wcstring & name ) { / / F3 9 const builtin _ data _ t * array _ end = builtin _ datas + BUILTIN _ COUNT ; 10 . . . } ( b ) Fish source Figure 1 . Comparative program understanding between bash and fish source code . Sifter can form an analogy between these implementations , helping explain the code for fish to a programmer used to the codebase of bash by noting where objects and functions ( like builtin _ address _ internal in bash and builtin _ lookup in fish ) play similar roles in each . from existing code . While this might be a reasonable default for this team , it is likely the case that some matrices in a pro - gram are better suited for gemm _ skinny — in that case , the instinctive default would be sub - optimal , and another pro - grammer might notice during code review that gemm _ skinny would be a better choice . The question we would like to consider is : given two ex - ample code pairs where gemm _ large has been transformed into gemm _ skinny , can we automatically optimize new code in the same manner ? This is fundamentally an analogy prob - lem , where we would like to compare the pairs of pre - and post - replacement code to learn the core transformation that explains all of them . We can then use this analogy to infer , for some new sub - optimal code , the corresponding optimized code . This is similar to completing the analogy abc → abd , efg → efh , ijk → ? in Section 2 . 1 . This scenario is shown in Figure 2 . The first two rows in that figure show pairs of examples of the desired source code transformation provided to Sifter , which play the same role as abc → abd and efg → efh in Section 2 . 1 . The code in the left - hand column is sub - optimal because it calls gemm _ large on matrices with dimensions that would be better suited for gemm _ skinny . The code in the right - hand column has been optimized by replacing the call to gemm _ large with a call to gemm _ skinny . In the third row of Figure 2 , we have provided Sifter with a new piece of code on the left and ask it to complete the analogy , i . e . , produce the corresponding piece of code on the right that makes all three rows the most similar . This plays the same role as the efg → ? input in the letter analogy example . The code produced by Sifter is shown on the bottom right of Figure 2 in green , where we see it has correctly replaced the call to gemm _ large with a call to gemm _ skinny . Challenge 3 : Avoiding False Positives Sifter is forming an analogy between the rows in Figure 2 , including between the before code on the left - hand side . In Figure 2 , for example , Sifter has noted as part of its anal - ogy that all of the left - hand code snippets call the function gemm _ large with the last argument at least twice that of the second - to - last argument . This behavior can be thought of as learning to recognize code that can be optimized , and can be used to avoid false positives . For example , suppose instead of the sub - optimal prompt code given in the bottom - left of Figure 2 , we gave Sifter the code : 1 assert ( k > 0 ) ; 2 int outer = k * 10 ; 3 int inner = k * 10 ; 4 read _ mat ( outer , inner , & A ) ; 5 read _ mat ( inner , outer , & B ) ; 6 gemm _ large ( A , B , & C , outer , inner , outer ) ; In that scenario , Sifter would attempt to form an analogy between this code and the example before - transformation code on the left - hand side of the first two rows of Figure 2 . While it may succeed in proposing an analogy , Sifter will note as part of its output that the analogy is not particularly strong . This is because this new code does not share the property that the last argument to gemm _ large is at least twice that of the second - to - last one . If examples of already - optimized code are available , given a new instance Sifter can also try to form an analogy using these negative examples . A threshold can be set based on a comparison with the negative vs . positive examples to determine whether to apply the transformation . Challenge 4 : Using Semantic Information Recognizing sub - optimal code relies on semantic information about the possible values a variable can take on . In partic - ular , we only want to apply the transformation when the inner matrix dimension is at most half the size of the outer dimensions . This would cause difficulty for syntax - based tools like GetAFix [ 4 ] . However , Sifter takes as input an ar - bitrary structure consisting of symbols and relations between the symbols . This means that , in addition to providing the source code , we can annotate the structure representing the source code with the results of a program analyzer , which Onward ! ’20 , November 15 – 20 , 2020 , Chicago , IL Sotoudeh and Thakur 1 assert ( k > 0 ) ; 2 int outer = k * 100 ; 3 int inner = k * 10 ; 4 read _ mat ( outer , inner , & A ) ; 5 read _ mat ( inner , outer , & B ) ; 6 gemm _ large ( A , B , & C , outer , inner , outer ) ; 1 assert ( k > 0 ) ; 2 int outer = k * 100 ; 3 int inner = k * 10 ; 4 read _ mat ( outer , inner , & A ) ; 5 read _ mat ( inner , outer , & B ) ; 6 gemm _ skinny ( A , B , & C , outer , inner , outer ) ; 1 assert ( k > 1 ) ; 2 int outer = k , A _ cols = k / 2 ; 3 read _ mat ( outer , A _ cols , & A ) ; 4 read _ mat ( A _ cols , outer , & B ) ; 5 while ( ! done ( A , B ) ) { 6 read _ row ( & A ) ; 7 read _ col ( & B ) ; 8 outer + + ; } 9 gemm _ large ( A , B , & C , outer , A _ cols , outer ) ; 1 assert ( k > 1 ) ; 2 int outer = k , A _ cols = k / 2 ; 3 read _ mat ( outer , A _ cols , & A ) ; 4 read _ mat ( A _ cols , outer , & B ) ; 5 while ( ! done ( A , B ) ) { 6 read _ row ( & A ) ; 7 read _ col ( & B ) ; 8 outer + + ; } 9 gemm _ skinny ( A , B , & C , outer , A _ cols , outer ) ; 1 assert ( k > 5 ) ; 2 int AB _ rowcol = k * k ; 3 int inner = k ; 4 read _ mat ( AB _ rowcol , inner , & A ) ; 5 read _ mat ( inner , AB _ rowcol , & B ) ; 6 gemm _ large ( A , B , & C , AB _ rowcol , inner , AB _ rowcol ) ; 1 assert ( k > 5 ) ; 2 int AB _ rowcol = k * k ; 3 int inner = k ; 4 read _ mat ( AB _ rowcol , inner , & A ) ; 5 read _ mat ( inner , AB _ rowcol , & B ) ; 6 gemm _ skinny ( A , B , & C , AB _ rowcol , inner , AB _ rowcol ) ; Figure 2 . Optimizing program source code with Sifter . The left column shows before the optimization and the right column after the optimization . The first two lines are the examples given to Sifter , while the green code is generated by Sifter to complete the analogy for the last line . Sifter includes in its analogy semantic information like the fact that all of the outer dimensions in the examples are at least twice that of the inner dimensions , helping it to avoid false positives . allows us to include information about semantic properties of the code . In this example , we can annotate the structure with relations that some variable is always at least twice that of another . The analogy - making algorithm that forms the core of Sifter is entirely indifferent to the underlying relations being used , and will use such semantic relations to form analogies just like it would more syntactic relationships describing the source code . 3 . 3 API Migration For the final task , consider the two versions of a camera library documented in Figure 3 , which has been updated to automatically determine the resolution to use as well as changed the error codes . Suppose you have a program that uses version 1 of this camera library . Snippets of this program are shown on the left column of Figure 4 . Your colleague has partially migrated your code to use version 2 of the camera library , as shown in the first two boxes on the right column of Figure 4 . You would now like to migrate the bottom - left code in Figure 4 to use version 2 . This is an analogy completion problem , where we want to form an analogy between the examples that effectively describes how to migrate code to use the new API . We then want to find a completion , or source code to fill in to the bottom - right of Figure 4 that makes the last row analogous to the first . Because this involves transforming source code , the input / output to Sifter will be similar to that of Section 3 . 2 . However , as we will see , we will face different challenges here . Just like in Section 3 . 2 , we can provide the first two rows of Figure 4 to Sifter as examples of the desired migration , then ask it to complete the analogy by producing the migrated code corresponding to the prompt ( unmigrated ) code in the bottom left of Figure 4 . The code generated by Sifter is shown in green on the bottom left of Figure 4 . Challenge 5 : Using Documentation in Analogies There is one particularly pressing challenge we wish to high - light here : given only these code pairs , there is no reasonable way to complete this analogy , because it depends on know - ing the new error code for record _ frame , which did not appear in any of the examples . To address this , we can give Sifter the before / after documentation in addition to just the source code . Again , because Sifter takes any structure as input , we can encode documentation just as easily as we can encode source code . Then , in making analogies , Sifter can refer to the documentation and include looking up in the documentation as part of the analogy . Challenge 6 : Using DNN Models in Analogy - Making Once we begin involving arbitrary text ( e . g . , in documenta - tion ) , we need to start being able to handle fuzziness inherent in human languages . For example , in the documentation for the first two functions , the corresponding error message could be found with a relatively simple search , because it was prefaced with “On error . . . returns . ” However , for the record _ frame function , the corresponding sentence uses “failure” instead of “error , ” which could cause Sifter to lose confidence in its analogy . To help increase Sifter’s confi - dence in its analogy and guide it towards the right answer , we can use existing natural - language tools such as DNN - based sentiment analysis models . These models take a paragraph , Analogy - Making as a Core Primitive in the Software Engineering Toolbox Onward ! ’20 , November 15 – 20 , 2020 , Chicago , IL 1 # CameraLib v1 . 0 2 # # ` record _ video ( buffer , buffer _ size , resolution ) ` 3 Records video from the main camera into ` buffer ` until ` buffer _ size ` bytes are reached . On error returns - 1 . 4 # # ` record _ audio ( buffer , buffer _ size , resolution ) ` 5 Uses the main camera ' s microphone to record audio into ` buffer ` until ` buffer _ size ` bytes have been recorded . On error returns - 5 . 6 # # ` record _ frame ( buffer , buffer _ size , resolution ) ` 7 Uses the main camera to record a single image to ` buffer ` . On failure returns - 3 . 1 # CameraLib v2 . 0 2 # # ` record _ video ( buffer , buffer _ size ) ` 3 Records video from the main camera into ` buffer ` until ` buffer _ size ` bytes are reached . On error returns - 4 . 4 # # ` record _ audio ( buffer , buffer _ size ) ` 5 Uses the main camera ' s microphone to record audio into ` buffer ` until ` buffer _ size ` bytes have been recorded . On error returns - 2 . 6 # # ` record _ frame ( buffer , buffer _ size ) ` 7 Uses the main camera to record a single image to ` buffer ` . Automatically sets the resolution to fit in ` buffer _ size ` . On failure returns - 6 . Figure 3 . API documentation before after migration for the camera API . This documentation is provided to Sifter to complete the analogy shown in Figure 4 . 1 . . . 2 void try _ record _ video ( ) { 3 int result = record _ video ( buffer , BUFFER _ SIZE , RES _ AUTO ) ; 4 if ( result = = - 1 ) { 5 printf ( " Could not record video . \ n " ) ; } 6 . . . } 1 . . . 2 void try _ record _ video ( ) { 3 int result = record _ video ( buffer , BUFFER _ SIZE ) ; 4 if ( result = = - 4 ) { 5 printf ( " Could not record video . \ n " ) ; } 6 . . . } 1 . . . 2 void try _ record _ audio ( ) { 3 int result = record _ audio ( buffer , BUFFER _ SIZE , RES _ AUTO ) ; 4 if ( result = = - 5 ) { 5 printf ( " Could not record audio . \ n " ) ; } 6 . . . } 1 . . . 2 void try _ record _ audio ( ) { 3 int result = record _ audio ( buffer , BUFFER _ SIZE ) ; 4 if ( result = = - 2 ) { 5 printf ( " Could not record audio . \ n " ) ; } 6 . . . } 1 . . . 2 void try _ record _ still ( ) { 3 int result = record _ frame ( buffer , BUFFER _ SIZE , RES _ AUTO ) ; 4 if ( result = = - 3 ) { 5 printf ( " Could not record still . \ n " ) ; } 6 . . . } 1 . . . 2 void try _ record _ still ( ) { 3 int result = record _ frame ( buffer , BUFFER _ SIZE ) ; 4 if ( result = = - 6 ) { 5 printf ( " Could not record still . \ n " ) ; } 6 . . . } Figure 4 . API migration with Sifter . The left ( right ) column shows before ( after ) the migration . The first two rows are the input to Sifter , while the green code is generated by Sifter to complete the analogy for the last row . Sifter was also given as input the API documentation pair from Figure 3 , which is where it looks to find the new error code used in the generated code . sentence , or word and estimate how positive or negative it is . Just like with the results of a program analyzer , we can anno - tate this information on top of the structure , e . g . , by marking all symbols representing words which are determined to be highly positive or highly negative by the sentiment ana - lyzer with a unary relation like IsNegativeSentiment . Even though they are not exactly the same word , the fact that they both satisfy the IsNegativeSentiment relation will increase Sifter’s confidence in the analogy . 3 . 4 Future Software Engineering Applications Future work can apply analogy completion to more varied input / output domains and languages . For example , analogy completion can generate documentation based on existing code , similar to the problem of automated comment genera - tion , which has been addressed by code - clone detection [ 88 ] . We can also treat translation between programming lan - guages as analogy completion using examples of semanti - cally equivalent programs in either language . This will likely rely on a number of smaller analogies , matching common patterns in one programming language and mapping them to idiomatic code for that pattern in another , similar to existing work in this field [ 47 , 50 ] . A smart editor may make analogies between the user’s current editor state and a corpus of code samples to suggest structural code completions , similar to those accomplished using large code corpuses like Aroma [ 45 ] or more local his - tory such as Blue Pencil [ 51 ] . Because our approach does not rely on AST parsing ( see Section 5 . 1 ) , we can use analo - gies to automatically improve tooling ( error messages , lint - ing , suggestions , bug finding , etc . ) for nascent and domain - specific languages ( DSLs ) that may not yet have a formal grammar [ 8 , 60 ] . Onward ! ’20 , November 15 – 20 , 2020 , Chicago , IL Sotoudeh and Thakur One might also apply analogy - makers to recover higher - level structure from low - level binaries or compiler interme - diate representations . Such information would be useful for decompilation of binary programs [ 2 ] , in - place binary anal - ysis [ 81 ] , binary rewriting [ 85 ] , de - obfuscation of code [ 65 ] , and identification of code replacable with highly - optimized libraries [ 16 ] or coprocessors [ 82 ] . Analogies between existing code with correctness proofs and new code may allow for proof transfer to more quickly prove correctness of the latter . A related technique has been proposed for the Coq theorem prover [ 62 ] . More varied information sources can be used for anal - ogy making . For example , the use of information from a profiler may be helpful in a code optimization setting , and compiler error - messages may be useful when using analo - gies to provide edit suggestions for syntactically - invalid code . This information could be used to rank different proposed analogies or to help find them in the first place . In a classroom setting , analogy - makers can cluster stu - dent assignments , an important problem which is currently addressed via a variety of different techniques [ 31 , 37 ] . Sifter can also detect where a strong analogy almost holds , under a small modification its inputs , e . g . , in abc and xyf . If applied to common coding patterns , this might suggest the existence of a bug in the program’s implementation of this pattern . For example , one binary - search implementation might be almost analogous to a reference one , except that it computes the midpoint as ( l + h ) / 2 instead of l + ( h - l ) / 2 , introducing a subtle integer overflow bug that a future version of Sifter might flag as anomalous in the analogy . 4 Design of Sifter In this section , we describe the design of our analogy - making algorithm Sifter and illustrate how it addresses the chal - lenges discussed in Section 3 . Its design was influenced by that of Copycat ( Section 2 . 2 ) . However , as we will discuss in Section 6 , Copycat’s implementation was specially de - signed for the letter - analogy domain , whereas we would like to support arbitrary relations and input structures . At a high level , the behavior of Sifter is formulated as a number of update rules operating on a workspace . The workspace initially contains a representation of the source code and other inputs which it is supposed to make analogies about . Update rules gradually modify the workspace , both identifying facts , such as when some letter is a successor of another , and making new analogies . Analogies made during this process are explicitly represented within the workspace , as discussed in Section 4 . 4 , and new analogies can build iteratively on existing analogies in the workspace . When a sufficient analogy is found by the system , it can be read off directly from the workspace and returned to the user . In Section 4 . 1 we will describe triplet structures , a novel data structure used to represent Sifter’s workspace . Triplet structures can represent arbitrary relational facts in a stan - dardized way , making them a particularly flexible tool for representing Sifter’s workspace . In Section 4 . 2 we will describe how we initialize the triplet structure represent - ing the Sifter workspace for an example analogy problem . In Section 4 . 3 , we introduce a domain - specific language for expressing update rules that modify triplet structures , and can be used to infer new facts about the objects in question . Section 4 . 4 describes how analogies are represented in the workspace , while Section 4 . 5 describes update rules that can be used to automatically find such analogies . 4 . 1 Triplet Structures A triplet structure is a novel data structure used to represent the state of Sifter’s workspace . A triplet structure : 1 . Represents objects and facts in a standardized form , so that code for operating on the workspace does not have to worry about details like arity of relations . 2 . Is able to naturally represent partial facts , e . g . , we can represent the state “I know letter O is the predecessor of something , but I’m not sure exactly what yet . ” 3 . Supports efficient lookups and queries , so that opera - tions on the structure can be performed quickly . Definition 4 . 1 . A triplet structure is a pair of sets ( S , F ) where F ⊆ S × S × S . We call each member of S a node , each member of S × S × S a triplet fact , and F the set of triplet facts in the structure . We can encode any finite mathematical structure as a triplet structure with polynomial increase in size . First , for every n - ary relation R , we add n nodes to the triplet structure representing slots in the relation . Generally , for an n - ary re - lation R we can always add nodes R : 1 through R : n , although we will usually use more descriptive names in our examples . Second , each fact in the original structure gets a fact node in the triplet structure , which is a node in S that represents the original fact itself in the triplet structure . For a fact in the original structure of the form R ( x 1 , x 2 , . . . , x n ) correspond - ing to a fact node f , we then add triplet facts of the form ( f , x i , R : i ) for every i ∈ { 1 , 2 , . . . , n } . Fact nodes in triplet structures can be thought of as C - style struct s , where each fact ( f , v , k ) asserts that the field k in struct f takes the value v . Alternatively , each fact node f can be thought of as expressing an interpretation of part of the structure , with a fact ( f , v , k ) asserting that , in the interpretation f , v is of type k . Example 4 . 2 . Consider a mathematical structure with ob - jects O = { x , y , z } , a single binary relation R , and two rela - tional facts R ( x , y ) , R ( y , z ) . To encode this mathematical structure as a triplet struc - ture , we break the binary relation R into two nodes R : 1 and R : 2 representing each of its slots . We then create the fact node f 1 for R ( x , y ) and the fact node f 2 for R ( y , z ) . We also Analogy - Making as a Core Primitive in the Software Engineering Toolbox Onward ! ’20 , November 15 – 20 , 2020 , Chicago , IL add nodes for each of the original objects in O to get the set of nodes : S = { x , y , z , R : 1 , R : 2 , f 1 , f 2 } . Finally , we add triplet facts relating each slot of each fact to arrive at the set of triplet facts in the structure : F = { ( f 1 , x , R : 1 ) , ( f 1 , y , R : 2 ) , ( f 2 , y , R : 1 ) , ( f 2 , z , R : 2 ) } . Triplet structures also have an intuitive graph represen - tation . Nodes in the structure correspond to nodes in the graph . For each triplet fact ( f , v , k ) , we add an edge v → k with label f . The graph for the triplet structure considered in this example is the Structure T1 shown below . x y z f 1 f 2 R : 1 R : 2 f 1 f 1 f 2 f 2 Triplet Structure T1 Note that , while we have drawn T1 using descriptive names , shapes , and colors , no intrinsic meaning is assigned to any symbol . In the rest of this paper , we will usually only show this visual representation of a triplet structure instead of explicitly listing the nodes and facts . Hence , the reader is encouraged to ensure the connection between the two is well - understood before proceeding . In addition to directly encoding relational facts , some structures can be more naturally expressed directly as a triplet structure . This is highlighted in the next example . Example 4 . 3 . Consider encoding the scenario “Homer and Marge are the parents of Bart and Lisa . ” We may encode this as four facts of the form Parent ( Homer , Bart ) , Parent ( Homer , Lisa ) , Parent ( Marдe , Bart ) , Parent ( Marдe , Lisa ) . With triplet structures , we can express this by saying “Homer , Marge , Bart , and Lisa form a family , where Homer and Marge are the parents , and Bart and Lisa are the children . ” This sce - nario is represented by Structure T2 below . Homer Marge Bart Lisa f 1 Family : Parents Family : Children f 1 f 1 f 1 f 1 Triplet Structure T2 Another feature of triplet structures is that they can rep - resent partial facts , as demonstrated by the next example . Example 4 . 4 . Suppose in the previous example that we know Abe is the parent of someone , but we are not sure who yet . We represent this uncertainty in Structure T3 below by adding a new fact node f 2 , which only states that Abe is a parent , without noting a corresponding child . Abe Homer Marge Bart Lisa f 1 f 2 Family : Parents Family : Children f 1 f 1 f 1 f 1 f 2 Triplet Structure T3 If we later learn that Homer is Abe’s child , we can extend f 2 to include this information as shown in Structure T4 below . Abe Homer Marge Bart Lisa f 1 f 2 Family : Parents Family : Children f 1 f 1 f 1 f 1 f 2 f 2 Triplet Structure T4 4 . 2 Initializing Workspaces The Sifter workspace initially contains only symbols rep - resenting input objects ( such as a in abc ) and information about their relative position . For example , when comparing the strings ab and ef , the Sifter workspace is initialized as shown below , where x 1 represents a , x 2 represents b , y 1 represents e , and y 2 represents f . x 1 x 2 y 1 y 2 Letter : a Letter : b Letter : f Letter : e Predecessor Successor NextTo : Left NextTo : Right n 1 n 2 p 1 p 2 p 3 p 4 p 1 p 2 n 1 n 1 p 3 p 4 n 2 n 2 Triplet Structure T5 Notably , we also have nodes like Letter : a representing the Pla - tonic concept of a particular letter ; the fact that x 1 is mapped to Letter : a corresponds to asserting the unary IsLetterA ( x 1 ) . We have included nodes for some predicates ( specifically Pre - decessor and Successor representing the slots of the binary LetterSuccessor predicate ) that have no incoming or outgo - ing edges . This indicates that , while Sifter knows about the Onward ! ’20 , November 15 – 20 , 2020 , Chicago , IL Sotoudeh and Thakur concept of predecessor and successor , it has not yet explic - itly recognized any letter - successor pairs in the structure . In the next section , we will describe how such facts may be inferred from this initial encoding of the problem via the use of update rules . 4 . 3 Modifying the Workspace with Update Rules Sifter proceeds to modify the workspace in two ways : ( 1 ) re - fining the representation of its inputs , e . g . , to infer the facts LetterSuccessor ( x 1 , x 2 ) and LetterSuccessor ( y 1 , y 2 ) in the above example , and ( 2 ) building an analogy between its inputs by comparing such inferred facts . Both types of modifications are implemented using the same framework of update rules . This section introduces our language for expressing update rules using a simple example rule of the first kind , deferring discussion of the second type of modification to Section 4 . 4 . Note that the language described here for expressing update rules works to define update rules for any triplet structure . However , we focus our examples on their use for expressing inference rules for the Sifter workspace . Note that , in this section , we will discuss a method of “hard - coding” certain rules to express things like letter - successorship , both because this is how our current implementation op - erates , as well as to introduce the notion of update rules . Section 4 . 6 describes more general mechanisms for making such changes without explicitly enumerating all such rules ahead of time . Recall the initial state of the Sifter workspace for the example of ab and ef , shown above as Structure T5 . Con - sider now the problem of defining a rule that modifies the workspace by identifying when some letter instance is an al - phabetical successor of another . For example , we may wish to create a rule that marks instances of the letter ‘a’ and the let - ter ‘b’ as LetterSuccessor pairs . In first - order logic , we might write the desired rule as IsLetterA ( v 1 ) ∧ IsLetterB ( v 2 ) = ⇒ LetterSuccessor ( v 1 , v 2 ) . We have developed a visual domain specific language ( DSL ) for expressing such rules operating on the Sifter workspace . Our full DSL is capable of ex - pressing rules containing alternating quantifiers and other pattern - matching features . We will describe here only a sim - plified subset of the language that suffices for the uses in this paper . Rules in this DSL look like triplet structures themselves ( and in fact can be stored as such ) , although they are anno - tated with extra information about which nodes represent variables to search for and how the structure should be mod - ified if such variables are found . For example , Rule R1 below shows a rule which notates a , b letter - successor pairs . Predecessor Successor Letter : a Letter : b v 1 v 2 v f 1 v f 2 nf 3 v f 1 v f 2 nf 3 nf 3 Triplet Structure Rule R1 In such rule diagrams , one first looks at the parts not shaded green . In these parts , dashed nodes are variables that should be looked for in the structure , while solid nodes are constants assumed already to exist in the structure . When this pattern is found in the structure , this is called a rule match and the green nodes and facts can be added . In this case , the rule expresses that whenever two nodes v 1 and v 2 are found such that v 1 is the letter ‘a’ and v 2 the letter ‘b’ , then we can add a new fact node and corresponding triplet facts which express that v 2 is an alphabetical successor of v 1 . For example , we may apply Rule R1 to Structure T5 by taking the rule assignment with v 1 = x 1 , v 2 = x 2 , v f 1 = p 1 , and v f 2 = p 2 . This produces a new fact node nf 3 which asserts that x 1 is a predecessor of the successor x 2 . Letting s 1 be the generated node corresponding to nf 3 , Rule R1 trans - forms Structure T5 into Structure T6 below . x 1 x 2 y 1 y 2 Letter : a Letter : b Letter : f Letter : e Predecessor Successor NextTo : Left NextTo : Right n 1 n 2 s 1 p 1 p 2 p 3 p 4 p 1 p 2 n 1 n 1 p 3 p 4 n 2 n 2 s 1 s 1 Triplet Structure T6 Similarly , Rule R2 below identifies e , f pairs as successor pairs . Predecessor Successor Letter : e Letter : f v 1 v 2 v f 1 v f 2 nf 3 v f 1 v f 2 nf 3 nf 3 Triplet Structure Rule R2 Applying Rule R2 to Structure T6 marks y 1 and y 2 as prede - cessor and successor respectively , producing Structure T7 below . Analogy - Making as a Core Primitive in the Software Engineering Toolbox Onward ! ’20 , November 15 – 20 , 2020 , Chicago , IL x 1 x 2 y 1 y 2 Letter : a Letter : b Letter : f Letter : e Predecessor Successor NextTo : Left NextTo : Right n 1 n 2 s 1 s 2 p 1 p 2 p 3 p 4 p 1 p 2 n 1 n 1 p 3 p 4 n 2 n 2 s 1 s 1 s 2 s 2 Triplet Structure T7 4 . 4 Representing Analogies in Triplet Structures This section discusses how Sifter represents and makes analogies in its triplet - structure workspace . Analogies are represented as abstractions , similar to the abstract letter strings in Section 2 . Intuitively , instructed to form an analogy between abc and efg , Sifter forms a shared abstract repre - sentation of them both , roughly of the form ( ? 1 ) ( ? 2 ) ( ? 3 ) with additional information such as ( ? 2 ) is a successor of ( ? 1 ) . It then adds facts stating that , for example , both the original a and e are instances of this more abstract ( ? 1 ) ob - ject . Two input objects correspond if they are instances of the same abstract node . Consider the example from Section 4 . 3 , where we are form - ing an analogy between two letter strings ab and ef . Suppose the current Sifter workspace is represented by Structure T8 below , which is identical to Structure T7 except with a few of the nodes / relations removed for ease of exposition . x 1 x 2 y 1 y 2 Predecessor Successor NextTo : Left NextTo : Right n 1 s 1 n 2 s 2 n 1 n 1 s 1 s 1 n 2 n 2 s 2 s 2 Triplet Structure T8 An analogy between the two strings ab and ef might determine that x 1 corresponds to y 1 and x 2 to y 2 , because they both form instances of a more abstract type of “two successive letters next to each other . ” This is represented in the Sifter workspace as Structure T9 below . For clarity , we have only shown the newly - added facts ( i . e . those that make up the abstraction ) , although the facts from Structure T8 would still be present . x 1 x 2 y 1 y 2 α 1 α 2 Predecessor Successor NextTo : Left NextTo : Right n 1 s 1 n 2 s 2 αn αs Mα 1 Mα 2 IsAbs Abstraction αn αn αs αs Mα 1 Mα 2 Mα 1 Mα 2 Mα 1 Mα 2 Mα 1 Mα 2 IsAbs IsAbs Triplet Structure T9 In Structure T9 , we have added new nodes α 1 and α 2 to repre - sent the abstract type of which x 1 , y 1 and x 2 , y 2 respectively are instances of . We have also abstracted the fact nodes that correspond to each other into nodes αn and αs . These abstract fact nodes each express the same fact about the abstract α 1 and α 2 as the original , or concrete , fact nodes expressed about , e . g . , x 1 and x 2 . Finally , we have added fact nodes Mα 1 and Mα 2 that map the concrete nodes in each instance to their abstract counterparts . For bookkeeping rea - sons in the structure , we label each of these as Abstraction s so we can keep track of which nodes in the workspace are abstract vs . provided in the input . From Structure T9 above , we can extract the analogy that x 1 corresponds to y 1 because both are instances of the ab - stract α 1 node , and similarly for x 2 , y 2 , and α 2 . 4 . 5 Rules for Making Analogies in a Triplet Structure We now turn our attention to designing rules for forming such analogies . All such rules will be of the form discussed in Section 4 . 3 . Each rule application makes a small change to the structure ; for example , abstracting two concrete nodes together , or lifting a single concrete fact to the abstraction . These rules create a search space that can be explored using heuristics . We have found that all of the rules necessary for abstraction - forming can be formed as variations on the following Begin Analogy rule , Rule R3 , which starts a new abstraction . Onward ! ’20 , November 15 – 20 , 2020 , Chicago , IL Sotoudeh and Thakur A B αAB C M A M B αM AB MαA MαB Abstraction IsAbs M A M B MαA MαB αM AB MαA MαB IsAbs IsAbs Triplet Structure Rule R3 Here , the variable nodes A and B represent the concrete nodes that should correspond to each other in the analogy , like x 1 and y 1 in the previous example . The variable node C is the field that they both share . For example , in the previous example C might be NextTo : Left , because both x 1 and y 1 are mapped to NextTo : Left by fact nodes n 1 and n 2 , which in turn map to M A and M B , respectively , in the rule above . Applying Rule R3 to Structure T9 may produce the start of an analogy shown below in Structure T10 . For clarity , we have left out the facts between concrete nodes . x 1 x 2 y 1 y 2 α 1 Predecessor Successor NextTo : Left NextTo : Right n 1 s 1 n 2 s 2 αn Mα 1 Mα 2 IsAbs Abstraction αn Mα 1 Mα 2 Mα 1 Mα 2 IsAbs IsAbs Triplet Structure T10 By shading different subsets of the nodes green , we can modify Rule R3 into a variety of rules for extending analogies . For example , Rule R4 below “follows” a fact node from an existing analogy to map two new concrete nodes to each other . A B αAB C M A M B αM AB MαA MαB Abstraction IsAbs M A M B MαA MαB αM AB MαA MαB IsAbs IsAbs Triplet Structure Rule R4 Applying Rule R4 to our running structure with A = x 2 , B = y 2 , and C = NextTo : Right would extend the analogy to include x 2 and y 2 by “following” the NextTo : Right relation , producing Structure T11 below . x 1 x 2 y 1 y 2 α 1 α 2 Predecessor Successor NextTo : Left NextTo : Right n 1 s 1 n 2 s 2 αn Mα 1 Mα 2 IsAbs Abstraction αn αn Mα 1 Mα 2 Mα 1 Mα 2 Mα 1 Mα 2 IsAbs IsAbs Triplet Structure T11 Similarly , by shading just the αM AB node , we get Rule R5 that adds a new fact node to the abstraction . A B αAB C M A M B αM AB MαA MαB Abstraction IsAbs M A M B MαA MαB αM AB MαA MαB IsAbs IsAbs Triplet Structure Rule R5 Applying Rule R5 to the previous abstraction with A = x 1 , B = y 1 , αAB = α 1 , C = Predecessor , M A = s 1 , and M B = s 2 allows us to associate s 1 and s 2 with each other , produc - ing Structure T12 as shown below . Analogy - Making as a Core Primitive in the Software Engineering Toolbox Onward ! ’20 , November 15 – 20 , 2020 , Chicago , IL x 1 x 2 y 1 y 2 α 1 α 2 Predecessor Successor NextTo : Left NextTo : Right n 1 s 1 n 2 s 2 αn αs Mα 1 Mα 2 IsAbs Abstraction αn αn αs Mα 1 Mα 2 Mα 1 Mα 2 Mα 1 Mα 2 Mα 1 Mα 2 IsAbs IsAbs Triplet Structure T12 Finally , by shading just the blue fact edge from αAB to C , we get Rule R6 that lifts a single fact into the abstraction . A B αAB C M A M B αM AB MαA MαB Abstraction IsAbs M A M B MαA MαB αM AB MαA MαB IsAbs IsAbs Triplet Structure Rule R6 Applying this rule with αAB = α 2 , C = Successor , and αM AB = αs completes the abstraction , giving the final ab - straction we saw earlier in Structure T9 , reproduced below . x 1 x 2 y 1 y 2 α 1 α 2 Predecessor Successor NextTo : Left NextTo : Right n 1 s 1 n 2 s 2 αn αs Mα 1 Mα 2 IsAbs Abstraction αn αn αs αs Mα 1 Mα 2 Mα 1 Mα 2 Mα 1 Mα 2 Mα 1 Mα 2 IsAbs IsAbs Triplet Structure T9 We encourage the motivated reader to consider interpreta - tions of different shadings . Of particular interest is if a node like B is shaded green , which corresponds to completing an analogy : constructing a concrete node that plays a particular role in an existing analogy . This shading of the rule proto - type is how Sifter generated the code in the bottom right of Figure 2 and Figure 4 . 4 . 6 Higher - Order Analogies and Slips We described in Section 4 . 3 that rules could be used to infer new facts , such as LetterSuccessor ( x 1 , x 2 ) . Such facts could later be used in analogies , e . g . , to compare ab and ef as “two - letter strings where the letters satisfy the LetterSuccessor relation” . To do this , we had to first explicitly add the facts LetterSuccessor ( x 1 , x 2 ) and LetterSuccessor ( y 1 , y 2 ) . In gen - eral , this approach requires us to explicitly enumerate rules for all such relations used in our analogies . This section con - siders a more general approach based on forming analogies between types in the structure . At first glance , it is tempting to resolve the issue using a general transitivity rule such that , for example , if x 1 is an instance of T 1 , x 2 is an instance of T 2 , and there is some fact R ( T 1 , T 2 ) , then we can add R ( x 1 , x 2 ) as well . For exam - ple , if LetterSuccessor ( Letter : a , Letter : b ) and x 1 was an instance of Letter : a , x 2 an instance of Letter : b , then the rule would infer LetterSuccessor ( x 1 , x 2 ) as desired . However , facts about types may not be valid or well - defined when applied to instances of those types . For example , when forming an analogy involving both numerical value and color we may have two nodes be instances of opposite numbers , e . g . , − 1 and 1 , or opposite colors , e . g . , black and white . If we were to directly use transitivity to say that the two nodes were simply “opposites , ” we would lose important informa - tion because we would not know whether they were opposite numbers or colors . Similarly , consider forming an analogy between the pairs abc → cba and efg → gfe . Fundamentally , what we want to express is that the letters in the first string satisfy either LetterSuccessor or LetterPredecessor , and that those in the second string satisfy the opposite . To express such scenarios naturally , we need a way to include the types in the analogy , i . e . , make a type slip . In the mapping rules shown so far , we require the both concrete nodes A and B to be of the same type C . However , we can define new mapping rules , using the template of Rule R7 , that allow the type itself to be abstracted and become part of the analogy . In the example discussed , we could have LetterSuccessor be C 1 and LetterPredecessor be C 2 . Onward ! ’20 , November 15 – 20 , 2020 , Chicago , IL Sotoudeh and Thakur A B αAB C 1 C 2 αC M A M B αM AB MαA MαB Abstraction IsAbs M A M B MαA MαA MαB MαB αM AB MαA MαB IsAbs IsAbs Triplet Structure Rule R7 Although allowing for creative analogies , such an ap - proach significantly increases the search space . To control this , one can make compound analogies , using type slips only for small sub - analogies with smaller search spaces . Then those analogies are used to define types with which to build up larger ones . For example , we could use a type slip to learn the abstract type of “pairs of nodes which are instances of types that have Successor relation , ” i . e . , effectively re - learn the LetterSuccessor relation on its own . Analogy - making rules could then be used to note that both x 1 , x 2 and y 1 , y 2 form an instance of this abstract type , and then the abstract type can be used exactly like Predecessor and Successor in future analogies . 4 . 7 Prototype Implementation and Optimizations We have implemented a proof - of - concept version of Sifter in Python , with hotspots written in C + + . We have run the demonstrations discussed in Section 3 on our prototype to verify that such analogies can be found , represented , and completed by Sifter . The project is divided into distinct components , including : TSLib , a library for declaring triplet structures and rules operating on them ; Abstracter , a collection of such rules which can be applied to build up analogies ; and TSRuntime , an interface for efficiently applying rules to a triplet - structure workspace and can optimize pattern matching , e . g . , by only checking parts of the structure that have changed since the pattern was last checked against . In its full generality , our update rule DSL is Turing - complete , and capable of expressing rules matching complex patterns . One useful feature of our system is its ability to express con - sistency constraints or desired invariants on the structure . For example , we may want to ensure that any symbol can either be an instance of Letter : a or Letter : b , but never both at the same time . Sifter supports consistency rules , which are just like normal update rules except ( 1 ) they are checked for matches every time the structure is modified , and ( 2 ) they force Sifter to backtrack when they match , i . e . undo the last modification . We optimized our implementation for efficient search through possible applications of update rules , described in more detail in Appendix A . The most impactful optimization has been the use of differential matching , where the design of our update rules allows us to restrict our search to only those assignments that make use of the facts added since we last checked for assignments , significantly reducing the amount of redundant time spent searching . More optimiza - tions are possible in the future , both in speeding up such a tree - search approach to analogy - making as well as by in - vestigating other architectures for making analogies within Sifter ( see Section 5 . 3 ) . 5 Efficient Software Analogies with Sifter This section discusses practical considerations with the ap - plication of Sifter to make analogies of the form shown in Section 3 . We focus on three particular factors , ( i ) the rep - resentation of source code as a triplet structure , ( ii ) the use of other sources of reasoning and information , and ( iii ) heuris - tics for finding analogies . In each section , we begin with a description of our current solution , then discuss our vision of what a future implementation may be able to accomplish . 5 . 1 Representing Source Code as Triplet Structures Currently , given a source file we perform a lightweight lex - ical analysis before encoding it in the structure . If more information about the meaning of some of the resulting lex - emes is known , we can include that as well . For example , given a source file consisting only of the statement name = user . name , we might encode it as shown in Structure T12 . NextTo : Left NextTo : Right Is“name” Is“ = ” Is“user” Is“ . ” File FileMember Object Access Field f ile . ext : name = user . name 1 1 2 2 3 3 4 4 5 5 5 6 6 6 6 6 6 7 8 9 10 11 Triplet Structure T12 For brevity , 11 fact nodes are not explicitly shown . However , their existence is implied by the colors and labels on the edges . We first create a node in the structure representing the file . For each lexeme in the file we add a correspond - ing node . Each lexeme node is marked as a member of the corresponding file , and their relative positions are specified using NextTo : Left and NextTo : Right . There are four nodes representing Platonic strings ( or ‘tokens’ ) , which play the same role as the Letter : a nodes in Section 4 . 3 or a unary IsLetterA ( x ) predicate . In this example , we assume addi - tional information about the language , namely that user . name represents an access of the name field of the user object . Notably , such a lexical analysis can usually be developed quite quickly even for new programming languages . At its Analogy - Making as a Core Primitive in the Software Engineering Toolbox Onward ! ’20 , November 15 – 20 , 2020 , Chicago , IL simplest , it can be implemented as just splitting the source file based on whitespace and special characters such as * . This allows for Sifter to be applicable to nascent DSLs and other languages where a full compiler and AST generator has not yet been developed , or to work with syntactically - invalid programs . As the language tooling grows in maturity or parts of the programs become syntactically valid , more detailed information can be produced from the lexing pass and included in the structure , such as the object - field access notated in the above example . Future Work : Full ASTs While the progressive - lexing style of encoding strikes a nice balance between flexibil - ity and richness , if a full AST is readily available for the code in question , then this can be used to produce a richer encod - ing of the structure . Structure T13 shows how an AST for the name = user . name example might be encoded as a triplet structure . AssiдnTo Assiдnment AssiдnFrom Identif ier “ name (cid:48)(cid:48) Identif ier “ user (cid:48)(cid:48) MemberExpr Object Property = name . user name 1 1 1 2 2 2 3 4 5 Triplet Structure T13 Future Work : Multiple Granularities One particularly exciting area of future work for our encoding is to allow the granularity of the encoding to change dynamically , as the analogy process is proceeding . In this model , the workspace would initially begin with only a listing of the names of files and folders in the root directory of the project ( s ) . As analogy - making proceeds , the contents of files may be added to the structure either randomly or according to activity from the analogy - making process itself . For example , if two files are named the same , they may be mapped together indicating their importance to the analogy and hinting to the system that the file contents might be important as well . If more semantic information about the programming languages is known , this type of multi - granularity encoding can be used at that level as well . For example , a file could be loaded first as just a list of functions contained in it . If two functions seem similar based on their signatures , then we expand them and include the full associated code in the workspace . Our current implementation supports such real - time mod - ifications to the structure , like adding a new file’s contents halfway during an analogy run . However , the heuristics for knowing when to do such are not yet developed , so we just add the full contents of the files to it at the start ( limiting us to small - ish projects ) . 5 . 2 Use of Other Engines Many other reasoning engines for both natural language and software source - code exist , including logic - based techniques ( such as Cyc [ 42 ] ) , abstract interpretation [ 14 ] , and statistical techniques ( such as deep learning [ 27 ] ) . We designed Sifter with the specific goal of easily integrating the knowledge stored in such tools with the analogy - making process . In particular , while we focused in Section 4 . 3 on the usage of update rules to make inferences about relations such as LetterSuccessor , there is no requirement that modifications to the structure come from such a update rule . Instead , other reasoning engines can provide their own insights into the problem at hand , which can then be translated into triplet facts and added to the structure . Such added facts are used in analogies just like any other facts . For example , a statistical model might be used to identify when words used are synonyms , which can be encoded into the workspace , e . g . , using a Synonym predicate or by stating that both words are instances of some common semantic notion . Similarly , a logical inference engine like Cyc [ 42 ] might be used to understand comments in , e . g . , function docstrings to identify the semantic meaning behind different functions , or infer the effects of applying multiple different functions in sequence . This information can be encoded back into the triplet structure and used to make analogies . Future Work : A Unified Workspace We envision that the triplet structure workspace of Sifter can serve as a shared workspace among a host of reasoning engines . The core analogy - making rules , which operate structurally , and are in some sense oblivious to the semantics of the relations , can act as glue that can help synthesize inferences across distinct reasoning engines . Reasoning engines can operate indepen - dently , inferring new facts and adding them to the structure . Furthermore , they may be able to use the facts inferred by other engines or even predicted to be true via analogy to further their own reasoning , resulting in a virtuous cycle of cooperation between different engines . Future Work : Probabilistic Triplet Structures To bet - ter interface with statistical models , it may be desirable to associate with each triplet fact a corresponding real - valued probability representing Sifter’s confidence in that inferred fact . As future inferences are made , their confidence val - ues can be computed as a function of the confidence in that specific step as well as the confidence in the facts it relies on to make that inference . However , as argued by the Cyc authors [ 42 ] , one should be careful in treating such numbers as a measure of truthfulness of a claim , and instead only as a representation of one’s epistemological uncertainty about immediate observations of the environment . Onward ! ’20 , November 15 – 20 , 2020 , Chicago , IL Sotoudeh and Thakur 5 . 3 Heuristics for and Identification of Strong Software Analogies To guide the search process , we need a notion of the strength of an analogy . One initial approach to this is to define a stronger analogy as one with more shared facts . This idea can be improved by weighting different types of relations with an importance . For a somewhat extreme example , we may prefer to map two functions together that share a relation of “called by analogous methods” rather than simply “share the same first letter . ” This approach is exemplified by the notion of a Slipnet in the Copycat architecture , which assign numerical , a priori importances to each type of relation . For scenarios where the goal of the analogy is to generate some completion ( as in Section 3 . 2 and 3 . 3 ) , we have found that an even stronger heuristic measure of analogy depth is to check if a full completion to the original problem can be made from it . In our experience , when we had bugs with our search process , we found that the completions produced in Figure 2 and 4 would either ( i ) contain very few nodes , or ( ii ) contain many nodes that the system thought would be there , but was not able to actually infer ( consistently ) what tokens they should be . This can be used to indicate when an analogy may fit the two examples very well , but does not generalize to the prompt . Future Work : Cognitive Models In the long term , we are excited about the possibility of having multiple workers that operate concurrently , either working on separate at - tempts at making such analogies , finding inconsistencies in analogies made by others , or working together to pro - duce a strong analogy . Such a system may take inspiration from psychology - inspired architectures and theories , like LIDA [ 22 ] and Global Workspace Theory [ 3 ] . Such a system could be supplemented via the use of something akin to ab - duction , where rules can request the help of other rules . For instance , an abstraction rule expressing that it would be able to abstract two things together if only one of them were also a letter successor would encourage rules to search for letter successor facts relating to that node . This abductive infer - ence is similar to the execution of the Slipnet and Coderack in the original Copycat algorithm . Future Work : Meta - Reasoning Sifter may be extended to support meta - reasoning similar to that of Metacat [ 49 ] , where the system learns to recognize common ‘snags’ that it can store and refer back to when it encounters a new problem that is challenging in the same way . It may recognize such “challenging in the same way” instances via a sort of meta - Sifter , forming analogies between solver states . In such a way , it would be able to effectively introspect on its own solving process via a ( copy of ) the solver itself . Such a system may be aided by the fact that our Sifter update rules can be expressed within triplet structures themselves . 6 Related Work Analogy making Analogies , and the more general class of metaphors [ 40 , 41 ] , have been studied extensively in cogni - tive science . The primary inspiration for this paper was the Copycat algorithm of Melanie Mitchell and Douglas Hofs - tadter [ 34 , 35 ] , which we generalized into the Sifter analogy - making algorithm presented here . Mitchell’s original source code [ 12 ] is written in a now - defunct dialect of Common Lisp for which we could not obtain an interpreter . Thank - fully , there are a number of more - modern ports [ 11 , 13 ] which we were able to reference and run . We originally in - tended to adapt these implementations for use on program source code , but quickly found that the Copycat algorithm is highly specific for the letter string domain . Adding sup - port even for upper - case letters , for example , turned out to be a significant project , touching almost every file in the implementation . This is because Copycat implements rela - tions like LetterPredecessor by special - case checks and data structures throughout the code , not as the sort of arbitrary relations that are more familiar in systems based on first - order logic . These issues motivated the construction of our Sifter analogy - making algorithm . Beyond Copycat , there are a number of other analogy - making algorithms explored in the cognitive science and philosophy literature , such as SME [ 20 ] , ACME [ 36 ] , Win - ston’s Analogy - Maker [ 87 ] , and the Geometric Analogy - Maker [ 19 ] . Below we will discuss SME , but ACME and Winston’s algorithm have a similar operation . The Geomet - ric Analogy - Maker is interesting and unique , incorporating some amount of grouping and representational manipulation similar to that of Copycat , although it is specific to geometric analogy problems . The Structure Mapping Engine ( SME ) [ 20 ] is an analogy - making algorithm that gained notoriety for , among other things , “discovering” the Rutherford model of the atom by analogy to a solar system [ 24 ] . Its basic operation is similar to that of a sub - graph isomorphism algorithm , in that it looks for an injective mapping between the objects and predicates in one structure into those of another that retains the facts . The SME algorithm has been criticized by some [ 34 ] for its reliance on hand - written input representations , which circumvents the hardest part of analogy - making . For exam - ple , when forming an analogy between the strings aaabbc and abbccc , it might be natural for a human to group the three aaa s and associate them either with the single a or the similar group - of - three ccc in the second . However , SME has no conception of modifying the structure , or its representa - tion of the structure , in such a way . The user would have to explicitly group letters before providing it to SME , at which point SME would just look for relations between groups . The Sifter workspace represents a its workspace using structures and relations . Similarly , TVLA [ 43 , 72 , 73 ] repre - sents possible program states using a variant of first - order Analogy - Making as a Core Primitive in the Software Engineering Toolbox Onward ! ’20 , November 15 – 20 , 2020 , Chicago , IL logic . In TVLA , such structures are abstracted into three - valued structures , somewhat similar to how we abstract con - crete instances in the workspace to form analogies . Comparative program understanding The problem of comparative program understanding is related to the prob - lem of code detection [ 23 , 38 , 39 , 48 , 71 ] with recent ap - proaches using deep learning [ 86 ] . CP - Miner identifies bugs related to copy - pasted code [ 44 ] . The func2vec technique computes function embeddings to learn function synonyms , which are functions are play a similar role in the source code [ 15 ] . Such function synonyms are used to identify error - handling bugs in the Linux kernel . The code2vec technique computes an embedding of source code using the AST [ 1 ] , which can be used to infer names of functions . These tech - niques represent a research thread that uses “Big Code” [ 84 ] . In contrast , Sifter uses relatively limited amount of source code to make analogies ; however , it can make use of models of source code learned via deep learning and other tech - niques . Program transformation - learning Recent approaches , such as GetAFix [ 4 ] , have explored the use of antiunification of program ASTs to learn program fixes . Such antiunification can be seen as a restricted special case of the analogy - as - abstraction process used by Sifter ( see Section 4 . 4 ) . Existing antiunification - based approaches , however , are limited to tree structures ( such as ASTs ) , and can not make use of addi - tional semantic information . For example , GetAFix would not have been able to accurately learn the transformation in Section 3 . 2 , which relied on semantic properties of the code , or the one in Section 3 . 3 , which relied on referencing the documentation . The program transformation - learning problem is related to Programming by Example [ 28 – 30 , 51 , 66 , 77 – 80 , 89 ] . Such techniques typically restrict the program transformation to a limited domain - specific language . Repenning et al . [ 68 ] describe how end - users of a programming - by - example sys - tem might use analogies to express the desired behavior by comparison to that of an existing program . Perrone et al . [ 61 ] propose that implementing code reuse via concrete analogies can be more natural than the use of standard object - oriented programming paradigms and help novice programmers avoid copy - and - pasting code . Recent approaches have explored using natural language and examples as input [ 67 ] and using deep learning techniques [ 83 ] . API Migration Many approaches for API migration that use statistical and machine learning techniques have been proposed [ 55 – 59 , 63 ] . Cognitive Science in SE There are numerous works which have highlighted the promise of models from cognitive sci - ence in software engineering . Call by Meaning [ 74 ] describes a system in which program components ( e . g . , functions ) can be addressed by their semantic meaning , not just their syntac - tic name . A programmer may describe an existing function using a high - level , semantic description language and the Cyc [ 42 ] cognitive model will be used to infer which ( com - position of ) function ( s ) best matches that description . The Semprola semiotic programming language [ 76 ] allows pro - grammers to directly use signs instead of the now - dominant focus on textual code symbols . Both Call by Meaning and Semprola are ambitious and exciting projects , requiring a fundamental re - thinking of how and in what languages we write code . While we envision that Sifter can benefit such approaches in the future , we are excited that , as described in Section 3 , Sifter can wield these cognitive models to more immediately benefit software engineers using the existing programming languages and environments of today . 7 Conclusion In this paper , we discussed analogy - making , a fundamental human ability that involves identifying underlying similari - ties between two objects . We first described analogy - making through examples in a restricted letter - string domain . We then showed how analogy - making can be used to address a variety of software engineering tasks , namely compara - tive program understanding , program optimization , and API migration . Finally , we described Sifter , our proposed al - gorithm for analogy - making , which is suitable for making analogies about programs . Sifter relies on a novel triplet - structure representation for its workspace , allowing it to form analogies over arbitrary inputs , such as source code , program analyzer outputs , and documentation . By reducing a variety of problems to analogy - making , improvements to the core analogy - making primitive can pay large dividends across a variety of applications . Software engineering repre - sents a difficult challenge for analogy - making , as it involves a unique balance of unambiguous syntax and semantics of the program , as well as ambiguous information about pro - grammer intent . We hope that this paper serves as a first step towards cementing analogy - making as a core primitive in the software engineering toolbox . Acknowledgments We thank the anonymous reviewers and Cindy Rubio Gonz ´ alez for comments that significantly improved this paper . References [ 1 ] Uri Alon , Meital Zilberstein , Omer Levy , and Eran Yahav . 2019 . code2vec : learning distributed representations of code . Proc . ACM Program . Lang . 3 , POPL ( 2019 ) , 40 : 1 – 40 : 29 . [ 2 ] Dennis Andriesse , Xi Chen , Victor Van Der Veen , Asia Slowinska , and Herbert Bos . 2016 . An in - depth analysis of disassembly on full - scale x86 / x64 binaries . In 25th { USENIX } Security Symposium ( { USENIX } Security 16 ) . 583 – 600 . [ 3 ] Bernard J Baars . 1993 . A cognitive theory of consciousness . Cambridge University Press . [ 4 ] Johannes Bader , Andrew Scott , Michael Pradel , and Satish Chandra . 2019 . Getafix : learning to fix bugs automatically . Proceedings of the ACM on Programming Languages 3 , OOPSLA ( 2019 ) , 1 – 27 . [ 5 ] Paul Bartha . 2019 . Analogy and Analogical Reasoning . In The Stanford Encyclopedia of Philosophy ( spring 2019 ed . ) , Edward N . Zalta ( Ed . ) . Onward ! ’20 , November 15 – 20 , 2020 , Chicago , IL Sotoudeh and Thakur Metaphysics Research Lab , Stanford University . [ 6 ] bash 2020 . fish - the friendly interactive shell . https : / / github . com / fish - shell / fish - shell . Accessed May , 2020 . [ 7 ] bash 2020 . GNU Bash . https : / / ftp . gnu . org / gnu / bash / . Accessed May , 2020 . [ 8 ] Fraser Brown , Andres N¨otzli , and Dawson Engler . 2016 . How to build static checking systems using orders of magnitude less code . In Pro - ceedings of the Twenty - First International Conference on Architectural Support for Programming Languages and Operating Systems . 143 – 157 . [ 9 ] JohnClement . 1993 . Usingbridginganalogiesandanchoringintuitions to deal with students’ preconceptions in physics . Journal of research in science teaching 30 , 10 ( 1993 ) , 1241 – 1257 . [ 10 ] CNN . 2020 . The ’beating hearts’ of these pulsating stars create mu - sic to astronomers’ ears . https : / / www . cnn . com / 2020 / 05 / 15 / world / pulsating - stars - delta - scuti - scn - trnd / index . html . Accessed May , 2020 . [ 11 ] copycat 2020 . Modern port of Melanie Mitchell’s and Douglas Hofs - tadter’s Copycat . https : / / github . com / fargonauts / copycat . Accessed May , 2020 . [ 12 ] copycat 2020 . Original Copycat Source Code . http : / / web . cecs . pdx . edu / ∼ mm / how - to - get - copycat . html . Accessed May , 2020 . [ 13 ] copycat 2020 . A translation of Melanie Mitchell’s original Copycat project from Lisp to Python . https : / / github . com / ajhager / copycat . Accessed May , 2020 . [ 14 ] Patrick Cousot and Radhia Cousot . 1977 . Abstract Interpretation : A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints . In POPL . ACM , 238 – 252 . [ 15 ] Daniel DeFreez , Aditya V . Thakur , and Cindy Rubio - Gonz´alez . 2018 . Path - based function embedding and its application to error - handling specification mining . In ESEC / SIGSOFT FSE . ACM , 423 – 433 . [ 16 ] Edoardo Di Napoli , Diego Fabregat - Traver , Gregorio Quintana - Ort´ı , and Paolo Bientinesi . 2014 . Towards an efficient use of the BLAS library for multilinear tensor contractions . Appl . Math . Comput . 235 ( 2014 ) , 454 – 468 . [ 17 ] Sarah A Douglas and Thomas P Moran . 1983 . Learning text editor se - mantics by analogy . In Proceedings of the SIGCHI conference on Human Factors in Computing Systems . 207 – 211 . [ 18 ] Enda Dunican . 2002 . Making the Analogy : Alternative Delivery Tech - niques for First Year Programming Courses . In Proceedings of the 14th Annual Workshop of the Psychology of Programming Interest Group , PPIG 2002 , London , UK , June 18 - 21 , 2002 . Psychology of Programming Interest Group , 8 . [ 19 ] Thomas G Evans . 1964 . A heuristic program to solve geometric - analogy problems . In Proceedings of the April 21 - 23 , 1964 , spring joint computer conference . 327 – 338 . [ 20 ] Brian Falkenhainer , Kenneth D Forbus , and Dedre Gentner . 1989 . The structure - mapping engine : Algorithm and examples . Artificial intelli - gence 41 , 1 ( 1989 ) , 1 – 63 . [ 21 ] Michal Foriˇsek and Monika Steinov´a . 2012 . Metaphors and analogies for teaching algorithms . In Proceedings of the 43rd ACM technical symposium on Computer Science Education . 15 – 20 . [ 22 ] Stan Franklin , Tamas Madl , Sidney Dfimello , and Javier Snaider . 2013 . LIDA : A systems - level architecture for cognition , emotion , and learn - ing . IEEE Transactions on Autonomous Mental Development 6 , 1 ( 2013 ) , 19 – 41 . [ 23 ] Mark Gabel , Lingxiao Jiang , and Zhendong Su . 2008 . Scalable detec - tion of semantic clones . In 30th International Conference on Software Engineering ( ICSE 2008 ) , Leipzig , Germany , May 10 - 18 , 2008 . 321 – 330 . [ 24 ] Dedre Gentner . 1983 . Structure - mapping : A theoretical framework for analogy . Cognitive science 7 , 2 ( 1983 ) , 155 – 170 . [ 25 ] DedreGentner , JeffreyLoewenstein , andLeighThompson . 2003 . Learn - ing and transfer : A general role for analogical encoding . Journal of Educational Psychology 95 , 2 ( 2003 ) , 393 . [ 26 ] Nasser Giacaman . 2012 . Teaching by example : using analogies and live coding demonstrations to teach parallel computing concepts to undergraduate students . In 2012 IEEE 26th International Parallel and DistributedProcessingSymposiumWorkshops & PhDForum . IEEE , 1295 – 1298 . [ 27 ] Ian Goodfellow , Yoshua Bengio , and Aaron Courville . 2016 . Deep learning . MIT press . [ 28 ] Sumit Gulwani . 2011 . Automating string processing in spreadsheets using input - output examples . In Proceedings of the 38th ACM SIGPLAN - SIGACT Symposium on Principles of Programming Languages , POPL 2011 , Austin , TX , USA , January 26 - 28 , 2011 . 317 – 330 . [ 29 ] Sumit Gulwani . 2017 . Programming by examples : applications , algo - rithms , and ambiguity resolution . In Proceedings of the 19th Interna - tional Symposium on Principles and Practice of Declarative Program - ming , Namur , Belgium , October 09 - 11 , 2017 . 2 . [ 30 ] Sumit Gulwani and Prateek Jain . 2017 . Programming by Examples : PL Meets ML . In Programming Languages and Systems - 15th Asian Sym - posium , APLAS 2017 , Suzhou , China , November 27 - 29 , 2017 , Proceedings . 3 – 20 . [ 31 ] Rahul Gupta , Aditya Kanade , and Shirish Shevade . 2019 . Deep rein - forcement learning for syntactic error repair in student programs . In Proceedings of the AAAI Conference on Artificial Intelligence , Vol . 33 . 930 – 937 . [ 32 ] Jeisson Hidalgo - C´espedes , Gabriela Mar´ın - Ravent´os , and Vladimir Lara - Villagr´an . 2014 . Playing with metaphors : a methodology to design video games for learning abstract programming concepts . In Proceedings of the 2014 conference on Innovation & technology in com - puter science education . 348 – 348 . [ 33 ] Douglas Hofstadter . 1995 . A Review of Mental Leaps : Analogy in Creative Thought . AI Magazine 16 , 3 ( 1995 ) , 75 – 80 . [ 34 ] Douglas R Hofstadter . 1995 . Fluid concepts and creative analogies : Computer models of the fundamental mechanisms of thought . Basic books . [ 35 ] Douglas R Hofstadter and Melanie Mitchell . 1994 . The Copycat project : A model of mental fluidity and analogy - making . ( 1994 ) . [ 36 ] Keith J Holyoak and Paul Thagard . 1989 . Analogical mapping by constraint satisfaction . Cognitive science 13 , 3 ( 1989 ) , 295 – 355 . [ 37 ] Shalini Kaleeswaran , Anirudh Santhiar , Aditya Kanade , and Sumit Gulwani . 2016 . Semi - Supervised Verified Feedback Generation . In Proceedings of the 2016 24th ACM SIGSOFT International Symposium on Foundations of Software Engineering ( Seattle , WA , USA ) ( FSE 2016 ) . Association for Computing Machinery , New York , NY , USA , 739fi?!750 . https : / / doi . org / 10 . 1145 / 2950290 . 2950363 [ 38 ] Toshihiro Kamiya , Shinji Kusumoto , and Katsuro Inoue . 2002 . CCFinder : a multilinguistic token - based code clone detection system for large scale source code . IEEE Transactions on Software Engineering 28 , 7 ( 2002 ) , 654 – 670 . [ 39 ] Raghavan Komondoor and Susan Horwitz . 2001 . Using Slicing to Identify Duplication in Source Code . In Static Analysis , 8th Interna - tional Symposium , SAS 2001 , Paris , France , July 16 - 18 , 2001 , Proceedings . 40 – 56 . [ 40 ] George Lakoff and Mark Johnson . 2008 . Metaphors we live by . Univer - sity of Chicago press . [ 41 ] George Lakoff and Rafael N´u˜nez . 2000 . Where mathematics comes from . Vol . 6 . New York : Basic Books . [ 42 ] Douglas B Lenat . 1995 . CYC : A large - scale investment in knowledge infrastructure . Commun . ACM 38 , 11 ( 1995 ) , 33 – 38 . [ 43 ] Tal Lev - Ami and Shmuel Sagiv . 2000 . TVLA : A System for Implement - ing Static Analyses . In Static Analysis , 7th International Symposium , SAS 2000 , Santa Barbara , CA , USA , June 29 - July 1 , 2000 , Proceed - ings ( Lecture Notes in Computer Science , Vol . 1824 ) , Jens Palsberg ( Ed . ) . Springer , 280 – 301 . https : / / doi . org / 10 . 1007 / 978 - 3 - 540 - 45099 - 3 15 [ 44 ] Zhenmin Li , Shan Lu , Suvda Myagmar , and Yuanyuan Zhou . 2006 . CP - Miner : Finding copy - paste and related bugs in large - scale software code . IEEE Transactions on software Engineering 32 , 3 ( 2006 ) , 176 – 192 . [ 45 ] Sifei Luan , Di Yang , Celeste Barnaby , Koushik Sen , and Satish Chan - dra . 2019 . Aroma : Code recommendation via structural code search . Proceedings of the ACM on Programming Languages 3 , OOPSLA ( 2019 ) , Analogy - Making as a Core Primitive in the Software Engineering Toolbox Onward ! ’20 , November 15 – 20 , 2020 , Chicago , IL 1 – 28 . [ 46 ] Katherine N Macfarlane and Barbee T Mynatt . 1988 . A study of an advance organizer as a technique for teaching computer programming concepts . ACM SIGCSE Bulletin 20 , 1 ( 1988 ) , 240 – 243 . [ 47 ] Solomon Maina , Anders Miltner , Kathleen Fisher , Benjamin C Pierce , David Walker , and Steve Zdancewic . 2018 . Synthesizing quotient lenses . Proceedings of the ACM on Programming Languages 2 , ICFP ( 2018 ) , 1 – 29 . [ 48 ] Andrian Marcus and Jonathan I Maletic . 2001 . Identification of high - level concept clones in source code . In Proceedings 16th Annual Inter - national Conference on Automated Software Engineering ( ASE 2001 ) . IEEE , 107 – 114 . [ 49 ] James B Marshall . 2000 . Metacat : A self - watching cognitive architec - ture for analogy - making and high - level perception . ( 2000 ) . [ 50 ] Anders Miltner , Kathleen Fisher , Benjamin C Pierce , David Walker , and Steve Zdancewic . 2017 . Synthesizing bijective lenses . Proceedings of the ACM on Programming Languages 2 , POPL ( 2017 ) , 1 – 30 . [ 51 ] Anders Miltner , Sumit Gulwani , Vu Le , Alan Leung , Arjun Rad - hakrishna , Gustavo Soares , Ashish Tiwari , and Abhishek Udupa . 2019 . On the Fly Synthesis of Edit Suggestions . Proc . ACM Pro - gram . Lang . 3 , OOPSLA , Article 143 ( Oct . 2019 ) , 29 pages . https : / / doi . org / 10 . 1145 / 3360569 [ 52 ] Marvin Lee Minsky . [ n . d . ] . Logical vs . Analogical ; or Symbolic vs . Connectionist ; or Neat vs . Scruffy . ( [ n . d . ] ) . [ 53 ] Matthew W Moskewicz , Conor F Madigan , Ying Zhao , Lintao Zhang , and Sharad Malik . 2001 . Chaff : Engineering an efficient SAT solver . In Proceedings of the 38th annual Design Automation Conference . 530 – 535 . [ 54 ] Robert F Nelson . 1975 . Use of analogy as a learning - teaching tool . Journal of Geography 74 , 2 ( 1975 ) , 83 – 86 . [ 55 ] Anh Tuan Nguyen , Hoan Anh Nguyen , Tung Thanh Nguyen , and Tien N . Nguyen . 2014 . Statistical learning approach for mining API usage mappings for code migration . In ACM / IEEE International Con - ference on Automated Software Engineering , ASE ’14 , Vasteras , Sweden - September 15 - 19 , 2014 . 457 – 468 . [ 56 ] Anh Tuan Nguyen , Hoan Anh Nguyen , Tung Thanh Nguyen , and Tien N . Nguyen . 2014 . Statistical learning of API mappings for lan - guage migration . In 36th International Conference on Software Engi - neering , ICSE ’14 , Companion Proceedings , Hyderabad , India , May 31 - June 07 , 2014 . 618 – 619 . [ 57 ] Trong Duc Nguyen , Anh Tuan Nguyen , and Tien N . Nguyen . 2016 . Mapping API elements for code migration with vector representa - tions . In Proceedings of the 38th International Conference on Software Engineering , ICSE 2016 , Austin , TX , USA , May 14 - 22 , 2016 - Companion Volume . 756 – 758 . [ 58 ] Trong Duc Nguyen , Anh Tuan Nguyen , Hung Dang Phan , and Tien N . Nguyen . 2017 . Exploring API embedding for API usages and applica - tions . In Proceedings of the 39th International Conference on Software Engineering , ICSE 2017 , Buenos Aires , Argentina , May 20 - 28 , 2017 . 438 – 449 . [ 59 ] Tien N . Nguyen . 2016 . Code migration with statistical machine trans - lation . In Proceedings of the 5th International Workshop on Software Mining , SoftwareMining @ ASE 2016 , Singapore , Singapore , September 3 , 2016 . 2 . [ 60 ] Emma Nilsson - Nyman , Torbj¨orn Ekman , and G¨orel Hedin . 2008 . Prac - tical scope recovery using bridge parsing . In International Conference on Software Language Engineering . Springer , 95 – 113 . [ 61 ] Corrina Perrone and Alexander Repenning . 1998 . Graphical rewrite rule analogies : avoiding the inherit or copy and paste reuse dilemma . In Proceedings . 1998 IEEE Symposium on Visual Languages . IEEE , 40 – 46 . [ 62 ] Frank Pfenning . 1991 . Unification and Anti - Unification in the Calculus of Constructions . In In Sixth Annual IEEE Symposium on Logic in Computer Science . 74 – 85 . [ 63 ] Hung Dang Phan , Anh Tuan Nguyen , Trong Duc Nguyen , and Tien N . Nguyen . 2017 . Statistical migration of API usages . In Proceedings of the 39th International Conference on Software Engineering , ICSE 2017 , Buenos Aires , Argentina , May 20 - 28 , 2017 - Companion Volume . 47 – 50 . [ 64 ] Noah S Podolefsky and Noah D Finkelstein . 2006 . Use of analogy in learning physics : The role of representations . Physical Review Special Topics - Physics Education Research 2 , 2 ( 2006 ) , 020101 . [ 65 ] Veselin Raychev , Martin Vechev , and Andreas Krause . 2015 . Predicting programpropertiesfrom”bigcode” . ACMSIGPLANNotices 50 , 1 ( 2015 ) , 111 – 124 . [ 66 ] Mohammad Raza and Sumit Gulwani . 2018 . Disjunctive Program Synthesis : A Robust Approach to Programming by Example . In Pro - ceedings of the Thirty - Second AAAI Conference on Artificial Intelligence , ( AAAI - 18 ) , the 30th innovative Applications of Artificial Intelligence ( IAAI - 18 ) , and the 8th AAAI Symposium on Educational Advances in Artificial Intelligence ( EAAI - 18 ) , New Orleans , Louisiana , USA , February 2 - 7 , 2018 . 1403 – 1412 . [ 67 ] Mohammad Raza , Sumit Gulwani , and Natasa Milic - Frayling . 2015 . Compositional Program Synthesis from Natural Language and Exam - ples . In Proceedings of the Twenty - Fourth International Joint Conference on Artificial Intelligence , IJCAI 2015 , Buenos Aires , Argentina , July 25 - 31 , 2015 . 792 – 800 . [ 68 ] Alexander Repenning and Corrina Perrone . 2000 . Programming by example : programming by analogous examples . Commun . ACM 43 , 3 ( 2000 ) , 90 – 97 . [ 69 ] Lindsey E Richland , Keith J Holyoak , and James W Stigler . 2004 . Anal - ogy use in eighth - grade mathematics classrooms . Cognition and in - struction 22 , 1 ( 2004 ) , 37 – 60 . [ 70 ] Lindsey E Richland , Osnat Zur , and Keith J Holyoak . 2007 . Cognitive supports for analogies in the mathematics classroom . Science 316 , 5828 ( 2007 ) , 1128 – 1129 . [ 71 ] Chanchal K Roy , James R Cordy , and Rainer Koschke . 2009 . Compari - son and evaluation of code clone detection techniques and tools : A qualitative approach . Science of computer programming 74 , 7 ( 2009 ) , 470 – 495 . [ 72 ] Shmuel Sagiv , Thomas W . Reps , and Reinhard Wilhelm . 1999 . Para - metric Shape Analysis via 3 - Valued Logic . In POPL ’99 , Proceedings of the 26th ACM SIGPLAN - SIGACT Symposium on Principles of Pro - gramming Languages , San Antonio , TX , USA , January 20 - 22 , 1999 , Andrew W . Appel and Alex Aiken ( Eds . ) . ACM , 105 – 118 . https : / / doi . org / 10 . 1145 / 292540 . 292552 [ 73 ] Shmuel Sagiv , Thomas W . Reps , and Reinhard Wilhelm . 2002 . Para - metric shape analysis via 3 - valued logic . ACM Trans . Program . Lang . Syst . 24 , 3 ( 2002 ) , 217 – 298 . https : / / doi . org / 10 . 1145 / 514188 . 514190 [ 74 ] Hesam Samimi , Chris Deaton , Yoshiki Ohshima , Alessandro Warth , and Todd Millstein . 2014 . Call by meaning . In Proceedings of the 2014 ACM International Symposium on New Ideas , New Paradigms , and Reflections on Programming & Software . 11 – 28 . [ 75 ] Yam San Chee . 1993 . Applying Gentner’s theory of analogy to the teaching of computer programming . International journal of man - machine studies 38 , 3 ( 1993 ) , 347 – 368 . [ 76 ] Oli Sharpe . 2018 . Semprola : a semiotic programming language . In Con - ference Companion of the 2nd International Conference on Art , Science , and Engineering of Programming . 202 – 213 . [ 77 ] Rishabh Singh . 2016 . BlinkFill : Semi - supervised Programming By Example for Syntactic String Transformations . Proc . VLDB Endow . 9 , 10 ( 2016 ) , 816 – 827 . [ 78 ] Rishabh Singh and Sumit Gulwani . 2012 . Learning Semantic String Transformations from Examples . Proc . VLDB Endow . 5 , 8 ( 2012 ) , 740 – 751 . [ 79 ] Rishabh Singh and Sumit Gulwani . 2016 . Transforming spreadsheet data types using examples . In Proceedings of the 43rd Annual ACM SIGPLAN - SIGACT Symposium on Principles of Programming Languages , POPL 2016 , St . Petersburg , FL , USA , January 20 - 22 , 2016 . 343 – 356 . [ 80 ] David Canfield Smith . 1975 . Pygmalion : a creative programming en - vironment . Technical Report . STANFORD UNIV CA DEPT OF COM - PUTER SCIENCE . Onward ! ’20 , November 15 – 20 , 2020 , Chicago , IL Sotoudeh and Thakur [ 81 ] Dawn Song , David Brumley , Heng Yin , Juan Caballero , Ivan Jager , Min Gyung Kang , Zhenkai Liang , James Newsome , Pongsin Poosankam , and Prateek Saxena . 2008 . BitBlaze : A new approach to computer security via binary analysis . In International Conference on Information Systems Security . Springer , 1 – 25 . [ 82 ] Matthew Sotoudeh , Anand Venkat , Michael Anderson , Evangelos Georganas , Alexander Heinecke , and Jason Knight . 2019 . ISA mapper : a compute and hardware agnostic deep learning compiler . In Proceed - ings of the 16th ACM International Conference on Computing Frontiers . 164 – 173 . [ 83 ] Marko Vasic , Aditya Kanade , Petros Maniatis , David Bieber , and Rishabh Singh . 2019 . Neural Program Repair by Jointly Learning to Localize and Repair . In 7th International Conference on Learning Representations , ICLR 2019 , New Orleans , LA , USA , May 6 - 9 , 2019 . [ 84 ] Martin T . Vechev and Eran Yahav . 2016 . Programming with ”Big Code” . Found . Trends Program . Lang . 3 , 4 ( 2016 ) , 231 – 284 . https : / / doi . org / 10 . 1561 / 2500000028 [ 85 ] Matthias Wenzl , Georg Merzdovnik , Johanna Ullrich , and Edgar Weippl . 2019 . From hack to elaborate techniquefi!?a survey on bi - nary rewriting . ACM Computing Surveys ( CSUR ) 52 , 3 ( 2019 ) , 1 – 37 . [ 86 ] Martin White , Michele Tufano , Christopher Vendome , and Denys Poshyvanyk . 2016 . Deep learning code fragments for code clone de - tection . In 2016 31st IEEE / ACM International Conference on Automated Software Engineering ( ASE ) . IEEE , 87 – 98 . [ 87 ] Patrick H Winston . 1980 . Learning and reasoning by analogy . Com - mun . ACM 23 , 12 ( 1980 ) , 689 – 703 . [ 88 ] Edmund Wong , Taiyue Liu , and Lin Tan . 2015 . Clocom : Mining existing source code for automatic comment generation . In 2015 IEEE 22nd International Conference on Software Analysis , Evolution , and Reengineering ( SANER ) . IEEE , 380 – 389 . [ 89 ] Moshe M . Zloof . 1977 . Query - by - example : A data base language . IBM systems Journal 16 , 4 ( 1977 ) , 324 – 343 . Analogy - Making as a Core Primitive in the Software Engineering Toolbox Onward ! ’20 , November 15 – 20 , 2020 , Chicago , IL A Efficient Implementation of Sifter A . 1 Efficient Rule Matching in Triplet Structures Most operations on the workspace need to quickly look for patterns in the triplet structure . Therefore , it is useful to rep - resent the triplet structure in such a way that many lookups are fast . Thankfully , because of the uniformity of the triplet representation , we can do this . Internally , we represent triplet structures by a hashmap , which takes triplets with holes to a list of triplets . In the example from Section 4 . 1 , we would associate with the key ( ? , ? , NextTo : Left ) the set of facts { ( f 1 , a , NextTo : Left ) , ( f 2 , b , NextTo : Left ) } . When adding a new fact to the structure , we add it to the 2 3 = 8 hashmaps formed by replacing some subset of its indices with a hole . This is a relatively manageable constant - factor overhead . With this representation , we can reduce looking for a node satisfying some pattern to simply intersecting sets . For example , if we wanted to find a node v which is “in the middle of a string , ” i . e . to the left of some node and to the right of another , we would use the constraints ( ? , v , NextTo : Left ) and ( ? , v , NextTo : Right ) . Since these are existential constraints in only a single variable , we can solve them by intersecting { t 2 | ( t 1 , t 2 , t 3 ) ∈ H [ ( ? , ? , NextTo : Left ) ] } ∩ { t 2 | ( t 1 , t 2 , t 3 ) ∈ H [ ( ? , ? , NextTo : Right ) ] } . Solving more complex constraints ( e . g . , finding multiple nodes which together satisfy some constraints ) is still an NP - hard constraint satisfaction problem in triplet structures , but such efficient single - variable existential lookups helps form the core of our solver for more complex constraint problems . A . 2 Differential , Symmetric , and Local Rule Matching In addition to efficiently storing the triplet structures , Sifter uses the following three other optimizations to speed up rule pattern matching . First , Sifter makes use of differential matching . The fun - damental observation is that , at least for the first existential layer of a rule , adding facts to the structure can only ever add more possible rule assignments , so every such new rule assignment must use one of the newly - added facts . Hence , Sifter can keep track of which facts have been added to the structure since it last looked for rule assignments , and only consider assignments which use those new facts . A similar technique works for filtering out old assignments that use removed facts . Second , we note that many rules have symmetries , where a valid variable assignment can be permuted to form a new valid variable assignment . Under certain conditions , Sifter can take advantage of these symmetries to only search for assignments to half of the variables , then consider all per - mutations to get the rest of the variables . Finally , heuristics can be used to localize the rules . For ex - ample , Sifter can only look for rules that match to symbols nearby a symbol modified on the last update rule application ( this is similar to the operation of the Slipnet in Copycat ) . A . 3 Commutative Node Names Many interesting search heuristics require reasoning across different branches of the search tree . For example , phase saving is used by SAT solvers such as Chaff [ 53 ] , where after backtracking and choosing another assignment to variable v i , the solver will attempt to perform the same assignments to v j for j > i as were made before the backtrack . To apply analogous heuristics to the type of search over update rule applications in Sifter , we need to be particu - larly careful about how we reference nodes in the structure . This is because rules can operate on nodes created by other rules . If we give newly - created nodes random names , or use something like a global counter to name them uniquely , then when trying to re - apply any rules that referenced nodes cre - ated after the point of backtracking will fail , because those exact nodes no longer exist , even if nodes playing exactly the same role were created exactly the same way in the new branch . To address this issue , we name nodes according to a hash of the rule and pattern assignment that produced them . Mod - ulo hash collisions and applying the same rule to the same assignment twice , this makes node names commutative with the exact order of applying update rules and allows us to attempt the same rule assignment before and after a back - track . An alternative to this solution would be to explicitly keep information about the provenance of such generated nodes and refer to it when necessary . If such information is further stored in the structure itself , it could be used to perform Meta - cat [ 49 ] style meta - reasoning , as discussed in Section 5 . 3 .