January 2006 A SEQUENTIAL IMPORTANCE SAMPLING ALGORITHM FOR GENERATING RANDOM GRAPHS WITH PRESCRIBED DEGREES By Joseph Blitzstein and Persi Diaconis ∗ Stanford University Random graphs with a given degree sequence are a useful model capturing several features absent in the classical Erd˝os - R´enyi model , such as dependent edges and non - binomial degrees . In this paper , we use a characterization due to Erd˝os and Gallai to develop a sequential algorithm for generating a random labeled graph with a given degree sequence . The algorithm is easy to implement and allows surprisingly eﬃcient sequential importance sampling . Applications are given , in - cluding simulating a biological network and estimating the number of graphs with a given degree sequence . 1 . Introduction . Random graphs with given vertex degrees have recently attracted great interest as a model for many real - world complex networks , including the World Wide Web , peer - to - peer networks , social networks , and biological networks . Newman [ 56 ] contains an excellent survey of these networks , with extensive references . A common approach to simulating these systems is to study ( empirically or theoretically ) the degrees of the vertices in instances of the network , and then to generate a random graph with the appropriate degrees . Graphs with prescribed degrees also appear in random matrix theory and string theory , which can call for large simulations based on random k - regular graphs . Throughout , we are concerned with generating simple graphs , i . e . , no loops or multiple edges are allowed ( the problem becomes considerably easier if loops and multiple edges are allowed ) . The main result of this paper is a new sequential importance sampling algorithm for generating random graphs with a given degree sequence . The idea is to build up the graph sequentially , at each stage choosing an edge from a list of candidates with probability proportional to the degrees . Most previously studied algorithms for this problem sometimes either get stuck or produce loops or multiple edges in the output , which is handled by starting over and trying again . Often for such algorithms , the probability of a restart being needed on a trial rapidly approaches 1 as the degree parameters grow , resulting in an enormous number of trials being needed on average to obtain a simple graph . A major advantage of our algorithm is that it never gets stuck . This is achieved using the Erd˝os - Gallai characterization , which is explained in Section 2 , and a carefully chosen order of edge selection . ∗ Research supported by NSF grants DMS 0072360 , 1 - 24685 - 1 - QABKW , and 1088720 - 100 - QALGE . AMS 2000 subject classiﬁcations : 05C07 , 05C80 , 68W20 , 65C05 . Keywords and phrases : graphical degree sequences , random graphs , random networks , randomized gen - erating algorithms , exponential models , sequential importance sampling . 1 2 J . BLITZSTEIN AND P . DIACONIS For example , the graph in Figure 1 is the observed food web of 33 types of organisms ( such as bacteria , oysters , and catﬁsh ) in the Chesapeake Bay during the summer . The data is from Baird and Ulanowicz [ 5 ] and is available online at [ 75 ] . Each vertex represents one of the 33 types of organisms , and an edge between two vertices indicates that one preys upon the other . We represent this as an undirected graph for this example , though it is clearly more natural to use a directed graph : it matters whether x eats y or y eats x ( especially to x and y ) . Nevertheless , we will see in Section 11 that the undirected food web reveals interesting information about the connectivity and common substructures in the food web . The blue crab , which is cannibalistic , is represented by vertex 19 ; we have omitted the loop at vertex 19 , not for any moral reason but because we are considering simple graphs . 1 7 8 11 12 13 22 23 9 10 20 21 24 19 26 27 28 32 33 30 31 2 3 14 15 16 17 18 25 29 4 5 6 Fig 1 . food web for the Chesapeake Bay ecosystem in summer The degree sequence of the above graph is d = ( 7 , 8 , 5 , 1 , 1 , 2 , 8 , 10 , 4 , 2 , 4 , 5 , 3 , 6 , 7 , 3 , 2 , 7 , 6 , 1 , 2 , 9 , 6 , 1 , 3 , 4 , 6 , 3 , 3 , 3 , 2 , 4 , 4 ) . Applying importance sampling as explained in Section 9 gave ( 1 . 51 ± 0 . 03 ) × 10 57 as the estimated number of graphs with the same degree sequence d . A natural way to test properties of the food web is to condition on the degree sequence , generate a large number of random graphs with the same degree sequence , and then see how the actual food web compares . See Section 11 for details of such a conditional test for this example , using 6000 random graphs with degree sequence d generated by our algorithm . Section 3 reviews several previous algorithms for our problem . There has been exten - sive recent development of algorithms for generating random graphs with a given degree ALGORITHM FOR GRAPHS WITH PRESCRIBED DEGREES 3 distribution or given expected degrees . Britton , Deijfen and Martin - L¨of [ 13 ] give several algorithms which they show asymptotically produce random graphs with a given degree distribution . Chung and Lu [ 17 , 18 ] analyze random graphs with given expected degrees ( with loops allowed ) . However , these algorithms and models are not suitable for applica - tions where exactly speciﬁed degrees are desired , such as generating or enumerating random k - regular graphs or the model - testing applications of Section 11 . Section 4 presents our algorithm , and Section 5 gives a proof that the algorithm works . The algorithm relies on an extension of the Erd˝os - Gallai Theorem handling the case where certain edges are forced ( required to be used ) ; this is discussed in Section 6 . This is followed in Section 7 by some estimates of the running time . Section 10 specializes to random trees with a given degree sequence . The probability of a given output for our algorithm is explicitly computable . The out - put distribution is generally non - uniform , but the random graphs produced can be used to simulate a general distribution via importance sampling . These ideas are discussed in Section 8 , which reviews the literature on importance sampling and sequential importance sampling and shows how they can be used with our algorithm . Applications to approxi - mately enumerating graphs with a given degree sequence are then given in Section 9 . Lastly , in Section 11 we describe an exponential family where the degrees are suﬃcient statistics , and use the algorithm to test this model on the food web example . 2 . Graphical Sequences . Definition 1 . A ﬁnite sequence ( d 1 , . . . , d n ) of nonnegative integers ( n ≥ 1 ) is called graphical if there is a labeled simple graph with vertex set { 1 , . . . , n } , in which vertex i has degree d i . Such a graph is called a realization of the degree sequence ( d 1 , . . . , d n ) . We will call the sequence ( d 1 , . . . , d n ) a degree sequence regardless of whether or not it is graphical . Graphical sequences are sometimes also called graphic or realizable . Note that if ( d 1 , . . . , d n ) is graphical , then P ni = 1 d i is even since in any graph , the sum of the degrees is twice the number of edges . Also , it is obviously necessary that 0 ≤ d i ≤ n − 1 for all i ; the extremes d i = 0 and d i = n − 1 correspond to an isolated vertex and a vertex connected by edges to all other vertices , respectively . There are many well - known eﬃcient tests of whether a sequence is graphical . For ex - ample , Mahadev and Peled [ 49 ] list eight equivalent necessary and suﬃcient conditions for graphicality . The most famous criterion for graphicality is due to Erd˝os and Gallai [ 25 ] : Theorem 1 ( Erd˝os - Gallai ) . Let d 1 ≥ d 2 ≥ · · · ≥ d n be nonnegative integers with P ni = 1 d i even . Then d = ( d 1 , . . . , d n ) is graphical if and only if k X i = 1 d i ≤ k ( k − 1 ) + n X i = k + 1 min ( k , d i ) for each k ∈ { 1 , . . . , n } . 4 J . BLITZSTEIN AND P . DIACONIS The necessity of these conditions is not hard to see : for any set S of k vertices in a realization of d , there are at most (cid:0) k 2 (cid:1) “internal” edges within S , and for each vertex v / ∈ S , there are at most min ( k , deg ( v ) ) edges from v into S . The suﬃciency of the Erd˝os - Gallai conditions is more diﬃcult to show . Many proofs have been given , including the original in Hungarian [ 25 ] , a proof using network ﬂows in Berge [ 9 ] , and a straightforward but tedious induction on the sum of the degrees by Choudum [ 16 ] . Note that the Erd˝os - Gallai conditions can be checked using Θ ( n ) arithmetic operations and comparisons and Θ ( n ) space , as we can compute and cache the n partial sums of the degrees and for each k the largest i with min ( k , d i ) = k ( if any exists ) , and there are n inequalities to check . The Erd˝os - Gallai conditions have been reﬁned somewhat , e . g . , it is easy to show that it only necessary to check up to k = n − 1 ( for n ≥ 2 ) , and Tripathi and Vijay [ 74 ] showed that the number of inequalities to be checked can be reduced to the number of distinct entries in d . However , these reductions still require checking Θ ( n ) inequalities in general . Also note that d needs to be sorted initially if not already given in that form . This can be done in O ( n log n ) time using a standard sorting algorithm such as merge - sort . Instead of having to test all of the inequalities in the Erd˝os - Gallai conditions , it is often convenient to have a recursive test . A particularly simple recursive test was found independently by Havel [ 34 ] and Hakimi [ 32 ] . We include the proof since it is instructive and will be useful below . Theorem 2 ( Havel - Hakimi ) . Let d be a degree sequence of length n ≥ 2 and let i be a coordinate with d i > 0 . If d does not have at least d i positive entries other than i , then d is not graphical . Assume that there are at least d i positive entries other than at i . Let ˜ d be the degree sequence of length n − 1 obtained from d by deleting coordinate i and subtracting 1 from the d i coordinates in d of highest degree , aside from i itself . Then d is graphical if and only if ˜ d is graphical . Moreover , if d is graphical , then it has a realization in which vertex i is joined to any choice of the d i highest degree vertices other than vertex i . Proof . If d does not have at least d i positive entries other than i , then there are not enough vertices to attach i to , so d is not graphical . So assume that there are at least d i positive entries aside from i . It is immediate that if ˜ d is graphical , then d is graphical : take a realization of ˜ d ( with labels ( 1 , 2 , . . . , i − 1 , i + 1 , . . . , n ) ) , introduce a new vertex labeled i , and join i to the d i vertices whose degrees had 1 subtracted from them . Conversely , assume that d is graphical , and let G be a realization of d . Let h 1 , . . . , h d i be a choice of the d i highest degree vertices other than vertex i ( so deg ( h j ) ≥ deg ( v ) for all v / ∈ { i , h 1 , . . . , h d i } ) . We are done if vertex i is already joined to all of the h j , since then we can delete vertex i and its edges to obtain a realization of ˜ d . So assume that there are vertices v and w ( not equal to i ) such that w = h j for some j , v is not equal to any of h 1 , . . . , h d i , and i is adjacent to v but not to w . If deg ( v ) = deg ( w ) , we can interchange vertices v and w without aﬀecting any degrees . So assume that deg ( v ) < deg ( w ) . Then there is a vertex x 6 = v joined by an edge to w ALGORITHM FOR GRAPHS WITH PRESCRIBED DEGREES 5 but not to v . Perform a switching by adding the edges { i , w } , { x , v } and deleting the edges { i , v } , { w , x } . This does not aﬀect the degrees , so we still have a realization of d . Repeating this if necessary , we can obtain a realization of d where vertex i is joined to the d i highest degree vertices other than i itself . The Havel - Hakimi Theorem thus gives a recursive test for whether d is graphical : apply the theorem repeatedly until either the theorem reports that the sequence is not graphical ( if there are not enough vertices available to connect to some vertex ) or the sequence becomes the zero vector ( in which case d is graphical ) . In practice , this recursive test runs very quickly since there are at most n iterations , each consisting of setting a component i to 0 and subtracting 1 from d i components . The algorithm also needs to ﬁnd the highest degrees at each stage , which can be done by initially sorting d ( in time O ( n log n ) ) and then maintaining the list in sorted order . Note that when d is graphical , the recursive application of Havel - Hakimi constructs a realization of d , by adding at each stage the edges corresponding to the change in the d vector . This is a simple algorithm for generating a deterministic realization of d . In the next section , we survey previous algorithms for obtaining random realizations of d . 3 . Previous Algorithms . 3 . 1 . Algorithms for random graphs with given degree distributions . In the classical ran - dom graph model G ( n , p ) of Erd˝os and R´enyi , generating a random graph is easy : for each pair of vertices i , j , independently ﬂip a coin with probability of heads p , and put an edge { i , j } iﬀ heads is the result . Thus , the degree of a given vertex has a Binomial ( n − 1 , p ) distribution . Also , note that all vertices have the same expected degree . Thus , a diﬀerent model is desirable for handling dependent edges and degree distributions that are far from binomial . For example , many researchers have observed that the Web and several other large networks obey a power - law degree distribution ( usually with an exponential cutoﬀ or trun - cation at some point ) , where the probability of a vertex having degree k is proportional to k − α for some positive constant α . See [ 2 ] , [ 6 ] , [ 12 ] , [ 13 ] , [ 20 ] , and [ 56 ] for more information about power - law graphs , where they arise , and ways of generating them . Our algorithm can also be used to generate power - law graphs or , more generally , graphs with a given degree distribution . To do this , ﬁrst sample i . i . d . random variables ( D 1 , . . . , D n ) according to the distribution . If ( D 1 , . . . , D n ) is graphical , use it as input to our algorithm ; otherwise , re - pick ( D 1 , . . . , D n ) . Recent work of Arratia and Liggett [ 4 ] gives the asymp - totic probability that ( D 1 , . . . , D n ) is graphical . In particular , the asymptotic probability is 1 / 2 if the distribution has ﬁnite mean and is not supported on only even degrees or on only odd degrees ; clearly , these conditions hold for power - law distributions . 3 . 2 . The Pairing Model . Returning to a ﬁxed degree sequence , several algorithms for generating a random ( uniform or near - uniform ) graph with desired degrees have been 6 J . BLITZSTEIN AND P . DIACONIS studied . Most of the existing literature has concentrated on the important case of regular graphs ( graphs where every vertex has the same degree ) , but some of the results extend to general degree sequences . In the remainder of this section , we will brieﬂy survey these existing algorithms ; more details can be found in the references , including the excellent survey on random regular graphs by Wormald [ 81 ] . The ﬁrst such algorithm was the pairing model ( also known , less descriptively , as the conﬁguration model ) . This model is so natural that it has been re - discovered many times in various forms ( see [ 81 ] for discussion of the history of the pairing model ) , but in this context the ﬁrst appearances seem to be in Bollob´as [ 11 ] and in Bender and Canﬁeld [ 8 ] . Fix n ( the number of vertices ) and d ( the degree ) with nd even , and let v 1 , . . . , v n be disjoint cells , each of which consists of d points ( for general degree sequences , we can let v i consist of d i points ) . Choose a perfect matching of these nd points uniformly . This can be done easily , e . g . , by at each stage randomly picking two unmatched points and then matching them together . The matching induces a multigraph , by viewing the cells at vertices and putting an edge between cells v and w for each occurrence of a match between a point in v and a point in w . Under the convention that each loop contributes 2 to the degree , this multigraph is d - regular . The pairing model algorithm is then to generate random multigraphs in this way until a simple graph G is obtained . Note that the resulting G is uniformly distributed since each simple graph is induced by the same number of perfect matchings . Some properties of Erd˝os - R´enyi random graphs have analogues in this setting . For example , Molloy and Reed [ 54 ] use the pairing model to prove the emergence of a giant component in a random graph with a given asymptotic degree sequence , under certain conditions on the degrees . Clearly , the probability P ( simple ) of a trial resulting in a simple graph is critical for the practicality of this algorithm : the expected number of matchings that need to be generated is 1 / P ( simple ) . Unfortunately , as d increases , the probability of having loops or multiple edges approaches 1 very rapidly . In fact , Bender and Canﬁeld showed that for ﬁxed d , P ( simple ) ∼ e 1 − d 2 4 as n → ∞ . For very small d such as d = 3 , this is not a problem and the algorithm works well . But for larger d , the number of repetitions needed to obtain a simple graph becomes prohibitive . For example , for d = 8 , about 6 . 9 million trials are needed on average in order to produce a simple graph by this method ( for n large ) . 3 . 3 . Algorithms Based on the Pairing Model . A sensible approach is to modify the pairing model by forbidding any choices of matching that will result in a loop or multiple edges . The simplest such method is to start with an empty graph and randomly add edges one at a time , choosing which edge to add by picking uniformly a pair of vertices which have not yet received their full allotment of edges . The process stops when no more edges can be added . With d the maximum allowable degree of each vertex , this is known as a ALGORITHM FOR GRAPHS WITH PRESCRIBED DEGREES 7 random d - process . Erd˝os asked about the asymptotic behavior of the d - process as n → ∞ with d ﬁxed . Ruci´nski and Wormald [ 63 ] answered this by showing that with probability tending to 1 , the resulting graph is d - regular ( for nd even ) . A similar result has been obtained by Robalewska and Wormald [ 61 ] for the star d - process , which at each stage chooses a vertex with a minimal current number δ of edges , and attempts to connect it to d − δ allowable vertices . However , for both the d - process and the star d - process , it is diﬃcult to compute the resulting probability distribution on d - regular graphs . Also , although it is possible to consider analogous processes for a general degree sequence ( d 1 , . . . , d n ) , little seems to be known in general about the probability of the process succeeding in producing a realization of ( d 1 , . . . , d n ) . A closely related algorithm for d - regular graphs is given by Steger and Wormald [ 69 ] , designed to have an approximately uniform output ( for large n , under certain growth restrictions on d ) . Their algorithm proceeds as in the pairing model , except that before deciding to make a match with two points i and j , one ﬁrst checks that they are not in the same cell and that there is not already a match between a cellmate of i and a cellmate of j . The algorithm continues until no more permissible pairs can be found . This can be viewed as a variant of the d - process with edges chosen with probabilities depending on the degrees , rather than uniformly . By construction , the Steger - Wormald algorithm avoids loops and multiple edges , but unlike the pairing model it can get stuck before a perfect matching is reached , as there may be unmatched vertices left over which are not allowed to be paired with each other . If the algorithm gets stuck in this way , it simply starts over and tries again . Steger and Wormald showed that the probability of their algorithm getting stuck approaches 0 for d = o ( ( n / ( log 3 n ) 1 / 11 ) , and Kim and Vu [ 40 ] recently improved this bound to d = o ( n 1 / 3 / log 2 n ) . The average running time is then O ( nd 2 ) for this case . Empirically , Steger and Wormald observed that their algorithm seems to get stuck with probability at most 0 . 7 for d ≤ n / 2 , but this has not been proved for d a sizable fraction of n . The output of the Steger - Wormald algorithm is not uniform , but their work and later improvements by Kim and Vu [ 39 ] show that for d = o ( n 1 / 3 − (cid:15) ) with (cid:15) > 0 ﬁxed , the output is asymp - totically uniform . For d of higher order than n 1 / 3 , it is not known whether the asymptotic distribution is close to uniform . Again these results are for regular graphs , and it is not clear how far they extend to general degree sequences . There is also an interesting earlier algorithm by McKay and Wormald [ 51 ] based on the pairing model . Their algorithm starts with a random pairing from the pairing model , and then uses two types of switchings ( slightly more complicated than the switchings in the Markov chain described below ) . One type of switching is used repeatedly to eliminate any loops from the pairing , and then the other type is used to eliminate any multiple edges from the pairing . To obtain an output graph which is uniformly distributed , an accept / reject procedure is used : in each iteration , a restart of the algorithm is performed with a certain probability . Let M = P ni = 1 d i , M 2 = P ni = 1 d i ( d i − 1 ) , and d max = max { d 1 , . . . , d n } . McKay and Wormald show that if d 3max = O ( M 2 / M 2 ) and d 3max = o ( M + M 2 ) , then the average 8 J . BLITZSTEIN AND P . DIACONIS running time of their algorithm is O ( M + M 22 ) . Note that for d - regular graphs , this reduces to an average running time of O ( n 2 d 4 ) for d = O ( n 1 / 3 ) . They also give a version that runs in O ( nd 3 ) time under the same conditions , but Wormald says in [ 81 ] that implementing this version is “the programmer’s nightmare . ” 3 . 4 . Adjacency Lists and Havel - Hakimi Variants . Tinhofer [ 72 , 73 ] gave a general al - gorithm for generating random graphs with given properties , including given degree se - quences . This approach involves choosing random adjacency lists , each of which consists of vertices adjacent to a particular vertex . These are chosen so that each edge is represented in only one adjacency list , to avoid redundancy . An accept / reject procedure can then be used to obtain a uniform output . However , this algorithm is quite complicated to analyze , and neither the average running time nor the correct accept / reject probabilities seem to be known . As noted earlier , the Havel - Hakimi Theorem gives a deterministic algorithm for gener - ating a realization of d . A simple modiﬁcation to add randomness is as follows . Start with vertices 1 , . . . , n and no edges . At each stage , pick a vertex i with d i > 0 and choose d i other vertices to join i to , according to some pre - speciﬁed probabilities depending on the degrees . Obtain d 0 from d by setting the entry at position i to 0 and subtracting 1 from each chosen vertex . If d 0 is graphical , update d to d 0 and continue ; otherwise , choose a diﬀerent sent of vertices to join i to . If favoritism is shown towards higher degree vertices , e . g . , by choosing to connect i to a legal j with probability proportional to the current degree of j , then this algorithm becomes similar to the preferential attachment model discussed in Barabasi and Albert [ 6 ] . However , we do not have good bounds on the probability of a chosen set of vertices being allowable , which makes it diﬃcult to analyze the average running time . Also , to use this algorithm with the importance sampling techniques given later , it seems necessary to know at each stage exactly how many choices of the d i vertices yield a graphical d 0 ; but it is obviously very undesirable to have to test all subsets of a certain size . 3 . 5 . Markov Chain Monte Carlo Algorithms . A natural , widely - used approach is to use a Markov chain Monte Carlo ( MCMC ) algorithm based on the switching moves used in the proof of the Havel - Hakimi Theorem . Let d = ( d 1 , . . . , d n ) be graphical . We can run a Markov Chain with state space the set of all realizations of d as follows . Start the chain at any realization of d ( this can be constructed eﬃciently using Havel - Hakimi ) . When at a realization G , pick two random edges { x , y } and { u , v } uniformly with x , y , u , v distinct . If { x , u } and { y , v } are not edges , then let the chain go to the realization G 0 obtained by adding the edges { x , u } , { y , v } and deleting the edges { x , y } , { u , v } ; otherwise , stay at G . ( Alternatively , we can also check whether { x , v } and { y , u } are non - edges ; if so and the other switching is not allowed , then use this switching . If both of these switchings are possible , we can give probability 1 / 2 to each . ) The Markov chain using switchings is irreducible since the proof of Havel - Hakimi can be ALGORITHM FOR GRAPHS WITH PRESCRIBED DEGREES 9 used to obtain a sequence of switchings to take any realization of d to any other realization of d . It is also easy to see that the chain is reversible with the uniform distribution as its stationary distribution . Note that in the context of tables , the corresponding random walk on adjacency matrices uses exactly the same moves as the well - known random walk on contingency tables or zero - one tables discussed in Diaconis and Gangolli [ 21 ] , where at each stage a pair of random rows and a pair of random columns are chosen , and the current table is modiﬁed in the four entries according to the pattern + − − + ! or the pattern − + + − ! , if possible . Diaconis and Sturmfels [ 22 ] have generalized these moves to discrete exponential families , which provides further evidence of the naturalness of this chain . For regular graphs , the mixing time of the switchings Markov chain has been studied very recently by Cooper , Dyer , and Greenhill [ 19 ] , using a path argument . They also use the switchings chain to model a peer - to - peer network , which is a decentralized network where users can share information and resources . The vertices of the graph correspond to the users , and two users who are joined by an edge can exchange information . Using random regular graphs is a ﬂexible , convenient way to create such a network . Practitioners sometimes want to generate only connected graphs with the given degree sequence . Note that a switching move may disconnect a connected graph . However , if we accept a switching only if the resulting graph is connected , it follows from a theorem of Tay - lor [ 71 ] that the switchings Markov chain on connected graphs is irreducible . To avoid the ineﬃciency of having to check after every step whether the graph is still connected , Gkant - sidis , Mihail , and Zegura [ 29 ] and Viger and Latapy [ 77 ] propose heuristic modiﬁcations and give empirical performance data . For regular graphs , another MCMC algorithm was given by Jerrum and Sinclair [ 37 ] . In their algorithm , a graph is constructed in which perfect matchings give rise to simple graphs . The algorithm then uses a Markov chain to obtain a perfect matching in this graph . Jerrum and Sinclair showed that this algorithm comes arbitrarily close to uniform in polynomial time ( in n ) . However , the polynomial is of fairly high order . Their algorithm can be extended to non - regular graphs , but is only known to run in polynomial time if d satisﬁes a condition called P - stability . Intuitively , a class of degree sequences is P - stable if a small perturbation of a degree sequence d in the class does not drastically change the number of graphs with that degree sequence . For precise details and conditions for P - stability in terms of the minimum and maximum degrees , see Jerrum , Sinclair and McKay [ 38 ] . 4 . The Sequential Algorithm . In this section , we present our sequential algorithm and describe some of its features . In a graph process aiming to produce a realization of a given degree sequence , the word “degree” could either mean the number of edges chosen already for some vertex , or it could mean the residual degree , which is the remaining number of edges which must be chosen for that vertex . In discussing our algorithm , degrees should be thought of as residual degrees unless otherwise speciﬁed ; in particular , we will start with 10 J . BLITZSTEIN AND P . DIACONIS the degree sequence d and add edges until the degree sequence is reduced to 0 . As we will be frequently adding or subtracting 1 at certain coordinates of degree se - quences , we introduce some notation for this operation . Notation 1 . For any vector d = ( d 1 , . . . d n ) and distinct i 1 , . . . , i k ∈ { 1 , . . . , n } , deﬁne ⊕ i 1 , . . . , i k d to be the vector obtained from d by adding 1 at each of the coordinates i 1 , . . . , i k , and deﬁne (cid:9) i 1 , . . . , i k analogously : ( ⊕ i 1 , . . . , i k d ) i = ( d i + 1 for i ∈ { i 1 , . . . , i k } , d i otherwise , , ( (cid:9) i 1 , . . . , i k d ) i = ( d i − 1 for i ∈ { i 1 , . . . , i k } , d i otherwise . For example , ⊕ 1 , 2 ( 3 , 2 , 2 , 1 ) = ( 4 , 3 , 2 , 1 ) and (cid:9) 1 , 2 ( 3 , 2 , 2 , 1 ) = ( 2 , 1 , 2 , 1 ) . With this no - tation , our sequential algorithm can be stated compactly . Sequential Algorithm For Random Graph with Given Degrees Input : a graphical degree sequence ( d 1 , . . . , d n ) . 1 . Let E be an empty list of edges . 2 . If d = 0 , terminate with output E . 3 . Choose the least i with d i a minimal positive entry . 4 . Compute candidate list J = { j 6 = i : { i , j } / ∈ E and (cid:9) i , j d is graphical } . 5 . Pick j ∈ J with probability proportional to its degree in d . 6 . Add the edge { i , j } to E and update d to (cid:9) i , j d . 7 . Repeat steps 4 - 6 until the degree of i is 0 . 8 . Return to step 2 . Output : E . For example , suppose that the starting sequence is ( 3 , 2 , 2 , 2 , 1 ) . The algorithm starts by choosing which vertex to join vertex 5 to , using the candidate list { 1 , 2 , 3 , 4 } . Say it chooses 2 . The new degree sequence is ( 3 , 1 , 2 , 2 , 0 ) . The degree of vertex 5 is now 0 , so the algorithm continues with vertex 2 , etc . One possible sequence of degree sequences is ( 3 , 2 , 2 , 2 , 1 ) → ( 3 , 1 , 2 , 2 , 0 ) → ( 2 , 0 , 2 , 2 , 0 ) → ( 1 , 0 , 2 , 1 , 0 ) → ( 0 , 0 , 1 , 1 , 0 ) → ( 0 , 0 , 0 , 0 , 0 ) , corresponding to the graph with edge set { { 5 , 2 } , { 2 , 1 } , { 1 , 4 } , { 1 , 3 } , { 3 , 4 } } . ALGORITHM FOR GRAPHS WITH PRESCRIBED DEGREES 11 As another example , we show below the ﬁrst two of 6000 graphs generated using our algorithm applied to the degree sequence of the food web of Figure 1 . Each took about 13 seconds to generate ( on a 1 . 33 GHz PowerBook ) . Qualitatively , they appear to be more spread out and less neatly hierarchical than the actual food web . We discuss this more in Section 11 , comparing some test statistics of the actual graph with those of the random graphs . 4 2 18 22 1 5 8 15 26 20 33 24 9 19 11 6 32 10 17 21 27 3 28 14 31 7 25 23 13 16 12 29 30 Fig 2 . random graph with food web degrees , 1 The algorithm always terminates in a realization of ( d 1 , . . . , d n ) . The output of the algorithm is not uniformly distributed over all realizations of ( d 1 , . . . , d n ) in general , but every realization of ( d 1 , . . . , d n ) has positive probability . Importance sampling techniques can then be used to compute expected values with respect to the uniform distribution if desired , as described in Section 8 . A few remarks on the speciﬁc steps are in order . 1 . In Step 4 , any test for graphicality can be used ; Erd˝os - Gallai is particularly easy to implement and runs quickly . 12 J . BLITZSTEIN AND P . DIACONIS 4 15 19 22 5 23 27 12 20 24 30 32 6 11 14 3 17 10 7 8 2 13 33 21 18 31 26 25 1 16 9 28 29 Fig 3 . random graph with food web degrees , 2 2 . It follows from Theorem 3 that a candidate at a later stage is also a candidate at an earlier stage , within the same choice of i from Step 3 . Thus , in Step 4 it is suﬃcient to test the vertices which were candidates in the previous stage , if that stage had the same choice of i . 3 . In Step 5 , any probability distribution p on J with p ( j ) > 0 for all j can be used . An interesting problem here is to ﬁnd a distribution p which makes the output as close to uniform as possible . In our empirical tests , choosing a candidate with probability pro - portional to its degree was signiﬁcantly better than choosing a candidate uniformly ( see Section 8 ) . But it remains open to prove some sort of optimality here . In the case of the algorithm for random trees ( see Section 10 ) , picking j with probability proportional to d j − 1 gives an exactly uniform tree . 4 . An alternative to Step 4 would be to pick j with { i , j } / ∈ E randomly and accept it if (cid:9) i , j d is graphical ; otherwise , pick again without replacement . This approach runs faster , but has the disadvantage that it becomes very diﬃcult to compute the sequential probabilities discussed in Section 8 . 5 . Another alternative would be to connect at each step a highest degree vertex to a randomly chosen candidate . This has the advantage that it is obvious from Havel - Hakimi that the algorithm never gets stuck . However , this seems to make it very diﬃcult to compute the weights c ( Y ) needed in Section 8 for importance sampling . ALGORITHM FOR GRAPHS WITH PRESCRIBED DEGREES 13 Choosing the maximum vertex on each step involves a lot of jumping around from vertex to vertex , whereas our main algorithm is more systematic in the sense that it chooses a vertex to fully connect , then chooses another vertex to fully connect , etc . 5 . Proof that the Algorithm Works . The theorem below guarantees that the al - gorithm never gets stuck , by showing that at least one candidate vertex exists at each stage . Theorem 3 . Let d = ( d 1 , . . . , d n ) be a graphical degree sequence with d i > 0 , arranged so that d n = min { d 1 , . . . , d n } . Let d = d ( 0 ) , d ( 1 ) , d ( 2 ) , . . . , d ( j ) = ˜ d be graphical degree se - quences of length n ( for some j ≥ 1 ) , such that d ( i ) is obtained from d ( i − 1 ) by subtracting 1 at coordinate n and at another coordinate v i not previously changed . That is , d ( i ) = (cid:9) n , v i d ( i − 1 ) for i ∈ { 1 , . . . , j } , where n , v 1 , . . . , v j are distinct . Then d has a realization containing all of the edges { n , v 1 } , . . . , { n , v j } , and ˜ d has a realization containing none of these edges . Proof . The desired realization of d immediately yields that of ˜ d , by deleting the edges { n , v 1 } , . . . , { n , v j } , and conversely the desired realization of ˜ d immediately gives that of d . Note that j ≤ d n since the degree of vertex n in d ( j ) is d n − j . We use a backwards induction on j , over 1 ≤ j ≤ d n , by showing that the claim is true for j = d n and that if it is true for j + 1 , then it is true for j . First assume j = d n , and let G j be a realization of the degree sequence d ( j ) . Note that vertex n has degree 0 in G j . Adding edges in G j from vertex n to each v i , 1 ≤ i ≤ j , yields a graph with degree sequence d ( 0 ) containing the desired edges . Now assume that the result holds for j + 1 , and show it for j , for some ﬁxed j with 1 ≤ j ≤ d n − 1 . Call the vertices v 1 , . . . , v j touched vertices , and the remaining vertices other than vertex n untouched . The proof hinges on whether we can ﬁnd a realization of d ( j ) where vertex n is adjacent to an untouched vertex . Suppose that d ( j ) has a realization G j containing an edge { n , x } , with x an untouched vertex . Deleting the edge { n , x } yields a graph G j + 1 with degree sequence d ( j + 1 ) of the form in the statement of the theorem , with j + 1 in place of j and v j + 1 = x . The inductive hy - pothesis then implies that d ( 0 ) has a realization containing the edges { n , v 1 } , . . . , { n , v j + 1 } . So it suﬃces to show that d ( j ) has a realization with an edge { n , x } , with x an untouched vertex . Let T consist of the j touched vertices , and decompose T = A ∪ B , where a touched vertex x is in A iﬀ { n , x } is an edge in some realization of d ( j ) , and B = T \ A . Here B may be empty , but we can assume A is nonempty , since otherwise any realization of d ( j ) has an edge { n , x } with x untouched . Let | A | = a and | B | = b ( so a + b = j ) . Let x ∈ A and y be an untouched vertex or y ∈ B . Consider a realization of d ( j ) containing the edge { n , x } . Note that if the degrees of x and y are equal in d ( j ) , then 14 J . BLITZSTEIN AND P . DIACONIS they can be interchanged without aﬀecting any degrees , and then { n , y } is an edge ( which contradicts the deﬁnition of B if y ∈ B , and gives us the desired edge if y is untouched ) . If the degree of x is less than that of y , then we can perform a switching as in the proof of the Havel - Hakimi Theorem ( pick a vertex w 6 = x adjacent to y but not adjacent to x , add edges { n , y } , { x , w } , and delete edges { n , x } , { y , w } ) , again producing a realization with the edge { n , y } . So assume that the degree of x is strictly greater than the degree of y in d ( j ) for all x ∈ A and y which is either untouched or in B . Then the vertices in A have the a highest degrees in d ( j ) . Let d 0 be the degree sequence with d 0 n = d n − b , d 0 y = d y − 1 for y ∈ B , and d 0 y = d y otherwise . Note that ˜ d i ≤ d 0 i ≤ d i for all i , with equality on the left for i ∈ B and equality on the right for i ∈ A . Also , the assumption d n = min { d 1 , . . . , d n } implies that d 0 n = min { d 0 1 , . . . , d 0 n } and d ( j ) n = min { d ( j ) 1 , . . . , d ( j ) n } . We claim that d 0 is graphical . Assuming that d 0 is graphical , we can then complete the proof as follows . Note that the vertices in A have the a highest degrees in d 0 since this is true for d ( j ) and in passing from d ( j ) to d 0 , these degrees are increased by 1 while all other degrees aside from that of vertex n are unchanged . So by the Havel - Hakimi Theorem , d 0 has a realization containing all of the edges { n , x } , x ∈ A ( as a ≤ d 0 n = d n − b , since j < d n ) . Deleting these edges yields a realization G ( j ) of d ( j ) containing none of these edges . By deﬁnition of B , G ( j ) also does not contain any edge { n , y } with y ∈ B . Thus , G ( j ) is as desired . So it suﬃces to prove that d 0 is graphical . To show that d 0 is graphical , we check the Erd˝os - Gallai conditions . For k = n , since d is graphical we have n X i = 1 d 0 i ≤ n X i = 1 d i ≤ n ( n − 1 ) . Assume k < n , and let I ⊆ { 1 , . . . , n − 1 } be an index set for the k largest degrees of d 0 . If k ≤ d 0 n , then k ≤ d 0 i ≤ d i for all i , and we have X i ∈ I d 0 i ≤ X i ∈ I d i ≤ k ( k − 1 ) + X i / ∈ I min { k , d i } = k ( k − 1 ) + X i / ∈ I k = k ( k − 1 ) + X i / ∈ I min { k , d 0 i } . So assume k > d 0 n ( which implies k > ˜ d n ) . Then X i ∈ I d 0 i = a 0 + X i ∈ I ˜ d i , ALGORITHM FOR GRAPHS WITH PRESCRIBED DEGREES 15 where a 0 ≤ a , since d 0 and ˜ d diﬀer only on A ∪ { n } . Since ˜ d is graphical , a 0 + X i ∈ I ˜ d i ≤ a 0 + k ( k − 1 ) + X i / ∈ I min { k , ˜ d i } = a 0 + k ( k − 1 ) + ˜ d n + X i / ∈ I , i 6 = n min { k , ˜ d i } ≤ a 0 + k ( k − 1 ) + ˜ d n + X i / ∈ I , i 6 = n min { k , d 0 i } = a 0 + k ( k − 1 ) + ˜ d n − d 0 n + X i / ∈ I min { k , d 0 i } ≤ k ( k − 1 ) + X i / ∈ I min { k , d 0 i } where the last inequality follows from a 0 + ˜ d n − d 0 n = a 0 + ( d n − j ) − ( d n − b ) = a 0 − a ≤ 0 . Hence , d 0 is graphical . The above result is false if the assumption d n = min { d 1 , . . . , d n } is dropped . For a counterexample , consider the degree sequences ( 1 , 1 , 2 , 2 , 5 , 3 ) , ( 1 , 1 , 2 , 2 , 4 , 2 ) , ( 0 , 1 , 2 , 2 , 4 , 1 ) . It is easily checked that they are graphical and each is obtained from the previous one in the desired way . But there is no realization of the sequence ( 1 , 1 , 2 , 2 , 5 , 3 ) containing the edge { 1 , 6 } , since clearly vertex 1 must be connected to vertex 5 . This would result in the algorithm getting stuck in some cases if we did not start with a minimal positive degree vertex : starting with ( 1 , 1 , 2 , 2 , 5 , 3 ) , the algorithm could choose to form the edge { 5 , 6 } and then choose { 1 , 6 } , since ( 0 , 1 , 2 , 2 , 4 , 1 ) is graphical . But then vertex 5 could never achieve degree 4 without creating multiple edges . Using the above theorem , we can now prove that the algorithm never gets stuck . Corollary 1 . Given a graphical sequence d = ( d 1 , . . . , d n ) as input , the algorithm above terminates with a realization of d . Every realization of d occurs with positive proba - bility . Proof . We use induction on the number of nonzero entries in the input vector d . If d = 0 , the algorithm terminates immediately with empty edge set , which is obviously the only realization of the zero vector . Suppose d 6 = 0 and the claim is true for all input vectors with fewer nonzero entries than d . Let i be the smallest index in d with minimal positive degree . There is at least one candidate vertex j to connect i to , since if { i , j } is an edge in a realization of d , then deleting this edge shows that the sequence d ( 1 ) obtained by subtracting 1 at coordinates i and j is graphical . 16 J . BLITZSTEIN AND P . DIACONIS Suppose that the algorithm has chosen edges { i , v 1 } , . . . , { i , v j } with corresponding de - gree sequences d = d ( 0 ) , d ( 1 ) , . . . , d ( j ) , where j ≥ 1 and d ( j ) i = d i − j > 0 . Omitting any zeroes in d and permuting each sequence to put vertex i at coordinate n , Theorem 3 implies that d ( j ) has a realization G j using none of the edges { i , v 1 } , . . . , { i , v j } . Then G j has an edge { i , x } with d x = d ( j ) x , and { i , x } is an allowable choice for the next edge . Therefore , the algorithm can always extend the list of degree sequences d = d ( 0 ) , . . . , d ( j ) until the degree at i is d i − j = 0 . Let { i , v 1 } , . . . { i , v j } be the edges selected ( with d i − j = 0 ) . Note that if { i , w 1 } , . . . { i , w j } are the edges incident with i in a realization of G , then these edges are chosen with positive probability ( as seen by deleting these edges one by one in any order ) . The algorithm then proceeds by picking a minimal positive entry in d ( j ) ( if any re - mains ) . By the inductive hypothesis , running the algorithm on input vector d ( j ) termi - nates with a realization of d ( j ) . Thus , the algorithm applied to d terminates with edge set E = { { i , v 1 } , . . . { i , v j } } ∪ ˜ E , where ˜ E is an output edge set of the algorithm applied to d ( j ) . No edges in ˜ E involve vertex i , so E is a realization of d . Again by the inductive hypothesis , every realization of d ( j ) is chosen with positive probability , and it follows that every realization of d is chosen with positive probability . 6 . Forced Sets of Edges . Theorem 3 is also related to the problem of ﬁnding a realization of a graph which requires or forbids certain edges . To make this precise , we introduce the notion of a forced set of edges . Definition 2 . Let d be a graphical degree sequence . A set F of pairs { i , j } with i , j ∈ { 1 , . . . , n } is forced for d if for every realization G = ( V , E ) of d , F ∩ E 6 = ∅ . If a singleton { e 1 } is forced for d , we will say that e 1 is a forced edge for d . The one - step case ( j = 1 ) in Theorem 3 gives a criterion for an edge to be forced . Indeed , for this case the assumption about the minimum is not needed . Proposition 1 . Let d be a graphical degree sequence and i , j ∈ { 1 , . . . , n } with i 6 = j . Then { i , j } is a forced edge for d if and only if ⊕ i , j d is not graphical . Proof . Suppose that { i , j } is not forced for d . Adding the edge { i , j } to a realization of d yields a realization of ⊕ i , j d . Conversely , suppose that { i , j } is forced for d . Arguing as in the proof of Theorem 3 , we see that i and j must have greater degrees in d than any other vertex . Suppose ( for contradiction ) that ⊕ i , j d is graphical . Then Havel - Hakimi gives a realization of ⊕ i , j d that uses the edge { i , j } . Deleting this edge gives a realization of d not containing the edge { i , j } , contradicting it being forced for d . Beyond this one - step case , an additional assumption is needed for analogous results on forced sets , as shown by the counterexample after the proof of Theorem 3 . Much of the ALGORITHM FOR GRAPHS WITH PRESCRIBED DEGREES 17 proof consisted of showing that the set of all “touched” vertices is not a forced set for ˜ d . This immediately yields the following result . Corollary 2 . Let d be a graphical degree sequence and d 0 = ⊕ ki ⊕ j 1 , . . . , j k for some distinct vertices i , j 1 , . . . , j k . Suppose that d 0 i = min { d 0 1 , . . . , d 0 n } . Then { { i , j 1 } , . . . , { i , j k } } is forced for d if and only if d 0 is not graphical . We may also want to know whether there is a realization of d containing a certain list of desired edges . This leads to the following notion . Definition 3 . Let d be a graphical degree sequence . A set S of pairs { i , j } with i , j ∈ { 1 , . . . , n } is simultaneously allowable for d if d has a realization G with every element of S an edge in G . If S is a simultaneously allowable singleton , we call it an allowable edge . Results on forced sets imply dual results for simultaneously allowable sets and vice versa , by adding or deleting the appropriate edges from a realization . For example , Proposition 1 above implies the following . Corollary 3 . Let d be a graphical degree sequence and i , j ∈ { 1 , . . . , n } with i 6 = j . Then { i , j } is an allowable edge for d if and only if (cid:9) i , j d is graphical . Similarly , the dual result to Corollary 2 is the following ( which is also an easy consequence of Theorem 3 ) . Corollary 4 . Let d be a graphical degree sequence and ˜ d = (cid:9) ki (cid:9) j 1 , . . . , j k d for some distinct vertices i , j 1 , . . . , j k . Suppose that d i = min { d 1 , . . . , d n } . Then { { i , j 1 } , . . . , { i , j k } } is simultaneously allowable for d if and only if ˜ d is graphical . 7 . Running Time . In this section , we examine the running time of the algorithm . Let d = ( d 1 , . . . , d n ) be the input . Since no restarts are needed , the algorithm has a ﬁxed , bounded worst case running time . Each time a candidate list is generated , the algorithm performs O ( n ) easy arithmetic operations ( adding or subtracting 1 ) and tests for graph - icality O ( n ) times . Each test for graphicality can be done in O ( n ) time by Erd˝os - Gallai , giving a total worst case O ( n 2 ) running time each time a candidate list is generated ( a sorted degree sequence also needs to be maintained , but the total time needed for this is dominated by the O ( n 2 ) time we already have ) . Since a candidate list is generated for each time an edge is selected , there are 12 P ni = 1 d i candidate lists to generate . Additionally , the algorithm sometimes needs to locate the small - est index of a minimal nonzero entry , but we are already assuming that we are maintaining a sorted degree sequence . 18 J . BLITZSTEIN AND P . DIACONIS The overall worst case running time is then O ( n 2 P ni = 1 d i ) . For d - regular graphs , this becomes a worst case of O ( n 3 d ) time . Note that an algorithm which requires restarts has an unbounded worst case running time . Using Remark 2 after Theorem 3 , the number of times that the Erd˝os - Gallai conditions must be applied is often considerably less than n . But we do not have a good bound on the average number of times that Erd˝os - Gallai must be invoked , so we do not have a better bound on the average running time than the worst case running time of O ( n 2 P ni = 1 d i ) . 8 . Importance Sampling . The random graphs generated by the sequential algo - rithms are not generally distributed uniformly , but the algorithm makes it easy to use importance sampling to estimate expected values and probabilities for any desired dis - tribution , including uniform . Importance sampling allows us to re - weight samples from a distribution available to us , called the trial distribution , to obtain estimates with respect to the desired target distribution . Often choosing a good trial distribution is a diﬃcult problem ; one approach to this , sequential importance sampling , involves building up the trial distribution recursively as a product , with each factor conditioned on the previous choices . Section 8 . 1 reviews some previous applications of importance sampling and explains how they are related to the current work . Section 8 . 2 then shows how sequential importance sampling works in the context of random graphs produced by our algorithm . For general background on Monte Carlo computations and importance sampling , we recommend Hammersley and Handscomb [ 33 ] , Liu [ 45 ] , and Fishman [ 26 ] . Sequential im - portance sampling is developed in Liu and Chen [ 46 ] and Doucet , de Freitas and Gor - don [ 23 ] . Important variations which could be coupled with the present algorithms include Owen’s [ 58 ] use of control variates to bound the variance and adaptive importance sam - pling as in Rubinstein [ 62 ] . Obtaining adequate bounds on the variance for importance sampling algorithms is an open research problem in most cases of interest ( see Bassetti and Diaconis [ 7 ] for some recent work in this area ) . 8 . 1 . Some Previous Applications . Sequential importance sampling was used in Sni - jders [ 67 ] to sample from the set of all zero - one tables with given row and column sums . The table was built up from left to right , one column at a time ; this algorithm could get stuck midway through , forcing it to backtrack or restart . Chen , Diaconis , Holmes , and Liu [ 14 ] introduced the crucial idea of using a combina - torial test to permit only partial ﬁllings which can be completed to full tables . Using this idea , they gave eﬃcient important sampling algorithms for zero - one tables and ( 2 - way ) contingency tables . For zero - one tables , the combinatorial test is the Gale - Ryser Theorem . For contingency tables , the test is simpler : the sum of the row sums and the sum of the column sums must agree . Similarly , our graph algorithm can be viewed as producing symmetric zero - one tables with trace 0 , where the combinatorial test is the Erd˝os - Gallai characterization . For both ALGORITHM FOR GRAPHS WITH PRESCRIBED DEGREES 19 zero - one tables and graphs , reﬁnements to the combinatorial theorems were needed to ensure that partially ﬁlled in tables could be completed and sequential probabilities could be computed . Another interesting sequential importance sampling algorithm is developed in Chen , Dinwoodie and Sullivant [ 15 ] , to handle multiway contingency tables . A completely diﬀerent set of mathematical tools turns out to be useful in this case , including Gr¨obner bases , Markov bases , and toric ideals . Again there is an appealing interplay between combinatorial and algebraic theorems and importance sampling . These problems fall under a general program : how can one convert a characterization of a combinatorial structure into an eﬃcient generating algorithm ? A reﬁnement of the char - acterization is often needed , for use with testing whether a partially - determined structure can be completed . More algorithms of this nature , including one for generating connected graphs , can be found in Blitzstein [ 10 ] . 8 . 2 . Importance Sampling of Graphs . When applying importance sampling with our algorithm , some care is needed because it is possible to generate the same graph in diﬀer - ent orders , with diﬀerent corresponding probabilities . For example , consider the graphical sequence d = ( 4 , 3 , 2 , 3 , 2 ) . The graph with edges { 1 , 3 } , { 2 , 3 } , { 2 , 4 } , { 1 , 2 } , { 1 , 5 } , { 1 , 4 } , { 4 , 5 } can be generated by the algorithm in any of 8 orders . For example , there is the order just given , and there is the order { 2 , 3 } , { 1 , 3 } , { 2 , 4 } , { 1 , 2 } , { 1 , 4 } , { 1 , 5 } , { 4 , 5 } . The probability of the former is 1 / 20 and that of the latter is 3 / 40 , even though the two sequences correspond to the same graph . This makes it more diﬃcult to directly compute the probability of generating a speciﬁc graph , but it does not prevent the importance sampling method from working . Fix a graphical sequence d of length n as input to the algorithm . We ﬁrst introduce some notation to clearly distinguish between a graph and a list of edges . Definition 4 . Let G n , d be the set of all realizations of d and let Y n , d be the set of all possible sequences of edges output by the algorithm . For any sequence Y ∈ Y n , d of edges , let Graph ( Y ) be the corresponding graph in G n , d ( with the listed edges and vertex set { 1 , . . . , n } ) . We call Y , Y 0 ∈ Y n , d equivalent if Graph ( Y 0 ) = Graph ( Y ) . Let c ( Y ) be the number of Y 0 ∈ Y n , d with Graph ( Y 0 ) = Graph ( Y ) . The equivalence relation deﬁned above partitions Y n , d into equivalence classes . There is an obvious one - to - one correspondence between the equivalence classes and G n , d , and the size of the class of Y is c ( Y ) . Note that c ( Y 0 ) = c ( Y ) if Y 0 is equivalent to Y . The number c ( Y ) is easy to compute as a product of factorials : 20 J . BLITZSTEIN AND P . DIACONIS Proposition 2 . Let Y ∈ Y n , d and let i 1 , i 2 , . . . , i m be the vertices chosen in the iterations of Step 3 of the algorithm in an instance where Y is output ( so the algo - rithm gives i 1 edges until its degree goes to 0 , and then does the same for i 2 , etc . ) . Let d = d ( 0 ) , d ( 1 ) , d ( 2 ) , . . . , d ( j ) = 0 be the corresponding sequence of graphical degree sequences . Put i 0 = 0 . Then c ( Y ) = m Y k = 1 d ( i k − 1 ) i k ! . Proof . Let Y 0 be equivalent to Y . Note from Step 3 of the algorithm that Y 0 has the same vertex choices i 1 , i 2 , . . . , i m as Y . We can decompose Y and Y 0 into blocks corre - sponding to i 1 , . . . , i m . Within each block , Y 0 and Y must have the same set of edges , possibly in a permuted order . Conversely , Theorem 3 implies that any permutation which independently permutes the edges within each block of the sequence Y yields a sequence Y 00 in Y n , d . Clearly any such Y 00 is equivalent to Y . A main goal in designing our algorithm , in addition to not letting it get stuck , was to have a simple formula for c ( Y ) . In many seemingly similar algorithms , it is diﬃcult to ﬁnd an analogue of the above formula for c ( Y ) , making it much more diﬃcult to use importance sampling eﬃciently . Before explaining how importance sampling works in this context , a little more notation is needed . Notation 2 . For Y ∈ Y n , d , write σ ( Y ) for the probability that the algorithm produces the sequence Y . Given a function f on G n , d , write ˆ f for the induced function on the larger space Y n , d , with ˆ f ( Y ) = f ( Graph ( Y ) ) . Note that for Y the output of a run of the algorithm , σ ( Y ) can easily be computed sequentially along the way . Each time the algorithm chooses an edge , have it record the probability with which it was chosen ( conditioned on all of the previously chosen edges ) , namely , its degree divided by the sum of the degrees of all candidates at that stage . Mul - tiplying these probabilities gives the probability σ ( Y ) of the algorithm producing Y . We can now show how to do importance sampling with the algorithm , despite having a proposal distribution σ distributed on Y n , d rather than on G n , d . Proposition 3 . Let π be a probability distribution on G n , d and G be a random graph drawn according to π . Let Y be a sequence of edges distributed according to σ . Then E (cid:18) ˆ π ( Y ) c ( Y ) σ ( Y ) ˆ f ( Y ) (cid:19) = Ef ( G ) . In particular , for Y 1 , . . . , Y N the output sequences of N independent runs of the algorithm , ˆ µ = 1 N N X i = 1 ˆ π ( Y i ) c ( Y i ) σ ( Y i ) ˆ f ( Y i ) ALGORITHM FOR GRAPHS WITH PRESCRIBED DEGREES 21 is an unbiased estimator of Ef ( G ) . Proof . Let Y be an output of the algorithm . We can compute a sum over Y n , d by ﬁrst summing within each equivalence class and then summing over all equivalence classes : E (cid:18) ˆ π ( Y ) c ( Y ) σ ( Y ) ˆ f ( Y ) (cid:19) = X y ∈Y n , d ˆ f ( y ) ˆ π ( y ) c ( y ) σ ( y ) σ ( y ) = X y ∈Y n , d ˆ f ( y ) ˆ π ( y ) c ( y ) = X G ∈G n , d X y : Graph ( y ) = G ˆ f ( y ) ˆ π ( y ) c ( y ) = X G ∈G n , d f ( G ) π ( G ) = Ef ( G ) , where the second to last equality is because on the set C ( G ) = { y : Graph ( y ) = G } , we have ˆ f ( y ) = f ( G ) , ˆ π ( y ) = π ( G ) , and c ( y ) = | C ( G ) | . Taking π to be uniform and f to be a constant function allows us to estimate the number of graphs with degree sequence d ; this is explored in the next section . The ratios W i = ˆ π ( Y i ) c ( Y i ) σ ( Y i ) are called importance weights . A crucial feature of our algorithm is that the quantity c ( Y i ) σ ( Y i ) can easily be computed on - the - ﬂy , as described above . By taking f to be a constant function , we see that EW i = 1 , so the average sum of the importance weights in ˆ µ is N . Another estimator of Ef ( G ) is then ˜ µ = 1 P Ni = 1 W i N X i = 1 W i ˆ f ( Y i ) . This estimator is biased , but often works well in practice and has the advantage that the importance weights need only be known up to a multiplicative constant . Since in practice one often works with distributions that involve unknown normalizing constants , having it suﬃce to know the importance weights up to a constant is often crucial . A major factor in the performance of importance sampling is how much variation there is in the importance weights . Let π be the uniform distribution on G n , d . We plot in Figure 4 a histogram of importance weights for 6000 trials with d the degree sequence of the food web of Figure 1 . The weights shown are scaled by dividing by 10 52 and omitting the constant ˆ π ( Y ) . The weights vary greatly from a minimum of 2 . 9 × 10 52 to a maximum of 2 . 9 × 10 58 , but most are between 1 . 2 × 10 56 and 1 . 9 × 10 57 . The ratio of maximum to median is 52 , making the largest few weights inﬂuential but not completely dominant in importance sampling estimates . 22 J . BLITZSTEIN AND P . DIACONIS Fig 4 . histogram of 6000 importance weights for the Chesapeake food web 9 . Estimating the Number of Graphs . To estimate the number | G n , d | of realiza - tions of d , let π be uniform on G n , d and take f to be the constant function f ( G ) = | G n , d | . By Proposition 3 , E (cid:18) 1 c ( Y ) σ ( Y ) (cid:19) = | G n , d | . Asymptotic formulas for | G n , d | are available for regular and some non - regular degree sequences ( see Bender and Canﬁeld [ 8 ] and McKay and Wormald [ 50 , 52 ] ) , but there are few non - asymptotic closed form expressions . For the food web example of Figure 1 , the estimated size of G n , d was ( 1 . 51 ± 0 . 03 ) × 10 57 using 6000 trials . The asymptotic formulas are not of much use in such an example , with a ﬁxed n of moderate size ( here n = 33 ) . As an application and test of this method , we estimated the number of labeled 3 - regular graphs on n vertices for various even values of n . The exact values for all even n ≤ 24 are available as Sequence A002829 in Sloane’s wonderful On - Line Encyclopedia of Integer Sequences [ 64 ] , and in general they can be computed using a messy recurrence in Goulden and Jackson [ 30 ] . For n = 4 , there is only one labeled 3 - regular graph on n vertices , the complete graph K 4 . Comfortingly , the algorithm does give 1 as its estimate for this case . In general , a degree sequence with exactly one realization is called a threshold sequence ( see [ 49 ] ) , and it is easy to see that the algorithm gives 1 as the estimate for any threshold sequence . The table below gives the estimators ˆ µ obtained by the trials for all even n between 6 and 24 , along with the number of trials , the correct value µ , and the percent error . The number after each ± indicates the estimated standard error . For each of these degree sequences , the coeﬃcient of variation ( ratio of standard deviation to mean ) was approximately 0 . 4 , ranging between 0 . 39 and 0 . 43 . A measure of the eﬃciency of an importance sampling scheme is the eﬀective sample size , as given in [ 42 ] . The eﬀective ALGORITHM FOR GRAPHS WITH PRESCRIBED DEGREES 23 sample size approximates the number of i . i . d . samples from the target distribution required to obtain the same standard error as the importance samples . The estimated eﬀective sample sizes for these examples , computed using the coeﬃcients of variation , range between 422 to 434 for 500 runs of the algorithm . n runs ˆ µ µ % error 6 500 71 . 1 ± 1 . 2 70 1 . 57 8 500 18964 ± 365 19355 2 . 06 10 500 ( 1 . 126 ± 0 . 021 ) × 10 7 1 . 118 × 10 7 0 . 72 12 500 ( 1 . 153 ± 0 . 022 ) × 10 10 1 . 156 × 10 10 0 . 26 14 500 ( 1 . 914 ± 0 . 036 ) × 10 13 1 . 951 × 10 13 1 . 93 16 500 ( 5 . 122 ± 0 . 093 ) × 10 16 5 . 026 × 10 16 1 . 91 18 500 ( 1 . 893 ± 0 . 034 ) × 10 20 1 . 877 × 10 20 0 . 85 20 500 ( 9 . 674 ± 0 . 17 ) × 10 23 9 . 763 × 10 23 0 . 92 22 500 ( 6 . 842 ± 0 . 12 ) × 10 27 6 . 840 × 10 27 0 . 029 24 500 ( 6 . 411 ± 0 . 11 ) × 10 31 6 . 287 × 10 31 1 . 97 As a comparison between choosing candidates uniformly and choosing candidates with probability proportional to their degrees , we generated 50 estimators from each algorithm , with each based on 100 runs of the algorithm applied to the 3 - regular degree sequence with n = 10 . The true value is 11180820 ≈ 1 . 118 × 10 7 . The mean of the estimators for uniform candidates was 1 . 137 × 10 7 ( an error of 1 . 7 % ) , while that of the degree - based selection was 1 . 121 × 10 7 ( an error of 0 . 25 % ) . For a non - regular example , we tested the algorithm with the graphical degree sequence d = ( 5 , 6 , 1 , . . . , 1 ) with eleven 1’s . To count the number of labeled graphs with this degree sequence , note that there are (cid:0) 115 (cid:1) = 462 such graphs with vertex 1 not joined to vertex 2 by an edge ( these graphs look like two separate stars ) , and there are (cid:0) 114 (cid:1)(cid:0) 75 (cid:1) = 6930 such graphs with an edge between vertices 1 and 2 ( these look like two joined stars with an isolated edge left over ) . Thus , the total number of realizations of d is 7392 . Running 500 trials of the algorithm gave the estimate 7176 . 1 , an error of 3 % . The algorithm with uniform selection of candidate gave the terrible estimate of 3702 . 0 with 500 trials , indicating the importance of choosing a good distribution on the candidate vertices . 10 . Trees . With a minor modiﬁcation , the sequential algorithm can be used to gen - erate random trees with a given degree sequence . The tree algorithm is simpler to analyze and faster than the graph algorithm . Moreover , with an appropriate choice of selection probabilities , the output is exactly uniform . This section uses some standard properties of trees and Pr¨ufer codes , which can be found in many good combinatorics books such as van Lint and Wilson [ 76 ] . Throughout this section , let n ≥ 2 and d = ( d 1 , . . . , d n ) be a degree sequence ( the 24 J . BLITZSTEIN AND P . DIACONIS case n = 1 is trivial ) . A tree with n vertices has n − 1 edges , so it is necessary that P ni = 1 d i = 2 n − 2 for a tree with degree sequence d to exist . Also , it is obviously necessary that d i ≥ 1 for all i . Conversely , it is easy to check ( by induction or using Pr¨ufer codes ) that these conditions are suﬃcient . So for trees , we can use the simple criterion below in place of Erd˝os - Gallai : Tree Criterion : There is a tree realizing d if and only if n X i = 1 d i = 2 n − 2 and d i ≥ 1 . We call a degree sequence satisfying the Tree Criterion arborical ( as the term “treeical” seemed too reminiscent of molasses ) . One simple algorithm uses Pr¨ufer codes . Let d be arborical . Generate a sequence of length n − 2 in which i appears d i − 1 times , and take a random permutation of this sequence . The result is the Pr¨ufer code of a uniformly distributed tree with degree sequence d . Of course , using this algorithm requires decoding the Pr¨ufer code to obtain the desired tree . The appearance of i exactly d i − 1 times in the Pr¨ufer code motivates the following modiﬁcation of our graph algorithm . In the tree algorithm below , we forbid creating an edge between two vertices of degree 1 ( except for the ﬁnal edge ) , and choose vertices with probability proportional to the degree minus 1 . Sequential Algorithm For Random Tree with Given Degrees Input : an arborical sequence ( d 1 , . . . , d n ) . 1 . Let E be an empty list of edges . 2 . If d is 0 except at i 6 = j with d i = d j = 1 , add { i , j } to E and terminate . 3 . Choose the least i with d i = 1 . 4 . Pick j of degree at least 2 , with probability proportional to d j − 1 . 5 . Add the edge { i , j } to E and update d to (cid:9) i , j d . 6 . Return to step 2 . Output : E . We need to show that the restriction against connecting degree 1 to degree 1 does not allow the tree algorithm to get stuck , and that the output is always a tree . Theorem 4 . Given an arborical sequence d = ( d 1 , . . . , d n ) as input , the algorithm above terminates with a tree realizing d . Proof . Note that there is no danger of creating multiple edges since except for the ﬁnal edge , each new edge joins a vertex of degree 1 to a vertex of degree greater than 1 , after which the degree 1 vertex is updated to degree 0 and not used again . We induct on n . For n = 2 , the only possible degree sequence is ( 1 , 1 ) , and the algorithm immediately terminates with the tree whose only edge is { 1 , 2 } . Assume that n ≥ 3 and the claim holds for n − 1 . ALGORITHM FOR GRAPHS WITH PRESCRIBED DEGREES 25 The sequence d must contain at least two 1’s , since otherwise the degree sum would be at least 2 n − 1 ( trees have leaves ! ) . And d must contain at least one entry greater than 1 , since otherwise the degree sum would be n < 2 n − 2 . Thus , the algorithm can complete the ﬁrst iteration , choosing an edge { i 0 , j 0 } where d i 0 = 1 , d j 0 > 1 . The algorithm then proceeds to operate on (cid:9) i 0 , j 0 d . Let d 0 be obtained from (cid:9) i 0 , j 0 d by deleting coordinate i 0 , which is the position of the only 0 in (cid:9) i 0 , j 0 d . Index the coordinates in d 0 as they were indexed in d . Then P n − 1 i = 1 d 0 i = 2 ( n − 1 ) − 2 and d 0 i ≥ 1 , so the inductive hypothesis applies to d 0 . Running the algorithm with d 0 as input gives a tree T 0 realizing d 0 , with { i 0 , j 0 } not an edge since T 0 does not even have a vertex labeled i 0 . Creating a leaf labeled i 0 in T 0 with an edge { i 0 , j 0 } yields a tree realizing d . Thus , the algorithm produces a tree of the desired form . It is well - known and easy to check ( again using induction or Pr¨ufer codes ; see Equation ( 2 . 4 ) in [ 76 ] ) that for any d , the number of labeled trees realizing d is the multinomial coeﬃcient N trees ( d 1 , . . . , d n ) = n − 2 d 1 − 1 , . . . , d n − 1 ! . We now show that the tree algorithm produces an exactly uniform tree . Proposition 4 . Let d be an arborical sequence . The output of the tree algorithm is a tree which is uniformly distributed among the N trees ( d ) trees realizing d . Proof . Let T be the random tree produced by the algorithm . There is only one order of edge generation which can produce T because at each stage a vertex of degree 1 is used . So it suﬃces to ﬁnd the probability of the algorithm generating the speciﬁc order of edges corresponding to T . Each vertex i with d i > 1 is chosen repeatedly ( not necessarily consecutively ) until its degree is reduced to 1 , each time with probability proportional to d i − 1 . The normalizing constant at each stage ( except for the ﬁnal joining of two 1’s ) is P i ( d i − 1 ) , summed over all i with d i > 1 . This quantity is initially n − 2 and decreases by 1 after each edge is picked , until it reaches a value of 1 . Thus , the probability of T being generated is ( d 1 − 1 ) ! ( d 2 − 1 ) ! · · · ( d n − 1 ) ! ( n − 2 ) ! = 1 / n − 2 d 1 − 1 , . . . , d n − 1 ! , which shows that T is uniformly distributed . 11 . An Exponential Model . For a labeled graph G with n vertices , let d i ( G ) be the degree of vertex i . In the preceding sections , we have kept d i ﬁxed . In this section , we allow d i to be random by putting an exponential model on the space of all labeled graphs with n vertices . In this model , the d i are used as energies or suﬃcient statistics . 26 J . BLITZSTEIN AND P . DIACONIS More formally , deﬁne a probability measure P β on the space of all graphs on n vertices by P β ( G ) = Z − 1 exp − n X i = 1 β i d i ( G ) ! , where Z is a normalizing constant . The real parameters β 1 , . . . , β n are chosen to achieve given expected degrees . This model appears explicitly in Park and Newman [ 59 ] , using the tools and language of statistical mechanics . Holland and Leinhardt [ 35 ] give iterative algorithms for the maximum likelihood es - timators of the parameters , and Snijders [ 65 ] considers MCMC methods . Techniques of Haberman [ 31 ] can be used to prove that the maximum likelihood estimates of the β i are consistent and asymptotically normal as n → ∞ , provided that there is a constant B such that | β i | ≤ B for all i . Such exponential models are standard fare in statistics , statistical mechanics , and social networking ( where they are called p ∗ models ) . They are used for directed graphs in Holland and Leinhardt [ 35 ] and for graphs in Frank and Strauss [ 27 , 70 ] and Snijders [ 65 , 66 ] , with a variety of suﬃcient statistics ( see the surveys in [ 3 ] , [ 56 ] , and [ 66 ] ) . One standard motivation for using the probability measure P β when the degree sequence is the main feature of interest is that this model gives the maximum entropy distribution on graphs with a given expected degree sequence ( see Lauritzen [ 43 ] for further discussion of this ) . Unlike most other exponential models on graphs , the normalizing constant Z is available in closed form . Furthermore , there is an easy method of sampling exactly from P β , as shown by the following . The same formulas are given in [ 59 ] , but for completeness we provide a brief proof . Lemma 1 . Fix real parameters β 1 , . . . , β n . Let Y ij be independent binary random vari - ables for 1 ≤ i < j ≤ n , with P ( Y ij = 1 ) = e − ( β i + β j ) 1 + e − ( β i + β j ) = 1 − P ( Y ij = 0 ) . Form a random graph G by creating an edge between i and j if and only if Y ij = 1 . Then G is distributed according to P β , with Z = Y 1 ≤ i < j ≤ n ( 1 + e − ( β i + β j ) ) . Proof . Let G be a graph and y ij = 1 if { i , j } is an edge of G , y ij = 0 otherwise . Then the probability of G under the above procedure is P ( Y ij = y ij for all i , j ) = Y i < j e − y ij ( β i + β j ) 1 + e − ( β i + β j ) . ALGORITHM FOR GRAPHS WITH PRESCRIBED DEGREES 27 The denominator in this expression is the claimed Z . The numerator simpliﬁes to e − P n i = 1 β i d i ( G ) since we can restrict the product to factors with y ij = 1 , and then each edge { i , j } con - tributes 1 to the coeﬃcients of both i and j . Note that putting β i = 0 results in the uniform distribution on graphs . Also , it follows from Lemma 1 above that choosing β i = β for all i , for β = − 12 log ( p 1 − p ) , we recover the classical Erd˝os - R´enyi model . Another model with given expected degrees and edges chosen independently is considered in Chung and Lu [ 17 , 18 ] , where an edge between i and j is created with probability w i w j / P k w k ( including the case i = j ) , where w i is the desired expected degree of vertex i and it is assumed that w 2 i < P k w k for all i . This has the advantage that it is immediate that the expected degree of vertex i is w i , without any parameter estimation required . The exponential model of this section makes it more diﬃcult to choose the β i , but it yields the maximum entropy distribution , makes the degrees suﬃcient statistics , and does not require the use of loops . If loops are desired in the exponential model , they may easily be added by allowing i = j in Lemma 1 . We would like to better understand the precise relationship between the distribution obtained from the Chung and Lu model and the maximum entropy distribution of the exponential model . We remark that the formula for the normalizing constant is equivalent to the identity Y 1 ≤ i < j ≤ n ( 1 + x i x j ) = X G n Y i = 1 x d i ( G ) i , where the sum on the right is over all graphs G on vertices 1 , . . . , n . This identity is closely related to the following symmetric function identity ( which is a consequence of Weyl’s identity for root systems ; see Exercise 9 in Section I . 5 of Macdonald [ 48 ] ) : Y 1 ≤ i < j ≤ n ( 1 + x i x j ) = X λ s λ , where s λ is the Schur function corresponding to a partition λ , and the sum on the right ranges over all partitions λ with Frobenius notation of the form ( α 1 − 1 · · · α r − 1 | α 1 · · · α r ) , with α 1 ≤ n − 1 . We hope to ﬁnd ( and use ) a stochastic interpretation for this Schur function expansion . The exponential model given by P β is quite rich ; it has n real parameters . We can test the suitability of the model ( with unspeciﬁed parameters ) by conditioning on the degrees and using the following lemma ( which follows easily from the fact that P β ( G ) depends on G only through its degrees ) . Lemma 2 . If a graph G is chosen according to P β for any ﬁxed choice of the parameters β 1 , . . . , β n , the conditional distribution of G given its degrees d 1 ( G ) , . . . , d n ( G ) is uniform over all graphs with this degree sequence . 28 J . BLITZSTEIN AND P . DIACONIS Thus , we may test the exponential model P β given a speciﬁc graph G with degrees d i ( G ) as follows . First choose any test statistic T ( such as the number of triangles , the diameter , the number of components , or the size of the largest component ) , and compute T ( G ) . Then generate a large number of uniform graphs with the same degrees as G , and compare the observed value of T ( G ) against the distribution of T obtained from the sampled random graphs . For history and background on these conditional tests , see Diaconis and Sturmfels [ 22 ] . An alternative approach to testing such a model is to embed it in a larger family , as in Holland and Leinhardt [ 35 ] . Indeed , it is shown in Section 4 . 4 of Lehmann and Romano [ 44 ] that our proposed test is optimal ( UMP unbiased ) in the exponential model extended by adding T ( G ) to the suﬃcient statistic ( d 1 ( G ) , . . . , d n ( G ) ) . As an example , we return now to the Chesapeake Bay food web shown in Figure 1 . The graph has 33 vertices including at least one of every degree from 1 to 10 , as illustrated below . Note that the degrees vary widely but do not resemble a power - law distribution . Fig 5 . frequencies of degrees in Chesapeake food web As a ﬁrst test statistic , we computed the clustering coeﬃcient of each graph . Intuitively , the clustering coeﬃcient measures how cliquish a network is , in the sense of how likely it is for two neighbors of the same vertex to be connected . There are a few diﬀerent deﬁnitions in use , but we will use the original deﬁnition of Watts and Strogatz [ 78 ] : for each vertex v of degree d v ≥ 2 , let C v be the proportion of edges present between neighbors of v out of the (cid:0) d v 2 (cid:1) possible edges . Put C v = 0 if d v < 2 . The clustering coeﬃcient of a graph is then deﬁned to be the average of C v over all vertices of the graph . Using the estimator ˜ µ of Section 8 . 2 , the estimated average clustering coeﬃcient for a graph with the same degrees as the food web is 0 . 157 . A histogram of the estimated distribution of the clustering coeﬃcient is shown below . To generate each bin , we again used the estimator ˜ µ , with f the indicator function of the clustering coeﬃcient falling into that interval . The actual clustering coeﬃcient of the food web is 0 . 176 , slightly above the mean . Thus , the clustering coeﬃcient agrees well with the predictions of the exponential model . ALGORITHM FOR GRAPHS WITH PRESCRIBED DEGREES 29 Fig 6 . histogram of clustering coeﬃcients ; real food web value is 0 . 176 In an attempt to explain and quantify the observation that the actual food web appeared more compact and neatly ordered than most of the random graphs such as those shown in Figures 2 and 3 , we decided to look at cycles in the graphs . Speciﬁcally , we counted the number of k - cycles in the real food web and the ﬁrst 1000 random graphs , for 3 ≤ k ≤ 6 . The cycles are treated as unoriented subgraphs of the graph , i . e . , a cycle x → y → z → x is considered the same cycle as y → z → x → y and x → z → y → x . The enumeration was done by recursively counting the number of simple paths from v to v , summing over all v , and dividing by 2 k since each cycle can be started at any of its k vertices and traversed in either direction . Histograms of the numbers of k - cycles are shown in Figure 7 . For 3 - cycles ( triangles ) , the actual value of 18 is extremely close to the estimated mean , which is 19 . This is not surprising , especially since the clustering coeﬃcient is closely related to the number of triangles . For 4 - cycles though , the actual value of 119 is nearly double the estimated mean of 60 . In fact , the number of 4 - cycles in the actual food web is larger than the number of 4 - cycles in any of the 1000 random graphs tested ! Explaining this of course requires looking at the directed graph , but the undirected graph was very helpful in detecting this phenomenon in the ﬁrst place . Inspecting the corresponding directed subgraphs , two forms are prevalent : ( 1 ) x and y both eat z and w and ( 2 ) x eats y and z , while y and z eat w . Interestingly , Milo et al . [ 53 ] observe that pattern ( 2 ) is extremely common in all seven of the food webs they study . They call a pattern which occurs much more often in real networks of some kind than in the corresponding random networks a “network motif” ( see also Itzkovitz et al . [ 36 ] for more on network motifs ) . Finding network motifs can reveal structure in the network which would be missed by taking a highly degree - centric point of view . In generating random graphs for comparison purposes , Milo et al . use two algorithms . First , they use the switchings Markov chain discussed in Section 3 . 5 ( adapted for directed graphs ) , which is not known to be rapidly mixing for general degree sequences . Second , they use a variant of the pairing model , modiﬁed from an algorithm in Newman , Strogatz 30 J . BLITZSTEIN AND P . DIACONIS Fig 7 . histograms of k - cycle counts ; real food web has 18 , 119 , 153 , 582 respectively and Watts [ 57 ] . Their algorithm sometimes gets stuck and the output is non - uniform , as explained in King [ 41 ] . Our algorithm also has a non - uniform output distribution , but never gets stuck and makes it easy to estimate with respect to the uniform distribution , provided that undirected graphs can be used ( which depends on the speciﬁc application ) . Returning to the cycle results , for 5 - cycles the actual value is 153 , which is signiﬁcantly lower than the estimated mean of 191 . It is at the 5th percentile of the estimated distribu - tion . For 6 - cycles , the actual value of 582 is close to the estimated mean of 595 . This was rather surprising , as the intuition that the food web is fairly hierarchical ( the big ﬁsh eats the small ﬁsh ) would suggest that there would be few long or moderately long cycles in the real graph . A biological interpretation would be welcome for why 4 - cycles are extremely common and 5 - cycles are rare , while 6 - cycles are close to the middle of the distribution . Software . Graphs were drawn using Graphviz [ 24 ] . The implementation of the algorithm and importance sampling computations presented here were done using Mathematica [ 79 ] and R [ 60 ] on Mac OS X . Source code for the algorithm is freely available by making an e - mail request to the ﬁrst author . Acknowledgements . We thank Alex Gamburd , Susan Holmes , Brendan McKay , Richard ALGORITHM FOR GRAPHS WITH PRESCRIBED DEGREES 31 Stanley , and Nick Wormald for their helpful suggestions and references . REFERENCES [ 1 ] Aiello , W . , Chung , F . , and Lu , L . ( 2001 ) . A random graph model for power law graphs . Experiment . Math . 10 , 1 , 53 – 66 . [ 2 ] Aiello , W . , Chung , F . , and Lu , L . ( 2002 ) . Random evolution in massive graphs . In Handbook of massive data sets . Massive Comput . , Vol . 4 . Kluwer Acad . Publ . , Dordrecht , 97 – 122 . [ 3 ] Anderson , C . , Wasserman , S . , and Crouch , B . ( 1999 ) . A p ∗ primer : Logit models for social networks . Social Networks 21 , 37 – 66 . [ 4 ] Arratia , R . and Liggett , T . M . ( 2005 ) . How likely is an i . i . d . degree sequence to be graphical ? Ann . Appl . Probab . 15 , 1B , 652 – 670 . [ 5 ] Baird , D . and Ulanowicz , R . E . ( 1989 ) . The seasonal dynamics of the Chesapeake bay ecosystem . Ecological Monographs 59 , 329 – 364 . [ 6 ] Barab´asi , A . - L . and Albert , R . ( 1999 ) . Emergence of scaling in random networks . Science 286 , 509 – 512 . [ 7 ] Bassetti , F . and Diaconis , P . ( 2005 ) . Examples comparing importance sampling and the Metropolis algorithm . Preprint . [ 8 ] Bender , E . A . and Canfield , E . R . ( 1978 ) . The asymptotic number of labeled graphs with given degree sequences . J . Combinatorial Theory Ser . A 24 , 3 , 296 – 307 . [ 9 ] Berge , C . ( 1976 ) . Graphs and Hypergraphs . Elsevier , New York . [ 10 ] Blitzstein , J . K . ( 2006 ) . Building random objects sequentially : From characterization to algorithm . Ph . D . thesis , Stanford University . In preparation . [ 11 ] Bollob´as , B . ( 1980 ) . A probabilistic proof of an asymptotic formula for the number of labelled regular graphs . European J . Combin . 1 , 4 , 311 – 316 . [ 12 ] Bollob´as , B . , Riordan , O . , Spencer , J . , and Tusn´ady , G . ( 2001 ) . The degree sequence of a scale - free random graph process . Random Structures Algorithms 18 , 3 , 279 – 290 . [ 13 ] Britton , T . , Deijfen , M . , and Martin - L¨of , A . ( 2005 ) . Generating simple random graphs with prescribed degree distribution . Preprint . [ 14 ] Chen , Y . , Diaconis , P . , Holmes , S . , and Liu , J . S . ( 2005 ) . Sequential Monte Carlo methods for statistical analysis of tables . Journal of the American Statistical Association 100 , 109 – 120 . [ 15 ] Chen , Y . , Dinwoodie , I . , and Sullivant , S . ( 2005 ) . Sequential importance sampling for multiway tables . Annals of Statistics ( to appear ) . [ 16 ] Choudum , S . A . ( 1986 ) . A simple proof of the Erd˝os - Gallai theorem on graph sequences . Bull . Austral . Math . Soc . 33 , 1 , 67 – 70 . [ 17 ] Chung , F . and Lu , L . ( 2002a ) . The average distances in random graphs with given expected degrees . Proc . Natl . Acad . Sci . USA 99 , 25 , 15879 – 15882 ( electronic ) . [ 18 ] Chung , F . and Lu , L . ( 2002b ) . Connected components in random graphs with given expected degree sequences . Ann . Comb . 6 , 2 , 125 – 145 . [ 19 ] Cooper , C . , Dyer , M . , and Greenhill , C . ( 2005 ) . Sampling regular graphs and a peer - to - peer network . Preprint . [ 20 ] Cooper , C . and Frieze , A . ( 2003 ) . A general model of web graphs . Random Structures Algo - rithms 22 , 3 , 311 – 335 . [ 21 ] Diaconis , P . and Gangolli , A . ( 1995 ) . Rectangular arrays with ﬁxed margins . In Discrete probability and algorithms ( Minneapolis , MN , 1993 ) . IMA Vol . Math . Appl . , Vol . 72 . Springer , New York , 15 – 41 . [ 22 ] Diaconis , P . and Sturmfels , B . ( 1998 ) . Algebraic algorithms for sampling from conditional distri - butions . Ann . Statist . 26 , 1 , 363 – 397 . [ 23 ] Doucet , A . , de Freitas , N . , and Gordon , N . ( 2001 ) . An introduction to sequential Monte Carlo methods . In Sequential Monte Carlo methods in practice . Stat . Eng . Inf . Sci . Springer , New York , 3 – 14 . [ 24 ] Ellson , J . , Gansner , E . , Koutsofios , E . , North , S . , and Woodhull , G . ( 2003 ) . Graphviz and dynagraph – static and dynamic graph drawing tools . In Graph Drawing Software , M . Junger and 32 J . BLITZSTEIN AND P . DIACONIS P . Mutzel , Eds . Springer - Verlag , Berlin , 127 – 148 . [ 25 ] Erd˝os , P . and Gallai , T . ( 1960 ) . Graphen mit punkten vorgeschriebenen grades . Mat . Lapok 11 , 264 – 274 . [ 26 ] Fishman , G . S . ( 1996 ) . Monte Carlo : Concepts , Algorithms , and Applications . Springer Series in Operations Research . Springer - Verlag , New York . [ 27 ] Frank , O . and Strauss , D . ( 1986 ) . Markov graphs . J . Amer . Statist . Assoc . 81 , 395 , 832 – 842 . [ 28 ] Gamburd , A . ( 2005 ) . Poisson - Dirichlet distribution for random Belyi surfaces . Preprint . [ 29 ] Gkantsidis , C . , Mihail , M . , and Zegura , E . ( 2003 ) . The Markov chain simulation method for generating connected power law random graphs . In Proc . 5th Workshop on Algorithm Engineering and Experiments ( ALENEX ) . SIAM , Philadelphia . [ 30 ] Goulden , I . P . and Jackson , D . M . ( 2004 ) . Combinatorial enumeration . Dover Publications Inc . , Mineola , NY . [ 31 ] Haberman , S . J . ( 1977 ) . Maximum likelihood estimates in exponential response models . Ann . Statist . 5 , 5 , 815 – 841 . [ 32 ] Hakimi , S . L . ( 1962 ) . On realizability of a set of integers as degrees of the vertices of a linear graph . I . J . Soc . Indust . Appl . Math . 10 , 496 – 506 . [ 33 ] Hammersley , J . M . and Handscomb , D . C . ( 1965 ) . Monte Carlo methods . Methuen & Co . Ltd . , London . [ 34 ] Havel , V . ( 1955 ) . A remark on the existence of ﬁnite graphs . ˘Casopis P˘est . Mat . 80 , 477 – 480 . [ 35 ] Holland , P . W . and Leinhardt , S . ( 1981 ) . An exponential family of probability distributions for directed graphs . J . Amer . Statist . Assoc . 76 , 373 , 33 – 65 . [ 36 ] Itzkovitz , S . , Milo , R . , Kashtan , N . , Ziv , G . , and Alon , U . ( 2003 ) . Subgraphs in random networks . Phys . Rev . E ( 3 ) 68 , 2 , 026127 , 8 . [ 37 ] Jerrum , M . and Sinclair , A . ( 1990 ) . Fast uniform generation of regular graphs . Theoret . Comput . Sci . 73 , 1 , 91 – 100 . [ 38 ] Jerrum , M . , Sinclair , A . , and McKay , B . ( 1992 ) . When is a graphical sequence stable ? In Random graphs , Vol . 2 ( Pozna´n , 1989 ) . Wiley - Intersci . Publ . Wiley , New York , 101 – 115 . [ 39 ] Kim , J . H . and Vu , V . H . ( 2003 ) . Generating random regular graphs . In Proceedings of the Thirty - Fifth Annual ACM Symposium on Theory of Computing . ACM , New York , 213 – 222 ( electronic ) . [ 40 ] Kim , J . H . and Vu , V . H . ( 2004 ) . Sandwiching random graphs : universality between random graph models . Adv . Math . 188 , 2 , 444 – 469 . [ 41 ] King , O . D . ( 2004 ) . Comment on : “Subgraphs in random networks” . Phys . Rev . E 70 , 5 , 058101 , 3 . [ 42 ] Kong , A . , Liu , J . S . , and Wong , W . H . ( 1994 ) . Sequential imputations and Bayesian missing data problems . Journal of the American Statistical Association 89 , 425 , 278 – 288 . [ 43 ] Lauritzen , S . L . ( 1988 ) . Extremal families and systems of suﬃcient statistics . Lecture Notes in Statistics , Vol . 49 . Springer - Verlag , New York . [ 44 ] Lehmann , E . L . and Romano , J . P . ( 2005 ) . Testing statistical hypotheses . Springer Texts in Statistics . Springer , New York . [ 45 ] Liu , J . S . ( 2001 ) . Monte Carlo strategies in scientiﬁc computing . Springer Series in Statistics . Springer - Verlag , New York . [ 46 ] Liu , J . S . and Chen , R . ( 1998 ) . Sequential Monte Carlo methods for dynamic systems . J . Amer . Statist . Assoc . 93 , 443 , 1032 – 1044 . [ 47 ] Lov´asz , L . and Plummer , M . D . ( 1986 ) . Matching theory . North - Holland Mathematics Studies , Vol . 121 . North - Holland Publishing Co . , Amsterdam . [ 48 ] Macdonald , I . G . ( 1995 ) . Symmetric functions and Hall polynomials . Oxford Mathematical Mono - graphs . The Clarendon Press Oxford University Press , New York . [ 49 ] Mahadev , N . V . R . and Peled , U . N . ( 1995 ) . Threshold graphs and related topics . Annals of Discrete Mathematics , Vol . 56 . North - Holland Publishing Co . , Amsterdam . [ 50 ] McKay , B . D . and Wormald , N . C . ( 1990a ) . Asymptotic enumeration by degree sequence of graphs of high degree . European J . Combin . 11 , 6 , 565 – 580 . ALGORITHM FOR GRAPHS WITH PRESCRIBED DEGREES 33 [ 51 ] McKay , B . D . and Wormald , N . C . ( 1990b ) . Uniform generation of random regular graphs of moderate degree . J . Algorithms 11 , 1 , 52 – 67 . [ 52 ] McKay , B . D . and Wormald , N . C . ( 1991 ) . Asymptotic enumeration by degree sequence of graphs with degrees o ( n 1 / 2 ) . Combinatorica 11 , 4 , 369 – 382 . [ 53 ] Milo , R . , Shen - Orr , S . , Itzkovitz , S . , Kashtan , N . , Chklovskii , D . , and Alon , U . ( 2002 ) . Network motifs : simple building blocks of complex networks . Science 298 , 824 – 827 . [ 54 ] Molloy , M . and Reed , B . ( 1995 ) . A critical point for random graphs with a given degree sequence . Random Structures and Algorithms 6 , 2 - 3 , 161 – 179 . [ 55 ] Molloy , M . and Reed , B . ( 1998 ) . The size of the giant component of a random graph with a given degree sequence . Combin . Probab . Comput . 7 , 3 , 295 – 305 . [ 56 ] Newman , M . ( 2003 ) . The structure and function of complex networks . SIAM Review 45 , 167 – 256 . [ 57 ] Newman , M . E . J . , Strogatz , S . , and Watts , D . ( 2001 ) . Random graphs with arbitrary degree distributions and their applications . Physical Review E 64 , 026118 . [ 58 ] Owen , A . and Zhou , Y . ( 2000 ) . Safe and eﬀective importance sampling . Journal of the American Statistical Association 95 , 449 , 135 – 143 . [ 59 ] Park , J . and Newman , M . E . J . ( 2004 ) . Statistical mechanics of networks . Phys . Rev . E ( 3 ) 70 , 6 , 066117 , 13 . [ 60 ] R Development Core Team . ( 2005 ) . R : A language and environment for statistical computing . R Foundation for Statistical Computing , Vienna . [ 61 ] Robalewska , H . D . and Wormald , N . C . ( 2000 ) . Random star processes . Combin . Probab . Com - put . 9 , 1 , 33 – 43 . [ 62 ] Rubinstein , R . Y . and Kroese , D . P . ( 2004 ) . The cross - entropy method . Information Science and Statistics . Springer - Verlag , New York . [ 63 ] Ruci´nski , A . and Wormald , N . C . ( 1992 ) . Random graph processes with degree restrictions . Com - bin . Probab . Comput . 1 , 2 , 169 – 180 . [ 64 ] Sloane , N . J . A . ( 2005 ) . The on - line encyclopedia of integer sequences , published electronically at http : / / www . research . att . com / ∼ njas / sequences / . [ 65 ] Snijders , T . ( 2002 ) . Markov chain Monte Carlo estimation of exponential random graph models . Journal of Social Structure 3 , 2 . [ 66 ] Snijders , T . , Pattison , P . , Robins , G . , and Handcock , M . ( 2004 ) . New speciﬁcations for expo - nential random graph models . Preprint . [ 67 ] Snijders , T . A . B . ( 1991 ) . Enumeration and simulation methods for 0 - 1 matrices with given marginals . Psychometrika 56 , 3 , 397 – 417 . [ 68 ] Stanley , R . P . ( 1999 ) . Enumerative combinatorics . Vol . 2 . Cambridge University Press , Cambridge . [ 69 ] Steger , A . and Wormald , N . C . ( 1999 ) . Generating random regular graphs quickly . Combin . Probab . Comput . 8 , 4 , 377 – 396 . [ 70 ] Strauss , D . ( 1986 ) . On a general class of models for interaction . SIAM Review 28 , 4 , 513 – 527 . [ 71 ] Taylor , R . ( 1982 ) . Switchings constrained to 2 - connectivity in simple graphs . SIAM J . Algebraic Discrete Methods 3 , 1 , 114 – 121 . [ 72 ] Tinhofer , G . ( 1979 ) . On the generation of random graphs with given properties and known distri - bution . Applied Computer Science Berichte Praktische Informatik 13 , 265 – 296 . [ 73 ] Tinhofer , G . ( 1990 ) . Generating graphs uniformly at random . Computing Supplementum 7 , 235 – 255 . [ 74 ] Tripathi , A . and Vijay , S . ( 2003 ) . A note on a theorem of Erd˝os & Gallai . Discrete Math . 265 , 1 - 3 , 417 – 420 . [ 75 ] Ulanowicz , R . E . ( 2005 ) . Ecosystem network analysis web page , published electronically at http : / / www . cbl . umces . edu / ∼ ulan / ntwk / network . html . [ 76 ] van Lint , J . H . and Wilson , R . M . ( 2001 ) . A course in combinatorics , Second ed . Cambridge University Press , Cambridge . [ 77 ] Viger , F . and Latapy , M . ( 2005 ) . Fast generation of random connected graphs with prescribed degrees . Preprint . 34 J . BLITZSTEIN AND P . DIACONIS [ 78 ] Watts , D . J . and Strogatz , S . H . ( 1998 ) . Collective dynamics of ’small - world’ networks . Na - ture 393 , 6684 , 440 – 442 . [ 79 ] Wolfram Research . ( 2001 ) . Mathematica , Version 4 . 2 . [ 80 ] Wormald , N . C . ( 1984 ) . Generating random regular graphs . J . Algorithms 5 , 2 , 247 – 280 . [ 81 ] Wormald , N . C . ( 1999 ) . Models of random regular graphs . In Surveys in combinatorics , 1999 ( Canterbury ) . London Math . Soc . Lecture Note Ser . , Vol . 267 . Cambridge Univ . Press , Cambridge , 239 – 298 . Department of Mathematics Stanford , CA 94305 e - mail : jkb @ math . stanford . edu Departments of Mathematics and Statistics Stanford , CA 94305