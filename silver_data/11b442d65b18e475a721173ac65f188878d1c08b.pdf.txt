Working Apart Together Foundations for Component Groupware G . Henri ter Hofte Enschede , The Netherlands , 1998 Telematica Instituut Fundamental Research Series , No . 001 ( TI / FRS / 001 ) Cover Design : Studio Oude Vrielink , Losser and Jos Hendrix , Groningen Book Design : Lidwien van de Wijngaert and Henri ter Hofte Printing : Universal Press , Veenendaal , The Netherlands Pictures : page 8 : by courtesy of Douglas Engelbart ; page 16 : by courtesy of Tom Brinck Samenstelling promotiecommissie : Voorzitter , secretaris : prof . dr . P . M . G . Apers Promotor : prof . dr . ir . C . A . Vissers Deskundige : dr . H . J . van der Lugt ( Telematica Instituut ) Referent : dr . P . Dewan ( University of North Carolina , USA ) Leden : prof . dr . J . H . E . Andriessen ( TU Delft ) dr . ir . M . A . W . Houtsma ( Telematica Instituut ) prof . ir . E . F . Michiels prof . dr . ir . I . G . M . M . Niemegeers dr . ir . M . J . van Sinderen ISSN 1388 - 1795 ; No . 001 ISBN 90 - 75176 - 14 - 7 Copyright © 1998 , Telematica Instituut , The Netherlands All rights reserved . Subject to exceptions provided for by law , no part of this publication may be reproduced , stored in a retrieval system , or transmitted , in any form or by any means , electronic , mechanical , photocopying , recording or otherwise , without the prior written permission of the copyright owner . No part of this publication may be adapted in whole or in part without the prior written permission of the author . Telematica Instituut , P . O . Box 589 , 7500 AN Enschede , The Netherlands E - mail : info @ telin . nl ; Internet : http : / / www . telin . nl Telephone : + 31 ( 0 ) 53 - 4850485 ; Fax : + 31 ( 0 ) 53 - 485400 WORKING APART TOGETHER FOUNDATIONS FOR COMPONENT GROUPWARE PROEFSCHRIFT ter verkrijging van de graad van doctor aan de Universiteit Twente , op gezag van de rector magnificus , prof . dr . F . A . van Vught , volgens besluit van het College voor Promoties in het openbaar te verdedigen op donderdag 4 juni 1998 te 13 . 15 uur . door Gerard Henri ter Hofte geboren op 18 februari 1969 te Enschede Dit proefschrift is goedgekeurd door de promotor , prof . dr . ir . C . A . Vissers . Preface This thesis is the culmination of five years of Working Apart Together . As a research theme , it struck me in 1993 that Working Apart Together was not only a way of working that groupware systems were designed to support , but also a principle that could be applied within the groupware systems themselves . As far as I can recollect , the original ideas that laid the basis for this thesis went something like “If groupware systems are designed to support people working apart together , thus enabling them to deliver better products or services to customers , why , then , not have different groupware applications themselves working apart together , thus delivering a better groupware service to their human users ? After all , if we don’t expect people to be omnipotent , why should we expect this from groupware applications ? ” I owe it to the Telematica Instituut and my Ph . D . supervisor Chris Vissers that I have been given the opportunity to pursue these intriguing questions in my research for the past years . Chris , thank you for your confidence in me , your time to provide guidance and review drafts despite your busy schedule as the scientific director of a newly founded research institute , and for trying to convey your experience in structuring distributed systems to me . Some day , I hope to understand 10 % of your work . As a way of working , Working Apart Together best sums up what was required to bring about this thesis . From a distance , writing a Ph . D . thesis may seem the most individual form of work conceivable , resembling a play with a single actor playing the part of researcher , system designer , author , graphic designer , critic , defender , as well as the occasional supporting part of system administrator , and pre - press and printing consultant . In a sense , this is a true reflection of reality . However , this is not the whole truth , I am glad to say . The work for this thesis has been a collaborative endeavour in many respects , which involved substantial efforts , generous help and support of many people ‘behind the VI P REFACE scenes’ , including both my colleagues at the Telematica Instituut and the participants of the research projects Platinum and MESH . I express my gratitude to all of you . In particular , I would like to mention a few people without whom this thesis could not have been accomplished . First and foremost , I would like to thank Hermen van der Lugt for being my ‘coach’ for all these years . Hermen , your calmness , sincerity and mind - boggling capacity to listen were a perfect counterbalance for my eagerness and inclination to talk . I would also like to thank Martin Wibbels and Harm Bakker for doing most of the implementation of CoCoDoc and MORB . Thanks , guys , for making me sorry we didn’t set up CoCoDoc Laboratories and MORB , Inc . Thanks are also due to Maurice Houtsma , for his consistent and meticulous reviewing work and supervision . Maurice , I did value your comments more than you might expect . I owe many thanks to my other reviewers , Prasun Dewan of the University of North Carolina and Marten van Sinderen of the University of Twente , for their proof - reading and suggestions to improve this thesis . Thank you for finding the time in your busy schedules . Thanks , also , to Douglas Engelbart for inventing groupware , along with other inventions , such as the mouse . You probably flabbergasted me more by picking up the phone in person than you did your audience in 1968 when you demonstrated the mouse , the groupware system NLS and videoconferencing . Thank you for the slides of the 1968 demo and for that final bit of pleasant adrenaline I needed to finish this thesis . The Telematica Instituut has been the stimulating working environment I had hoped for . Special thanks go to all ( ex - ) members of the TAO group , who formed a crucial bit of the social fabric at work . As a way of living , Working Apart Together has also dominated my personal life for the past five years . I owe this to my parents , who gave me more perseverance than they now think is good for me and to my in - laws , who were always confident that doing Ph . D . research was the natural thing for me to do . Thank you for setting the stage and leaving me the choice . There is one person , finally , who has been truly vital throughout . Anita , I know that not so much our working apart together in a physical sense due to our one hour commute in opposite directions and my long hours at work , but rather my regular mental absence associated with writing a thesis must have been the toughest part for you of five years of working apart together . That you married me amidst all of this and that we didn’t reach the stage of Sleeping Apart Together , is a clear testimony to your love and encouragement that enabled me to write this thesis in the first place . Henri ter Hofte Zutphen , the Netherlands , May 1998 Contents C HAPTER 1 Introduction 1 1 . 1 Objective 2 1 . 2 Approach 3 1 . 3 Structure 3 C HAPTER 2 Groupware : an Overview 7 2 . 1 Groupware Systems : History and State of the Art 8 2 . 2 Developing Groupware 34 2 . 3 The Need for Integration , Flexibility and Tailorability 46 2 . 4 Conclusions 51 C HAPTER 3 Design Concepts for Extensibility and Composability 53 3 . 1 Extensibility and Composability 53 3 . 2 A Model of Groupware Design 59 3 . 3 Summary 75 C HAPTER 4 A Generic Model of Groupware 77 4 . 1 A Model of Cooperative Work 78 4 . 2 A Generic Groupware Service Model 88 4 . 3 Example 111 4 . 4 Conclusions 111 C HAPTER 5 A Reference Architecture for Component Groupware 113 5 . 1 Structuring Guidelines at Service Level 114 5 . 2 The CoMeCo Groupware Service Architecture 120 5 . 3 Conclusions 137 VIII C ONTENTS C HAPTER 6 Collaborative Compound Document Editing 139 6 . 1 CoCoDoc Service and Logical Architecture 140 6 . 2 The CoCoDoc Framework 151 6 . 3 CoCoDoc Distributed Architecture 153 6 . 4 Platform Support for Distributed Grouplets 168 6 . 5 Conclusions 190 C HAPTER 7 Implementation 193 7 . 1 Context : the Projects Platinum and MESH 193 7 . 2 MediaBuilder : a CoMeCo Prototype 195 7 . 3 MORB : a Prototype Collaborative Object Group Platform 198 7 . 4 CoCoDoc Prototype 210 7 . 5 CoCoTree : a Simple Collaborative Outline Editor 212 7 . 6 Directions for Further Development 219 7 . 7 Conclusions 222 C HAPTER 8 Conclusions and Further Research 225 8 . 1 Contributions of This Book 228 8 . 2 Directions for Further Research and Development 229 A PPENDIX A Service Specification of a Simple Shared Whiteboard 231 A PPENDIX B Ordered Message Delivery 235 B . 1 F IFO Order 236 B . 2 C AUSAL Order 237 B . 3 T OTAL Order 240 B . 4 T RANSFORMED Order 244 Samenvatting 249 References 255 Index 275 Chapter 1 1 . Introduction Fuelled by organisational trends , such as increased teamwork , and technical trends , such as increased availability of networked computing , Computer Supported Cooperative Work ( CSCW ) has emerged as a promising way of supporting tasks that are carried out by groups of mutually dependent persons . Despite this promise , however , computer support for cooperative work — which is also known as groupware — often fails to provide adequate support for day - to - day cooperative work . Studies have shown that support for limited collaborative tasks only , inflexible support and a lack of integration between different types of groupware hinder the productive use of groupware . We believe that these problems should be addressed by alleviating the tension that exists between the demanding requirements for comprehensive and flexible groupware services on the one hand and the complexity of groupware development on the other hand , as described below ( see also chapter 2 for a more detailed motivation ) . On the one hand , groupware developers face demanding requirements for groupware services . Depending on factors such as task , group , duration and context , cooperative work can have many forms . These forms often change over time , even within the confines of a single project . To support such dynamic contexts , groupware services typically should be comprehensive and flexible . For example , requirements may range between support for : – same - time and different - time cooperative work ; – same - place and different - place cooperative work ; – single , discrete media such as text or graphics , and multiple media including continuous media such as audio and video ; – much freedom in the actions of users ( permissive support ) and coordination of the actions of users ( restrictive support ) . On the other hand , groupware developers face many complexities in the groupware development process . Compared to the development of single - user 2 C HAPTER 1 I NTRODUCTION applications , the development of groupware systems involves many additional technical issues from the area of distributed systems development , such as replication , consistency , concurrency , and communication protocols . In this book , we focus on the achievement of two properties of groupware systems , viz . extensibility and composability , as a means to alleviate the tension between the demand side and the supply side of groupware development . Given the contingent nature of the relation between the form of cooperative work and the type of support that is required from groupware systems , composability is a desirable property of groupware : it allows groupware users and user organisations to pick and mix different groupware components , thus facilitating users to tailor the support provided by a groupware system to the situations in which it is used . Given the complexity of groupware development and the evolution of groupware user requirements , extensibility is another desirable property of groupware : it allows users to add groupware components as soon as available or as late as needed . Together , composability and extensibility allow developers to focus on the development of groupware components , i . e . , relatively small chunks of groupware functionality . With this book , we aim to contribute to the design of extensible and composable groupware systems  systems we will also refer to in the rest of this book as component groupware . 1 . 1 Objective A design trajectory of complex systems such as component groupware systems typically involves the creation of several related designs . Making decisions about the structure of each of these designs is one of the most challenging design tasks , which may have a profound impact on the composability and extensibility of the system ( see also chapter 3 ) . Therefore , the main objective of this book is to provide an answer to the following research question : How should groupware systems be structured , in order to achieve extensibility and composability ? A PPROACH 3 1 . 2 Approach In this book , we provide structuring guidelines , generic architectures and platforms as the foundations that can be used by developers of component groupware to achieve extensibility and composability . – Structuring guidelines are rules that help designers to choose appropriate structures in their designs . In this book , we propose various guidelines for component groupware . – Generic architectures are structured high - level designs that can be used for a range of systems . In this book , we develop generic architectures for component groupware that conform to the proposed structuring guidelines . These architectures can be used by designers as a generic template for the structure of a component groupware system , from which the structure of a specific component groupware system can be derived . – Platforms are any form of re - usable functionality , such as libraries , toolkits , languages , frameworks , or run - time support functions , that embody generic design knowledge for a particular class of systems . In this book we propose several platforms , primarily as a means to embody , support and promote the use of the proposed structuring guidelines and generic architectures . In our research that led to the structuring guidelines , generic architectures and platforms , we used the following approach : – Study the design and structure ( at various levels of abstraction ) of existing groupware systems . – Develop guidelines and generic architectures ( for each level of abstraction ) that help to structure the design of component groupware systems . – Apply and support these guidelines and architectures in groupware platforms . – Demonstrate , test and improve the structuring guidelines , architectures and platforms by implementing prototypes . 1 . 3 Structure The chapters following this introductory chapter can be grouped as follows . Chapters 2 and 3 provide a frame of reference . – Chapter 2 , Groupware : an overview introduces various types of existing groupware systems , describes the complexities faced by developers of groupware systems and motivates the need for extensible and 4 C HAPTER 1 I NTRODUCTION composable groupware based on results from studies of computer supported cooperative work . – Chapter 3 , Design concepts for extensibility and composability , provides definitions for various concepts related to the design of extensible and composable groupware systems that will be used throughout this book . It defines extensibility and composability , i . e . , the target properties of groupware systems in this book ; concepts for the design process of groupware systems , i . e . , the context in which we try to achieve extensibility and composability , as well as structuring guidelines , architectures and platforms , i . e . , the means we use to achieve extensibility and composability in this context . Moreover , it defines three abstraction levels in the design trajectory of groupware systems , viz . service level , logical level and distributed level : for each of these levels , we propose structuring guidelines , architectures and platforms . Chapters 4 , 5 and 6 provide structuring guidelines , architectures and platforms for the design of component groupware . As such , they constitute the core of this book . Each chapter proposes a coherent set of structuring guidelines , an architecture and / or a platform . Each chapter has a different scope in terms of service provided to users and in terms of coverage of the three abstraction levels , as discussed below . – Chapter 4 , A Generic Model of Groupware , covers the entire range of groupware services we identify in chapter 2 , but focuses only on the service level design of a groupware system . Based on an analysis of a range of existing groupware applications and on a conceptual model of cooperative work , it defines , both informally and formally , a generic model of groupware services . As such , it forms the basis for the reference architecture for component groupware in the next chapter . – Chapter 5 , CoMeCo , a Reference Architecture for Component Groupware , proposes guidelines to structure groupware services at a high level . These structuring guidelines are applied to the generic model of groupware of chapter 4 . Thus , we obtain a generic high - level service architecture , that can be used as a reference architecture for extensible and composable groupware services . For each of the service components , we describe essential design parameters . – Chapter 6 , Collaborative Compound Document Editing , is restricted to medium services , one of the service component types that was identified in chapter 5 . For this type of service , we propose more detailed structuring guidelines that can be used to decompose a medium service in smaller parts . Based on these detailed structuring guidelines , we define a detailed service and logical architecture . In addition , we propose structuring guidelines and architectures at the distributed level . Moreover , we describe the functionality of two related platforms that S TRUCTURE 5 provide support for the proposed logical and distributed architecture , respectively . Chapter 7 , Implementation , describes our implementation of prototypes of the set of related platforms proposed in the previous chapters . In addition , it describes the implementation of a simple extensible and composable groupware system on top of these platforms . Chapter 8 , Conclusions and Further Research , presents conclusions and provides directions for further research and development . Two appendices at the end of this book contain detailed information about a service specification of a shared whiteboard system and ordered message delivery . Chapter 2 2 . Groupware : an Over view Various groupware systems have been developed in academia and industry to support particular forms of cooperative work . In this chapter , we : – provide an overview of these systems , in order to exhibit the diversity in groupware functions , and the large variety of cooperative tasks for which these functions are considered useful ; – mention problems specific to groupware development , which make it hard for developers to build comprehensive groupware systems that are tailored to particular cooperative work settings ; – describe problems with integration and flexibility encountered in groupware use , which illustrate the need for comprehensive groupware systems which are tailorable to particular cooperative work settings . First , in section 2 . 1 , we briefly describe the history of CSCW research and groupware development . Against this background , we describe various types of existing groupware systems and mention some representative systems , in section 2 . 1 . 1 . Though not exhaustive , this overview is sufficiently comprehensive to exhibit the scope , diversity and overlap of functionality of groupware systems . In section 2 . 1 . 2 , we describe a few classifications of groupware systems , each distinguishing one or more dimensions along which groupware systems can be ordered . In developing groupware systems , developers are faced with many specific difficulties . Many of these difficulties are rarely encountered in single - user applications and conventional distributed applications . In section 2 . 2 , we describe such difficulties and identify some deficiencies in distributed platforms relative to groupware development . We also describe some groupware platforms and standards that aim to reduce the burden of reinventing solutions to common groupware problems . Finally , in section 2 . 3 , we focus on empirical evidence in studies of groupware use about the lack of integration and flexibility of current groupware applications . We conclude this chapter by motivating the need for extensible and composable groupware . 8 C HAPTER 2 G ROUPWARE : AN O VERVIEW 2 . 1 Groupware Systems : History and State of the Art Far ahead of his time , Douglas Engelbart flabbergasted his audience in a special session ( see Figure 2 - 1 ) at the 1968 Fall Joint Computer Conference in San Francisco with a live demonstration of NLS ( oNLine System ; later commercially available as Augment ) [ EnEn68 ; Enge75 ] , an integrated prototype that featured on - screen video teleconferencing , shared - screen collaboration and telepointing between Engelbart on the podium at the conference and Bill Paxton from the SRI lab in Menlo Park . Apart from groupware , Engelbart pioneered many other innovations , such as using a mouse ( see Figure 2 - 2 ) , two - dimensional display editing , windows , and hypermedia . It took many years until these ground - breaking ideas were fully appreciated and realised . Some ideas , such as windows , the mouse and , more recently , hypermedia , have gradually found their way to the screens of millions of office workers , consumers and other computer users . Other ideas , in particular his ideas on groupware , have taken much longer to assimilate into computing practice . Meanwhile , at the New Jersey Institute of Technology , Murray Turoff developed one of the first computer conferencing systems ( see also page 10 ) , called EMISARI ( Emergency Management Information System and Reference Index ) followed by EIES , in 1976 . For over a decade , Turoff and Hiltz studied the potential of computer conferencing systems , how people used computer conferencing systems and how that usage compares with communication in other media ( see [ HiTu78 ] for a review ) . In 1984 , the computing world was still trying to cope with the paradigm shift induced by the introduction of the Personal Computer by IBM in 1981 , and the introduction of the ‘user friendly’ Macintosh by Apple in 1984 . Whereas timeshared computers — invented to give their users the idea that they were the only user of the system — still had some elementary services for computer mediated communication , attention in the personal computer era for using computers in group tasks seemed more distant than ever before . Yet , it was 1984 when Engelbart’s ideas on groupware found resonance in a workshop at MIT , organised by Irene Greif and Paul Cashman . Greif was working at MIT on RTCAL and MBlink , two systems inspired by NLS [ SaGr85 ] ( see also page 26 and page 13 , respectively ) . Cashman was working at Digital Equipment Corporation on XCP [ SlCa84 ] , an experimental tool for supporting office procedures , based on speech - act theory ( see also “Workflow Management Systems” on page 12 ) . Together , Greif and Cashman coined the term Computer Supported Cooperative Work ( CSCW ) as a unifying term for a new research area . Soon , biannual scientific conferences followed in the USA [ CSCW86 ; CSCW88 ; CSCW90 ; CSCW92 ; CSCW94 ; CSCW96 ] and in Europe [ ECSCW89 ; ECSCW91 ; ECSCW93 ; ECSCW95 ; ECSCW97 ] . The research field of CSCW — for Figure 2 - 1 NLS and videoconferencing demonstration in 1968 by Douglas Engelbart , the ‘father of groupware’ Figure 2 - 2 The first mouse ever made G ROUPWARE S YSTEMS : H ISTORY AND S TATE OF THE A RT 9 overviews , we refer to [ Wils88 ; ScBa92 ; OCL + 93 ; McCa94 ] — motivated and validated the development of a large number of groupware systems . 2 . 1 . 1 Some Groupware Systems Both in academia and in industry , various groupware prototypes and products emerged , each providing particular functionality to users . Each groupware system was designed to support a particular cooperative work situation or a particular range of cooperative work situations . Cooperative work settings are very diverse in terms of task , duration , group , organisational context and culture [ Hins98 ] , and likewise is the diversity in groupware . Below , we briefly describe several groupware systems . The groupware systems are loosely organised in categories , based on frequently used product category names in literature . Besides the names we use below , there have been other names , which roughly denote the same category of systems . In Table 2 - 1 we present an overview of the categories and the aliases . The order in which the categories are presented , roughly corresponds to the historical order in which many publications about the various categories were published . Groupware category Roughly equivalent names computer conferencing systems bulletin board systems , newsgroups chat systems workflow management systems office procedure systems , coordination systems electronic meeting systems Group ( Decision ) Support Systems ( G ( D ) SS ) , electronic meeting rooms application sharing systems screen / window sharing systems , desktop / data conferencing systems shared whiteboards shared drawing systems co - authoring systems collaborative / joint / shared editing systems multi - user hypermedia systems collaborative virtual environments multiplayer games , virtual worlds group scheduling systems group calendaring systems audio conferencing systems videoconferencing systems multimedia conferencing systems collaborative software engineering systems In the descriptions below , we focus on the functions provided to users and include references to some representative systems . Table 2 - 1 Groupware categories and roughly equivalent names 10 C HAPTER 2 G ROUPWARE : AN O VERVIEW Computer Conferencing Systems These systems can be regarded as a variant of electronic mail systems . Whereas electronic mail systems facilitate interpersonal communication by sending messages via the computer to one or more persons , computer conferencing systems allow users to send a message to a uniquely identified place in cyberspace devoted to discussion about a particular topic . Similar to a notice board , which allows notes pinned to the board to be read at later times , messages sent with a computer conferencing system can be retrieved and reacted upon by other interested users at a later time . One of the first computer conferencing systems is EMISARI ( to be more precise : the Discussion module in EMISARI ) , developed by Murray Turoff at the New Jersey Institute of Technology , later to be followed by EIES , in 1976 [ HiTu78 ] . One of the most well - known and probably the largest computer conferencing system is Usenet 1 ( see also Figure 2 - 3 ) , which uses the same network infrastructure as the Internet and provides thousands of places for discussion , known as newsgroups . Each of these newsgroups typically is used by hundreds of users , and traffic per newsgroup varies from several to more than hundred messages per day in some newsgroups . Apart from showing the temporal order of posted messages , some computer conferencing systems support and exploit additional relations between messages . For example , Usenet supports the relation is response to , which allows presentation of messages ordered in ‘threads’ , i . e . , hierarchies of messages in which responses are ordered under the message they 1 Usenet is also known as “Internet news” , or simply , “news” . The system itself is probably better known than its official name . Figure 2 - 3 Netscape News , one of many interfaces to Usenet G ROUPWARE S YSTEMS : H ISTORY AND S TATE OF THE A RT 11 respond to . The gIBIS system [ CoBe88 ] is a computer conferencing system that supports four types of messages — issue , position , argument and other — as well as relations between messages of these types , such as questions , is - suggested - by , supports , objects - to , generalises , specialises and replaces . Whereas early conferencing systems only supported textual messages , more recent commercially available computer conferencing systems such as Teamtalk [ Sale94 ] allow other types of documents to be posted , such as word processor documents , pictures , spreadsheets , etc . Computer conferencing is also one of the core functions of Lotus Notes [ KBH + 92 ; Sale94 ] , one of the first products marketed under the ‘groupware’ label . Lotus Notes is generally considered one of the most successful groupware products to date . Based on the core computer conferencing function , which supports documents of various kinds , Lotus Notes provides the ability to program various dedicated groupware applications . Chat Systems Similar to E - mail and computer conferencing systems , chat systems provide text - based computer - mediated discussions between users . Unlike E - mail and computer conferencing , however , each letter or sentence that is typed is immediately observable on the screens of other users , which facilitates rapid turn taking in discussions . Early chat systems , such as UNIX talk , started out as supplementary features of timeshared operating systems , and provided communication between two users of a network . More recently , systems such as Internet Relay Chat ( IRC ) ( see also Figure 2 - 4 ) provide interpersonal communication for an arbitrary number of users connected with personal computers to the Internet . 2 Reprinted from http : / / www . mirc . co . uk Figure 2 - 4 mIRC , an interface to Internet Relay Chat 2 12 C HAPTER 2 G ROUPWARE : AN O VERVIEW Workflow Management Systems To help a group of users reach particular goals , workflow management systems coordinate actions by users , i . e . , they encourage or enforce the right contributions at the right time by the right users , based on a model of a cooperative task that is embedded in the workflow system . Some early workflow management systems evolved from electronic messaging systems , by increasing the amount of computer interpretable information in messages . Based on this additional ‘standardised’ information , the system can track the state of a particular workflow ( i . e . , an instance of particular workflow model ) and will prohibit and / or suggest certain actions by certain users at certain times , while providing relevant information needed for particular actions . One early strand of research systems such as the Coordinator [ Wino88 ] , XCP [ SlCa84 ] and CHAOS [ CMS + 86 ] , is based on speech - act theory , a theory which considers language as a series of actions . The models contained in speech - act systems are conversations , which define the possible courses of action within a conversation between two actors . Another strand of work is based on office procedures , which describe relatively well - structured tasks , such as the procedure for handling a request for a loan , in terms of roles , tasks , sub - tasks and dependencies between tasks . Systems such as COSMOS [ BoCR88 ] , AMIGO [ DPP + 86 ] , GRACE [ BSS + 92 ] and DOMINO [ ViSo91 ] are examples of procedure - based systems . Recently , interest in workflow management systems increased considerably , giving rise to a wide range of commercially available workflow management systems , such as Staffware , InConcert , FlowMark , and the development of standards by the Workflow Management Committee ( see also section 2 . 2 . 4 ) . Electronic Meeting Systems Managers spend large proportions of their time in face - to - face meetings . Several groupware systems have been developed , targeted at increasing the effectiveness and efficiency of such meetings ( for overviews , we refer to [ KrKi86 ; NDV + 91 ; KrSe94 ] ) . One of the simplest electronic meeting systems is an electronic voting system , found in many parliaments . It provides a rapid , anonymous and accurate way of voting . Other parts of the meeting process that can benefit from computer support , include brainstorming , idea organisation and idea evaluation . Typically , electronic meeting systems such as the MIS Planning and Decision Laboratory [ ApKN86 ] , developed at the University of Arizona — the basis of the commercially available electronic meeting system GroupSystems ( see Figure 2 - 5 ) — and Colab [ SFB + 87 ] developed by Xerox PARC , consist of a room furnished with a large common screen , connected to a set of interconnected personal computers or terminals . Some benefits provided by such systems are : G ROUPWARE S YSTEMS : H ISTORY AND S TATE OF THE A RT 13 – Parallel typing , rapid forwarding and accumulation of ideas . Finding interesting or inspirational ideas is faster when the ideas are presented in written , rather than spoken form . Furthermore , the speed of idea production is increased because people can type ideas in parallel , despite the fact that most people type slower than they speak . Oral presentation of ideas requires waiting for a suitable moment to speak up . At that time , the idea may be forgotten . Parallel typing reduces this kind of ‘production blocking’ [ NDV + 91 ] . – Optional anonymity , which can alleviate non - functional socially inhibiting factors . For example , anonymity may facilitate proposing bold ideas and giving honest opinions about ideas . – Transferring computer - based information in and out of the meeting . Meeting support systems can facilitate viewing and manipulating electronic documents , such as designs , during a meeting . Similarly , the systems may allow the generation of electronic documents , such as sketches and action points , which can be used in electronic meeting minutes and other documents . Application Sharing Systems Application sharing systems allow existing single - user applications to be used without modification by multiple users , simultaneously . This is achieved by a generic function external to applications that performs multicasting of output and collation of input , in such a way that it maintains the single - user image for the application . It takes output from the 3 Reprinted from http : / / www . ventana . com Figure 2 - 5 Electronic brainstorming with GroupSystems 3 14 C HAPTER 2 G ROUPWARE : AN O VERVIEW application and presents it to each of the screens of the users . Combining input from users is typically done in such a way that only one user at a time can control the application . Typical for application sharing systems is the immediate visibility of all actions for other users , including user interface actions such as mouse movements and menu selections . In early application sharing systems ( also known as screen sharing systems ) , such as NLS / Augment [ EnEn68 ; Enge75 ] , the entire screen is shared : each user sees the same at his or her screen and there is no private space . The advent of bitmapped displays and windowing systems such as Xerox Star in 1981 [ JRV + 89 ] , Microsoft Windows in 1985 and X windows in 1986 [ ScGe86 ] spurred the development of tools that enable sharing just a single application window , instead of the entire screen . Examples of such systems , which are also known as shared window systems or window sharing systems , are : – MBlink 4 [ SaGr85 ] , which was based on sharing the output bitmaps of programs that ran on Xerox workstations and Vconf / Dialogo [ Lant86 ; LaLa90 ] , which was based on virtual graphics terminal architectures prior to the current de - facto standard X windows . – X windows - based tools such as XTV [ AbFe91 ] , shX [ AlNT90 ] and the commercially available SharedX from Hewlett Packard [ GaWY94 ] and the application sharing module in ShowMe from Sun ( see Figure 2 - 6 ) ; for other systems , we refer to [ BaGP93 ] ; 4 MBlink was provided as library , which required re - linking an existing single - user program and adding a dozen lines of code before the existing single - user program could be shared . 5 Reprinted from http : / / www . sun . com / products - n - solutions / sw / ShowMe Figure 2 - 6 Application sharing with ShowMe SharedApp 5 ( note the two pointers ) G ROUPWARE S YSTEMS : H ISTORY AND S TATE OF THE A RT 15 – Microsoft Windows - based tools such as the application sharing tools within Netmeeting from Microsoft , Person to Person from IBM ( which is based on XTV ) [ RiWe94 ] and ProShare from Intel . – cross - platform tools such as the BERKOM Multimedia Collaboration Service ( MMC ) [ ADH + 93 ; WoFS95 ] , and the commercially available Face to Face and Timbuktu Pro , which allow sharing applications between users that use different graphical user interface platforms , such as Apple Macintosh , MS Windows and X windows . Increasingly , application sharing software is sold in combination with audio conferencing and videoconferencing systems , as part of so - called multimedia conferencing packages . Often , such packages also include shared whiteboard software . Meanwhile , the screen sharing paradigm has not been forgotten ; a revival of screen sharing can currently be observed in some remote control 6 systems that enable remote helpdesk support . Shared Whiteboards In many formal and informal meetings , particularly those involving discussions about designs and other complex phenomena , you find people drawing sketches ( e . g . , on a whiteboard ) , pointing out particular items and relations . Other people in the meeting can refer to such drawings , and may propose modifications by altering the drawing . Shared whiteboard systems are designed to support such meetings , particularly when the participants are not in the same room . Objects drawn in the shared workspace provided by such shared whiteboards are immediately visible for all other users . – ( Bitmapped ) shared whiteboards , such as GroupSketch [ GRW + 92 ] , Wscrawl [ Wils95 ] and the commercially available shared whiteboards in Person - to - Person , ProShare [ Labr94 ] , Sun ShowMe and the whiteboard in Netscape Conference are essentially multi - user variants of single - user paint programs , which allow users to manipulate a bitmapped drawing . Bitmapped shared whiteboards typically have functions for easy import of captured screen images . – Vector - based shared whiteboards ( also known as shared drawing systems ) , such as GroupDraw [ GRW + 92 ] , ConversationBoard [ BrGo92 ] ( see Figure 2 - 7 ) and commercially available tools such as Aspects and the whiteboard in Microsoft Netmeeting , are essentially multi - user variants of single - user drawing programs , which allow users to manipulate vector - based drawings , which consist of two - dimensional mathematically defined curves and shapes . 6 Some remote control systems , e . g . , those aimed at supporting telework , only provide single - user remote control and do not allow multiple users to share and pass control over the computer . 16 C HAPTER 2 G ROUPWARE : AN O VERVIEW Rudimentary shared whiteboards can be obtained by using a single - user paint or drawing application in combination with an application sharing system . In contrast to such rudimentary systems , shared whiteboards allow multiple users to draw , type and gesture in the shared workspace simultaneously . Moreover , some of these systems allow users to have a different view on the shared workspace if they wish ( e . g . , they can scroll and zoom individually ) . For a more complete review of shared whiteboards , we refer to [ GrHR95 ] and [ Peng93 ] . Co - authoring Systems Creating documents ( ‘authoring’ ) is the most frequent task which computers help people to accomplish . Until recently , conventional editors and word processors primarily assisted individuals in producing polished final copy and provided little support for co - authoring . Yet , many documents result from cooperation between two or more persons . In some fields of science , for example , 65 % of articles are written by two or more authors [ FKL + 88 ] . Although some commercial word processors supported revision marks aimed at collaborative document production as early as 1988 , virtually all communication and coordination between co - authors had to be performed without any system support , e . g . , by passing draft 7 Reprinted from http : / / www . crew . umich . edu / ~ brinck / CSCW92 . html Figure 2 - 7 ConversationBoard 7 G ROUPWARE S YSTEMS : H ISTORY AND S TATE OF THE A RT 17 copies for the collection of written annotations , or by meeting each other in person to discuss the document . Rudimentary co - authoring support can be created by combining a conventional editor with a shared file system , a messaging system or an application sharing system : – Messaging systems and shared file systems provide significant efficiency improvements over diskette - based draft passing , especially for dispersed co - authoring groups . Passing drafts becomes a matter of mailing the document or saving a document into a shared directory and notifying the recipient . – Application sharing systems , when combined with a conventional single - user editing application , provide an environment in which multiple dispersed users may view and manipulate the same document . However , not only the document is shared , but also the interface to the document ; users cannot scroll , zoom and type independently . This limits the utility of this approach for tasks other than focused activities such as constructing an outline or reviewing the exact wording of particular sections . Co - authoring systems are explicitly designed to support multiple users in their joint effort to create a document . In recent years , commercial word processor developers started to add co - authoring features to their products such as merging annotations from different users , revision management and document routing ( the latter based on using messaging systems ) . Only recently 8 , co - authoring support of this kind was used as a prominent sales argument for word processors . The class of co - authoring systems is very diverse in terms of support for : – different phases of authoring , e . g . , brainstorming , doing research , planning , writing , and reviewing ; – text - only documents , formatted documents or multimedia documents ; – simultaneous document editing and / or sequential document editing ; – annotations , versions and revisions ; – communication between authors about the document or the authoring process ; – coordination of the authoring process . 8 April 1995 , Lotus Development Corporation announced Lotus Word Pro , “a word processor that helps teams of individuals work together more effectively by streamlining the process of creating , reviewing and editing shared documents” . 18 C HAPTER 2 G ROUPWARE : AN O VERVIEW Below , we describe 9 a few representative co - authoring systems : Quilt , GROVE , SEPIA and CoMEdiA ( for a more complete overview , we refer to [ MiRa96 ; Hoft96 ] ) . Quilt was developed at Bellcore around 1988 [ FKL + 88 ; LeFK88 ] . Quilt’s designers focused mainly on providing a rich set of annotation mechanisms and definition of social roles as a means for coordinating the authoring process . Most support is aimed at the document writing , editing , and reviewing phases . Quilt’s support for shared documents is based on a shared database that stores texts and annotations . Annotations may be suggestions for revision and voice or text comments . Annotations are associated via a hypertext link with particular parts of the base document , or with another annotation . Annotations come in three flavours : private comments , which are visible only to the creator , directed messages , which are only exposed to explicitly named users or user groups , and public comments , which are exposed to all users that may read the base document . Users become aware of other’s document versions , suggestions and annotations only after the originator has ‘committed’ the version , or ‘sent’ the suggestion or annotation . Quilt allows multiple users to edit the base document concurrently , resulting in the emergence of potentially conflicting document versions . Quilt allows “easy examination of the difference between the two versions , and swapping in of the revised version” ( i . e . , substituting a suggestion for its associated base document part ) [ LeFK88 ] . To avoid unwanted conflicts , Quilt provides a warning if another user is already modifying the base document . In addition , Quilt can automatically lock the base document to prevent others from editing . Quilt’s strength lies in its abundant support for the usage and definition of social roles , which are defined in a hierarchy of roles that give rights with respect to certain actions on the shared document and annotations . For example , a role hierarchy may be a partial ordering reader < commenter < co - author , which specifies that if a particular right is granted to a reader , it implies the right is also granted to commenters and co - authors and that if a particular right is given to a commenter , it implies that the right is also given to a co - author , but not necessarily to a reader . The units over which rights may be granted are base document , suggested revision , public comment , directed message , private comment and history . Rights supported by Quilt are create , modify , delete , attach revision , attach comment , attach message and attach private comment and read . A ‘collaboration style’ in Quilt is defined by 9 We describe co - authoring systems in more detail than other types of systems , since we focus on these systems in more detail in chapter 6 . G ROUPWARE S YSTEMS : H ISTORY AND S TATE OF THE A RT 19 associating each combination of ( unit , right ) with a role from the role hierarchy , or with ‘no - one’ . A collaboration in Quilt is created by one user , has a name and consists of one document , a set of users , each of which is associated with a role ( users may have the same roles ) , and a collaboration style that defines the associations between rights , units and roles . The creator of the collaboration may choose from pre - defined collaboration styles ( including three Quilt - provided styles ) , or the creator may define a new collaboration style . The GRoup Outline and Viewing Editor ( GROVE ) was developed at the Microelectronics and Computer Technology Corporation ( MCC ) , around 1988 [ ElGi89 ; ElGR90 ; ElGR91 ] . The purpose of the GROVE prototype was both to explore implementation alternatives for a ‘real - time multi - user tool’ and to collect informal observations on its use . GROVE conferences are initiated by one user , which specifies the filename of a document that is to be edited . Basically , any user with access to the file may participate in the conference by clicking on the file icon . GROVE’s shared documents are limited to simple outlines , upon which simple editing operations may be performed . Unlike Quilt , which notifies users only when changes made by other users are ‘committed’ ( e . g . , by saving or sending ) , GROVE largely follows the What You See Is What I See ( WYSIWIS ) [ SBF + 87 ] paradigm . It notifies users of each individual operation on , e . g . , characters ( insert , delete ) , outline items ( open , close ) , and scrollbars ( back , forth ) . GROVE does not employ locking , but it allows concurrent and conflicting operations . In order to keep response and notification times minimal , it uses a special algorithm that exploits operational transformations to maintain consistency [ ElGi89 ] . GROVE also allows relaxation of the WYSIWIS - paradigm . Each user gets a user - specific presentation of items that informs a user of his or her access rights to the item . Further , a user may only see his or her own cursor , may see different sets of windows on their screens , at different positions . Each window shows a sub - tree of the outline tree and may only be visible and accessible to subgroups of the participants . In particular , GROVE supports private windows ( accessible only to the creator ) , shared windows ( accessible only to an enumerated set of users ) and public windows ( accessible to all participants ) , which may be created by any user . Users may temporarily leave and later rejoin a session . In GROVE’s first version , described in [ ElGR90 ] , rejoining users were simply shown the current state . Later , GROVE’s designers proposed ageing of text , where colours indicate ‘news’ , in order to help rejoining users to catch - up more easily . 20 C HAPTER 2 G ROUPWARE : AN O VERVIEW GROVE provides access control based on the document structure , in which outline items are the units to which rights are allocated . By default , all users have ( concurrent ) read and write access to all outline items . However , for each outline item , users may revoke ( and grant ) read and write permissions for individual users . Only recently , co - authoring tools have emerged that support both Quilt - style and GROVE - style co - authoring and transitions between theses modes , such as SEPIA [ HaWi92 ] ( see Figure 2 - 8 ) . SEPIA was developed in the division Cooperative Hypermedia Systems at the Institute for Integrated Publication and Information Systems ( IPSI ) of the Gesellschaft für Matematik und Datenverarbeitung ( GMD ) around 1992 [ HaWi92 ; HaHa93 ; Stre94 ] . It is based on a cognitive model of authoring , which led to a first , non - collaborative version of SEPIA , which only supported ‘individual work’ . In later stages [ HaWi92 ] , explicit support for ‘loosely coupled’ and ‘tightly coupled’ co - authoring has been added , as well as support for smooth transitions between these modes . A more recent version described in literature [ HaHa93 ; Stre94 ] , includes version support services and supports isolated work , where just one author is allowed to work on a specific document part , and separate work , where several co - authors may work on separate drafts of the same document part , but without interfering with each other . SEPIA’s designers focused mainly on using hypertext to support different modes of collaboration , on providing support for smooth transitions between these modes and on providing version management support . Below , we outline the co - authoring services provided by a recent version of SEPIA , as described in [ HaHa93 ] . SEPIA’s shared document is a hypermedia document comprising atomic nodes ( containing data : text , graphics , images or sound ) , labelled links and composite nodes ( aggregate structures of atomic and composite nodes related by links ) . To guarantee consistency at the document level , SEPIA employs automatic locking of nodes and links when a user selects a node or link . Users may also employ explicit locking by entering the ‘isolated work’ mode for a particular node . Each user controls a pointer which can be made visible for other users , with a user name attached for identification . A selected node or link is indicated in colour : yellow on the display of the user that selected the node , red on the displays of the other users . Upon request , the identity of the user that selected a node can be displayed . G ROUPWARE S YSTEMS : H ISTORY AND S TATE OF THE A RT 21 For each node that is opened by more than one user , a separate window is opened . By default , users that open the same composite node enter the ‘loosely coupled mode’ . In this mode , operations on nodes and links are visible for other users , yet scrolling through the node’s contents is independent . When users leave a loosely coupled node and later re - enter , by default , they are shown the current state . Within a loosely coupled node , a subgroup of the group of users for that node may decide to enter the ‘tightly coupled mode’ for that node . As one user can only have one tightly coupled session per node , multiple , non - overlapping subgroups may exist for a node , each having a separate tightly coupled session for that node . Within tightly coupled mode , the strict WYSIWIS - paradigm applies . Starting a tightly coupled session also triggers the creation of an audio conferencing conversation space for the tightly - coupled group of users . Upon explicit request , SEPIA can also provide a videoconferencing facility in tightly coupled mode . 10 Reprinted from http : / / www . darmstadt . gmd . de / concert Figure 2 - 8 Collaborative hypermedia editing with SEPIA 10 22 C HAPTER 2 G ROUPWARE : AN O VERVIEW SEPIA provides elaborate version management services , based on the maintenance of a derivation history . Version navigation services allows versions to be searched on various attributes and then selected in a ‘multi - state object ( mob ) browser’ . Relative version navigation ( multi - user undo ) , is not supported in SEPIA , however . In addition , SEPIA provides version merging services ; a comparison of two alternative versions of a node may be used either by an individual user or in a tightly coupled session by a number of users to merge two versions into a new version . SEPIA does not enforce particular rights and obligations with respect to document editing actions . As a means for encouraging coordination , however , SEPIA supports the notion of a task space , which allows users to coordinate rights and obligations on the fly . The task space shows the development of the project up to the current point in time . Nodes in the task space correspond to significant versions of the document ( or parts of it ) . Different independent successor versions may be derived from the document . Later , different versions may be the basis for a derived merged version . As such , SEPIA’s coordination support is largely based on the hypermedia document structure , not on a pre - defined process structure . The Cooperative hyperMedia Editing Architecture ( CoMEdiA ) was developed at Fraunhofer Institute for Computer Graphics around 1991 [ HoSa91b ; SaTr94 ; Sant95 ] . CoMEdiA’s designers focused mainly on integration of shared multimedia document support , multimedia conferencing and coordination support based on social roles . CoMEdiA’s shared document is a hypermedia document comprising chapters , each containing one medium . A recent version of CoMEdiA , as described in [ Sant95 ] supports the following media : texts , raster images , 2D - graphics , audio and video . CoMEdiA supports two types of locking ( although only one may be used in a session ) that guarantee consistency for document content . Chunk lock is a form of explicit locking in CoMEdiA that guarantees exclusive write access to a user - definable part of the document . Position lock , on the other hand , is a form of automatic locking : the system will lock a minimal portion of a document to perform a particular editing operation for a user . In CoMEdiA a user always observes the most recent version of the shared document . Individual window arrangements and independent scrolling are allowed . Users may instruct CoMEdiA to expose their mouse cursor positions selectively to a subgroup of users ; users may also specify a filter to be selectively aware of the cursor positions of only a subgroup of other users . Each user must select a unique cursor when joining a CoMEdiA session to enable identification of cursors . CoMEdiA’s ‘follow’ feature allows a user to link their view as a slave of the view of another user . G ROUPWARE S YSTEMS : H ISTORY AND S TATE OF THE A RT 23 For direct communication between users , CoMEdiA provides a shared telepointer , annotations , audio conferencing and videoconferencing . Users may ‘pick’ ( and later ‘release’ ) the shared telepointer to direct the group’s attention to particular portions of the document . CoMEdiA supports three types of annotations : private annotations , public comments , and off - document communication spaces . Private annotations and public comments consist of either text or graphics ; they are hyperlinked to the document part they refer to . When users prefer directed messages , they may use CoMEdiA’s ‘off - document communication’ feature , which provides a separate chat window for each pair of users . CoMEdiA’s provides support for coordination based on the built - in social roles of chairperson , author , commenter and reader . Each user selects one role when joining the session . There may be only one chairperson ; a role that is granted to the first user that selects this role . Roles express the rights to perform actions . A reader may read the document and use the private annotations and intra - group communication ( off - document communication , audio conferencing and video conferencing ) . A commenter has all rights of a reader , plus the right to make public comments . An author has all the rights of a commenter , plus the right to edit the shared document and to request information about the state of the group and other users . The chairperson has all the rights of an author , plus the right to change social roles , edit particular session parameters , disable the login of particular authors , and to manipulate ( save , load ) the shared multimedia document as a whole . Multi - user Hypermedia Systems The concept of hypermedia , i . e . , non - linear documents consisting of nodes that are interconnected by links , inspired and enabled the creation of a range of groupware applications . – Some co - authoring systems are based on the partitioned nature of hypermedia documents , which can be used as a basis for partitioning authoring tasks . The World Wide Web , for example , can be used as a simple co - authoring system : each user can be responsible for writing a part of a hypermedia document . Users can work simultaneously when working on different nodes . They can observe updates of other nodes as soon as others have saved them . When multiple users have write - access to the same node , they can both edit that node , but typically not simultaneously . – Some co - authoring systems , such as Quilt [ LeFK88 ; FKL + 88 ] , CoAUTHOR [ HJE + 91 ] and SEPIA [ HaWi92 ] use the linking feature of hypermedia to link annotations and revisions to the main document . In addition to annotation links , CoAUTHOR and SEPIA support many other types of links between nodes in a hypermedia document . For 24 C HAPTER 2 G ROUPWARE : AN O VERVIEW example , both planning relations and hierarchical relations can be defined between nodes ; which allows for different views ( a planning and outline view , respectively ) on the same hypermedia document . – Public annotation systems , such as NCSA Hypernews [ LaBr95 ] , ComMentor ( see Figure 2 - 9 ) and other web conferencing systems , use the infrastructure of the World Wide Web as a basis for a computer conferencing system : messages sent to a web conference are attached with hyperlinks to a conference page . In public annotation systems , the conference can be attached as a series of annotations to an existing web page . Collaborative Virtual Environments Collaborative Virtual Environments [ Gree97 ] comprise applications such as multiplayer games and distributed battlefield simulations . Computer games are serious business . With respect to the business aspect , it may be surprising to learn that , for example , world - wide , the computer game industry is larger in size to the American motion picture industry ( US $ 15000 million world - wide ) [ Negr95 p . 82 - 83 ] . With respect 11 Reprinted from http : / / Walrus . stanford . edu Figure 2 - 9 Annotating hypertext in ComMentor 11 G ROUPWARE S YSTEMS : H ISTORY AND S TATE OF THE A RT 25 to the serious aspect , it may be surprising to learn that there is a long history of games being a domain of inspiration and validation for computer science . The game of chess , for example , has been a domain of inspiration and validation for research into artificial intelligence and parallel processing . Similarly , computer games have been a domain of inspiration and validation for research into the direct manipulation paradigm of human - computer interaction [ Shne83 ] . The recent foundation of the DigiPen Applied Computer Graphics School [ CoGh96 ] , which provides a curriculum dedicated to the design and implementation of computer games is yet another testimony to computer games being serious business . The computer game industry is currently going through a paradigm - shift from single - user to multi - user computer games , triggered by the advent of local interconnectivity between personal computers in research and office environments , between game computers in arcade halls and on a global scale between consumer PCs on the Internet . Some of these multiplayer games are restricted to human participants only , such as xtrek ( a game in which each user controls a spacecraft , can join a team that plays against one or more other teams on a two - dimensional playing field ) , Alpha World and Worlds Chat ( see Figure 2 - 10 ) , 3D - spaces in which users can select and move a kind of puppet that serves as a representation of themselves , observe representations of other users , and talk to others nearby through textual chat facilities . Other multiplayer games , such as Quake , have both human and non - human participants . Similar to single - user games and single - user application research , multiplayer games serve as a domain of inspiration and validation for research into groupware . Some examples are the development of test case applications for groupware toolkits ( groupware toolkits will be described in more detail in section 2 . 2 . 3 ) , such as Tic - Tac - Toe and CardTable on top of Rendezvous [ HBR + 94 ] and Tic - Tac - Toe , Solitaire , and Tetrominos on top of GroupKit [ RoGr96 ] . 12 Reprinted from http : / / www . cnet . com / Content / Reviews / Compare / Chat Figure 2 - 10 Multiplayer virtual worlds in Worlds Chat 12 26 C HAPTER 2 G ROUPWARE : AN O VERVIEW Apart from being applied for entertainment , games are also used as a tool for learning in education and training . By extension , this holds for multi - user computer games also . As an example , we mention the distributed battlefield simulations that are used by some armed forces as a training tool . These kind of applications are very similar to other collaborative virtual environments , such as multiplayer games . Group Scheduling Systems Scheduling a meeting with a group is one of the group tasks which might benefit from computer support . In particular , finding free time in several personal schedules seems a task that can be done much more efficiently by a groupware system . One of the first systems designed to support scheduling group meetings was RTCAL [ SaGr85 ] , an extension of the personal calendar system PCAL in use at MIT . It allowed a number of users to align their electronic calendars and schedule a meeting , in which they could be supported by voting mechanism . It did not have a function to find free time . Most contemporary group scheduling systems , such as Microsoft Schedule + ( see Figure 2 - 11 ) , Lotus Calendar and Novell Groupwise Calendar do have such a function to find free time . These systems are based on electronic mail infrastructures . Hence , scheduling a meeting in such systems does not require all prospective participants to be continuously available during the meeting scheduling process ; it involves the exchange of a series of special messages , such as invitations , acknowledgements , and declines . Figure 2 - 11 Microsoft Schedule + , a group scheduling system G ROUPWARE S YSTEMS : H ISTORY AND S TATE OF THE A RT 27 Audio Conferencing Systems The telephone system might be characterised as groupware ‘avant la lettre’ 13 , since it allows two , and in some cases three or more , humans who are geographically separated to interact by voice over distance . In the design of many groupware systems , such as shared whiteboards , it is assumed that people can communicate by voice via a system external to the groupware system , such as the telephone system ( see e . g . , [ SaGr85 , p . 44 ; ElGR90 ; KnPr90 ; GRW + 92 ] ) . Based on technological advances that support audio streams over computer networks , such as the Internet , other groupware systems , such as Netscape Conference , and Microsoft Netmeeting provide audio conferencing as an auxiliary service integrated with shared whiteboards . Such an approach allows for setting up shared workspaces and audio conferences in one shot , on - screen indication of the person who is speaking , synchronising audio and pointing actions in the shared workspace , etc . Videoconferencing Systems Ever since the introduction of videotelephony in science fiction movies and the introduction of the Picturephone by AT & T at the 1964 World Fair [ Egid88 ] , designers have been exploring the use of video to support cooperatively working at a distance . Despite a lack of research findings that video enhances many types of cooperative work ( e . g . , [ Egid88 ; OCL + 93 ; Heer96 ] ) , people persist in trying to find useful applications for this technology . This has led to the development of prototypes and research systems with a focus on various aspects of video communication , ranging from : – systems such as CRUISER [ Root88 ] and Montage [ TaIR94 ] ( see Figure 2 - 12 ) , which allow glances into people’s offices to see if one is available for conversation ; – systems such as the Inria Videoconferencing System ( IVS ) and CAVECAT , which puts the faces of co - workers on the screen in small windows , – systems such as the VideoWindow [ FiKC90 ] , which used permanent large - screen video connections between places in two geographically separated offices where people come for causal interaction , such as hallways and near coffee machines ; – systems such as Commune [ MiBl91 ] , MERMAID , [ WSM + 90 ] , and ClearBoard [ IsKG92 ] , which provide some form of integration between the video component and a shared workspace component of a 13 While the current telephone system relies almost completely on computer support , one might argue whether telephone is being perceived as a “computer supported” solution for cooperative work . This is , however , not a useful debate in the context of this book . 14 Reprinted from http : / / www . sun . com / tech / projects / coco / montage Figure 2 - 12 Peeking into someone’s office with Montage 14 28 C HAPTER 2 G ROUPWARE : AN O VERVIEW multimedia conferencing system . ClearBoard goes a long way to provide a seamless integration by arranging the two persons in a shared drawing session as if they were drawing on two sides of a transparent glass through which they can see each other and their actions ( see Figure 2 - 14 and Figure 2 - 13 ) . – Some advanced prototypes take this idea of seamless integration between the video and shared workspace one step further and provide 3D videoconferencing . One example is a system developed at the Advanced Telecommunication Research ( ATR ) Laboratory in Japan [ TaKi92 ] , which provides users with a stereoscopic image that provides the illusion of a 3D space when viewed through special goggles . In the 3D space , shared 3D computer - based artefacts such as a car design can be seen . The artefact can be manipulated ( e . g . , rotated ) through gesturing with a data glove . Ultimately , ATR intends to put 3D representations of the other participants in the 3D space as well , thus providing full virtual space videoconferencing . Facilitated by recent technological developments in public networks , such as the introduction of the Integrated Services Digital Network ( ISDN ) , the use of Asynchronous Transfer Mode ( ATM ) technology , and developments in image compression technology , a wide range of commercially available videoconferencing products have been developed . Currently , three generations can be distinguished , based on their physical appearance : – Rooms - based videoconferencing systems consist of a dedicated room , fitted with a large screens , camera ( s ) and microphones . A meeting in a rooms - based videoconferencing system typically consists of two interconnected rooms , with a group of persons in each room that can see the other group on the videoconferencing screen . Early versions of these systems required the use of expensive , high - capacity leased telecommunication lines . As a result , the use of such systems was primarily concentrated in 15 Reprinted from http : / / ullmer . www . media . mit . edu / people / ishii 16 Reprinted from http : / / ullmer . www . media . mit . edu / people / ishii Figure 2 - 13 ClearBoard : final system 15 Figure 2 - 14 ClearBoard mock - up ( above ) and prototype ( below ) 16 G ROUPWARE S YSTEMS : H ISTORY AND S TATE OF THE A RT 29 large organisations . Recent versions of these systems can also use less expensive dial - up links such as ISDN . – Roll - about videoconferencing systems are very similar to rooms - based videoconferencing systems , the major difference being the ability for easy transport of the videoconferencing hardware and software that is mounted on a movable rack . – Desktop videoconferencing systems make videoconferencing available to individuals as a personal computer application . Desktop videoconferencing systems typically do not require advance booking of rooms and dedicated videoconferencing equipment . This facilitates casual , short - lived interaction between two or more people who are not co - located . Some examples of commercially available desktop videoconferencing systems are CU - SeeMe from White Pine Software , the Live series of videoconferencing products from PictureTel , ProShare from Intel , ShowMe from Sun , and InPerson from Silicon Graphics and Netmeeting from Microsoft . An extensive list of over a hundred desktop videoconferencing products can be found in [ Hewi96 ] . Often , desktop videoconferencing systems are sold under the label ‘multimedia conferencing systems’ and include a shared whiteboard and / or application sharing system . This kind of integration facilitates the integration of personal computer - based work and group work . For example , application sharing allows for others to join in working with one’s personal applications , while shared whiteboards allow a . o . the presentation and annotation of screen snapshots from one’s personal applications . Typically , desktop videoconferencing systems can be used over a range of networks , including ISDN , Local Area Networks and combinations of these ( e . g . , LAN for the intra - site connectivity , ISDN for inter - site interconnectivity ) . Collaborative Software Engineering Systems The development of nontrivial software applications is a cooperative process involving various people . Most software engineering tools , however , are single - user tools that largely ignore the cooperative nature of software engineering . Typically , the emphasis in CASE and other recent software engineering technologies is on exchange of information between tools and not people [ ChCe96 ] . Various research initiatives have started with the goal of providing groupware support for software engineering , which resulted in a variety of research prototypes , including : – ICICLE [ BrSM90 ] , which supports formal code inspection meetings ; – GroupCRC [ ChCe96 ] , which supports the CRC cards method for object oriented software design , in which participants assume the role of objects in enactment of scenarios for the purpose of creating a shared 30 C HAPTER 2 G ROUPWARE : AN O VERVIEW understanding of the design and discovering defects such as missing responsibilities and collaborations ; – Serendipity / SPE [ GrHM96 ] and SPADE - 1 [ BaDF96 ] , which aim at integration of the process - modelling approach to software engineering on the one hand and the support for unstructured real - time communication provided by many groupware applications on the other hand . Similar to workflow management systems , process - centred software engineering environments ( PSEEs ) contain a model of a cooperative process , which is used to guide or check actions of users . 2 . 1 . 2 Groupware Classifications Various schemes have been proposed to classify the ever expanding collection of groupware systems . Such classifications provide insight in the dimensions across which groupware systems vary . One example is the product - based classification we used in section 2 . 1 . 1 . It describes groups of systems with similar characteristics , that support a particular range of cooperative tasks . Although useful for giving an impression of the variety in groupware systems , such a product - based classification is not unambiguous , nor exhaustive , nor stable . As can be observed from section 2 . 1 . 1 , there is substantial overlap between various categories , which causes ambiguity in the classification of particular groupware systems . For instance , many ( desktop ) videoconferencing systems also include a shared whiteboard and / or an application sharing system , some multi - user hypermedia applications can also be regarded as co - authoring systems , and collaborative software engineering systems can be regarded a particular type of co - authoring system . As time progressed , new product - based classifications were proposed that extended and adapted previous ones to reflect better the current state of the art ( see e . g . , [ Wils88 ; Oppe88 ; Malm94b ; Malm94 ; MSA + 94 ] ) . The classification presented in section 2 . 1 . 1 , though current at the time of writing and fit for the purpose of giving an impression of the variety of groupware systems developed , is not exhaustive . Moreover , it will most likely be considered archaic in a few years time . Several classifications have been proposed with the intent to be less ambiguous , more exhaustive and more stable . Below , we describe some of them . The Time - place Matrix One of the best known and most - cited classifications for groupware systems is the time - place matrix [ Joha88b ] . The matrix distinguishes four classes of cooperative work situations , based on temporal and spatial patterns of G ROUPWARE S YSTEMS : H ISTORY AND S TATE OF THE A RT 31 interpersonal communication occurring in cooperative work situations , as illustrated in Figure 2 - 15 . In one dimension , it distinguishes same time ( synchronous ) cooperative work from different time ( asynchronous ) cooperative work . In the other dimension , it distinguishes same - place cooperative work from different - place cooperative work . With the time - place matrix , groupware systems can be classified by placing them in the quadrant ( s ) they support . In Figure 2 - 15 , some examples of groupware systems are given for each of the four quadrants . The quadrant for different time , same place groupware may seem a bit awkward at first sight . However , systems have been proposed that fit within this category , such as electronic project rooms equipped with poster - size computers ( ‘boards’ ) and paper - size computers ( ‘tabs’ ) [ Weis95 ] . same time ( synchronous ) different time ( asynchronous ) same place ( local ) electronic meeting rooms co - authoring ( e . g . , SEPIA / DOLPHIN ) electronic project room different place ( remote ) shared whiteboard videoconferencing co - authoring ( e . g . , GROVE ) group scheduling ( e . g . , RTCAL ) computer conferencing system group scheduling ( e . g . , Schedule + ) co - authoring ( e . g . , PREP , Quilt ) The time - place matrix has been subject to considerable criticism , mainly concerning the dichotomies created between synchronous and asynchronous and between same - place and different - place . These dichotomies are considered problematic in a number of respects : – The time - place matrix leaves no room for intermediate stages between the extremes of synchronous versus asynchronous and local versus remote . For example , one might argue whether a chat system that allows people to observe text typed by others as soon as those others complete a line is synchronous or asynchronous . Some researchers have proposed richer models for the temporal dimension of the time - place matrix . For example , Dourish proposes a model in which the absolute notions of synchrony and asynchrony are replaced by the notion of synchronisation as an activity that re - establishes consistency between two representations of a shared workspace that diverged due to activities of users [ Dour95 ] . This model allows for many forms and rates of synchronisation , including the extremes synchronous ( synchronising often ) and asynchronous ( synchronising only now and then ) . With respect to the spatial dimension , there is a similar problem . For example , how would one classify groupware systems that are used by Figure 2 - 15 Classifying groupware with the time - place matrix 32 C HAPTER 2 G ROUPWARE : AN O VERVIEW people that work in adjacent offices ? Some researchers proposed more detailed classifications in this dimension , too ( see e . g . , [ RoBl92a ] ) . – The time - place matrix does not seem to promote consideration of cooperative work situations that involve transitions between synchronous and asynchronous work , or between local and remote work . Although periods of limited duration or limited tasks within cooperative work settings may fit within one of the quadrants , several cooperative work patterns , observed in e . g . , studies of co - authoring [ PoBa93 ] and cooperative reviews [ SaKu93 ] , involve more than one quadrant , with frequent transitions between them . Some have even argued ( e . g . , [ Cock93 ] ) that the dichotomies created by the time - space matrix promoted development of isolated groupware applications that focused on providing support within the confines of one of the quadrants of the time - place matrix , thus diverting the attention of groupware developers away from providing flexible or composable systems that support smooth transitions between the quadrants ( see also section 2 . 3 . 1 ) . – Another problem associated with classifying groupware with the time - place matrix is whether classification should be based on the functionality provided by the groupware system , or on the way this functionality is used . Exchange of messages ( asynchronous groupware functionality ) , when used with high frequency can be used to support tasks which would be classified as synchronous . Vice versa , a shared drawing space can be used to support a work style that would be classified as asynchronous . Restrictive Versus Permissive Groupware Some groupware systems , such as workflow management systems ( see section 2 . 1 . 1 ) , constrain or direct the behaviour of their human users . Such groupware is called restrictive groupware [ GaKr90 ] since it typically embeds a model of possible or desirable courses of action , which prescribes or restricts the real course of action . Other groupware systems , such as computer conferencing systems and shared whiteboards , allow any user to do any action at any time . Such groupware is called permissive , since it does not attempt to constrain or direct the behaviour of its human users . Rather , it leaves coordination to the human users and allows for the emergence of social protocols . Restrictive and permissive groupware are proposed as extremes on a continuous scale . There are several systems that have both permissive and restrictive aspects . For example , a shared whiteboard with a floor control mechanism in which a chairman can determine who can draw on the whiteboard has both permissive aspects ( each user can have the floor and G ROUPWARE S YSTEMS : H ISTORY AND S TATE OF THE A RT 33 then draw ) and restrictive aspects ( there is a designated chairman that grants and revokes access to the floor ) . There has been considerable debate , not so much about the classification per se , but rather about the question how restrictive or permissive groupware should be . We revert to this issue in section 2 . 3 . 2 . Information Sharing Versus Information Exchange Some groupware systems , such as shared whiteboards and application sharing systems , support information sharing . They allow users to observe and manipulate shared objects in a shared workspace . Actions by users on shared objects are interpreted by the groupware system , resulting in updates of the state of the shared workspace , which are observable for other users . Other groupware systems , such as videoconferencing systems , support direct exchange of information between users [ Rodd93 ] . With these systems , actions by users , such as speaking , gesturing or typing are relayed relatively transparently to other users , i . e . , without interpretation by the computer system . A related classification was proposed by Rüdebusch , who distinguished among implicit interaction ( i . e . , indirect communication via a shared object ) and explicit interaction ( i . e . , direct communication via a channel ) , respectively [ Rude93 ] . Although these classifications may seem clear at first sight , they suffer from a duality between information exchange and information sharing : sending a message can be considered equivalent to giving someone else access to ( a copy of ) shared information . This duality is most apparent with computer conferencing systems . In [ Rude93 ] , computer conferencing systems are classified as information exchange systems , since they support the direct , explicit exchange of information between users in the form of messages . In [ Rodd93 ] , a computer conference is regarded a shared information object , which is updated by each message send to the conference . A similar classification problem occurs when an information sharing system allows users to do many actions on a shared object , before initiating re - synchronisation . Such re - synchronisation is typically presented to the user as a ‘send’ , ‘update’ or ‘ exchange ’ action . Information exchange and information sharing are often needed in combination . In tasks such as cooperative design it is important to be able to communicate about the design . Vice versa , in direct communication about the design , frequent references will be made to the design . Hence , many systems such as multimedia conferencing systems and many co - authoring systems support both information exchange and information sharing . 34 C HAPTER 2 G ROUPWARE : AN O VERVIEW 2 . 2 Developing Groupware Currently , groupware developers are faced with the complex task of building multi - user , multi - computer systems on top of single - user , single - computer infrastructures . In this section , we describe several facets of this complexity and the solutions which are currently available to reduce this complexity . Due to the specific nature of the service that is to be provided to users , groupware development involves many issues that introduce additional technical problems compared to the development of single - user applications and conventional distributed applications , as described in section 2 . 2 . 1 . Currently prevalent platforms do not sufficiently address these specific issues and fail to give appropriate groupware support , as described in section 2 . 2 . 2 . There are some groupware development platforms , described in section 2 . 2 . 3 , and groupware standards , as described in section 2 . 2 . 4 , that address some of these issues . However , most of the platforms are experimental and most of the standards are still in their infancy . 2 . 2 . 1 Specific Groupware Development Issues Presence and Awareness To be able to cooperate , users must be aware to some extent of each other’s presence and actions . One of the main tasks of any groupware system is to provide users with information to maintain such awareness , even though users may not be continuously working in the same room , or working at the same time . Groupware systems do this by providing users with feedthrough information about actions performed by other users , in addition to providing feedback to their own actions , as in single - user systems . Groupware developers face issues such as : – How much presence and awareness is required , i . e . , which feedthrough must the groupware system provide on which actions of which users ? – To what extent can users control their presence , i . e . , have control over which of their actions cause feedthrough at what time to which other users ? – To what extent can users control their awareness , i . e . , have control over when which actions of which others cause feedthrough to them ? Collaborative Consistency Management In groupware that contains a shared workspace function , the above issues translate into maintaining some kind of consistency between two or more representations of the shared workspace , despite concurrent activity of D EVELOPING G ROUPWARE 35 human users . One of the problems faced by groupware developers is that such concurrent user activity may lead to concurrent actions on the shared workspace , which may cause inconsistent representations of the shared workspace . The fundamental cause of the emergence of inconsistency is that mapping actions at one location onto actions at another location consumes ( an unpredictable amount of ) time , due to network latency , processing time and queuing time . This may result in different order of actions at different locations , as illustrated in Figure 2 - 16 . a 2 ( s  s Η 1 ) a 1 ( s  s Η 1 ) a ( s  s Η 1 ) 2 1 b 1 ( s  s ⌠ 2 ) b ( s  s ⌠ 2 ) b 2 ( s  s ⌠ 2 ) globaltime divergence inconsistency s = 2 s = 2 s = 3 s = 6 s = 4 s = 5 Action a ( a request to add one to the variable s ) at location 1 is mapped onto its associated feedback action a 1 at location 1 ( show the result to user at location 1 ) , taking an amount of time we denote as response time , and onto its associated feedthrough action a 2 at location 2 ( show the result to user at location 2 ) , taking an amount of time we denote as notification time . Usually , notification time is larger than response time , due to considerable network latency . In this case , divergence emerges when a 1 occurs at location 1 : two users can observe different values for s . The divergence would have been lifted as soon as a 2 would have occurred at location 2 . Before a 2 occurs , however , the user at location 2 performs an action b ( a request to multiply the variable s by two ) , causing the associated actions b 1 and b 2 . As illustrated , a 1 and b 1 may occur in a different order compared to a 2 and b 2 . When a and b are non - commutative actions , as illustrated in Figure 2 - 16 , the divergence evolves into inconsistency : a situation in which re - establishment of consistency may require human intervention . Per se , this is not a problem unique to groupware . Many multi - user systems such as timeshared computers and database systems face similar Figure 2 - 16 Emergence of inconsistency due to different ordering of actions 36 C HAPTER 2 G ROUPWARE : AN O VERVIEW problems . In database systems , a typical solution to this problem is to prevent the emergence of inconsistency by making sure only one user at a time gets the privilege to modify ( a particular part of ) the database ; other users who attempt to modify ( that particular part of ) the database are denied access : for them , ( that particular part of ) the database is ‘locked’ . However , in groupware development , the issues involved in dealing with inconsistency are fundamentally different from those in conventional database applications . First of all , allowing inconsistency to emerge may be a better choice than trying to prevent it . For example , allowing the emergence of occasional inconsistencies in a bitmapped shared whiteboard ( e . g . , the inconsistency that may arise at the intersection of two lines drawn simultaneously by different users with different colours ) , may be more desirable than preventing inconsistency ( e . g . , by locking pixels , regions or the entire shared whiteboard ) , which inevitably deteriorates the responsiveness of the system . Furthermore , awareness may reduce the likelihood of conflicting actions . Groupware systems can provide awareness information about the actions of the other users . Social protocols may reduce the likelihood of conflicting actions ( e . g . , it may be considered rude to start drawing at the place where somebody else is already drawing ) , which can reduce or eliminate the need for inconsistency detection or prevention . Moreover , inconsistency may be intentional . For example , users may want to make two different versions of a document . Later re - establishment of consistency ( ‘version merging’ ) may be done interactively with the users . This is in sharp contrast with conventional database systems , which consider it the sole responsibility of the system to maintain consistency . Another situation in which inconsistency is intentional is when two users want to switch from having consistent views to having different views on the same document ( e . g . , by both dragging their scrollbar in a different direction ) . Such situations require detection of inconsistency , support for inconsistency and interactive consistency re - establishment , not prevention of inconsistency . Finally , even if inconsistency prevention is the preferable option , groupware developers have many options . For example , instead of denying certain actions ( as is done with locking ) , it may be better to postpone actions of users in such a way that all actions are executed at all sites in the same order . For example , action b 2 in Figure 2 - 16 might be postponed until action a 2 is completed . Such a mechanism can ensure consistency , without denying any user any actions . However , depending on the intentions of the users , the result , though consistent , may not be the desired one . This is the case if the users in Figure 2 - 16 wanted to propose an alternative value for s ( i . e . , it should have been either a , or b , but not both ) . In such cases , it may D EVELOPING G ROUPWARE 37 be preferable to temporarily deny access to some users and give privileged access to other users ( e . g . , by using locks ) . Note , however , that in groupware systems information about who has the lock may be important to users , whereas in database systems it typically is only relevant whether you have the lock or not . Moreover , a groupware system might give a lock not only to individuals , but also to a ( sub ) group [ MuDe96 ] . This may occur when two users indicate they want to edit the same section together . A groupware system may support such a situation by giving two people the lock and making sure they can see changes of each other immediately , while others are not allowed to change the section and can typically only see the result of the changes when the lock is released . Latecoming Many groupware systems need to support situations where participants join a running conference . One of the problems to be solved in such a situation is : how to convey the current state of the conference , such as the current state of a shared workspace , to the new user , without disturbing the other users too much ? In some cases , the solution is relatively simple : – when users share the user interface to a single copy of an application , the application is asked to redraw itself on another screen once more . – when users only share a file that is stored on a shared file server , the application that is started for the new user simply loads the shared file . However , many other cases which may require ( a combination of ) : – transferring state information for existing users to new users , which includes both state information that is traditionally stored persistently , as well as ephemeral state information , such as scroll bar position , cursor position and view type ; – replaying actions that have been recorded for the purpose of updating latecomers . 2 . 2 . 2 Contemporary Software Development Platforms : Shortcomings Platforms allow developers to abstract from generic issues , by providing reuse of generic functionality that is embodied in the platform . They allow developers to concentrate on important details of their particular application . Currently prevalent platforms typically include generic support for dealing with persistent storage and dealing with the ( graphical ) user interface . Lately , distributed file systems , which include support for accessing files across a network , and distributed platforms have emerged , which typically provide a Remote Procedure Call ( RPC ) mechanism as generic means for communication across networks . However , as described below , these contemporary software development platforms have several 38 C HAPTER 2 G ROUPWARE : AN O VERVIEW shortcomings with respect to groupware issues such as those mentioned in section 2 . 2 . 1 . Distributed File Systems Most distributed file systems , such as NFS and NetWare , were not designed with collaborative consistency management in mind . Though distributed file systems allow applications to access and share files that are located on other computers on the network , typically , only one user at a time is allowed to update the file . Such an approach reflects the assumption that it is the file system’s responsibility to maintain consistency of the file , and disregards the existence of groupware applications that can maintain consistency . Moreover , many distributed file systems were not designed with presence and awareness in mind : they typically do not provide update notifications and do not allow for modification of access rights ( e . g . , from read to write access ) , without closing and re - opening the file , which hampers the construction of groupware on top of these file systems . Many hypermedia applications partly circumvent these limitations of network file systems : by storing different nodes of a hypermedia document in different files , hypermedia applications can provide simultaneous access to the hypertext document as a whole , while only one user at a time can edit a single node . User Interface Systems Most contemporary user interface systems and toolkits , such as X windows , Microsoft Windows and the Java Abstract Windows Toolkit ( AWT ) [ BeSS97 ] , were not designed with groupware and multi - user interfaces in mind . For example , such contemporary user interface systems do not provide support for presence and awareness . Multi - user interface objects , such as multiple telepointers , shared telepointers and multi - user scrollbars , which can provide awareness about the activities of other users , can be directly derived from single - user counterparts . Others , such as radar views , which provide awareness which regions other users have ‘in view’ [ GuRG96 ] , require considerable redesign of their single - user interface counterparts . Lack of support for e . g . , multiple telepointers requires re - implementation of basic pointer mechanisms with graphic primitives [ GRW + 92 ] . This places unacceptable burdens on groupware application programmers . Another example of lack of support for awareness is the practice of greying out unavailable menu options . Typically , user interface systems are not designed to redraw a menu after a user has opened it , when another user simultaneously completed an action which should result in greying out a menu item . With some user interface platforms , the situation is even worse : the core of the application is blocked as soon as one user opens a menu , D EVELOPING G ROUPWARE 39 thus preventing the other users from doing anything while the user is making a selection from a menu [ HBP + 93 ] . As a corollary of the lacking support for presence and awareness , contemporary user interface systems did not have to deal with issues such as consistency between user interface objects or supporting the externalisation of user interface object state for latecomers . Even with support for presence , awareness and collaborative consistency management in place , it would be hard to reuse some single - user interface constructs , since their design may be based on the assumption that there is only one user , who is doing only one thing at a time . For example , the standard bounding box that is typically displayed for objects being moved , is based on assumption that only a single object is on the move at any time . When multiple objects are moved by multiple persons , it may become hard to see which object is going where [ HBR + 94 ] . Distributed Platforms At data transport level , groupware requires point - to - multipoint and multipoint - to - multipoint communication , whereas most communication support in contemporary distributed platforms is focused on point - to - point communication ( e . g . , RPC , TCP / IP , SMTP ) . Simulating multipoint communications with many point - to - point messages , though possible , is highly inefficient , and error - prone . This , in turn , complicates collaborative consistency management . For groupware with an asynchronous nature , this inefficiency is not very problematic . In fact , most commercially available groupware systems are based on point - to - point message transfer services such as SMTP . At application level , groupware needs support for presence , awareness and collaborative consistency management . However , distributed middleware platforms ( e . g . , ANSAware , DCE , DCOM and CORBA - compliant systems such as SOM and Orbix ) and distributed operating systems ( e . g . , Amoeba , Chorus and MACH [ Tane95 ] ) do not provide sufficient support for building groupware , since they are typically aimed at masking out the presence of other users , thus giving the users the impression as if they were the only user of the system [ RoBl92a ] . The support that most middleware platforms provides is centred around the Remote Procedure Call ( RPC ) mechanism , which provides conventional procedure - based access to modules , objects or components irrespective of their location . Standards such as the Common Object Request Broker Architecture ( CORBA ) [ OrHE96 ; OMG97 ] facilitate distributed RPC - like interaction between objects , irrespective of differences such as operating system , language or compiler . Typical middleware services are [ RoBl92a ] : naming services , load balancing strategies , distributed ( atomic ) transaction mechanisms . 40 C HAPTER 2 G ROUPWARE : AN O VERVIEW In distributed operating systems , middleware services are integrated into the operating system . Typical services provided by distributed operating systems are distributed process management , distributed shared memory , distributed file systems , communication , and synchronisation . Few middleware and distributed operating systems products and research platforms ( typically , only those that are aimed at fault - tolerant computing ) , provide support for multipoint communication and consistency management of replicated data . Some examples that do are Transis , ISIS , Horus [ GrCo96 ] and Amoeba [ KaTV93 ; KaTa96 ] . ISIS in particular has been used as a basis for groupware platforms ( see section 2 . 2 . 3 ) , such as DistEdit [ KnPr90 ; KnPr93 ] , a platform for developing co - authoring systems and COLA [ TrRB95 ] , a more generic groupware platform . 2 . 2 . 3 Groupware Development Platforms Developing groupware systems on top of conventional platforms for single - user or distributed systems proved to be a frustrating experience ; developers found themselves inventing similar solutions for similar problems over and over again [ RoGr96 ] . Factoring out generic solutions into groupware development platforms , has been the goal of many research and development initiatives ( for more extensive overviews of groupware development platforms , we refer to [ Dewa93b ; UrNe94 ; Cort94 ; Dour96a ; HoLu97b ] ) . The goal of such platforms is to reduce the complexity of groupware development by providing reuse of solutions for common problems , particularly those for which conventional software development platforms do not provide sufficient support . This allows for more efficient development of specific groupware applications . Moreover , it facilitates a prototypical approach to groupware development . Roughly , four categories of groupware development platforms can be distinguished , based on the focus of support . Multi - user Interface Platforms Platforms such as Rendezvous [ PHR + 90 ; HBR + 94 ] , GroupKit [ RoGr92 ; RoGr96 ] , Suite [ DeCh92 ; DeCh95 ] and MEAD [ BRS + 94 ; Bent94 ] , provide run - time services and programming abstractions for implementing multi - user interfaces . The focus in such platforms is on supporting presence , awareness , collaborative consistency management and latecoming in groupware applications that provide multiple users an interface to a shared workspace , where each of the users may have a different view on the shared workspace . As a typical example of such platforms , we describe GroupKit . It provides a run - time infrastructure , which automatically creates processes , D EVELOPING G ROUPWARE 41 manages their interconnections and communications . Processes involved in a GroupKit application are session manager processes , which communicate with a registrar process in order to allows users to create , delete , monitor or leave conferences and conference application processes , which provide a groupware service such as a shared whiteboard or a game , etc . For programming conference applications , GroupKit provides programming abstractions such as multicast remote procedure calls , shared data structures ( with embedded collaborative consistency management ) called ‘environments’ , multi - user interface objects and session management events . Shared Object Platforms Shared object platforms , such as COCOON [ Koll95 ] , COLA [ TrRB95 ] , ObjectWorld [ TBE + 94 ] , Prospero [ Dour96a ] , and SCOOT [ CFS + 94 ] , are specifically designed to support collaborative consistency management and latecoming . Typically , these platforms take care of : – formation and disbanding of groups of replicated objects , which is typically used when a new conference is started or terminated , respectively ; – multicasting messages or calls to all group members , with various options for ordering and reliability ; – latecoming , by creating a new object replica in the group and bringing it up to date , which is typically used when new user joins an conference ; – removing an object replica in the group , which is typically used when a user leaves a conference ; – giving privileged access to shared data with ‘tokens’ or ‘locks’ . As such , they give much more direct support for collaborative activity than conventional shared database systems and shared file systems . Message - based Groupware Platforms Message - based groupware platforms , such as ConversationBuilder [ KaCa92 ; BTB + 96 ] and OVAL [ MaLF92 ] , facilitate the construction of computer conferencing and workflow systems . Typically , these platforms are based on a messaging infrastructure , either a proprietary infrastructure such as ConversationBuilder’s message bus , or a standardised messaging infrastructure which makes these systems more open , such as X . 400 and SMTP . ConversationBuilder is a platform for developing workflow management systems , based on speech - act theory . ConversationBuilder allows definition of various specific conversations , called protocols . For this purpose , ConversationBuilder provides basic protocols , which can be specialised and composed in sequential or hierarchical order . In protocols , programmers define : various protocol states , which actions ( utterances ) are possible in 42 C HAPTER 2 G ROUPWARE : AN O VERVIEW which states and which actions lead to which state transitions . Utterances are typed , which allows the conversation manager component in ConversationBuilder to track the state changes of a conversation . Furthermore , utterances in protocols may create , change , link and unlink shared artefacts . Using ConversationBuilder , various specific groupware systems have been be modelled , such as the Coordinator , CHAOS , and gIBIS . Oval [ MaLF92 ] facilitates development of groupware systems by programmers and ‘radical’ tailoring of such systems by end - users , based on four basic components — Objects , Views , Agents and Links . Semi - structured Objects represent things such as tasks , messages and meetings . Each object definition includes a list of untyped fields and field values and a set of actions that can be performed upon it . Views are ( editable ) visualisations of objects and object collections , for instance as tables or graphs . Agents are production rules associated with objects which trigger when their conditions—typically , particular values of object fields—are met . Links relate objects , allowing the creation of networks , hierarchies , etc . In Oval , an application can be constructed by defining a set of objects , creating agents to trigger behaviours on input or computation , and providing an appropriate set of visualisations . Using Oval , various pre - existing systems have been experimentally ( re ) implemented , such as : the Coordinator , gIBIS , Lotus Notes and Information Lens , an email filtering system . Co - authoring Development Platforms Most groupware platforms can be used in the construction of co - authoring tools . We are aware of only a few platforms that provide dedicated platform support for the construction of co - authoring systems , viz . DistEdit [ KnPr90 ; KnPr93 ] , IRIS [ Koch95 ; Koch97 ] and GroupIE [ Rude93 ; Rude95 ] . Below , we briefly describe DistEdit . DistEdit is a toolkit that can be used to build new co - authoring tools and adapt existing single - user editors to provide co - authoring support . It was developed by the Collaborative Systems Research Group of the University of Michigan around 1990 . DistEdit’s support revolves around a shared text buffer , which is implemented as a special type of shared object on top of the ISIS toolkit [ Birm93 ] . Co - authoring systems can be built on top of this shared text buffer , or by replacing the text buffer of an existing single - user editor with the DistEdit shared text buffer . To evaluate the toolkit , three popular editors , Xedit , MicroEmacs and GNU Emacs , have been re - engineered into co - authoring tools with DistEdit . Since they all use the DistEdit toolkit , these different reengineered editors can even be used in one co - authoring session . D EVELOPING G ROUPWARE 43 The shared text buffer of DistEdit offers operations for text insertions ( letters , strings ) and deletions , and for moving the text cursor . In addition , DistEdit provides automatic locking ( when certain operations are invoked ) or explicit locking ( with dedicated lock and unlock operations ) of the shared text buffer . Locking may be applied to arbitrary document units , from single characters to the entire document . DistEdit also provides a ‘lock step’ mode , which couples the text cursors of the individual in order to obtain a ‘shared’ text cursor . As soon as one person changes his or her cursor position , the position of the text cursors of all others that are in lock - step mode will also change . Concurrent interactions with a shared text cursor are serialised ; the first user in the lock step population that starts an interaction that changes the document , he or she will receive the lock on the shared cursor . Last but not least , DistEdit provides support for support for multi - user undo , either undo of the globally last interaction that changed the document and undo of a user’s own last interaction that changed the document [ PrKn92 ; PrKn94b ] . 2 . 2 . 4 Groupware Standards Interoperability between similar groupware products from different vendors is rare . In order to facilitate such interoperability , a few groupware standardisation initiatives have recently emerged , partly in response to a need to use groupware in inter - organisational settings . These standards , which are briefly described below , are primarily related to groupware product categories for which a market has been established : – computer conferencing : RFC 1036 and OSI Group Communication Service – multimedia conferencing : ITU - T T . 120 and IETF mmusic – workflow management : WfMC reference model – group scheduling and calendaring : IETF calsch . Except for standards in the area of computer conferencing , the groupware standards discussed below are brand new , or still under construction . Although these standards could be supported in the groupware development platforms we described in section 2 . 2 . 3 ( e . g . , multi - user interface development platforms could employ multimedia conferencing standards and message - based groupware platforms could employ computer conferencing , group scheduling and workflow management standards ) , we are not aware of any groupware development platform that does . Computer Conferencing Standards Although not an official Internet standard , the Internet RFC 1036 for Usenet News [ HoAd87 ] , a form of computer conferencing , could be considered one of the first true groupware standards . It defines a protocol and message 44 C HAPTER 2 G ROUPWARE : AN O VERVIEW format for the interchange of news messages . A large part of the success of Usenet News can be attributed to the early availability and widespread adoption of this ‘standard’ . Without it , creating a critical mass of users for each of the hundreds of discussion groups about very specific topics would have been virtually impossible . Less successful in terms of adoption was the OSI Group Communication Service ( GCS ) [ Palm93 ] , which was developed in ISO / IEC JTC1 / SC18 / WG4 . The standard defines services and protocols for computer conferences and more specific applications such as electronic voting , on top of standards such as the standard for Message Handling Systems ( the X . 400 series of recommendations ) and the standard for Directory Systems ( the X . 500 series of recommendations ) . The standard reached the status of Committee Draft — the lowest level of standards document — but due to lack of interest , the standardisation process has been abandoned . Multimedia Conferencing Standards Since 1989 , work has been going on in the International Telecommunication Union ( ITU ) to standardise the T . 120 series of standards for multipoint multimedia conferencing [ Clar94 ] , which defines a . o . protocols for : – multipoint communication ( T . 122 / 125 ) , a connection oriented service which corresponds to the OSI session layer ; it can run on top of various transport protocol stacks ( as defined in T . 123 ) , such as ISDN and PSTN ; – generic conference control ( T . 124 ) , which provides a set of services for setting up and managing a multipoint meeting ; – multipoint still image and annotation protocol ( T . 126 ) , an application - specific protocol that supports shared whiteboards , shared drawing systems , and the exchange of still images ; – multipoint binary file transfer ( T . 127 ) , an application - specific protocol that supports transfer of binary files from one to other participants in a conference ; – multipoint application sharing protocol ( T . 128 ) , an application - specific protocol defines how participants in a T . 120 protocol can share applications . Recently , this core of the T . 120 series of standards has been adopted 17 , both formally by the ITU and in practice in various T . 120 - compliant products , such as Intel ProShare and various PictureTel products . 17 Except for T . 128 , which had been summitted for decision ; see http : / / www . imtc . org / i / standard / itu / i _ t120 . htm for up - to - date information . D EVELOPING G ROUPWARE 45 Another set of standards for multimedia conferencing has been developed by the Internet Engineering Task Force ( IETF ) Working Group on Multiparty Multimedia Session Control ( mmusic ) [ Scho96 ] . The group produced Internet Drafts 18 for protocols that support the management and coordination of multiple sessions and their multiple users in multiple media ( e . g . , audio , video ) over the Internet . This includes protocols , such as a Session Description Protocol ( SDP ) and a Session Announcement Protocol ( SAP ) , a Session Initiation Protocol ( SIP ) , a Simple Conference Control Protocol ( SCCP ) and a Real Time Stream Protocol ( RTSP ) . Unlike the ITU - T . 120 standards , the IETF mmusic standards do not include any application - specific standards . Workflow Management Coalition ( WfMC ) Standards The Workflow Management Coalition ( WfMC ) is a market - driven , non - profit international organisation that aims to promote the use of workflow systems through the establishment of standards for software terminology , interoperability and connectivity between workflow products . The WfMC defines a reference model [ Holl94 ] , which distinguishes five types of functional components and interfaces between them : 1 . process definition tools , which analyse , model and describe a business process ; such tools interact with the workflow enactment service though a standardised process import / export interface ; 2 . workflow client applications , which presents the end user with work items and which may invoke other applications which present the task and data relating to it and allow the user to perform actions ; 3 . invoked applications , such as message services based on X . 400 or document management services , which are used to store and / or forward data and changes relating to work items and business processes ; 4 . workflow enactment service , which provides the run - time environment in which one or more workflow processes are executed ; all other functional components interface to the workflow enactment service , including other workflow enactment services . 5 . administration & monitoring tools , which can provide various overviews of the state of work in the workflows . The specification of the standardised interfaces between the workflow enactment service and these five components was still ongoing at the time of writing 19 . 18 See http : / / www . ietf . org / html . charters / mmusic - charter . html for up - to - date information . 19 See http : / / www . wfmc . org for up - to - date information . Just before going to press , we found out that OMG will also define a standard for a Workflow Management Facility ; see http : / / www . omg . org / library / schedule / Workflow _ RFP . htm for more details . 46 C HAPTER 2 G ROUPWARE : AN O VERVIEW Group Calendaring and Scheduling Standards Based on considerable prior work in this area , the IETF Working Group on Calendaring and scheduling is defining 20 the : – Core Object Specification ( COS ) , a standard data format for representing scheduled events as a MIME content types , which will enable the object to be exchanged using several transports , including but not limited to SMTP , HTTP , a file system , desktop interactive protocols such as the use of a memory - based clipboard or drag / drop interactions , etc . – Calendaring Interoperability Protocol ( CIP ) , a standard mechanism for exchanging events and other information between scheduling systems – Calendaring Access Protocol ( CAP ) , a standard mechanism that scheduling user agents may use to access user calendars ( similar to POP ) . 2 . 3 The Need for Integration , Flexibility and Tailorability Groupware often does not adequately support the variability in cooperative work in organisations . This typically manifests itself in problems with integration between different types of groupware support , as described in section 2 . 3 . 1 , or as inflexible support , as described in section 2 . 3 . 2 . These are symptoms of a more generic need for groupware tailorability , which is described in section 2 . 3 . 3 . 2 . 3 . 1 Problems with Groupware Integration Depending on e . g . , task , group , duration and context , cooperative work can take on a variety of forms [ MaOL94 ] . Moreover , within a single project or cooperative task , people frequently make transitions between various forms of cooperative work , such as transitions between : – synchronous and asynchronous cooperative work ( and the many forms in between ) [ SaKu93 ] ; – collaborative work and individual work [ Ishi90 ; ScRo96 ] ; – distributed and non - distributed cooperative work [ Stre94 ] . Despite the existence of a large variety of groupware applications supporting an equally large variety of cooperative tasks ( see section 2 . 1 . 1 ) , most groupware applications are specialised for dedicated task types . Hence , for many projects and cooperative tasks , a variety of different groupware applications is required . 20 See http : / / www . ietf . org / html . charters / calsch - charter . html for up - to - date information . Just before going to press , we found out that OMG will also define a standard for a Calendar Facility ; see http : / / www . omg . org / library / schedule / Calendar _ Facility _ RFP . htm for more details . T HE N EED FOR I NTEGRATION , F LEXIBILITY AND T AILORABILITY 47 From a large study in 1991 , involving 223 people in 25 organisations , each using a subset of a set of eight groupware applications , Bullen and Bennett [ BuBe93 ] concluded that a lack of integration between groupware tools hinders the productive use of groupware , primarily because the burden of switching between different groupware applications is imposed entirely on users . Activities that compose collaborative work are interrelated in a variety of ways , for example [ NaPR93 ] : – each person may be involved in many activities ; – activities may use common resources and share common information ; – activities may have well - defined temporal relations . Most groupware applications , however , are unaware of the existence of other groupware applications [ NaPR93 ; WaBD94 ] . This imposes on users the full burden of switching between groupware applications , including : – logging on to a variety of groupware applications to initiate a particular collaborative task ; – copying data between applications when users shift from asynchronous to synchronous collaboration , from distributed to non - distributed collaboration , or from a single - user program to a collaborative program ; – move the result from a groupware application used for one collaborative activity into the groupware application that is used for another collaborative activity . The need for better integration and better ways to handle the various transitions inherent in ( cooperative ) work is now widely recognised in CSCW literature [ Ishi90 ; DeCh91 ; DoBe92 ; MaOL94 ; NaPR93 ; PoBa93 ; Beau94b ; Stre94 ; ScRo96 ] . However , integration should not be achieved at the cost of functionality . In a study of the use of such integrated packages in the early days of single - user computing applications [ NMB + 86 ] , Nielsen et al . concluded that a key reason for the unpopularity of such packages was the lack of functionality compared to specialised standalone applications . It seems unwise to repeat such a call for integrated packages in the early days of groupware applications . Instead , the focus should be on ways that provide both the power of focused solutions and the virtues of integration . 2 . 3 . 2 Problems with Groupware Flexibility Flexible groupware is characterised by a design that embeds few , if any , assumptions about the context in which it is going to be used . In particular such groupware allows opportunistic , non - routine user behaviour . Many groupware applications , however , lack such flexibility . 48 C HAPTER 2 G ROUPWARE : AN O VERVIEW A significant line of work in CSCW research has been to model collaborative work processes and to use computer representations of these models as a basis for system support ( see e . g . , page 12 ) . This has led to restrictive groupware systems that track the state of collaborative work process in order to guide and constrain users in their actions , such as the Coordinator and gIBIS . In many of these systems , users can only communicate if they adhere to the patterns defined in the model . Some systems allow users to step outside the defined patterns , but in that case , support is typically severely reduced , because the state of the model embedded in the system is no longer in line with the real world . The basic assumptions underlying restrictive groupware systems is : – Users are capable and willing to provide extra information ( such as indicating the message category in the Coordinator ) , in order to keep the state of the model up to date . – Designers are capable of adequately modelling regularities in collaborative work practice . Various studies show that for many cooperative work contexts these assumptions do not hold . For example , in their study of groupware use , Bullen and Bennett found that users typically ignored the possibility to indicate a category for messages they send [ BuBe93 ] , even though they were aware that this would increase the benefit the group would get from using the system . The groupware used , however , was ‘guidance dependent’ , i . e . , it relied on this additional effort by users in order to achieve group benefit . In combination with critical mass effects [ Grud88 ; MaCo90 ] , Cockburn identified such ‘guidance dependency’ in groupware systems as one of the main causes of groupware failure [ Cock93 ] . Even if users are prepared to put in the extra effort , inadequate models of collaborative work processes may hamper the utility and usability of groupware . In a study of co - authoring practice in academia , Beck and Belotti [ BeBe93 ] found that people tend to use highly opportunistic strategies , in which agreed protocols may be adapted , or individual authors may make autonomous decisions as to whether it is appropriate to break agreements . In such environments , it is hard to find regularities that can be used as a basis for system design . Building systems that guide and constrain users based on inappropriately derived regularities can evoke severe user dissatisfaction . In some evaluative studies , user descriptions of the support provided by the Coordinator ranged from “fascist” to “worse than a lobotomised file clerk” [ Cock93 ] . Such dissatisfaction is not constrained to the area of workflow systems . Some users of Cognoter , a shared whiteboard - like multi - user idea organising tool , found the software so frustrating that they “put their heads in theirs hands , raised theirs voices and ultimately threatened to walk out” ; they even “expressed astonishment T HE N EED FOR I NTEGRATION , F LEXIBILITY AND T AILORABILITY 49 that anyone would build such a system” [ TaFB91 ] . From a study of its use , Tatar et al . concluded [ TaFB91 ] that many of the difficulties stemmed from using an incorrect model of conversation 21 implicit in the design of the software . Bentley and Dourish eloquently summarise the modelling problem as follows [ BeDo95 ] : “Details of individuals’ working contexts , which determine their requirements for system support , are so contingent on factors like individual , local and organisational knowledge , as well as tasks being supported and personal preferences , that trying to model these factors at a level suitable for system design is unlikely to be successful . Indeed , the very variability of these factors , and their highly individual nature , suggests that we should take an alternative approach . ” Based on such observations , many researchers have called for flexibility in the services provided by groupware in general and collaborative editing applications in particular ( e . g . , [ BeBe93 ; PoBa93 ; NKC + 94 ; DeCS94 ] ) . Bentley and Dourish suggest an alternative approach that focuses on flexibility [ BeDo95 ] , an approach “that does not regard the creation of even more intricate and detailed representations of group work as the main route towards more effective cooperative systems . Rather , our approach promotes the view of a cooperative system as one whose behaviour can be adapted through high - level customization to meet the need of its users and that effective ‘support’ arises from precisely this openness and flexibility . ” In effect , they argue for flexible groupware that has very few , if any , built in assumptions about the context in which it is used , that provides unconstrained ways to interact with other people . Complementary to the flexible design , they call for groupware that can be tailored , upon user initiative , to provide specific restrictive groupware support . 2 . 3 . 3 The Need for Groupware Tailorability The problems with ( the lack of ) groupware integration and ( the lack of ) groupware flexibility are symptoms of a more fundamental problem with groupware , viz . that of fitting the support provided by groupware to the situations in which it is used . As suggested by [ BeDo95 ] and others , we currently do not know enough about group work to design groupware that adequately fits a particular group work situation . One of the solutions is to 21 The design of Cognoter was based on a ‘parcel - post’ model of conversation where an ‘interactive’ model of conversation would have been more appropriate . Details of these models are not relevant to the argument being made here ; interested readers are referred to [ TaFB91 ] . 50 C HAPTER 2 G ROUPWARE : AN O VERVIEW find ways to design tailorable groupware , i . e . , groupware that can be tailored to fit a particular group work situation . Such tailoring takes place after design and implementation , i . e . , after the groupware has been put in the context it is supposed to support . Whereas flexibility relies on the design of a groupware system to fit a particular group work situation , tailorability relies on additional effort after design and implementation . Tailoring can be performed by end - users , help desk staff within organisations , programmers , or by the program itself ( e . g . , by learning patterns of use and changing the behaviour of the groupware system to better support these patterns ) . The extent of tailoring may vary greatly , from user interface tailoring , such as defining keyboard shortcuts for frequently used menu options , to ‘radical tailoring’ as proposed in the OVAL system [ MaLF92 ] ( see also page 41 ) , which can be used to radically alter the functionality of a groupware system . Due to the complexity of groupware development , we argue that there will typically be no single groupware application sufficiently comprehensive to support all requirements in a typical cooperative work context . Rather , we assume a groupware system will consists of multiple groupware applications that serve as components . In such a component - based system , there are various ways in which tailoring can be achieved [ Stie97 ] : 1 . Tailoring by configuring components . As an example , consider selecting the floor control policy in a shared whiteboard [ Gree91b ] , or selecting ‘novice’ or ‘advanced’ user interface and functions in an E - mail system . This tailoring approach requires that the designer of the component makes configuration parameters available for tailoring . 2 . Tailoring by changing ( or extending ) the implementation of a component . As an example , consider changing the source code of a shared drawing tool that allows one user at a time to manipulate an object in such a way that users can jointly enlarge an object by each dragging one handle . This tailoring approach requires access to the source code of groupware components . 3 . Tailoring by changing ( or extending ) the composition of components . By selecting and integrating components , users tailor the generic set of components into a specific groupware system that fits their needs . As an example , consider attaching a computer conferencing component to a shared editing component in such a way that computer conferences can be used as annotations . To give another example , consider combining a shared whiteboard with a floor control component that implements a central moderator floor control policy . This tailoring approach requires well - defined generic relations and interfaces between components . C ONCLUSIONS 51 A final observation regarding groupware tailorability is that it can be used to support co - evolution of user practice and system support , something which Douglas Engelbart pointed out , as early as 1978 , as an extremely important issue for the field of computer supported cooperative work [ Enge78 ] : “And finally , for any application of significant power [ … ] the adaptability and evolutionary flexibility of the computer - communication system is extremely important . The working methods of individuals will shift markedly as they settle into use of a comprehensive workshop , and with these new methods and skills will come payoff potential for changes and additions to their workshops — a cycle that will be significantly active for many years to come . A similar cycle will be even more dramatically evident at the organisational level . An evolutionary approach seems the only viable alternative when the effects of a prospective change are not well known ; and for many years to come this will be the case relative to the impacts of significant , prospective steps in office automation upon the operations of our organisations . We have an immense amount to learn about how people can better harness their basic capabilities toward individual and organisational ends . ” 2 . 4 Conclusions Despite the existence of a large variety of groupware applications , supporting an equally large variety of cooperative tasks , various studies of computer supported cooperative work found that groupware does not adequately support the variability of cooperative work in organisations . Supporting such variability requires either a comprehensive and flexible groupware application , or integration of different groupware applications . Developing groupware , however , is complex , which makes it hard to build comprehensive groupware systems . Until now , most groupware applications do not provide comprehensive support . Rather , most groupware applications are specialised for dedicated task types and largely ignore the existence of other applications , which hinders integration . Moreover , all too often , groupware applications have been made too specialised , in the sense that they support only a specific pattern of use and lack the flexibility to support deviations from this pattern . Practical evidence shows that many problems with groupware stem from a lack of integration or a lack of flexibility . These are symptoms of the more generic problem fitting the support provided by groupware to the situations in which it is used . We argued that these problems should be alleviated by making groupware tailorable , i . e . , groupware that can be tailored to fit the situation in which it is used . Moreover , we argued that most cooperative work 52 C HAPTER 2 G ROUPWARE : AN O VERVIEW contexts will involve a multitude of groupware applications as components . Tailoring such groupware systems is done by extending the system with new components and / or changing the composition of these components . These actions , if carefully designed , can be performed by non - programmers , such as end - users and help desk staff , i . e . , by people who know best the context in which the groupware system must fit . Motivated by these observations , we focus on extensibility and composability as the key stepping stones on an evolutionary road towards better groupware . Chapter 3 3 . Design Concepts for Extensibility and Composability Making groupware extensible and composable requires conscious design . In this chapter , we define more precisely the ends , the context and the means of this process , viz . : – extensibility and composability — as the ends that are to be achieved ; – groupware design — as the context in which these ends are to be achieved ; – structuring guidelines and architectures —as the means we choose to achieve these ends in this context . It is not a purpose of this chapter to contribute new design concepts or design methodologies to computer science . Rather , the purpose is to set the stage for the specific structuring guidelines and architectures , which will be described in chapters 5 and 6 . In describing these , various basic concepts from computer science will be used . In this chapter , we define the concepts that are used in the remainder of this book . 3 . 1 Extensibility and Composability Extensibility and composability are two closely related , desirable properties of groupware systems . In this section , we define them separately and describe their relation . In the rest of this chapter and the rest of this book , however , we will not distinguish between these properties unless explicitly specified . 54 C HAPTER 3 D ESIGN C ONCEPTS FOR E XTENSIBILITY AND C OMPOSABILITY 3 . 1 . 1 Extensibility Extensibility is the property of a system that denotes how easy new functions can be added to the system , without interference with existing functions . The notion of extensibility is not absolute , but a matter of degree . As an example , consider adding a new floor to a building , i . e . , adding a ‘space - for - living’ function to a ‘place - to - live - in’ system . Some buildings are designed in such a way that new floors can easily be added , whereas other buildings require considerably more construction work , as illustrated in Figure 3 - 1 . In information systems , extensibility can be found both at the hardware level — e . g . , adding a new input device such as a joystick to a PC or adding a math coprocessor — and at the software level — e . g . , adding an Acrobat Plug - In to a Netscape Navigator web browser that enables it to display Portable Document Format ( PDF ) files . Extensibility involves a trade - off between ease of extension and power of extension . Some extensions , such as adding a Plug - In to the Netscape Navigator web browser , can be as simple for users as the proverbial press on the button . However , such extensions are limited to predetermined types of extensions , such as viewers for new data types . Other ways of extension , such as modifying and recompiling the source code of a program , allow for arbitrary extensions , but such extensions are far more complex to realise and require extensive programming skills . 3 . 1 . 2 Composability Composability is the property of a system that denotes how easy the function of a system can be composed by selecting and combining more basic component functions . As an example of a composable system , consider a hi - fi audio system , which may be composed by selecting different components , such as an amplifier , a tuner , a set of loudspeakers , a pickup and a CD - player . For each type of component , various models from the same vendor or from different vendors may be chosen from . The freedom of choice and composition is inherently limited , however . For an audio system , at least the following component functions are needed : an audio source device ( e . g . , CD - player or tuner ) , an amplifier and an audio reproducer ( e . g . , loudspeakers or headphone ) . Like extensibility , the notion of composability is not absolute , but a matter of degree . Composability is determined by two aspects : the compositional possibilities and power of composition . Definition 3 - 1 Extensibility Figure 3 - 1 Adding a new floor : the upper building is more easily extensible than the lower building Definition 3 - 2 Composability Figure 3 - 2 Hi - fi system : a composable system E XTENSIBILITY AND C OMPOSABILITY 55 Compositional possibilities may include : – Selecting component functions . Some systems do not allow users to select component functions at all . Other systems , such as audio systems , do . – Relating component functions . Some systems only allow predetermined relations between components . For example , in an audio system , the types of the relations between the components is predetermined : audio sources and audio reproducers can interact with an amplifier , but not directly with each other . Other systems allow for the definition of arbitrary relations between components , e . g . , software systems that contain scripting systems ( see “Scripting” in section 3 . 1 . 4 ) . The power of composition may vary between : – Coexistence of components . As an example of coexisting components , consider running a set of arbitrary applications on a PC . Before the introduction of standard cut and paste mechanisms between applications , there was no real synergy between applications ; the operating system allowed users to run an arbitrary set of applications on their system , sequentially and ( later ) in parallel . Although there was no real synergy and all application integration had to be done ‘by hand’ — e . g . , by reading output from one application and typing it into another — at least , there was no undesirable interference between components . – Connecting components with pre - determined relations . As an example , consider arbitrary applications that support data transfer to and from a system clipboard with cut and paste . Another example is the hi - fi audio system : the type of relations between audio sources and amplifier components and between audio producers and an amplifier are pre - determined ; composition is a matter of selecting the components that are to be connected . – Custom composition of components . As an example , consider integrating a database application , a word processing application and an E - mail application with a script that retrieves addresses from a database , subsequently calls the mail merge function of the word processor and finally sends of the result via E - mail to the various destinations . Similar to extensibility , composability involves a trade - off between ease and power of composition . Composing coexisting applications is very simple : ‘composition’ is done by starting another application . Composing components with pre - determined relations is slightly more complex , since it involves selecting the components that are to be related . However , this additional effort may yield synergy such as data transfer between applications . Custom integration of components is more complex and often requires programming skills to specify the interaction between components 56 C HAPTER 3 D ESIGN C ONCEPTS FOR E XTENSIBILITY AND C OMPOSABILITY in , e . g . , scripts . However , this additional effort may yield synergy such as complete automation of frequently executed tasks . 3 . 1 . 3 Relation between Extensibility and Composability Extension and composition are closely related . In the context of groupware systems , extension refers to installing a groupware component , whereas composition refers to running and relating instances of groupware components . In general , extensibility does not necessarily imply composability : systems that can be extended do not have to give users the ability to select and relate components , e . g . , when the composition is fixed after each extension . For example , a website with many internal hyperlinks may be easily extensible , but restructuring the site to present just a composition of a few subjects may be hard , especially if the website has not been designed for this purpose . Vice versa , composability does not necessarily imply extensibility : systems may allow users to select and relate components from a fixed set of components , which cannot be extended . For example , a tangram puzzle , which consists of a fixed set of pieces , can be used to make a virtually unlimited number of compositions . In this book , we focus on systems based on components that can be used both as a unit of extension and as a unit of composition . Unless specified otherwise , we will not make a distinction between extensibility and composability . 3 . 1 . 4 Mechanisms for Composition by End - Users Composability is not a new property of software . Various mechanisms have been developed that allow developers to compose a system implementation from partial implementations , such as modules , objects and , more recently , software components ( we will describe these mechanisms in more detail in “Platforms and Mechanisms for Implementation of Decomposed Designs” in section 3 . 2 . 3 ) . Gradually , these mechanisms allowed composition at a later stage in the development process of a system . Allowing users to compose their systems from components can be seen as a logical continuation of this trend . Various mechanisms exist that allow users to make their own composition of , e . g . , applications . As an illustration of what composability may mean for end - users , we describe some of these mechanisms below : pipes , clipboards , linking , embedding and scripting . These mechanisms illustrate the trade - off between power of composition and ease of composition . Each subsequent mechanism provides a more powerful form of composition . At the same time , each subsequent mechanism is less easy : E XTENSIBILITY AND C OMPOSABILITY 57 it requires more knowledge from the user about the compositional mechanisms and about the applications that are to be composed . Pipes : Input / Output Redirection In various operating systems , applications interact with their environment via ‘streams’ , i . e . , software interfaces to which characters can be written and from which characters can be read . Through the operating system , the user controls how these streams are connected , e . g . , to files , to input or output devices , or to each other . By default , applications read their input from a standardised input stream ( UNIX : stdin ) and write their output to standard output stream ( UNIX : stdout ) . Using the ‘pipe’ mechanism , users can compose applications by redirecting the output of one application to the input of another application , thus creating a linear chain of applications . As an example , consider two applications : one application ( invoked by the command “ ypcat hosts ” ) that checks the list of known host computers and presents it to the output stream and another application ( invoked by the command “ grep fuji ” ) that can filter lines of text that contain " fuji " . Users can invoke a composition of these applications by placing the pipe - symbol “ | ” between the commands . The resulting composed command “ ypcat hosts | grep fuji ” specifies that the output of the “ ypcat hosts ” program must be redirected to the input of the “ grep fuji ” program , as illustrated in Figure 3 - 3 . Clipboard : Cut & Paste Ever since the introduction of the Apple Macintosh operating system , a clipboard has been used as a means to transfer data between applications . When users cut ( or copy ) data from an application , that data will be transferred to the clipboard , an application - independent system - wide polymorphic data container . Users can then switch to another application and paste the data from the clipboard into the other application . This mechanism requires each application to have the ability to interact with the system’s clipboard . Moreover , the applications must be able to understand each other’s data formats , either directly , via an import conversion filter , via an export conversion filter , or via both import and export conversion filters . To be usable for end users , this scheme requires each application to provide the same user interface to the cut , copy and paste operations . Linking : Publish & Subscribe Links can maintain dependency relations between data in applications . For example , a pie chart that is pasted from a spreadsheet into a word processing document may depend on several cells in the spreadsheet . Most ypcat grep pipe Figure 3 - 3 Redirecting output of one application to input of another application with a pipe 58 C HAPTER 3 D ESIGN C ONCEPTS FOR E XTENSIBILITY AND C OMPOSABILITY likely , when the data in one of these cells is updated , the pie chart in the document in the word processing application needs to be updated as well . If the user creates a link between the spreadsheet pie chart and the pie chart in the document ( e . g . , by ‘publishing’ the pie chart from the spreadsheet application and ‘subscribing’ to that pie chart in the word processing application ) , each time the spreadsheet pie chart is updated ( e . g . , because some spreadsheet cells are changed ) , the pie chart in the document will also be updated . This mechanism requires each application to have the ability to interact with the system’s linking function and to understand each other’s data formats , directly , or via conversion filters . Embedding Embedding , as found in OpenDoc and OLE 2 . 0 [ OrHE96 ] , takes the idea of linking one step further : not only the data from one application is inserted into another application , but also the application itself is embedded in the other application . The embedded application remains responsible for displaying , printing , storing and editing the data that is inserted , in the space that is provided by the embedding application . The embedded data is not transferred from one application to another , which means that embedding does not require applications to understand each other’s data formats . Moreover , embedding does not require conversion filters . Instead , embedding requires applications to be able to interact with the system’s embedding function and to be able to interact with each other about the space in which the embedded data is displayed on the screen and printed on paper , about the space in the file in which the embedded data is stored and about user interface controls such as menus which are shared between the embedding and the embedded application . A limited form of embedding can be found in Netscape Navigator , which can embed viewer Plug - In applications to display particular data formats in the main Navigator window that cannot be displayed by Navigator itself . This form of embedding only requires applications to be able to interact with Navigator’s embedding function and does not require applications to interact about storage space . Scripting One way to allow an application to invoke the operations of another application is to expose the operations of the latter ( i . e . , their names , parameters and parameter types ) to a system - wide scripting service . A scripting service allows users to write scripts that include these application - specific operations . Such a script can be executed by the scripting system , which interprets the script and invokes the operations in the order defined in the script . One script may contain operations of various applications . A M ODEL OF G ROUPWARE D ESIGN 59 Thus , scripts can be used as a kind of cross - application macros . Users may write their own scripts , thus integrating various applications . As an example , consider a word processing application ‘ WP ’ , exposing the operations GetSelection $ ( ) , and ReplaceSelection ( in replacement $ ) and a thesaurus program ‘ TH ’ , exposing the operation Lookup ( in lookup $ , out selectedsynonym $ ) . A composition of these two applications can be made with the following simple script , which could be defined by the user , or by the developers of the thesaurus or word processing application : TH : Lookup ( WP : GetSelection $ ( ) , new $ ) ; WP : ReplaceSelection ( new $ ) Alternatively , the thesaurus program could use the exposed operations GetSelection $ ( ) , and ReplaceSelection ( in replacement $ ) directly . With scripts and exposed operations , application suites can be made . Application suites consist of a loose federation of applications — e . g . , a word processor , a spreadsheet , a drawing and presentation application , a database application , a group scheduling application and an E - mail application — that are related with various scripts 22 that automate tasks that require more than one application . Whereas data transfer via clipboards , linking and embedding are generic mechanisms for application composition , application suites are application - specific : they contain application - specific scripts as a means to compose a set of applications . Typically , all applications in an application suite come from a single vendor and the scripts are vendor - specific . However , in theory , mixed - vendor application suites are possible . 3 . 2 A Model of Groupware Design Complex systems , such as bridges , buildings and information systems are not built in a trial and error fashion , but generally involve some systematic activity aimed at the creation of these systems . This activity is called design . Design is a systematic activity aimed at the creation of a system for a specific function or end . Design of information systems in general , and groupware systems in particular , is a highly complex activity . Design involves using various methods and techniques to deal with complexity and using guidelines to take design decisions . 22 These may be ‘real’ scripts , or scripts that are encoded in one application as calls to exposed operations of other applications . Definition 3 - 3 Design ( verb ) 60 C HAPTER 3 D ESIGN C ONCEPTS FOR E XTENSIBILITY AND C OMPOSABILITY Somewhere in the design process , designers need to take appropriate decisions in order to make their systems composable and extensible . In this section we identify where . To do this , we first define various elementary design techniques and concepts , such as modelling , abstraction , decomposition and architecture . Subsequently , we describe the role of structuring guidelines as a means to achieve extensible and composable groupware systems . We describe how structuring guidelines are conceived and how they can be evaluated . Finally , we identify three abstraction levels in the design trajectory of a groupware system . Each of these levels represents a place in the design process where important design decisions need to be taken . In chapter 5 and 6 , structuring guidelines are developed for each of these levels . 3 . 2 . 1 Abstraction and Modelling To handle complexity in design , designers create and manipulate models of the system that is to be realised , by abstracting from irrelevant aspects of the system . These models allow designers to focus on important aspects of the system , to communicate about the system with its prospective users and other designers , before the system is realised . Moreover , such models can be communicated with tools that help the designer to realise the system . Below , we will define various concepts used in this paragraph . A system is a related set of entities that function as a whole . Almost anything can be regarded as a system : a bridge , a building , a human being , the earth , the solar system , a culture , etc . The question whether something is a system or not is not so relevant . Rather , describing and studying an object or phenomenon as a system poses helpful questions such as : what is the nature of the entities , which entities are part of the system ( and which are not , i . e . , what is the scope of the system ) , what is the nature of the relation between the entities , do the entities have a relation with entities outside the system , or not , etc . We are interested in the design of a specific type of systems , viz . groupware systems , which , in turn , are a specific type of information system . An information system is a system that is able to process , store , retrieve and / or transfer data , based on computer and / or communication technology . Whereas in some definitions , information systems do not have to involve the use of computer or communication technology , we explicitly specify this constraint in our definition , in order to represent the class of systems we focused on in our research . Definition 3 - 4 System Definition 3 - 5 Information system A M ODEL OF G ROUPWARE D ESIGN 61 A groupware system is an information system that supports cooperative work . One of the fundamental techniques to deal with complexity in designing systems is abstraction , which can be used to make models of a system . An abstraction is a representation of certain aspects of a system that are considered relevant for the purpose of that abstraction . A model is an abstraction of a system . Models contain aspects of a system that are considered relevant and leave out details that are considered irrelevant . Which aspects of a system are relevant and which are not , may depend on : – the ( function of the ) system being modelled ; – the goal of the model , which may be to help understand a particular aspect of the system or to express design decisions about particular aspects of a system . A model itself is again a system . It is related to the system it models through abstraction . Systems ( including models ) can have various forms : concrete , conceptual or symbolic [ Bakk94 ] . A concrete system is a system that consists of entities that are concrete , i . e . , physical things and / or phenomena . Definition 3 - 6 Groupware system Definition 3 - 7 Abstraction Definition 3 - 8 Model Example 3 - 1 Model of a bridge Consider an architectural drawing of a bridge over a river . It contains details about the bridge such as the construction , but it may leave out details such as the colour of the bridge , which is not relevant for the function of the bridge described in the model , viz . enabling people and traffic to cross the river safely . However , in an artist’s impression of the bridge , another model of the bridge , that allows people to judge aesthetic aspects of the bridge , the colour may be considered . In this model , for example , the colour is important and must be represented , whereas particular construction details may be left out . Example 3 - 2 Scale model of an aeroplane Consider a scale model of an aeroplane that is used in a wind tunnel to study aerodynamic behaviour of an aeroplane that is being designed . The scale model must correctly represent the shape of the aeroplane , in order to obtain valid data about aerodynamic behaviour . Details such as colour and the internal layout of the plane are irrelevant to the aerodynamic behaviour and are not represented in the scale model . Definition 3 - 9 Concrete system 62 C HAPTER 3 D ESIGN C ONCEPTS FOR E XTENSIBILITY AND C OMPOSABILITY The creation of concrete systems is the eventual goal of many design processes . Nonetheless , the imminent goal of many design processes is to make models that can be easily realised in terms of concrete systems . For example , the imminent goal in the design of information systems is often a program , which models the behaviour that a computer system should exhibit . Eventually , it is the physical behaviour that makes the computer system useful . In design , however , this last step , from ( compiled ) program to physical behaviour , is often considered self - evident and trivial and hence , a program is often considered as the goal of design . A conceptual system is a system that consists of entities that are represented in someone’s mind . Conceptual models are conceptual systems that help humans understand and conceive complex systems . Design involves various humans — designer ( s ) and / or user ( s ) — that need to communicate ( about ) the model . Before a conceptual model can be communicated between humans , however , it must be represented in some language ( e . g . , each entity in a conceptual model is represented as one or more textual , graphic or auditory symbols ) , yielding a symbolic model . A symbolic 23 system is a system that consists of entities that are symbols that can be communicated between humans . We define formal models as a subclass of symbolic models . A formal model is a symbolic model of which the semantics is mathematically defined . Thus , formal models allow for ( automated support of ) proof and mathematical reasoning , which can be useful during design . The purpose of a model may vary from strictly descriptive to strictly prescriptive ( or : normative ) . This distinction determines whether the model or the system that is modelled has to be adjusted when an inconsistency between the two is discovered . A model is descriptive , if the model must be a valid abstraction of the system it models . 23 These are also called formal systems in [ Bakk94 ] . We define formal systems a subclass of symbolic systems . Definition 3 - 10 Conceptual system Definition 3 - 11 Symbolic system Definition 3 - 12 Formal model Definition 3 - 13 Descriptive model A M ODEL OF G ROUPWARE D ESIGN 63 As a consequence , a descriptive model needs to be changed if it is inconsistent with the system it models . A model is prescriptive , if the system it models must be a valid implementation of the model itself . A prescriptive model is also known as a ‘design’ . As a consequence , a prescriptive model does not need to be changed if it is inconsistent with the system it models ; instead , the system that it models needs to be changed . Below , we give some examples of the use of models in information systems design : – A specification is a prescriptive symbolic model of a system that is to be realised . – A program expressed in a programming language is a prescriptive symbolic model of a system that is to be realised . Realisation of the prescribed system is an automated process that involves interpreting the program or compiling the program into an executable program on a concrete computer system . A design process of a complex system such as a groupware system involves several designs . Each design may abstract from different details of the system that is to be realised . A design models the system at a certain abstraction level when abstraction from the same aspects is applied consistently throughout the design . An established practice in the design of information systems is a step - wise refinement design methodology , which identifies an ordered set of abstraction levels and associated designs , e . g . , an initial high - level design , various intermediate designs and a final , low - level design . In a top - down , step - wise refinement design approach , higher level designs are abstractions of lower - level designs and lower - level designs are implementations of higher - level designs . Such an approach divides the design process into a number of transformations , each of which includes the design decisions to transform a higher - level design into the next lower - level design . These abstraction levels are to be taken as reference points , not as a means to totally prescribe a sequential order in which design activity must take place . To be more precise , step - wise refinement does not imply that high - level design decisions cannot be altered once lower - level design decisions are taken . An example of the latter is the waterfall model of software development , which — contrary to popular belief — allowed designers to go back one level and alter design decisions belonging to the next higher transformation [ Bakk94 ] . Step - wise refinement does not imply , either , that all higher - level design decisions should be taken before all lower Definition 3 - 14 Prescriptive model , design ( noun ) high - level design intermediatedesign low - level design Figure 3 - 4 Abstraction levels 64 C HAPTER 3 D ESIGN C ONCEPTS FOR E XTENSIBILITY AND C OMPOSABILITY level design decisions . For example , the cyclic design approach [ Sind95 ] , which distinguishes a number of high - level subsystems ( e . g . , a subset of the functional specification ) , first completes one design cycle for that subsystem , i . e . , all design transformations . Then , the design cycle is completed for a larger subsystem ( e . g . , a larger subset of the functional specification ) . This is repeated until the entire functional specification has been covered . During the early stages of design , the desired characteristics of a system with respect to its environment ( e . g . , human users ) is usually initially modelled in a functional model 24 . This model may be represented in a functional specification . Intuitively defined , a functional model prescribes what a system should do whereas an implementation model describes how that should be done . Before we can define the term functional model and implementation model more precisely , we must first define the concepts interaction and interface . Interaction is a mutual or reciprocal action or influence between systems or between a system and its environment . An interface is a logical location at which systems interact or at which a system interacts with its environment . A well known example of an interface is a user interface , i . e . , a logical location at which a computer system interacts with a user . A functional model of a system is a model that exhibits only particular aspects of the system’s responsibility for the interaction of that system with its environment . A functional model of a system is also known as a system’s ‘function’ . A functional model abstracts from ( i . e . , does not restrict ) choices in the means that are chosen to achieve the prescribed functional model . In particular , a functional model abstracts from : – inner workings of a system , such as internal interactions and internal decomposition ( see 3 . 2 . 2 ) . Because a functional model hides the inner workings of a system , it is sometimes also referred to as the ‘black - box’ representation of a system . 24 In some literature ( e . g . , [ Sind95 ] ) , the term architecture is used to denote the functional model . We will use a different definition of the term architecture that is closer to the common interpretation in CSCW and software design literature . Definition 3 - 15 Interaction Definition 3 - 16 Interface Definition 3 - 17 Functional model , function A M ODEL OF G ROUPWARE D ESIGN 65 – particular details of the interaction between the system and its environment . For example , a functional model of an information system does not have to specify each detail of the energy exchange that realises the interaction between the system and its human users . Some functional models may abstract from this physical realisation of the interaction at the user interface and only specify partial orderings of parameterised operations , without any reference to real - time constraints , without any details about the representation ( s ) of operations at the user interface and / or without details about the sequence of actions that is needed to invoke operations . Other , more detailed functional models , may contain such real - time constrains or user interface details . An implementation model is a model of a system which reveals the means used to realise a functional model . An implementation model of a system is also known as a system’s ‘implementation’ . The abstraction level of a functional model is higher than the abstraction level of an implementation model . In an abstraction hierarchy , the terms functional model and implementation model do not denote two absolute abstraction levels ; rather they only denote relative position : two models at any two abstraction levels can be related as functional model and implementation model . Moreover , one model ( cf . the intermediate design in Figure 3 - 4 ) can be both an implementation model with respect to a higher - level design , as well as a functional model with respect to a lower - level design . There may be many valid implementations of a particular functional model . Choosing between these implies making design decisions . Which specific implementation is ultimately chosen by a designer depends on factors such as constraints put forward by the prospective users and the environment of the system ( e . g . , cost ) and factors inherent to the design process and designer team , such as the design method and tools used and the experience of a designer . 3 . 2 . 2 Decomposition and Composition One of the ways to manage complexity in design is to divide a system into smaller entities . A decomposition of a system is a model that presents the system as a composition of interacting entities ( which can , at a lower abstraction level , in turn be considered as systems ; these entities are also known as ‘subsystems’ , or ‘components’ ) . Definition 3 - 18 Implementation model , implementation functional model implementationmodel Figure 3 - 5 Relative position of functional and implementation model in an abstraction hierarchy Definition 3 - 19 Decomposition , subsystem 66 C HAPTER 3 D ESIGN C ONCEPTS FOR E XTENSIBILITY AND C OMPOSABILITY In principle , a functional model can be implemented by decomposing it into a composition of subsystems , i . e . , by designing a composition of subsystems that conforms to the non - decomposed model . Each of these subsystems , in turn , has its own functional model and can , in principle , be implemented by decomposing it into a composition of subsystems , etc . Whatever the modelling purpose , at some level the process of decomposition stops , e . g . , when all subsystems in a specification are expressed in elements of a programming language or when all subsystems in the model can be realised by available building blocks . At that point , the system is decomposed into atomic entities that the designer will not or can not decompose any further . When decomposition is applied repetitively , as in the bicycle example , a multi - level hierarchy of systems results . Decomposition of a book , for example , may yield the following hierarchy : book , chapter , section , subsection , paragraph , sentence , word , and letter . This is natural decomposition for authors and readers of a book . Another decomposition , more natural for book printers and binders , is a decomposition in terms of a book cover and a book interior , where the interior consists of sheets of paper and the sheets of paper consist of sides . Decomposition can serve a number of purposes , such as enhancing the comprehensibility and modifiability of a system , separation of concerns , reflecting physical distribution or allowing re - use . These reasons are treated in more detail in the following subsections . 25 Wherever we use male forms we imply female forms as well , and vice versa , unless explicitly stated . In this case , the male form “bicycle repair man” was chosen , because , coming from a famous Monty Python sketch , it had a nice ring to it . Example 3 - 3 Bicycle decomposition Consider a bicycle , which consists of a frame , a saddle seat , a steering handle , two wheels , and a propelling system . Some of the subsystems have a fixed connection between each other ( i . e . , ‘interact’ by exerting forces in such a way that they remain in the same relative position ) , whereas other entities can rotate with respect to each other around an axis . This decomposition may be sufficient for the average cyclist to recognise a bicycle and gain a basic understanding that is needed to ride a bicycle . However , each of these subsystems in the bicycle model may , in turn , be decomposed into smaller bits and pieces , such as bolts and nuts . For the average bicycle repair man 25 , a decomposed model that does not further decompose than nuts and bolts is sufficient ; it describes all the phenomena needed to diagnose and repair malfunctioning bicycles . Of course , to study some bicycle phenomena , it may be necessary to decompose the subsystems further into molecules and atoms . A M ODEL OF G ROUPWARE D ESIGN 67 Comprehensibility Many systems — designs in particular — are easier to comprehend when they are presented as a composition of a limited number of subsystems . It allows focusing on the high - level structure of a system and abstracting from the details of the subsystems until needed . Cyclists , almost naturally , perceive a bicycle as a composition of subsystems such as wheels , saddle , etc . Books are easier to comprehend when they are presented as a composition of chapters , each with their own message . Similarly , designs of information systems — which can be very voluminous and complex — are easier to comprehend if presented as a carefully chosen composition of subsystems . In general , systems may be easier to comprehend if the system is structured as a composition of subsystems with certain quality principles in mind , such as comprehensibility . The alternative , a non - structured model , is often referred to as ‘spaghetti’ , a common term in information systems design for an incomprehensible system design . Modifiability Many systems — designs in particular — need to be modified frequently . After information systems are realised , circumstances may change , which may require the system to be modified . Some examples of such changing circumstances are the emergence of new user needs and technological changes . Also , during the design process , user requirements for the system may change , or design decisions may turn out to be wrong . In such cases , a design of the system needs to be modified . Making the required modifications is tedious and error - prone if many subsystems must be modified . Decomposition can isolate the required modifications to a few subsystems or even to a single subsystem , while the interaction between the subsystems may not have to be modified . Of course , if each modification would require a different decomposition , more would be lost than would be gained from decomposition . Hence , as Sullivan and Notkin put it : “A challenge , then , is to find design approaches that isolate design decisions likely to change as requirements evolve . ” [ SuNo90 ] . We will focus on this subject in more detail in section 3 . 2 . 3 . Two types of modification are particularly relevant in the context of this book : – extension , i . e . , extending a system with a new function . Decomposition can isolate the extension as an extension of a single component , or as a new component , which does not require new capabilities for interaction from other components . – modifying the composition , i . e . , selecting different components and / or modifying the relation between components . Decomposition is a prerequisite for such modifications . 68 C HAPTER 3 D ESIGN C ONCEPTS FOR E XTENSIBILITY AND C OMPOSABILITY Good decompositions are those that isolate the required modifications to a few components or to just a single component . Separation of Concerns An appropriate decomposition clusters design decisions that are strongly related in a single subsystem , and separates design decisions that are relatively independent , in different subsystems . For example , suppose a system A is decomposed into a composition of A’ and A’’ . This decomposition allows designers to cluster design decisions as follows : Cluster 1 . decisions about distribution of functions of A over A’ and A’’ and the interaction between A’ and A’’ , i . e . , decisions about the functional model of A’ and A’’ ; Cluster 2 . decisions about the implementation of A’ ; Cluster 3 . decisions about the implementation of A’’ . This clustering separates design decisions concerning the system as a whole and design decisions concerning individual subsystems . Provided that decisions in cluster 1 are respected , design decisions in cluster 2 and 3 are relatively independent . That is , design decisions about the implementation of A’ can be based on a minimal functional model of A’’ , which captures only the way A’’ interacts with A’ . As long as this functional model does not change and the implementation of A” conforms to this model , the implementation of A’ is valid in the context of A . Thus , propagation of the effects of design decisions can be contained , allowing designers to focus on a single set of design decisions at a time . Decomposition can also be used to allow different designers to work on different subsystems , i . e . , design concerns can be separated across different people or teams . For example , design decisions in cluster 1 could be assigned to a systems architect , whereas design decisions in cluster 2 and 3 could be assigned to different design teams . Physical Distribution In the design process of physically distributed information systems consisting of computers that are interconnected by , e . g . , networks , subsystems ultimately can be implemented as computer programs on a computer system and interaction between subsystems can be implemented as signals that are transported over the cables of the networks that interconnect the computer systems . At some point in the design process of these physically distributed information systems , the decomposition must reflect this physical reality in the sense that each subsystem can be allocated to a single computer system . A M ODEL OF G ROUPWARE D ESIGN 69 It should be noted , however , that distributed computing platforms ( see section 2 . 2 . 3 ) may relieve the designer of the obligation to decide on such decompositions , leaving such decisions to the platform designers . Re - use While decomposing different systems into subsystems , one may encounter subsystems with an equivalent functional model . This allows for re - use of that subsystem in different contexts . More importantly , it allows for re - using the implementation of that subsystem , which may save time and money . Such re - use may also enhance the system’s reliability when re - using subsystem implementations that have been successfully tested to conform to their functional specification . If there are relatively many contexts in which a particular subsystem can be used , it is called ‘generic’ . If there are relatively few , it is called ‘specific’ . Sometimes , finding a decomposition in which existing systems can be used as an implementation of a subsystem is even an explicit constraint for design ; not re - using such a ‘legacy’ system would make the design too expensive . 3 . 2 . 3 Structuring Guidelines A design can in principle be decomposed correctly in infinitely many different ways . These decompositions are all implementations of the non - decomposed design of the system . Designers have to choose between the various decompositions . In a seminal paper on the criteria to be used for decomposing a system into modules , Parnas [ Parn72 ] showed that the modifiability of different decompositions varied drastically , even though the systems that finally result may not be different . This renders decomposition decisions highly relevant for extensibility and composability , since extensibility and composability are specific cases of modifiability . Moreover , making decomposition decisions that optimise modifiability is not only an important task for designers , but also one of the most challenging tasks for designers : – Optimising modifiability during design requires knowledge about likely modifications during design . – Optimising modifiability for extension and composition requires knowledge about likely modifications — e . g . , extensions and compositions— to the realised system after installation . Such knowledge requires experience : the knowledge can be acquired from an inductive process involving many designs . This book presents such knowledge in the form of structuring guidelines that help designers to choose those decompositions that lead to extensible 70 C HAPTER 3 D ESIGN C ONCEPTS FOR E XTENSIBILITY AND C OMPOSABILITY and composable groupware systems . In the following subsections , we describe how we obtained the structuring guidelines , how the structuring guidelines have been evaluated and how we made the structuring guidelines usable for designers . Obtaining Structuring Guidelines The structuring guidelines presented in this book are based on induction from existing groupware systems , their designs and the decompositions that are used or could have been used in the design of these systems . Orthogonality , a design principle that says “do not link what is independent” [ Sind95 ] is the single design principle that is most instrumental to guiding this inductive process . Rephrased in object oriented design terminology , this principle is known as maximising the ‘cohesion’ within subsystems and minimising the ‘coupling’ between subsystems [ SMC + 74 ; Bakk94 ] . When systems are decomposed according to orthogonality , most modifications in the system are confined to a single subsystem only . Hence , orthogonality improves modifiability . Moreover , orthogonality reduces the number of subsystems needed to build a range of systems . We illustrate this in Example 3 - 4 . As can be observed from the example , if a range of systems ( cf . Brandwagon Siena ) is to be designed with two orthogonal features ( cf . engine capacity and car colour ) and the system design is decomposed into two orthogonal classes of subsystems ( cf . engine and body ) , the number of subsystems needed to support all possible combinations in the range is in the order of , say , N ( cf . three engines and three bodies ) . To support all possible combinations without Example 3 - 4 Orthogonality in car production To suit the taste and needs of customers , a car manufacturer , say ‘Brandwagon’ , decides to produce a particular type of cars , say ‘Siena’ , in three colours ( white , red , blue ) and with three engines with varying capacity ( 1100cc , 1800cc , 2200cc ) . In total , nine variants of the Brandwagon Siena are possible : colour and motor capacity of the car are orthogonal features . Suppose , that the car manufacturer designs the Siena as a composition of two types of subsystems ( engine and body , which respectively determine the engine capacity and car colour ) , and that the car manufacturer makes sure that arbitrary combinations of body and engine are possible . In that case , the types of subsystems are orthogonal and only six subsystems ( white body , red body , blue body , 1100cc engine , 1800cc engine , 2200cc engine ) are needed to make the nine variants of the Brandwagon Siena . Suppose , now , that each body subsystem only fits to one engine , i . e . , arbitrary combinations of body and engine are impossible . In this case , to make the nine models , 9 car bodies are needed ( white for 1100cc , white for 1800cc , . . . blue for 2200cc ) and 9 engines are needed ( 1100cc for white , 1100cc for red , … 2200cc for blue ) . Now , the types of subsystems are not orthogonal and , in total , 18 subsystems are needed to make the nine variants of the Brandwagon Siena . A M ODEL OF G ROUPWARE D ESIGN 71 the orthogonal decomposition would require a number of subsystems in the order of N 2 ( cf . 3 2 engines and 3 2 bodies ) . Hence , orthogonality of subsystems is a desirable property for extensibility and composability , as it supports a large variety of systems , with a minimal number of component types . The orthogonality principle calls for a decomposition that isolates the variability that may be found across a large range of groupware systems ( cf . the Brandwagon Siena ) within the component classes ( cf . engine and body ) , i . e . , allow for variability by different instances of component classes ( cf . three types of engine and three types of body ) , and that isolates the stability across groupware systems in the interaction between component classes ( cf . the way an engine fits a body ) . Evaluating Structuring Guidelines How do we know that the structuring guidelines ( that are presented in chapter 5 and 6 ) will be effective ? A complete evaluation of the structuring guidelines would consist of repeating the following procedure for many cases : 1 . Ask two groups of designers to develop an extensible and composable groupware system . 2 . Make the structuring guidelines available for one group of designers , and not to another group , that will function as control group . 3 . Have groups of users work with the various systems produced . 4 . Evaluate the utility , usability and satisfaction of the various design processes by asking the various designers and evaluating the utility , usability and satisfaction of the various composable and extensible groupware systems by asking the various system users . Such a validation requires a massive and costly effort , beyond the scope of this research for this book . So , we chose a modest approach to test the structuring guidelines : 1 . check that structuring guidelines do not violate the more generic principle of orthogonality ; 2 . demonstrate the feasibility of making extensible and composable systems by applying the structuring guidelines in the design of a limited number of groupware systems ( as described in chapter 7 ) . Making Structuring Guidelines Usable To enhance their usability , the structuring guidelines presented in chapter 5 and 6 are elaborated into architectures that conform to the guidelines and have the desired characteristics . In addition , we will describe platform support that make it easy for developers to conform to the structuring guidelines and architectures . 72 C HAPTER 3 D ESIGN C ONCEPTS FOR E XTENSIBILITY AND C OMPOSABILITY An architecture is a high - level decomposition of a system . Users not only need systems that have a architecture that make them composable and extensible , but also components to compose and extend with . This requires a canonical architecture , i . e . , an architecture that is generally accepted in a particular domain [ KBA + 94 ] . Such an architecture is also known as a reference architecture . A reference architecture 26 is a generic architecture that can be used across a range of systems . By adding system - specific details , a reference architecture can be elaborated into a system design . A reference architecture can provide a basis for standardisation of interactions between subsystems across the interfaces it identifies . Within the constraints set by such standards , specific subsystems ( comprising one or more subsystems defined in the reference architecture ) can be developed that can work with the other subsystems that conform to the standards in the reference architecture . An example of such reference architectures in the groupware area is the WfMC reference model [ Holl94 ] , which identifies and standardises four interfaces ( see section 2 . 2 . 4 ) . The structuring guidelines and architectures presented in this book can be used as basis for a reference architecture for extensible and composable groupware systems . Platforms and Mechanisms for Implementation of Decomposed Designs At the foundation of platforms that make it easy to conform to architectures and structuring guidelines , we find mechanisms for implementing decomposed designs . Such mechanisms partly determine the ease of composition and extension . Over the years , various mechanisms emerged in software development environments , each known for the name of the subsystems it can compose : – Procedures . In a design process that uses a procedural programming environment , an information system is represented as a ( mainly sequential and hierarchical ) composition of procedures . – Modules . In a design process that uses a modular programming environment , an information system is represented as a composition of modules . Modules adhere to the principle of information hiding [ Parn72 ] : they contain sets of related procedures with the data they manipulate . Thus , modules encapsulate an abstract data type , by hiding 26 Also known as a ‘reference model’ . Definition 3 - 20 Architecture Definition 3 - 21 Reference architecture , reference model A M ODEL OF G ROUPWARE D ESIGN 73 the details of data access and storage within a module . Modules interact only through well - defined external interfaces . – Objects . In a design process that uses an object oriented programming environment , an information system is represented as a composition of objects . Objects are modules that allow , in addition , for inheritance . – Software Components . In a design process that uses a software component programming environment , an information system is represented as a composition of software components , which allow for ‘third party composition’ , i . e . composition of the components by developers other than the developers of the components , using mechanisms similar to scripts ( see section 3 . 1 . 4 ) . Whereas procedural , modular and object oriented programming only support extension with and composition of procedures that are implemented in the same programming language and require recompilation and / or re - linking , software component oriented programming environments allow for extension with and composition of components that may be programmed in a different programming language , using a different compiler or running on a different machine that is using a different operating system , all without re - linking and / or recompilation . These environments often use a programming , compiler , machine and operating system independent language for specification of the interaction between components . Lately , the interest in software components has lead to de - facto standards such as JavaBeans [ Hami97 ] and the establishment of industrial consortia such as the Object Management Group ( OMG 27 ) that define standards such as the Common Object Request Broker Architecture ( CORBA ; see also section 7 . 3 . 1 ) [ OrHE96 ] . The technical capabilities of component - based platforms and the ongoing standardisation efforts make component oriented software programming environments an ideal choice for implementing extensible and composable systems . 3 . 2 . 4 Abstraction Levels for Component Groupware Design For the design process of component groupware , we identify three major abstraction levels at which decomposed designs of groupware systems can be expressed . For each abstraction level , structuring guidelines and architectures are developed and presented ( in chapter 5 and 6 ) that guide decomposition decisions at that level . 27 http : / / www . omg . org / 74 C HAPTER 3 D ESIGN C ONCEPTS FOR E XTENSIBILITY AND C OMPOSABILITY Service Level : Grouplet Services A service architecture is a decomposed prescriptive functional model of a groupware system that exhibits only externally observable interactions with human users , while abstracting both from internal logical structure and from physical distribution . The service architecture subsystems are called grouplet services , which are the units of extension and composition for users . Grouplet services are units of design : different grouplet services ( e . g . , a shared whiteboard service , a videoconferencing service , and a collaborative editing service ) may be designed by different authorities . Logical Level : Grouplets A logical architecture is a decomposed prescriptive model of a groupware system that exhibits internal structure from a developer’s perspective , while abstracting from physical distribution . The logical architecture conforms to the service architecture and distinguishes the following subsystems : grouplets , which are the units of extension and composition , and the grouplet bus . Each grouplet implements a single grouplet service . Grouplets are units of design and implementation : different grouplets may be designed and implemented by different authorities . In terms of grouplets , extension denotes adding a grouplet to a groupware system , thus making it available for composition . Composition then denotes relating instances of grouplet realisations , thus composing the groupware service . The grouplet bus supports inter - grouplet interaction . Distributed Level : Grouplet Entities A distributed architecture is a decomposed prescriptive model of a groupware system that , in addition to the logical decomposition according to the logical architecture , exhibits physical decomposition . The distributed architecture distinguishes the following subsystems : grouplet entities , which are the subsystems that result from physical decomposition of a grouplet , and the grouplet bus , which supports interaction between grouplet entities ( i . e . , in addition to interaction between grouplets ) . Figure 3 - 6 A service architecture : a composition of grouplet services ( dark squares ) ; which interact at interfaces ( white circles ) with users Figure 3 - 7 A logical architecture : grouplets ( top ) and grouplet bus ( bottom ) Figure 3 - 8 A distributed architecture : grouplet entities ( top ) and grouplet bus ( bottom ) S UMMARY 75 3 . 3 Summary In this chapter , we described and defined various basic concepts , including – extensibility and composability , as desirable properties of groupware systems , – decomposition and modifiability , as crucial factors for the achievement of these properties , and – structuring guidelines , architectures and platforms , as the means we use to achieve the properties . Moreover , we defined three abstraction levels in the design trajectory of groupware systems , viz . – service level , which focuses on external behaviour of a groupware system , – logical level , which focuses on internal decomposition , but abstracts from physical distribution , and – distributed level , which exhibits both logical and physical decomposition . For each of these levels , structuring guidelines , architectures and platforms are proposed in subsequent chapters . Chapter 4 4 . A Generic Model of Groupware Before we can present any structuring guidelines , we should first establish the subject to which such structuring guidelines are applied . In our case , the subject consists of a wide range of groupware services , like those of the systems described in section 2 . 1 . 1 . We take a two - step approach towards specifying a generic model of groupware services , as illustrated in Figure 4 - 1 . – In section 4 . 1 , we describe a generic model of cooperative work . – In section 4 . 2 , we describe a generic model of groupware services , that describes the role of a groupware system in cooperative work . This model serves as a basis for the service architecture for component groupware in chapter 5 , which is the top - level architecture we identified in chapter 3 . section 2 . 1 . 1 section 4 . 1 section 4 . 2 generalise groupware2 CSCWn CSCW2 application CSCW1 CSCW model groupware service model groupware n generalise groupware1 CSCW model groupware service model focus In order to achieve both an understandable and a precise basis for structuring guidelines , we describe the cooperative work model and the groupware service model using both natural language and a more formal notation based on sets and logic . Figure 4 - 1 Structure of chapter 4 78 C HAPTER 4 A GENERIC MODEL OF GROUPWARE Our modelling approach is inspired by Rüdebusch’ model of cooperative work [ Rude93 , p . 39 - 75 ] , Dourish’ model for divergence , synchronisation and consistency [ Dour95 ; Dour96a ; Dour96b ] and Dewan’s notion of flexible coupling [ Dewa96 ] . With respect to these models , our contributions focus on two areas : in the generic groupware service model that is described in section 4 . 2 , we add the notion of consistency levels , and in the generic groupware service architecture in section 5 . 2 , we add the structuring guidelines that guide the decomposition of the generic groupware service model into a service reference architecture . 4 . 1 A Model of Cooperative Work There are many ways to model cooperative work . For example , in section 4 . 1 . 1 , we describe an informal model of cooperative work that is still relatively close to everyday practice . It serves as a context in which we can reason about our formal model of cooperative work . For our formal model of cooperative work ( section 4 . 1 . 4 and 4 . 1 . 5 ) , we selected our modelling approach ( section 4 . 1 . 3 ) on the basis of modelling requirements ( section 4 . 1 . 2 ) which we derived from the context in which the model serves its goal — the design of a groupware service reference architecture . 4 . 1 . 1 An Informal Description of Cooperative Work Cooperative work takes place in a cooperative context , which is characterised by a lifetime , human participants and a goal . The lifetime typically varies between several minutes and several months . During the lifetime , the number of participants may vary . Each participant may be involved in various cooperative contexts , possibly simultaneously . artifact participant participant ( b ) ( b’ ) ( a ) ( b ) Figure 4 - 2 Conceptual model of a collaborative context with two participants , without coordination ( adapted from [ MMD + 93 ] ) A M ODEL OF C OOPERATIVE W ORK 79 Within a cooperative context ( denoted as the outer ellipse in Figure 4 - 2 ) , participants work towards a goal , e . g . , writing an article , sharing information or negotiating a compromise . Cooperative work involves several activities that are incurred by the fact that not one , but several humans are engaged in the work . To perform these activities , participants use two fundamental human skills [ Beau94b ] : direct communication with other participants ( denoted as ( a ) in Figure 4 - 2 ) and manipulation of shared artefacts ( denoted as ( b ) in Figure 4 - 2 ) . Manipulation of a shared artefact can be observed by other participants , thus constituting a form of indirect communication between participants ( denoted as ( b’ ) in Figure 4 - 2 ) . These skills are often used in combination . For example , when communicating directly , participants often use references to shared artefacts as an easy way to establish referential identity , i . e . , the mutual belief that the participants have correctly identified a referent [ ClBr91 ] . Similarly , when working with shared artefacts , participants often also communicate directly with each other . Often , actors must coordinate their actions so as to ensure all work is done , no redundant work is done ( e . g . , avoid conflicting actions ) and work is done in a timely manner . Some researchers argue [ ScBa92 ] that these activities , or “articulation work” as they call it , are at the heart of cooperative work . Figure 4 - 2 represents an elementary collaborative context with two actors . Although this figure illustrates most issues , we need to be aware of the limitations of the figure : it does not represent coordination and issues that occur with three or more participants involved , such as issues related to the existence of sub - groups . 4 . 1 . 2 Modelling Requirements In order to serve as a good basis for a generic groupware service model and groupware service reference architecture for extensible and composable groupware , the Cooperative Work ( CW ) model must be : 1 . Relevant for groupware design . The CW model comprises both human activity and activities of the groupware system . The CW model describes the common activity of humans and the groupware system in this context ; the CW model should not describe whether an activity is ( to be ) performed by humans or by the groupware system . This does not imply , however , that all aspects of a cooperative work context should be included ; only those that are relevant for groupware design should be included . It is of less use describing aspects of cooperative work which are less or only indirectly relevant for the design of a groupware service . For example , the colour of the eyes of the user should not be part of the CW model . 80 C HAPTER 4 A GENERIC MODEL OF GROUPWARE 2 . Generic . Considering the role of the CW model , i . e . , forming the basis for a generic groupware service model and architecture , the CW model should be a common abstraction of as much cooperative work contexts as possible , e . g . , of the cooperative work contexts supported by all groupware systems described in chapter 2 . It should be possible to express the groupware services of all of these systems as a specialisation of the groupware service reference architecture that is derived from the generic groupware service model that conforms to the CW model . From our discussion about flexibility in section 2 . 3 , we observed that modelling cooperative work at a fine level of detail does not always lead to better support of cooperative work . Some details of cooperative work — e . g . , what patterns emerge in passing the floor in a discussion between students and a teacher when a student assignment is reviewed — may not be informative for groupware design ( using these details as a basis for groupware design might lead to automating a fiction ) , or may only be required for some forms of groupware support . Such specific details should not be included in the generic CW model . 3 . Comprehensive . The CW model should be able to describe cooperative work situations in which many types of groupware services are used in combination . This requirement is a specialisation of the previous requirement for generality : not only specialisation of the groupware service reference architecture to many groupware services in isolation must be possible , but also specialisation to a combination of the different groupware services . For example , a specialisation of the groupware service reference architecture may include support for a combination of groupware services for collaborative document editing , for videoconferencing and for chatting . 4 . In line with dynamic and opportunistic user behaviour . The set of cooperative working contexts we aim to model includes cooperative contexts in which people join and leave cooperative activities at will , switch from co - located to distributed cooperation , from cooperative work to individual work , from rather synchronous and focused cooperation to rather asynchronous and loose cooperation and from formalised , predetermined work patterns — working “by the book” — to opportunistic work patterns . In addition , the moments of such transitions are hard to predict . The CW model should not be prohibitive for such dynamic environments . 4 . 1 . 3 Modelling Approach The main challenge emerging from the requirements in section 4 . 1 . 2 is to strike a balance between the conflicting demands of being generic and being relevant for the design of groupware services . A M ODEL OF C OOPERATIVE W ORK 81 Our approach to achieve this is based on the following principles : – use collaborative interaction as the central modelling concept ; – model individual work as a special case of collaborative work ; – use a uniform approach for modelling synchronous and asynchronous cooperation ; – model coordination orthogonal to interaction . These principles are explained in more detail in the following subsections . For a detailed definitions of various concepts that will be used in these subsections , we refer to section 4 . 2 . Collaborative Interaction as Core Concept Modelling cooperative work as a ( partially ordered ) set of collaborative interactions is the central premise of our modelling approach . Defined informally , a collaborative interaction consists of both an action initiated by someone on a medium that is in a particular state , and the observation of the medium state change that is caused by that action , by both the initiator and some others . In our model of cooperative work , collaborative interactions will be the sole means for mutual influence between persons in a cooperative work context ( see also section 4 . 1 . 4 ) . Compared to the informal description of cooperative work in section 4 . 1 . 1 , we use fewer , more generic concepts to describe the same set of groupware services ; indirect communication and direct communication are considered to be specific forms of mediated communication . In indirect communication , the shared artefact is the medium that mediates collaborative interactions . In direct communication , e . g . , the air that carries the sound of speech or the “ether” that carries radio signals can be thought of as media . The role of a groupware system in cooperative work , is to provide mediated communication to support both indirect communication and direct communication . Model Individual Work as Special Case of Collaborative Work If a collaborative interaction only has an initiator and no other people that can observe the collaborative interaction , it degenerates to a single - user action . This allows us to model individual work as a special case of collaborative work . Hence , groupware systems may support ( periods of ) individual work by degenerating the collaborative interactions to single - user interactions . Vice versa , many single - user applications , such as word processors , can be modelled as systems that allow users to perform single - user actions , where results of actions are observable for the initiator only . Transforming actions into collaborative interactions will allow single - user applications to provide support for cooperative work . Generic ( i . e . , application - 82 C HAPTER 4 A GENERIC MODEL OF GROUPWARE independent ) facilities similar to application sharing systems ( see section 2 . 1 . 1 ) support such transformations . In combination with such a facility , existing single - user applications can be used , without modification , as an extension of a groupware system . A groupware system could start with a basis of existing single - user applications , or could be easily extended with new single - user applications . Considering that users are used to existing single - user applications and development of single - user applications will not suddenly stop once a groupware reference architecture is adopted , such a facility is highly desirable . Uniform Approach for Modelling Synchronous and Asynchronous Cooperation With a collaborative interaction we will associate a timing property which describes how long it takes between initiation of a collaborative interaction by an initiator and the moment ( s ) when the people involved can observe the collaborative interaction , which may be different for each person involved . Switching from rather synchronous cooperation to rather asynchronous cooperation and vice versa can be modelled with collaborative interactions in two ways : – by using other values for the timing property of collaborative interactions , or – by increasing or decreasing the number of collaborative interactions ; this can be used to represent changes such as a switch : – from a situation in which people only observe entire sentences that are written on a whiteboard to a situation in which people can observe each letter that is written on the whiteboard ( a change in interaction aggregation granularity ) – from a situation in which people can only observe changes on a whiteboard ( be they sentences or letters ) , to a situation in which people in addition are aware of the way people write on the whiteboard , which marker is used , who holds which marker , who is looking at which part of the whiteboard , etc . ( a change in interaction level ) . Model Coordination Orthogonal to Interaction Coordination can be modelled relative to collaborative interactions as rights and / or obligations to initiate a particular collaborative interaction by a particular person at a particular moment . By separating coordination from collaborative interaction , it will be easier to change the coordination model , if required . Moreover , it allows for a design of a permissive groupware system that can be extended with coordination functions . A M ODEL OF C OOPERATIVE W ORK 83 How Our Approach Helps to Meet the Requirements Our approach helps to meet the modelling requirements as follows : – Requirement 1 : relevant for groupware design . Collaborative interactions are used to model cooperative work in the CW model . The primary role of groupware systems is to support cooperative work , i . e . , groupware systems support some of the collaborative interactions specified in a particular instance of the CW model . With each collaborative interaction , we will associate properties such as the people who are involved in the collaborative interaction and which medium is involved in the collaborative interaction . – Requirement 2 : generality . With collaborative interactions , we can describe both direct communication and indirect communication . Moreover , collaborative interactions may refer to any type of medium . In these respects , the CW model is as generic as the informal description in section 4 . 1 . 1 . – Requirement 3 : comprehensiveness . Different collaborative interactions may refer to different media . This allows us to model comprehensive cooperative work settings in which many media are involved . – Requirement 4 : dynamic and opportunistic user behaviour . – Different collaborative interactions may refer to different sets of persons . This allows us to describe the fact that people join or leave a cooperative work context as one person extra or fewer in the list of people involved in the collaborative interaction compared to a previous collaborative interaction . The notion of cooperative work context from the informal description will not be explicitly modelled in the CW model ; it is implicitly modelled as similarities in the subsequent lists of people of collaborative interactions . – A collaborative interaction abstracts from the physical location of the people involved . Instead , in our model , collaborative interactions that are supported by groupware , occur at logical locations called interfaces . For each user , there is a single interface at which collaborative interactions occur ; such an interface is also known as a user interface . Hence , a single collaborative interaction that involves multiple users occurs at multiple user interfaces . It is assumed that a user interface , i . e . , a logical location , is located at the physical location as desired by the corresponding user . Hence , switching between co - located cooperation and distributed cooperation will not be visible in our CW model directly . Only certain consequences of a switch from co - located to distributed or vice versa are visible in our model , e . g . , changes in the set of media that are used or the tightness or looseness of collaboration . – Single - user interactions are modelled as a special form of collaborative interactions . This is the basis for the design of multi - 84 C HAPTER 4 A GENERIC MODEL OF GROUPWARE user applications that can also be used to support individual work , and for the design of facilities that allow single - user applications to support cooperative work . Switching between individual work and cooperative work and vice versa can be modelled by adding or removing observers in subsequent collaborative interactions . – Using the timing property of collaborative interactions and the possibility to vary the level and / or granularity of collaborative interactions , we can model various forms of cooperative work , ranging from synchronous to asynchronous . – Transitions between coordinated cooperative work and less coordinated cooperative work can be modelled as enlarging or reducing the number of rights and obligations . 4 . 1 . 4 Collaborative Interaction A collaborative interaction is a particular kind of interaction ( cf . Definition 3 - 16 ) , viz . a unit of reciprocal influence between a groupware system and its environment , i . e . , a group of users . For a more precise definition of collaborative interaction , we first need to define the concepts interaction group , initiator , observer group , medium , state , and action . The interaction group ( P ) 28 of a collaborative interaction  a set of persons that is involved in a collaborative interaction . A person is involved in a collaborative interaction if he / she initiated the collaborative interaction and / or can observe the ( results of the ) collaborative interaction . Let p (cid:2) P , then The initiator ( p ) of a collaborative interaction  the person that initiates the collaborative interaction . Let p (cid:2) P be the initiator of a collaborative interaction , then the observer group ( O ) of a collaborative interaction  P \ p , i . e . , the persons from the interaction group that do not initiate the collaborative interaction . A medium ( m )  a tuple ( S , A ) , where S is the medium state space , i . e . , the set of all possible medium states that m can be in ( see Definition 4 - 5 ) , and A is the set of all medium actions on m ( see Definition 4 - 6 ) 28 Throughout this chapter , boldface text indicates the concept that is defined in a definition . Boldface text in parentheses indicates the abbreviation that is defined . Definition 4 - 1 Interaction group : ( P ) Definition 4 - 2 Initiator ( p ) Definition 4 - 3 Observer group ( O ) Definition 4 - 4 Medium ( m ) A M ODEL OF C OOPERATIVE W ORK 85 For notational convenience , the constituents of a particular medium m are also denoted as S m and A m . The set of all possible media is also denoted as M . A medium may be a shared artefact , such as a shared whiteboard , a document , etc . It may also be a communication channel , such as the air , a telephone connection , etc . Sharing of a medium is to be interpreted in a loose sense ; sharing does not imply the medium is available to all members of P at the same time . In extreme cases , sharing may even mean that only one user at a time can use it at certain moments . For example , when passing a letter from sender to receiver , the letter that carries the message is the medium that is considered to be ‘shared’ between sender and receiver of the letter . Let m (cid:2) M , then the state ( s ) of a medium m describes the condition the medium is in at a particular moment in time . For notational convenience , the state of a medium m is also denoted as s m . As an example , suppose the state space of a simple medium m , S m , consists of the set of integers , § . Then , s m , the state of m at a particular moment in time , is described by an integer . As its name implies , the function of a medium is to mediate ( “carry” ) collaborative interactions . Actions are the basis of collaborative interactions : actions , such as inserting a word in a text , sending E - mail to someone , uttering a word in a conversation or making a gesture , cause state transitions in media , that may be observed by other participants . Multiple consecutive actions give rise to sequences of medium states , i . e . , medium state traces of the form [ s ( 0 ) , s ( 1 ) , … , s ( n ) ] , where n (cid:2) | , ? t (cid:2) [ 0 , … , n ] : s ( t ) (cid:2) S . Let m (cid:2) M , a (cid:2) A m , x , y (cid:2) S m , t (cid:2) | , then an action  a binary relation a (cid:3) S m ⌠ S m , where ( x , y ) (cid:2) a means : when a occurs at ( logical ) moment t and s ( t ) = x , then s ( t + 1 ) = y . For notational convenience , ( x , y ) (cid:2) a is also denoted as a ( x ) = y . Returning to our previous example , suppose m is a medium for which S m = § . An action a (cid:2) A m that adds one to the state can be specified as a = { … , ( - 2 , - 1 ) , ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 2 ) , ( 2 , 3 ) , … } . Clearly , a (cid:4) § ⌠ § . The fact that ( 2 , 3 ) (cid:2) a ( which may also be written as a ( 2 ) = 3 ) , specifies that when a occurs at moment t and s m ( t ) = 2 , then s m ( t + 1 ) = 3 . Definition 4 - 5 State ( s ) Definition 4 - 6 Action ( a ) 86 C HAPTER 4 A GENERIC MODEL OF GROUPWARE Not all actions have to be possible in all medium states . There may be some x (cid:2) S m for which some actions a (cid:2) A m are undefined 29 ( e . g . , because the action is meaningless or not allowed when the medium is in a particular state ; see also Definition 4 - 29 ) . Such restrictions can be used to prescribe restrictions to the set of state traces that the medium can support . In the CW model , media are modelled as discrete event systems , hence medium state traces have the form [ s ( 0 ) , s ( 1 ) , … , s ( n ) ] . Even continuous media such as audio are modelled in this way . This may seem strange at first sight , but considering our modelling context , in which we will focus on collaborative interactions that are supported by groupware systems , which handle continuous media in a discrete way , this modelling approach is not unrealistic . Moreover , the advantage of this approach is the uniformity in modelling of continuous media ( such as audio ) and discrete media ( such as a shared document ) . In a collaborative interaction , actions may be observed by different persons involved in the collaborative interaction . Let px (cid:2) P , then the timing ( αααα T ) of a collaborative interaction  { α t ( px ) | px (cid:2) P } , where α t ( px ) denotes the amount of real time that elapses between the initiation of the action of the collaborative interaction and the observation 30 of the results of that action by person px The response time of a collaborative interaction  α t ( px ) , for px = p . A notification time of a collaborative interaction  α t ( px ) , for px (cid:2) O . Note that every person involved in the collaborative interaction may observe its results at a different time . Usually , the response time is smaller than the smallest of the notification times . Now , we can define collaborative interactions . Let m (cid:2) M , s (cid:2) S m , a (cid:2) A m , then A collaborative interaction ( i )  ( p , a , m , s , α T , O ) . For notational convenience , the constituents of a particular collaborative 29 However , typically ? x (cid:2) S m Α a (cid:2) A m , y (cid:2) S m : ( x , y ) (cid:2) a . 30 When used descriptively , the timing denotes the exact time that elapses between initiation and actual observation . When used prescriptively , the timing denotes the maximal time that may elapse between initiation and moment the results become observable . Definition 4 - 7 Timing ( α T ) Definition 4 - 8 Response time Definition 4 - 9 Notification time Definition 4 - 10 Collaborative interaction ( i ) A M ODEL OF C OOPERATIVE W ORK 87 interaction i are also denoted as p i , a i , m i , s i , α T i , and O i . The interaction group of a particular collaborative interaction i is also denoted as P i . A collaborative interaction i involves an initiator ( p i ) , who initiates an action ( a i ) on a medium ( m i ) , which is in a particular state ( s i ) . After certain amounts of time ( α T i ) the members of the interaction group of the collaborative interaction ( O i ) can each observe the result of the action . A graphical representation of a collaborative interaction can be found in Figure 4 - 3 . In the rest of this book , we will sometimes use the term ‘interaction’ as a shorthand for ‘collaborative interaction’ . O i p i a i m i α t ( p i ) α t ( O i ) s i  a i ( s i ) 4 . 1 . 5 Cooperative Work With the definition of collaborative interaction in mind , we can now give a formal definition of a cooperative work context and cooperative work . A cooperative work context ( cw )  a partially ordered set of collaborative interactions that is used to produce a certain product or service . We deliberately restrict our model of a cooperative work context to a partially ordered set of collaborative interactions , since collaborative interactions constitute the aspect of real - life cooperative work that is directly relevant to the design of groupware systems . Cooperative work ( CW )  the set of all possible cooperative work contexts . Note , that we deliberately leave open the scale of cooperative work , which may range from small scale , short lived cooperative work contexts such as a three students working on a collaborative assignment to large - scale , long - Figure 4 - 3 A collaborative interaction Definition 4 - 11 Cooperative work context ( cw ) Definition 4 - 12 Cooperative work ( CW ) 88 C HAPTER 4 A GENERIC MODEL OF GROUPWARE lived cooperative work contexts such as designing and building a ship or a new PC operating system . When O i = (cid:1) , a interaction i degenerates to single - person interaction . This can be used to model periods of individual work : individual work is a set of collaborative interactions by a single person that others do not observe . Only when all interactions in a particular cooperative working context cw (cid:2) CW are single - person interactions , a cooperative work context degenerates into an individual work context . Periods of individual work may be part of a cooperative working context , either as a set of single - person interactions , or as a multi - user interaction that aggregates a set of single - person interactions ( i . e . , an interaction that represents the net results of the composition of all the actions in the period of individual work ) . Different interactions in a cooperative work context may use various media , which allows for modelling different media alongside each other in a cooperative work context ; it also allows modelling changes in the set of media that are used during cooperative work . Different interactions in a cooperative work context may involve different interaction groups , which allows modelling changes in the set of people involved in collaborative work ( e . g . , people joining and leaving the collaborative context ) and different involvement by different sets of people in different parts of the collaborative work . 4 . 2 A Generic Groupware Service Model A groupware service model describes the role of a groupware system in a cooperative work context . In the previous section , we defined a cooperative work context as a partially ordered set of interactions . The essence of groupware systems is to mediate some of these interactions . This may facilitate distributing collaborative interactions over time and space . This , in turn will facilitate distributing cooperative work over time and space when required . Some media in a cooperative work context will be supported by a groupware system . Hence , a groupware service can be described as a partially ordered set of collaborative interactions that are supported by the groupware system . Groupware media may be designed to compensate for the absence of some media in distributed settings . For example , a video conferencing medium may compensate for the absence of face to face conversations . Other media , such as an electronic voting tool , may augment a cooperative work context . Yet other groupware media may provide sharing of artefacts . In addition to conventional computer services for supporting artefacts ( e . g . , storing , retrieving , editing , and searching artefacts A G ENERIC G ROUPWARE S ERVICE M ODEL 89 such as documents ) , such groupware media can provide the additional possibility to work cooperatively with these artefacts . Not all media from a cooperative work setting have to be mediated through the groupware system . For example , in a group decision room system , where people can still hear and see each other , audio will typically not be mediated through groupware . A specification of a groupware service focuses on the responsibility of the groupware system as a service provider that supports collaborative interactions . It should comprise only those interactions and only those aspects of interactions in which a groupware system is involved . What it should not describe , for example , is the behaviour of groupware users in the interactions . Hence , social protocols will not be part of the specification of a groupware service . A cooperative work context may involve many interactions . In order to deal with this multitude of interactions , people organise their interactions in smaller contexts such as tasks , sub - tasks , media , groups of people , meeting rooms , etc . Such organising structures emerge almost naturally in cooperative work — similar to the way people arrange papers on their desks , applications on their screen , etc . — and allow people to focus on a particular set of logically related interactions without being disturbed too much by other interactions and allow easy switching of attention between such contexts . Hence , in addition to mediating interactions , groupware systems should support such emergent structures , by providing basic structures on which users can easily map the emergent organising structures for their interactions . 4 . 2 . 1 Feedback , Feedthrough , and Coupled Actions Some important concepts for reasoning about and specification of groupware support for interactions are feedback , feedthrough , and coupled actions . The feedback of an interaction i  what p i can observe of the transition from s i to a i ( s i ) . Some examples of feedback are : moving a mouse cursor on a screen in response to moving a mouse device , the appearance of a letter on the screen after pressing a key , the removal of a word after pressing the delete key , the removal of a file icon after clicking the mouse button over a highlighted “delete” option in a menu , or the portrayal of a video frame that was captured by a local camera on top of a user’s workstation . Definition 4 - 13 Feedback 90 C HAPTER 4 A GENERIC MODEL OF GROUPWARE The feedthrough of an interaction i  what px (cid:2) O i can observe of the transition from s i to a ( s i ) . The feedthrough of an interaction may be the same as the feedback of that interaction . It may also be different . Some examples of the latter are : indicating feedthrough in another colour than feedback , showing a grey background for the text that has been altered by another user , without changing the text itself , or showing video with reduced quality compared to the feedback video . Making people aware of each other’s interactions by providing feedthrough is an important function of groupware systems . In order to reason about the nature and scope of this feedthrough , we define the notion of coupled actions . First , we have to define the concept of members as the set of all people involved in interactions in a particular cooperative work context . Let cw (cid:2) CW , then the members ( P cw ) of a cooperative working context  (cid:6) i (cid:1) cw { px | px (cid:2) P i } . Now , to define the extent to which one user is aware of actions of another user in a medium , we define the set of coupled actions , i . e . , those actions of the latter user on a medium for which the former user can observe the resulting feedthrough . Let cw (cid:2) CW , p1 , p2 (cid:2) P cw , p1  p2 , then the set of coupled actions , Coupled ( p1 , p2 , m )  { a i | i (cid:2) cw , p1 = p i , p2 (cid:2) O i } Note that this is a unidirectional notion between two users , i . e . , coupling from p1 to p2 may differ from coupling from p2 to p1 and may be different for different sets of users . 4 . 2 . 2 Controlling Coupling , Presence and Awareness The nature , extent and timing of the coupling of actions is a critical factor for the utility and usability of groupware . Too much coupling of actions or coupling of actions between the wrong people will cause unnecessary distraction and / or information overload , while too little coupling of actions may cause misunderstandings . Moreover , the optimal nature , extent and timing of coupling is very contingent on factors such as the task , the persons involved , the time pressure , etc . Hence , groupware systems should not only mediate interactions , i . e . , have the ability to couple actions , but Definition 4 - 14 Feedthrough Definition 4 - 15 Members Definition 4 - 16 Coupled actions A G ENERIC G ROUPWARE S ERVICE M ODEL 91 they should also give users some control over the nature , extent and timing of the coupling of actions [ DeCS94 ] . Both initiators and observers may want control over the coupling of actions . On the one hand , as an initiator , a user may want to control presence , i . e . , which of the actions he initiates can be observed by certain others . On the other hand , as an observer , a user may want to control awareness , i . e . , which of the actions initiated by another user can be observed by him . In line with the sharing principle of Dewan , Choudhary and Shen [ DeCS94 ] , which states that “ Local editing changes sent to remote users should contain the intersection of the information the local and remote users want to tell and know , respectively ” , in Definition 4 - 21 , we will define that actions that are coupled only include those actions that satisfy both presence criteria and awareness criteria . In order to give users control over presence , awareness and coupling , users must be able to specify in advance — e . g . , before a series of actions occur — which actions satisfy presence , awareness and coupling criteria . In general , such in advance criteria can be based on a classification of interactions , e . g . , classifications based on the interaction group , the medium , or the action . In our model , we will specify presence and awareness per medium , per pair of users , using actions types as a classification of actions . An action type ( A x ) is a subset of all possible actions . Determinable action types ( DA ) is the set of all action types for which a groupware system can easily determine whether a particular action is an element of one of the action types , without requiring much user guidance . Some examples of determinable action types are : mouse actions , keyboard actions , actions that change the view on a medium , actions that change a document , actions that change colour , actions that change the layout of a document , etc . These action types can be used as a basis for controlling which actions are coupled , and which are not . Some examples of subsets of actions that are not easily determinable , are subclasses such as ‘the set of offensive expressions’ and ‘friendly gestures’ ; most groupware systems that use contemporary technology would require user guidance to determine whether a particular action belongs to such a class . Hence , such a subclass would not be suitable as a basis for coupling control . One part of coupling control is a presence control facility that lets users determine the presence of their actions on a medium for other users . We Definition 4 - 17 Action type ( A x ) Definition 4 - 18 Determinable action types ( DA ) 92 C HAPTER 4 A GENERIC MODEL OF GROUPWARE model such a facility as a set of presence filters , so that the presence can be controlled for each observer independently , if needed . Let p1 , p2 (cid:2) P cw , p1  p2 , A presence (cid:2) DA then a presence filter , PresFlt ( p1 , p2 , m )  A presence specifies the set of all possible actions on medium m for interactions initiated by user p1 that user p1 would like to make observable for user p2 . Another part of coupling control is an awareness control facility that lets users determine the awareness of actions of others in a medium . We model such a facility as a set of awareness filters , so that the awareness can be controlled for each initiator independently , if needed . Let p1 , p2 (cid:2) P cw , p1  p2 , A aware (cid:2) DA then an awareness filter , AwareFlt ( p1 , p2 , m )  A aware specifies the set of all possible actions on medium m for interactions initiated by user p1 that user p2 would like to observe from user p1 . A coupling control filter is a combination of presence and awareness filter ; it allows only those actions that pass both the presence filter and awareness filter . Let p1 , p2 (cid:2) P cw , p1  p2 , then a coupling control filter , CouplingFlt ( p1 , p2 , m )  PresFlt ( p1 , p2 , m ) (cid:7) AwareFlt ( p1 , p2 , m ) A user p2 is fully aware of the presence of another user p1 , if the awareness filter from p1 to p2 passes all the actions that pass the presence filter of p1 to p2 . A user p2 (cid:2) P cw is fully aware of the presence of another user p1 (cid:2) P cw in medium m , if PresFlt ( p1 , p2 , m , ) (cid:3) AwareFlt ( p1 , p2 , m ) We say two users are symmetrically coupled , if the set of actions in the coupling filter from p1 to p2 is the same as the set of actions in the coupling filter of p2 to p1 . Two users p1 , p2 (cid:2) P cw are symmetrically coupled in medium m , if CouplingFlt ( p1 , p2 , m ) = CouplingFlt ( p2 , p1 , m ) The coupling filters determine a part of a groupware system’s behaviour , viz . which of the actions that actually occur in a cooperative work context Definition 4 - 19 Presence filter ( PresFlt ) Definition 4 - 20 Awareness filter ( AwareFlt ) Definition 4 - 21 Coupling control filter ( CouplingFlt ) Definition 4 - 22 Full awareness of presence Definition 4 - 23 Symmetrically coupled A G ENERIC G ROUPWARE S ERVICE M ODEL 93 are coupled . It is the responsibility of the groupware system to make sure that the set of actions that are coupled from user p1 to user p2 are those that are initiated by p1 , that can be observed by p2 and that satisfy coupling filter settings , i . e . : Coupled ( p1 , p2 , m ) = { a i | i (cid:2) cw , p1 = p i (cid:7) p2 (cid:2) O i (cid:7) ? px (cid:2) O i : a i (cid:2) CouplingFlt ( p1 , px , m ) } . Groupware systems can deal with coupling control through presence and awareness filters in a variety of ways . We distinguish : – Built - in coupling . Presence , awareness and coupling filters are built - in in the groupware system ; users can not modify the coupling in any way . Modifying the coupling requires selecting a different groupware system . Most contemporary groupware systems have built - in coupling . – Static coupling . Presence , awareness and coupling filters can be selected before each use of the groupware system ( e . g . , with configuration files or options ) , but cannot be changed during use . – Dynamic coupling . During a cooperative work session , the coupling filters may be modified by users 31 — directly , or indirectly via presence and awareness filters ( cf . Definition 4 - 21 ) . This allows users to switch between tight and loose coupling when needed . In our groupware service model , we will assume dynamic coupling , which allows us to express static and built - in coupling as specific forms of dynamic coupling . 4 . 2 . 3 Controlling Coupling : Coupling Levels In this section , we describe how abstraction levels can provide a useful way to organise the set of actions into a set of determinable action types . Using such a level - based partitioning of actions into action types , users can express the level of coupling , e . g . , whether users want to be tightly coupled , or loosely coupled . When a user interacts 32 with a computer system , one physical human - computer interaction , such as clicking a mouse button , may be interpreted as a set of actions , at a variety of user interface abstraction levels . At a low level of abstraction from the user interface , this action may be interpreted as an action on the pressed state of a menu option . On a higher level of 31 Applying our modelling approach recursively , filters can be modelled as separate media , and filter settings as state of such media . In principle , collaborative editing of filter settings is possible . This process may use coupling filters , etc . 32 This is a human - computer interaction , not a collaborative interaction . Human - computer interactions form the basis for actions , which in turn form the basis of groupware - supported collaborative interactions . 94 C HAPTER 4 A GENERIC MODEL OF GROUPWARE abstraction from the user interface , this action may be interpreted as an action on a document , e . g . , a command to delete the current selection from the document and copy it into a clipboard , when the menu option read “cut” . Often , a series of low - level interactions ( e . g . , dragging a rectangle in a object - based drawing application ) is used to complete a high - level action ( enlarge rectangle ) . user interface user interface human human computer ( s ) In some situations , as illustrated in Figure 4 - 4 , users may want to couple only high - level actions ( e . g . , only couple actions that change the state of a document , but do not couple lower level actions such as scrolling , which only change the way a document is viewed ) , whereas in other situations , users may want to couple high - level actions and various lower level interactions ( e . g . , to explain user interface features to someone , or to point something out using a telepointer ) . By partitioning the set of actions that may be coupled into a set of levels , and by allowing users to set their presence and awareness filters using these levels , the level of interaction can be specified dynamically by the users . Figure 4 - 4 Action levels in human - computer - human interaction A G ENERIC G ROUPWARE S ERVICE M ODEL 95 The action type list [ A 1 , A 2 , … , A n ] is an ordered list of action levels , if A 1 , A 2 , … , A n (cid:2) DA , { A 1 , A 2 , … , A n } is a partitioning of A m and A 1  A 2 , … ,  A n , where A x  A x + 1 , x (cid:2) [ 1 , … , n - 1 ] means : ( ? ax (cid:2) A x , ? ax’ (cid:2) A x + 1 : ax  ax’ ) , where ax  ax’ means ax is of the same or of a lower abstraction level than ax’ . Using these levels , all users px (cid:2) P cw can set the filters PresFlt ( px , py , m ) for their desired level of presence each of the other users py (cid:2) P cw \ px , and all users py (cid:2) P cw \ px can set the filters AwareFlt ( px , py , m ) for their desired level of awareness of each of the other users px (cid:2) P cw \ py . This effectively allows all coupling filters CouplingFlt ( px , py , m ) to be defined . The nature of coupling that results is indicated as the coupling level , i . e . , the lowest level of actions that is coupled , as defined in Definition 4 - 25 . Let A 1 , A 2 , … , A n be an ordered set of action levels that is used to specify the coupling filter , then the coupling level , CouplingLev ( p1 , p2 , m )  min ( { A x | A x (cid:3) CouplingFlt ( p1 , p2 , m ) , x (cid:2) [ 1…n ] } ) Whereas many service specifications of distributed systems abstract from actions that are at user - interface level ( such as moving a mouse , typing a key , etc . ) , the specification of a groupware system service may very well include such user interface actions , since coupling of such actions and control over coupling of such actions may be a crucial part of a groupware system’s functionality . There is even an entire category of groupware systems , viz . application sharing ( see section entitled Application Sharing Systems , in section 2 . 1 . 2 ) , that is entirely based on built - in coupling of actions at user - interface level . 4 . 2 . 4 Controlling Coupling Granularity and Timing : Aggregation Within each coupling level , groupware systems may give users control over the granularity of the actions that are coupled . For example , when typing a memo , the insertion of letters could be coupled , only the insertion of entire words , only the insertion of entire sentences , or only the insertion of the content of the complete memo . Both an initiating user and an observer may want control over the granularity of coupling . This may be specified using aggregation filters , which essentially specify how actions should be aggregated ( i . e . , functionally composed ) before their net result is used for coupled interactions . We assume that actions of an action level can be functionally composed , e . g . , when a 1 = insert ( ‘W’ ) , a 2 = insert ( ‘O’ ) , a 3 = insert ( ‘R’ ) , a 4 = insert ( ‘D’ ) , where a t denotes the action at moment t , then the groupware system can calculate the composition a 4  a 3  a 2  a 1 = insert ( ‘WORD’ ) . Definition 4 - 24 Action levels Definition 4 - 25 Coupling Level ( CouplingLev ) 96 C HAPTER 4 A GENERIC MODEL OF GROUPWARE Aggregation filters contain rules that determine when the time has come to aggregate a number of actions and make the result available for coupling . We distinguish the following types of trigger rules for aggregation : – action counter - based , i . e . , after a specified number of actions , aggregation and coupling is triggered . – timer - based , i . e . , after a specified period of activity 33 and / or inactivity , aggregation and coupling is triggered . This type of trigger rule may be used to specify that only the net effect of a series of actions during an active period needs to be coupled each time a user pauses . It may also be used to specify the frame rate in a video medium ( e . g . , only once every second , the current video image is coupled ) . – action sequence - based , i . e . , sequences of actions that trigger aggregation and coupling . Such trigger sequences may be simple trigger sequences , e . g . , sequences that contain only a single action ( e . g . , send , save , update , load , refresh ) , or they may be more complex , ( e . g . , trigger sequences that are constructed to detect crossing a border of a sub - unit such as a word , a sentence , a paragraph , etc . ) . In an aggregation filter , composite rules may be constructed with disjunction ( only one of the rules needs to trigger the composite rule ) , or with conjunction ( all rules need to trigger the combined rule ) . Aggregation filters may be used for presence aggregation , awareness aggregation and coupling aggregation . Let m (cid:2) M , p1 , p2 (cid:2) P cw , p1  p2 , let A x be an action level , let [ a ( t1 ) , a ( t2 ) , a ( t3 ) , … ] be a list of actions on a medium by one user that belong to action level A x , ( i . e . , a ( tn ) (cid:2) A x (cid:7) A m ) , and let R PresAgg ( A x ) be a combination of action counter based , action sequence based and action - trigger based rules defined over A x then a presence aggregation filter , PresAggFlt ( p1 , p2 , m , R PresAgg ( A x ) )  is a function that can be defined by PresAggFlt ( p1 , p2 , m , R PresAgg ( A x ) ) [ ] = [ ] , and PresAggFlt ( p1 , p2 , m , R PresAgg ( A x ) ) [ a ( t1 ) , a ( t2 ) , a ( t3 ) , … ] = aggr tagg ( a ( tn )  …  a ( t1 ) ) tagg : 34 PresAggFlt ( p1 , p2 , m , R PresAgg ( A x ) ) [ a ( t ( n + 1 ) ) , a ( t ( n + 2 ) ) , a ( t ( n + 3 ) ) , … ] , where aggr tagg = ( a ( tn )  …  a ( t1 ) ) tagg is a composition of the actions , where tagg ∫ tn , and a ( tn ) is determined according to the rules R PresAgg ( A x ) . 33 A period of activity is defined as a sequence of actions with a delay between actions that does not cross a certain threshold . 34 The colon is used here as an operator that puts an element in front of a sequence . Definition 4 - 26 Presence aggregation filter A G ENERIC G ROUPWARE S ERVICE M ODEL 97 Hence , a presence aggregation filter transforms a sequence of actions of a particular action level of a particular user on a particular medium into a sequence of composed actions , according to particular trigger rules . Let m (cid:2) M , p1 , p2 (cid:2) P cw , p1  p2 , let A x be an action level , let [ a ( t1 ) , a ( t2 ) , a ( t3 ) , … ] be a list of actions on a medium by one user that belong to action level A x , ( i . e . , a ( tn ) (cid:2) A x (cid:7) A m ) , and let R AwareAgg ( A x ) be a combination of action counter based , action sequence based and action - trigger based rules defined over A x then an awareness aggregation filter , AwareAggFlt ( p1 , p2 , m , R AwareAgg ( A x ) )  is a function that can be defined by AwareAggFlt ( p1 , p2 , m , R AwareAgg ( A x ) ) [ ] = [ ] , and AwareAggFlt ( p1 , p2 , m , R AwareAgg ( A x ) ) [ a ( t1 ) , a ( t2 ) , a ( t3 ) , … ] = aggr tagg ( a ( tn )  …  a ( t1 ) ) tagg : AwareAggFlt ( p1 , p2 , m , R AwareAgg ( A x ) ) [ a ( t ( n + 1 ) ) , a ( t ( n + 2 ) ) , a ( t ( n + 3 ) ) , … ] , whereaggr tagg = ( a tn  …  a t1 ) tagg is a composition of the actions , where tagg ∫ tn , and a ( tn ) is determined according to the rules R AwareAgg ( A x ) . Let p1 , p2 (cid:2) P cw , p1  p2 , let A x be an action level , then a coupling aggregation filter , CouplingAggFlt ( p1 , p2 , m , R PresAgg ( A x ) , R AwareAgg ( A x ) )  AwareAggFlt ( p1 , p2 , m , R AwareAgg ( A x ) )  PresAggFlt ( p1 , p2 , m , R PresAgg ( A x ) ) A complete specification of aggregation requires a specification of the nature of the composition of actions ( aggr tagg = ( a tn  …  a t1 ) tagg ) , which may be medium - specific , e . g . , add ( n )  add ( m ) = add ( n + m ) . There is , however , a specific type of functional composition which may be supported by all media types , viz . record - replay composition . It allows sequences of actions to be recorded into a single action ‘package’ , which can be replayed later by another user . Groupware systems and techniques have been proposed to support such record - replay composition in , e . g . , [ MaPr95 ] . A groupware system must make sure that the interactions are coupled conform the specifications of the coupling aggregation filters . 4 . 2 . 5 Ordering Actions and Interactions on a Medium Not all actions on a medium are always possible . For example , it is not possible to delete a letter from a text if the text is empty . In such cases , Definition 4 - 27 Awareness aggregation filter Definition 4 - 28 Coupling aggregation filter 98 C HAPTER 4 A GENERIC MODEL OF GROUPWARE users should get feedback that the action they submitted to the system is not possible . Constraints such as these are inherent to the medium , i . e . , they describe in which medium states actions are enabled or disabled , regardless which user is involved . The actions are enabled and disabled for all users alike and would also be enabled and disabled when the medium is used for individual work . There is another type of constraints , viz . coordination constraints , which enable and disable actions for a subset of all users , in order to express different rights and obligations of different users at various times when a medium is used collaboratively . Expressing the inherent medium constraints separately from the coordination constraints is an important part of our modelling approach , which aims at modelling coordination orthogonal to interaction . Hence , we first describe a generic model for inherent medium constraints , whereas coordination constraints will be described in section 4 . 2 . 6 . Informally defined , the medium order is a set of constraints on the order of actions on a medium , which are inherent to the medium . Whether an action is enabled or disabled due to the medium order depends only on the state of the medium , not on the person that initiates the action . Specifying a medium order can be done in different ways , e . g . – In a procedural medium order specification , an action is are never enabled , unless it is explicitly specified that it is enabled . Such a specification usually contains a set of enabling rules that specify which actions are enabled in which states . – In a declarative medium order specification , an action is are always enabled , unless explicitly specified in a constraint that it is disabled . Such a specification describes constraints on the order of ( inter ) actions , e . g . , which ( inter ) actions should occur before which other actions . In our model we use a procedural approach to specify the order of actions on a medium . Procedural versus declarative specification is chosen based on convenience , not on the type of ordering that needs to be specified , such as permissive versus restrictive systems . A restrictive system can be specified either with a declarative specification that consists of many constraints , or with a procedural specification that consists of few enabling rules . Similarly , a permissive system can be specified either with a declarative specification that consists of few constraints , or with a procedural specification that consists of many enabling rules . A G ENERIC G ROUPWARE S ERVICE M ODEL 99 Let m (cid:2) M , then a medium action order is a relation AO (cid:3) S m ⌠ A m , where ( s , a ) (cid:2) AO means : action a is enabled in state s which implies Α y (cid:2) S m : ( s , y ) (cid:2) a . For notational convenience , the medium action order of a particular medium m is also denoted as AO m . An action a is dis abled in state s (cid:2) S m , if ? y (cid:2) S m : ( s , y ) (cid:8) a . When an action a occurs when it is en abled , the medium state transition s ( t )  a ( s ( t ) ) will occur , i . e . , after the state transition , s ( t + 1 ) = a ( s ( t ) ) will be the current medium state . The concept of medium action order give rise to medium interaction order . Let m (cid:2) M , let AO m be the medium action order over m , and let I m be { i | m i = m } , then the medium interaction order is a relation IO (cid:3) S m ⌠ I m , where ( s , i ) (cid:2) IO means : the interaction i is enabled in state s for the user p i ; the relation IO is defined by { ( s , i ) | ( s , a i ) (cid:2) AO m (cid:12) m = m i } . For notational convenience , the medium interaction order of a particular medium m is also denoted as IO m . As can be observed form the above definition , in each state , a medium interaction order enables interactions based on the same action for all users alike . 4 . 2 . 6 Coordination In the previous section , we modelled a groupware service using interactions and medium interaction order a way that enables and disables interactions for all users alike . This leaves the responsibility for coordination of the interactions to the users themselves , which is fine in many situations . In some situations , however , users may want the groupware system to encourage or enforce particular rights and / or obligations to initiate a particular interaction by a particular person at a particular moment . In other words , users may require coordination support from the groupware system . Coordination support is the part of a groupware service that makes sure that people do not have the same rights and obligations as other persons at a particular moment . As already observed in section 2 . 3 . 2 and section 4 . 1 . 3 , the nature and extent of coordination support varies per situation . Hence , we will only describe the generic way in which the coordination support aspect of a groupware service can be modelled ( i . e . , we describe generic properties of Definition 4 - 29 Medium Action Order ( AO ) Definition 4 - 30 Medium Interaction Order ( IO ) 100 C HAPTER 4 A GENERIC MODEL OF GROUPWARE coordination services ) , leaving description of specific coordination support services to designers of groupware services themselves ( i . e . , we abstract from the specific policies ) . In our model of coordination we use a declarative approach to specify the coordination order as a relation that defines which persons are not allowed to initiate a certain action in a certain state . Let m (cid:2) M , let AO m be the medium action order of medium m , and let px (cid:2) P cw be one of the persons involved in a cooperative work context cw , then Medium coordination is a relation Coord (cid:3) P cw ⌠ AO m , where ( px , ( s , a ) ) (cid:2) Coord means : action a is dis abled for person px in state s . For notational convenience , medium coordination of a particular medium m is also denoted as Coord m . By modelling coordination as a set of constraints and not as a set of enabling rules , it is possible to use coordination as a restrictive overlay of medium action order . This way of modelling enhances the orthogonality between coordination and media : different types of medium coordination may be used for a single medium . We define a coordination filter as the set of disabled interactions in a particular cooperative working context . Let m (cid:2) M , let Coord m be the medium coordination for m , then the medium coordination filter ( CoordFlt )  { i | m i = m (cid:12) ( p i , ( s i , a i ) ) (cid:2) Coord m (cid:12) p i (cid:2) P cw } . For notational convenience , the medium coordination filter of a particular medium m is also denoted as CoordFlt m . A coordinated medium interaction order can be defined as a combination of the medium action order and the coordination filter ( note that the coordination filter specifies the residue , whereas filters such as coupling and aggregations filters specify the filtrate ) . Let m (cid:2) M , let AO m be the medium action order over m , let CoordFlt m be the medium coordination filter for m , and let I be the set of all interactions , then the coordinated medium interaction order is a relation CIO (cid:3) S m ⌠ I , where ( s , i ) (cid:2) CIO means : the interaction i is enabled in state s for the user p i ; this relation is defined by { ( s , i ) | m i = m (cid:12) ( s , a i ) (cid:2) AO m (cid:12) i (cid:13) CoordFlt m } . For notational convenience , the medium coordination filter of a particular medium m is also denoted as CIO m . Definition 4 - 31 Medium Coordination ( Coord ) Definition 4 - 32 Coordination filter ( CoordFlt ) Definition 4 - 33 Coordinated Medium Interaction Order ( CIO ) A G ENERIC G ROUPWARE S ERVICE M ODEL 101 With trivial coordination ( Coord m = (cid:10) ) , the coordinated medium interaction order ( CIO m ) degenerates to medium interaction order ( IO m ) , which means that in a particular state , the same actions are enabled for all persons alike . Proof : Coord m = (cid:1) ( Definition 4 - 32 ) (cid:2) CoordFlt m = { i | m i = m (cid:3) ( p i , ( s i , a i ) ) (cid:4) Coord m (cid:3) p i (cid:4) P cw } = (cid:1) ( Definition 4 - 33 ) (cid:2) CIO m = { ( s , i ) | m i = m (cid:3) ( s , a i ) (cid:4) AO m (cid:3) i (cid:5) CoordFlt m } = { ( s , i ) | m i = m (cid:3) ( s , a i ) (cid:4) AO m } ( Definition 4 - 30 ) = IO m By negating this implication , we see that unequal rights in a groupware service must be due to coordination , i . e . , CIO m  IO m (cid:12) Coord m (cid:10) . As an example of a coordination filter , consider a ‘floor control policy’ [ LaLa90 ] for an audio conversation channel . A restrictive version of such a floor control policy can be effectuated by temporarily denying users to make contributions , e . g . , by muting their microphone . The floor control policy may specify that only one conference member has the role of floor granter , a role which can be transferred by the current floor granter to other conference members ; that maximally one conference member has the floor at any given moment ; that conference members can request and release the floor ; that a queue is maintained of members who requested the floor , that this queue is available to the floor granter only and that the floor granter can revoke the floor at any moment and grant the floor to any other member . This is just one of many possible floor control policies ( see e . g . , [ RoGr93 ] ) . Such floor control policies would not only be applicable to coordinate an audio conversation channel , they can also be used to coordinate an entire shared workspace , or a shared object in a shared workspace . In the latter case , the floor to an object is usually referred to as a ‘write lock’ . Other examples of coordination filters include collaboration styles for co - authoring [ LeFK88 ] and workflow process definitions ( also known as office procedures [ Rodd93 ] ) . 4 . 2 . 7 Divergence , Synchronisation , and Consistency In the previous sections , we abstracted from the possibility that at a particular ( logical ) moment ( see Definition 4 - 6 ) , different users may observe different states of a medium . While reasoning about properties such as having the same rights and obligations in the case of trivial coordination , we expressed properties relative to the medium state users can observe , without referring to the real time ( s ) this state is observable for the users involved . If we can assume that at one moment in time , all users 102 C HAPTER 4 A GENERIC MODEL OF GROUPWARE always observe the same medium state , then properties such as having the same rights and obligations when observing the same state , can be translated into more meaningful properties such as : users have the same rights and obligations at the same time . However , as argued in the section entitled Collaborative Consistency Management , in section 2 . 1 . 1 , it is likely that not all users can always observe the same state at exactly the same ( physical ) time . Making sure that users can observe the same state at exactly the same ( physical ) time would be very hard to realise . Moreover , users seldom require such precisely synchronised feedback and feedthrough . For example , in face - to - face discussions , users can cope with the small differences in the time that a sound can be heard by the different participants . In other media , such as a object - based shared whiteboard , timing restrictions are even more relaxed ; in these environments , users may tolerate slightly higher response and notification times , in order to get consistency in the object - based shared whiteboard content in the long run . With bitmapped shared whiteboards , the same trade - off is present , but here , users are likely to tolerate slight inconsistencies ( like a few inconsistent bits in the different versions of a bitmapped shared whiteboard ) in order to get better response and notification times . Finally , when collaborating on documents , users may even deliberately choose for inconsistencies , in order to be able to work with different , parallel versions of the document . In the interest of generality , we have to drop our implicit , but naive view on consistency — that users can always observe the same medium state at the same time . Inspired by Dourish’ work on the relation between consistency , divergence , and synchronisation [ Dour95 ; Dour96a ; Dour96b ] , and on Greenberg and Marwood’s analysis of concurrency control in groupware environments [ GrMa94 ] , we refine our notion of consistency by acknowledging the existence of divergence , providing a framework for describing when inconsistency emerges and for describing the types of strategies for dealing with inconsistency . Criteria for Inconsistency Consistency is a measure of the ‘sameness’ of the state of a medium for different users . We know , however , that divergence is unavoidable . The relevant question , then , is “When does divergence develop into inconsistency ? ” For each groupware medium , the answer may be different . A G ENERIC G ROUPWARE S ERVICE M ODEL 103 To enable groupware developers to set the criteria for the emergence of inconsistency , we refine the notion of consistency using the following approach : – First of all , we split the medium state into several parallel versions 35 , one for each user ( see Figure 4 - 5 ) . Actions operate on the state of a version . Version state can be made observable in feedback and feedthrough directly to the associated user , but it does not have to be ( i . e . , a user can choose to delay feedback and local feedthrough of actions of others ) . For our notion of consistency , however , we abstract from this subtle difference between a version and a version as it is observed . We define consistency as a measure of the sameness of the states of these different versions themselves , not as a measure of the sameness of the different states that are made observable by feedback and feedthrough based on each of these versions . Hence , inconsistency is defined over what users can observe , not what they do observe . o i p i a i m i α t ( p i ) α t ( O i ) s i  a i ( s i )  o i p i a i m i α t ( p i ) α t ( o i ) s i  a i ( s i ) s i  a i ( s i ) – Second , we allow consistency to be defined over subsets of the state of a medium , instead of over the medium state in its entirety ( see Figure 4 - 6 ) . The state of a medium may be partitioned according to a medium - specific scheme . This partitioning scheme is applied to each of the versions of the medium state . Consistency , then , is defined over the set of corresponding subsets of the state of the different versions . Each subset may have its own criteria for inconsistency and have different requirements for dealing with emerging inconsistency . For example , each coupling level in a groupware medium ( e . g . , file level , edit level , view control level and UI control level ) , may have different consistency requirements for the subset of the state that is influenced by actions of a level ( we assume here that all actions that influence the state of a 35 Note that the existence of parallel versions is , in principle , orthogonal to the existence of replication of medium state in a distributed computing environment . We will revert to this issue in section 6 . 4 . 2 . Figure 4 - 5 Interaction model without versions ( left ) and interaction model with versions ( right ) 104 C HAPTER 4 A GENERIC MODEL OF GROUPWARE particular subset belong to the same action level 36 ) : when a level is not coupled , inconsistency may be allowed , whereas when a level is coupled , inconsistency may have to be prevented . As another example , in an object - based shared whiteboard where state changes in one object do not influence state changes in another object , the consistency of each of the shared objects may be considered separately . o i p i a i m i α t ( p i ) α t ( o i ) s i  a i ( s i ) s i  a i ( s i )  o i p i a i m i α t ( p i ) α t ( o i ) s yi  a yi ( s yi ) s xi  a xi ( s xi ) s yi  a yi ( s yi ) s xi  a xi ( s xi ) – Third , consistency can be defined in a number of ways : – based on real time : i . e . , the medium is considered inconsistent if the maximum feedthrough time exceeds a particular limit ( e . g . , 100 ms for audio conferencing [ Swin91 ] ( cited in [ Scho96 ] ) ) . Such a collaborative consistency requirement is usually in addition to a requirement for an upper bound for feedback time . – based on logical time : the medium is considered inconsistent if the state of the different parallel versions is different at a certain logical time . There are many ways to define logical time [ RaSi96 ] . For example , as a measure of logical time , the number of state transitions can be used . Hence , parallel versions are considered inconsistent at logical time n when the various n th state transitions occurring at each of the different parallel versions are not the same . An example of such a situation can be found in Figure 4 - 7 , where messages that mediate actions arrive in different order due to ( unpredictable ) latency in message transfer time . 36 As an example , consider a set of action levels { { insert , delete } , { collapse , expand , normal _ view , outline _ view } , { MoveMouse , MouseUp , MouseDown } } and a set of medium state { model _ state , view _ control _ state , user _ interface _ control _ state } . This satisfies the requirement , since in this particular medium , insert and delete only influence model state ; collapse , expand , normal _ view , and outline _ view , only influence view _ control _ state , and move _ mouse , mouse _ up , mouse _ down only influence user _ interface _ control _ state . Figure 4 - 6 Interaction model without state subsets ( left ) and interaction model with state subsets ( right ) A G ENERIC G ROUPWARE S ERVICE M ODEL 105 a 2 ( s  s Η 1 ) a 1 ( s  s Η 1 ) a ( s  s Η 1 ) 2 1 b 1 ( s  s ⌠ 2 ) b ( s  s ⌠ 2 ) b 2 ( s  s ⌠ 2 ) globaltime divergence inconsistency s = 2 s = 2 s = 3 s = 6 s = 4 s = 5 Dealing with Emerging Inconsistency The above concepts allow us to specify a number of non - overlapping subsets of the state of a medium , and define the criteria for inconsistency for each of these subsets separately ( i . e . , criteria based on real time or logical time ) . A groupware system can deal in a variety of ways with emerging inconsistencies . The two main strategies are : avoiding or allowing the emergence of inconsistency . From a technological perspective , strategies to avoid inconsistency ( also known as pessimistic concurrency control ) generally increase response and notification times , and reduce the availability of the medium for actions , compared to strategies that allow for inconsistency ( see e . g . , appendix B ) . From a human perspective , low response and notification times may improve the awareness of actions of other users and reduce the likelihood of conflicting interactions in the first place . The choice between inconsistency avoidance or inconsistency allowance is a trade off between consistency on the one hand and response and notification times and availability on the other hand . Each context requires careful consideration of the alternatives . As pointed out by Greenberg and Marwood , ill - considered design choices may lead to bad designs and much unnecessary work : “ In the worst case , a system which would have been fairly responsive without complex concurrency control ( and thus not need sophisticated schemes ) , could have its performance dragged down to make it [ i . e . , concurrency control ] necessary . “ [ GrMa94 ] . Inconsistency Avoidance A groupware system may try to avoid the emergence of inconsistency . On the surface , it seems that various concurrency control techniques known Figure 4 - 7 Emergence of inconsistency due to different ordering of actions 106 C HAPTER 4 A GENERIC MODEL OF GROUPWARE from distributed systems research may be applied to achieve this . However , as Greenberg and Marwood point out in their analysis [ GrMa94 ] , groupware systems differ significantly from conventional distributed systems , which profoundly impacts the choice for a particular concurrency control technique . In groupware systems , the domain over which concurrency control is exerted not only includes computers , but humans as well , who may tolerate both more and less consistency problems than computers . In line with Greenberg and Marwood , we distinguish among two ways in which groupware systems can avoid inconsistency , each with different effects for the users : – Ordering . One strategy to avoid inconsistencies is to accept actions that may cause inconsistency , but postpone their execution to a moment that will not cause the emergence of inconsistency , i . e . , to find an order of actions on all versions that does not lead to inconsistency . This approach is also known as serialisation [ GrMa94 ] . An example of this ordering strategy can be found in Figure 4 - 8 . Although various approaches exist that can ensure consistency requirements based on logical time ( e . g . , causal and total ordering , which we will define more precisely in appendix B ) , it may not always be possible to ensure particular real - time consistency requirements , due to increased response times and notification times that this scheme causes in many distributed environments . In addition , although ordering may avoid inconsistency , it may not be able to prevent users from initiating concurrent , semantically conflicting actions , such as inserting a letter in a word by one user , while another user concurrently deletes the same word . a ( s  s Η 1 ) 2 1 b ( s  s ⌠ 2 ) b 2 ( s  s ⌠ 2 ) globaltime divergence s = 2 s = 2 s = 3 s = 6 s = 6 s = 3 a 1 ( s  s Η 1 ) b 1 ( s  s ⌠ 2 ) a 2 ( s  s Η 1 ) Figure 4 - 8 Avoiding the emergence of inconsistency with ordering A G ENERIC G ROUPWARE S ERVICE M ODEL 107 – Locking . Another strategy is not to accept actions that may cause inconsistency , i . e . , to deny some actions by some users . This may be realised by locking , a form of coordination that gives only one user at a time the ( temporary ) privilege to initiate actions that may cause inconsistency , while restricting others to do such actions as long as the user holds the lock . Important design parameters of a lock coordination policy are the granularity of the lock ( e . g . : lock an entire document , an object , a handle of an object , or let the user specify the granularity ) , and whether the lock is acquired and released automatically . Allowing Inconsistency and Re - establishing Consistency Instead of avoiding inconsistency , a groupware system may decide not to subject conflicting actions to ordering or locking , but to allow the emergence of inconsistency and support different , parallel versions for each user . The reasons for allowing inconsistencies and the time the versions remain inconsistent may vary . In order to improve response and notification times , a groupware system may use an optimistic strategy , i . e . , a strategy that assumes conflicting interactions rarely occur and can be repaired when they occur ( also known as optimistic serialisation and optimistic locking in [ GrMa94 ] ) . In the above cases , inconsistencies typically only last a very short time . Another reason for groupware systems to allow inconsistencies to emerge may be to make media available for action during periods of disconnection in mobile systems . Some of these inconsistencies may be resolved automatically as soon as the systems reconnect , others may require human intervention . Finally , a groupware system may allow inconsistencies in order to honour a deliberate request of users — e . g . , when two users are working on alternatives for a chapter of a book , or when each user is temporarily allowed to control his own scrollbar position on a shared workspace , instead of sharing scrollbar positions . In such cases , inconsistencies may last a long time . Whatever the cause of the emergence of inconsistency , by providing additional support to synchronise these multiple parallel versions , groupware systems can alleviate the burden of having different parallel versions . We distinguish various synchronisation strategies : – Inconsistency detection . The groupware system may be able to detect the emergence of inconsistency [ SBF + 87 ] . We distinguish two main forms of inconsistency detection : – Automatic notification . As soon as the system detects the emergence of inconsistency , the users may be notified , who may then take appropriate action to synchronise the parallel versions themselves , or 108 C HAPTER 4 A GENERIC MODEL OF GROUPWARE to use the parallel versions individually , thus postponing the consistency re - establishment . – User - requested notification . If the system cannot provide automatic inconsistency notification , it may offer to compare the different parallel versions upon user request and detect whether there is a difference or not ( e . g . , by sending over the complete state of different versions and comparing them ) . – Consistency re - establishment . In addition to detecting inconsistency , many groupware systems offer support for combining the different parallel versions . We distinguish two extreme forms : – Slicing [ KaBe95 ] . In the ‘slicing’ approach , the combination of the different parallel versions is rather trivial : after the combination , all the different parallel versions that were present before the combination are present in each parallel version ( i . e . , without any further integration than being all present in a single parallel version ) . Before the combination , there were n users that could each observe 1 version , whereas after the combination , each of the n users can observe all n versions . As far as the groupware system is concerned , the different parallel versions after the combination are consistent . However , this consistency is only syntactic ; users may desire more semantic integration between the different versions . This semantic combination may not be necessary in situations where no real integration of the different versions is required , e . g . , when users can switch from having a single , shared telepointer to multiple , independent telepointers or when multi - user scrollbars are needed , that are each visible to all other participants , as illustrated in Figure 4 - 9 [ RoGr96 ] . In this particular case , the syntactic combination is pro - active , i . e . , after each action , the different parallel versions are combined syntactically . – Version merging . In many cases , users require more support for combining different parallel versions than just a syntactic combination in the form of version merging . Some conflicts may be resolved completely automatically . In general , however , version merging can not be automated completely , since users may have made semantically conflicting updates . Deciding between these conflicting updates may require human intervention in addition to automated decision heuristics . We distinguish two types of version merging . – Operational transformation . Some emerging semantic inconsistencies may be resolved completely automatically , e . g . , when commutative actions have been ordered differently at different sites , or when operational transformation or undo / redo operations or can be applied to repair inconsistency as soon as Figure 4 - 9 Multi - user scrollbars in GroupKit applications ( from [ RoGr96 ] ) A G ENERIC G ROUPWARE S ERVICE M ODEL 109 the system discovers that non - commutative actions have been ordered differently at different sites ( see also section B . 4 in appendix B . ) . For some examples of the application of operational transformations in groupware systems , we refer to algorithms such as dOPT [ ElGi89 ] , ORESTE [ KaBe93 ] , adOPTed [ ReNG96 ] , and LICRA [ Kana97 ] . These mechanisms may improve response and notification time , while guaranteeing consistency at system quiescence [ Kana97 ] , based on medium - specific knowledge about e . g . , commutativity of actions . However , as Greenberg and Marwood [ GrMa94 ] pointed out , it may be hard to design interfaces for such optimistic schemes that match the expectations of users . – Diff & Merge . Some semantic inconsistencies may be resolved only partially automatically , e . g . , when two users created two alternatives for a paragraph during a disconnected period . Usually , one stage of version merging can be automated , viz . calculating “diffs” , i . e . , creating a medium - specific , meaningful representation of the differences between the multiple parallel versions that cannot be resolved automatically . Representing these diffs is usually done with revision marks as various mainstream word processors do . Another stage , merging , requires interaction with ( and possibly between ) humans , viz . supporting users in choosing between these differences . Many techniques are available for calculating diffs and supporting merging of documents — e . g . , calculating non - incremental diffs as in PREP [ NCK + 92 ] , CoVer [ HaHa93 ] , Sync [ MuDe97 ] and MARC [ Berg96 ] — or calculating incremental diffs , at various moments — e . g . , “active diffs” as in COOP / Orm [ MiMa93 ; MaAs97 ] . Specifying Consistency Requirements : Consistency Contexts To express consistency requirements in a groupware service specification , we introduce the notion of a consistency context . It specifies how the groupware service deals with consistency between parallel versions of two users for a subset ( s x ) of the state 37 of a medium m . A consistency context must apply to all actions that operate on s x , say A x . Consistency contexts are valid for particular combinations of a partitioning of medium state and a partitioning of the set of actions on a medium . We define MP = { s 1 , s 2 , s 3 , … , s n } , as a partitioning of the medium state s of medium m , and an AP = { A 1 , A 2 , A 3 , … , A n } as a partitioning of A m , the 37 The state of a medium m ( s m , see Definition 4 - 5 ) is different from state space of that medium ( S m , see Definition 4 - 4 ) . 110 C HAPTER 4 A GENERIC MODEL OF GROUPWARE actions that are defined for medium m . We have to choose MP and AP in such a way that each action operates only on one medium subset and that each A x contains all actions that operate on s x . In that case , we say MP and AP are consistent medium and action partitionings . Moreover , since consistency is a symmetric property , we require that the actions that operate on s x are symmetrically coupled . Let m (cid:2) M , let p1 , p2 (cid:2) P cw , p1  p2 , and let MP = { s 1 , s 2 , s 3 , … , s n } be a partitioning of the medium state of medium m , let AP = { A 1 , A 2 , A 3 , … , A n } be a partitioning of A m , , let MP and AP be consistent medium and action partitionings , let s x (cid:2) MP be a subset of medium state , let A x (cid:2) AP be an action type that contains all the actions that operate on s x let A x (cid:7) CouplingFlt ( p1 , p2 , m ) = A x (cid:7) CouplingFlt ( p2 , p1 , m ) , then A consistency context CC ( p1 , p2 , s x ) is a tuple ( α t , CH ) , where - α t is the consistency criterion of the consistency context , which specifies the maximum skew in real time in a consistent medium , where α t = 0 indicates consistency is required at the same logical time . - CH is a 3 - tuple ( avoid , detect , synchronise ) , that specifies how inconsistency emergence is handled in the consistency context 38 , where avoid (cid:2) { no _ avoid , order , lock } detect (cid:2) { no _ detect , detect _ automatically , detect _ on _ request } synchronise (cid:2) { no _ synchronise , slice , transform , diff _ merge } Due to symmetry , by definition : CC ( p1 , p2 , s x )  CC ( p2 , p1 , s x ) . By specifying a consistency context for each pair of users and for each of the subsets of medium state , a medium consistency policy can be specified completely . Let m (cid:2) M , let p1 , p2 (cid:2) P cw , p1  p2 , and let MP = { s 1 , s 2 , s 3 , … , s n } be a partitioning of the medium state of medium m , then medium consistency policy of a medium m ( CC ) is defined as { CC ( p1 , p2 , s x ) | p1 , p2 (cid:2) P cw , p1  p2 , s x (cid:2) MP } . For notational convenience , the medium consistency policy of a particular medium m is also denoted as CC m . 38 Details of consistency handling other than those specified in this definition are beyond the scope of this chapter . Definition 4 - 34 Consistency context Definition 4 - 35 Medium consistency policy ( CC ) E XAMPLE 111 Interactions on a medium are subject to consistency control as specified in the medium consistency policy . Each interaction is influenced by exactly one consistency context in a medium , because of the consistent definition of action partitioning and medium partitioning . Armed with these definitions , we can now express synchronous and asynchronous in terms of a particular combination of consistency contexts plus coupling filters plus aggregation filters : – ( more ) synchronous interaction , also known as ‘tight’ collaboration can be defined as collaboration though interactions that are coupled at ( relatively ) low level , with ( relatively ) frequent action aggregation in ( relatively ) small chunks , with ( relatively ) short timing properties . – ( more ) asynchronous interaction , or ‘loose’ collaboration can be defined as collaboration though interactions that are only coupled at ( relatively ) high level , with ( relatively ) infrequent action aggregation in ( relatively ) large chunks , with ( relatively ) long timing properties . 4 . 3 Example As an example , an elaborated specification of a simple shared whiteboard service that uses the concepts defined in this chapter may be found in appendix A . 4 . 4 Conclusions Based on analysis of a range of existing groupware systems in chapter 2 and on a model of cooperative work , we defined a generic model of groupware services , both informally and formally . This model uses collaborative interaction as the central modelling concept , models individual work as a special case of collaborative work , uses a uniform approach for modelling synchronous and asynchronous cooperation and models coordination orthogonal to interaction . It contains precise definitions ( based on standard set theory and logic ) for various concepts , such as collaborative interaction , medium , action , feedback , feedthrough , presence , awareness , coupling , coupling levels , aggregation , medium coordination and consistency contexts . This model may be used to specify the relevant aspects of service that a groupware system provides to its users , in a form that is relevant for the design of groupware systems . In chapter 5 , we use this model as a basis for a groupware service reference architecture . Chapter 5 5 . A Reference Architecture for Component Groupware In this chapter , we present the Conference – Media – Coordination ( CoMeCo ) service architecture for component groupware . It distinguishes several classes of grouplet services . The service architecture is based on high - level structuring guidelines for decomposing groupware services . – In section 5 . 1 , we describe the structuring guidelines , which are based on an analysis of a wide range of existing collaborative applications and on a survey of groupware literature . – In section 5 . 2 , we describe the CoMeCo service architecture , which results from decomposition of the generic model of groupware services of section 4 . 2 based on the structuring guidelines of section 5 . 1 . section 4 . 2 section 5 . 2 CSCW model groupware service reference architecture section 5 . 1 CSCW model groupware service model structuringguidelines for extensibility & composability decompose Figure 5 - 1 illustrates the structure of this chapter . In this chapter , we do not present structuring guidelines or architectures for the logical and distributed design level . Neither do we describe platform support for developing groupware systems that conform to the CoMeCo service architecture . This will be described in chapters 6 and 7 . Figure 5 - 1 Structure of chapter 5 114 C HAPTER 5 A REFERENCE ARCHITECTURE FOR COMPONENT GROUPWARE 5 . 1 Structuring Guidelines at Service Level As explained in chapter 4 , a groupware service can be described by a set of media , actions , medium consistency policies , and filters for coupling , aggregation and coordination . In this section , we describe the guidelines that support structuring this set of services into grouplet services , in such a way that extensibility and composability can be achieved . 5 . 1 . 1 Requirements for Decomposition To find the appropriate guidelines for decomposing groupware services into grouplet services , we focused on the following requirements : – The grouplet services that result from applying the structuring guidelines should be as orthogonal as possible . In addition , the relations between grouplet services should be limited in number and in complexity . This facilitates developing grouplet services without knowledge of other grouplet services , which may have been developed by others . – End - user composition of grouplet services that result from applying the structuring guidelines should be relatively simple . As a consequence , the number of grouplet services used for composition should not be several orders of magnitude larger than the number of applications users deal with in single - user application environments . As a more general requirement , the structuring guidelines should make it clear to developers when to put functions in different grouplet services and when in the same grouplet service . 5 . 1 . 2 Groupware Service Structuring Guidelines The structuring guidelines we present in this section are derived from regularly occurring patterns in the set of interactions supported by groupware services . In general , deriving these structuring guidelines has been an intuitive process , informed by a study of many different groupware applications and toolkits that are described in section 2 . 1 . 2 . Below , we describe and motivate the following structuring guidelines for decomposing groupware services : 1 . Separate different media in different grouplet services . 2 . Keep together different forms of coupling and aggregation in a medium . 3 . Encapsulate a single - user application in a grouplet service . 4 . Separate conference management services from other groupware services . 5 . Separate coordination services from other groupware services . S TRUCTURING G UIDELINES AT S ERVICE L EVEL 115 Separate Different Media in Different Grouplet Services According to this structuring guideline , interactions that refer to different media should be supported by different grouplet services . Media in our decomposition play a similar role in groupware services as single - user applications in single - user computing environments : a user of single - user computing environments uses a specific combination of single - user applications for individual work . Similarly , a group of users of a groupware system uses a specific combination of media for cooperative work . Media lend themselves very well to be used as a unit of composition and extension by groupware users . A large variety of groupware media are conceivable , such as a bitmapped shared whiteboard , a vector - based shared whiteboard , a video conversation medium , a collaborative word processor , a collaborative spreadsheet , a collaborative project planning tool , etc . The combination of media that people want to use in a collaboration depends on factors such as the task at hand , the preferences of the group , the time pressure , etc . Moreover , media lend themselves very well to be used as units of design and implementation . Many aspects of a groupware service are medium - specific , such as medium actions , medium action order , and most aspects of coupling and aggregation filters . Distributing the support for a medium over different grouplet services would create medium - specific dependencies between grouplet services and would increase the complexity of interaction between grouplets . This , in turn , would mean that grouplet services would require much knowledge about other grouplet services and in general , the possibilities for combination of grouplet services would be severely reduced . Dependencies between media are often relatively simple , such as co - existence , and starting and stopping the media at the same time . Hence , when media correspond to grouplet services , dependencies between grouplet services are relatively simple , which facilitates combining different grouplet services , particularly if they are developed by different authorities , such as different software vendors . In the literature , particularly in literature that describes groupware toolkits , ample support for this structuring guideline can be found . Our notion of medium corresponds , for example , to a GroupKit conference application [ RoGr96 ] , a T . 120 application protocol [ Clar94 ] , and a DiCE application [ ViCB93 ] . Though this structuring guideline is simple and straightforward in most cases , in some cases it may be difficult to decide what constitutes a medium and hence , what constitutes a medium grouplet service . As a rule of thumb , groupware services should be separated when they can easily be used separately , developed separately and / or sold separately and if , in addition , their requirements for combined use can be adequately supported . For example , one may discuss whether a video conferencing service should be 116 C HAPTER 5 A REFERENCE ARCHITECTURE FOR COMPONENT GROUPWARE modelled as two separate media for audio and video , or as a single audio - visual medium . This largely depends on the type of relations between the two parts of the service the groupware system is required to support . If these are generic inter - media relations that can be supported in a generic groupware architecture , then separating the audio and video as two media is possible . Otherwise , they must be combined in a single audio - visual medium . Keep Together Different Forms of Coupling and Aggregation in a Medium In general , users do not want to put effort into transferring data from one medium to another , just to be able to collaborate more closely during some periods of cooperative work and to collaborate more loosely during other periods . This problem is more severe in persistent media , such as collaborative editors , collaborative spreadsheets and collaborative CAD systems , than in transient media , such as audio - visual conversation media . In the latter , there is no need to transfer resulting data when switching from one medium to another , whereas in the former , the resulting data must be transferred from one medium to another , which requires the media to understand the syntax and semantics of each other’s data formats , or some neutral intermediary data format . This requirement to understand another medium’s data format drastically reduces orthogonality between media 39 . Distributing , e . g . , the support in a shared whiteboard for model coupling and scroll coupling ( see appendix A ) in different grouplet services , would only increase the need for grouplets to understand each other’s data formats . Reducing the need for grouplets to understand each other’s data formats is possible if all interactions that refer to a medium are supported by a single grouplet service . This generally requires that medium grouplet services support a range of coupling and aggregation filters . This structuring guideline is in sharp contrast with the dichotomy between synchronous and asynchronous groupware as present in Johansen’s time - space matrix and the separation of user interface model and ontological model in [ ElWa94 ] . It is more in line with approaches proposed by Dourish [ Dour95 ; Dour96a ; Dour96b ] and Dewan [ DeCS94 ; Dewa96 ] . As an extreme consequence of this structuring guideline , many persistent medium grouplets must be able to serve as a single - user tool : 39 Solutions such as standardised data formats , e . g . , SGML , RTF , GIF , JPEG , WMF , etc . plus converters to and from these standardised formats , alleviate the problems somewhat , but as can be observed by the ever increasing amount of standards , for each type of content , a new standard format seems to be needed . S TRUCTURING G UIDELINES AT S ERVICE L EVEL 117 users often need to prepare data in isolation , which is later used as a basis for collaboration ( e . g . , a collaborative review session ) , and users often need to be able to work individually on the data that has been produced during earlier collaboration . Encapsulate a Single - user Application in a Grouplet Service Earlier , we modelled actions in single - user applications as degenerated collaborative intern actions . By wrapping a single - user software component in a facility that transforms single - user actions into collaborative intern actions , an application can provide a grouplet service , similar to the grouplet service of a medium . Most valuable in this respect is a generic facility that can wrap any existing single - user application , without requiring modifications to the single - user application . The nature of actions that can be transformed without changing the single - user application software component are limited , though . Typically , only those actions can be transformed that are external to the single - user application software component , such as user interface actions ( which are delivered to the application software component by the operating system ) and file system actions ( which are delivered by the application software component to the file system ) . Hence , the forms of coupling that can be provided to users by such a facility are typically limited to e . g . , user interface coupling ( also known as application sharing ) and file coupling ( where save actions are coupled ) . The disadvantage of the relatively inflexible form of coupling that this facility can support is often outweighed by the fact that this facility allows users to work with a vast array of groupware media based on existing single - user applications , including applications they are familiar with . In addition , this facility allows users to keep working with their legacy data , without conversion . Moreover , using this facility , a collaborative work environment can be jump - started with many existing applications , after which the environment can migrate gradually towards more flexibly coupled media , e . g . , when software developers upgrade their collaboration - transparent applications to make them collaboration - aware , or when competitive collaboration - aware products become available . Separate Conference Management Services from other Groupware Services Many groupware applications allow users to manage an abstraction of a collaborative working context explicitly . We denote this abstraction , which describes the groupware system’s view on which people and which media are involved in the context , with the term conference . 118 C HAPTER 5 A REFERENCE ARCHITECTURE FOR COMPONENT GROUPWARE Various other terms have been used in the literature to denote about the same concept , such as spaces [ Beau94b ] , places [ FiKM96 ] , locales [ FiKT95 ] , conversations [ KaCa92 ] , and sessions [ Edwa94 ; RoGr96 ; WiPl97 ; Scho96 ] . We chose the term conference as the generic term , in line with e . g . , [ AhEH88 ; VeVi91 ; ViCB93 ; ADH + 93 ; RaVV95 ] , since it has been used in various combinations to denote the type of medium available in the conference , e . g . , computer conference , data conference ( shared whiteboards and application sharing ) , video conference , audio conference , etc . This is perfectly in line with our definition of conference , in which the combination of conference and media largely determines the type of groupware service . Moreover , by choosing conference as the generic term , we explicitly include the possibility of long - term ( e . g . , multi - day ) conferences , whereas the more popular term session usually only denotes the short periods of time in which communication resources are used or reserved . Conference management , then , is the service provided by the groupware system to manage conference abstractions . With conference management , users can manage the membership of the interaction group explicitly , which allows them to refer to the current conference membership in each interaction only implicitly , instead of specifying the interaction group for each interaction explicitly . Moreover , in order to get involved in all groupware media that are used in a cooperative work context , e . g . , both a video connection and a shared whiteboard , a new user only needs to join the conference , instead of joining the interaction group of each medium separately . Similar to cooperative work contexts such as projects , meetings , tasks , meeting rooms , spontaneous conversations in hallways , etc . , conference management services can , if designed properly , make conferences a very effective and efficient means for users to organise their collaborative work . In reflection of the variety in collaborative working contexts , conferences may vary widely in several respects , such as : – duration , e . g . , ranging from minutes to months ; – number of participants , e . g . , ranging from zero ( a suspended conference ) , one ( a single - user conference ) , two ( e . g . , telephone ) , to 3 - 6 ( small group conference ) , 7 - 40 ( large group conference ) , 41 - thousands ( huge group conference ) ; – the way conferences are created , e . g . , explicitly as in telephone conversations , or implicitly , in response to overlapping scopes of activity ( as in collaborative virtual environments where people meet by coming within range of each other’s awareness scope ) ; – the nature of membership : static or dynamic , open or closed ; – the relations allowed between conferences , e . g . , co - existence , overlapping membership , hierarchical relations , etc . S TRUCTURING G UIDELINES AT S ERVICE L EVEL 119 These are only a few dimensions of the design space of conferences and conference management services , which will be described in more detail in section 5 . 2 . 1 . We recommend separating conference management services from other groupware services . First and foremost , because in many collaborative working contexts , most consecutive interactions in a groupware service involve the same interaction group . Second , we recommend this separation , since it enables separate attention for development of a conference management grouplet service . As Roseman and Greenberg put it : “ Session management must be more than an afterthought added to the applications , and should be tuned to the needs and collaboration patterns of the target user group . ” [ RoGr96 ] . In the groupware literature , there seems to be general consensus about the desirability of this separation , e . g . , in [ WiPl97 ; Scho96 ; Edwa94 ; ElWa94 ; OMK + 93 ; ViCB93 ; RoGr92 ; ABF + 92 ; CMB + 90 ] . Not only is this separation desirable , it is also feasible . First of all , grouplet services for conference management and media are largely orthogonal : one conference management grouplet service could be combined with many groupware medium grouplet services . This form of re - use is often motivated by amortising the cost of developing a conference management service and effort of learning how to use a conference management service over many different media . Vice versa , various conference management grouplet services could manage one medium 40 , which allows different groups to use the same medium , with the conference managers they prefer . As a further testimony to the feasibility of this separation , we refer to standards such as ITU T . 120 [ Clar94 ] and IETF mmusic [ Scho96 ] , that employ a similar separation . In section 5 . 2 , we will define the separation in more detail , by defining the generic relation between grouplet services for conference management and other grouplet services , such as media . Separate Coordination Services from Other Groupware Services In section 4 . 1 . 3 we have motivated separate modelling of coordination , which we pursued in section 4 . 2 . 6 , in Definition 4 - 31 - Definition 4 - 33 . At this place , we recommend — perhaps not surprisingly — to separate grouplet services for coordination from other grouplet services . The groupware literature seems to be divided about this structuring guideline . In many multimedia conferencing environments that consist of audio ( - video ) and shared application media , such as Rapport [ AhEH88 ] , BERKOM - MMC [ ADH + 93 ] and JVTOS [ GSS + 93 ] , floor control for 40 Not simultaneously , that is . 120 C HAPTER 5 A REFERENCE ARCHITECTURE FOR COMPONENT GROUPWARE audio and video is often modelled as part of conference management . In such multimedia conferencing environments , floor control , i . e . , requesting , releasing , granting and revoking the right to perform actions on a per - medium basis , is sufficient for coordination , so combining conference management — which only knows about entire media and not about the structure within media — with floor control may seem an appropriate choice . However , floor control policies may very well be re - used to coordinate interaction over medium - specific units of finer granularity , such as objects on a shared whiteboard , and chapters in a book . This opportunity for re - use is lost when conference management is combined with floor control : as far as conference management is concerned , it’s no use having multiple floors on a single medium . In some groupware systems , coordination support is an essential , if not the only mechanism for consistency management . For example , floor control may be a way to implement locks on entire media [ DoGa97 ] , as is done in many application sharing systems . However , except for the few cases where coordination and locking make a perfect match , coordination can be treated separately from consistency management , as if it were a filtering layer on top of a medium consistency policy . By separating coordination from both conference management and media , as proposed here and in e . g . , [ Rude93 ; ElWa94 ; BeDo95 ; CoMi96 ] , the possibilities for re - use of coordination policies in different conferences and over different media can be increased . As may be observed from the Definition 4 - 31 , however , medium coordination ( Coord ) , is defined in terms of the medium action order ( AO ) , which is medium specific , and current conference membership , which is conference specific . In order to make coordination policies re - usable in combination with many media and in many conferences , coordination policies will have to be defined as abstractions of medium coordination . To achieve this goal , we will define mappings in section 5 . 2 . 3 , that define how generic coordination policies can be applied to media in a conference . 5 . 2 The CoMeCo Groupware Service Architecture In this section we describe the generic service architecture that results from decomposing groupware services , as described in section 4 . 2 . , along the lines identified by the structuring guidelines that are described in section 5 . 1 . T HE C O M E C O G ROUPWARE S ERVICE A RCHITECTURE 121 The resulting groupware service architecture , CoMeCo , is named after the three grouplet service classes it distinguishes : – conference management grouplet services ; – medium grouplet services ; – coordination grouplet services . Below we describe these grouplet service classes in more detail . We identify main design parameters of each of the grouplet service classes . Designing a grouplet service , i . e . , an instance of such a grouplet service class , can be viewed as setting these design parameters . We describe the way grouplet services relate to each other and how grouplet services can be combined to form a groupware service . 5 . 2 . 1 Conference Management Grouplet Services A conference management grouplet service 41 provides users with the functionality to manage a set of conferences . A conference is a computer - based representation of a cooperative context . It consists of participants , media , and applied coordination policies . We model a conference management service as a specific groupware medium service , which supports interactions on the set of conferences and on the conferences themselves . This allows for an easy specification that many of the actions on a conference , such as joining a conference , or adding a medium to a conference , should be observable for other users . For a more precise definition of a conference management service , we first need to define the concept conference , which represents the state of a conference that is managed by a conference management service . A conference  a 3 - tuple c = ( PC , MC , ACC ) , where PC is the set of participants in the conference , MC is the set of media in the conference , and ACC is the set of applied coordination policies in the conference . In addition , we need to define the concept conference hierarchy . Let C be a set of conferences , then A conference hierarchy  a tree h = ( sub , C ) , where sub (cid:2) C ⌠ C is a partial ordering on C , where ( cx , cy ) (cid:4) sub means : cx is a sub - conference of cy . Now , we can define a conference management service as a medium that handles multiple conferences , which may be arranged in hierarchies . 41 Also denoted as ‘conference management service’ . Definition 5 - 1 Conference ( c ) Definition 5 - 2 Conference hierarchy ( h ) 122 C HAPTER 5 A REFERENCE ARCHITECTURE FOR COMPONENT GROUPWARE Let C be a set of conferences and let H be a set of conference hierarchies , then A conference management service  a medium cm = ( S cm , A cm ) , where s cm ( t ) = { { s cmc1 ( t ) , s cmc2 ( t ) , … , s cmcn ( t ) } , H ( t ) } (cid:4) S cm , where s cmcx ( t ) = cx ( t ) = ( PC cx ( t ) , MC cx ( t ) , ACC cx ( t ) ) , cx (cid:4) { c1 , … , cn } , n (cid:4) | describes the state of conference cx at time t and H ( t ) describes the set of conference hierarchies ( h ) at time t , and A cm describes the set of conference management actions . We explicitly allow sub - trees of conference hierarchies to be handled by an other conference management grouplet service ( i . e . , different from the conference management grouplet service that handles the top level ( s ) ) , as a way of composition of conference management grouplet services in a groupware system . Multiple conferences may exist simultaneously . We explicitly allow users to participate simultaneously in many conferences , i . e . , it is possible that PC cx ( t ) (cid:1) PC cy ( t ) (cid:3) for certain cx , cy , and t . We define the following conference management actions and action types : A cm = A existence (cid:4) A membership (cid:4) A media (cid:4) A coordination (cid:4) A multiconference (cid:4) A persistence (cid:4) A conftemplate (cid:4) A navigate ; these actions and action types are defined and described in Table 5 - 1 and in the sections below . As indicated in Table 5 - 1 , a conference management service at least needs to provide action types A existence , A membership , and A media ; the rest is optional . Action type Actions A existence { CreateConference , DeleteConference } A membership { AddMember , DeleteMember , JoinConference , LeaveConference } A media { AddMedium , DeleteMedium } A coordination { ApplyCoordinationPolicy , RemoveCoordinationPolicy } A multiconference { EmbedAsSubConference , RemoveAsSubConference , MoveConference , SplitConference , MergeConferences } A persistence { SuspendConference , ResumeConference } A conftemplate { CreateTemplateFromConference , ChangeTemplate , CreateConferenceFromTemplate } A navigate { Focus , Defocus } Definition 5 - 3 Conference management service ( cm ) Table 5 - 1 Conference management action types ( actions in italic font on lighter background are optional ) T HE C O M E C O G ROUPWARE S ERVICE A RCHITECTURE 123 Conference Existence Actions A existence that manipulate the existence of conferences form the basis of conference management . We distinguish two main design options for conference existence management : – In direct conference existence management , users issue the actions A existence explicitly . – In indirect conference management , actions A existence are only issued implicitly , i . e . , they are derived from other actions on the various entities constituting the conference [ ViCB93 ] , such as : – Members joining and leaving the conference . For example , a two - person telephone conference creation may be regarded complete only when both users have joined the conference and it is deleted as soon as one member leaves the conference . Another example is an audio - visual lecture conference that is configured to be deleted when the lecturer leaves the conference . – Media being added to or deleted from the conference . – Actions in a super - conference . For example , in the Intermezzo system [ Edwa94 ] , a conference may be created when two persons start editing the same file on a shared file system . We model such a long - term shared context like a shared file system as a super - conference from which sub - conferences can be created ( see also the description of A multiconference on page 125 ) . Conference Membership Actions A membership that manipulate the membership PC cx of a conference cx are another essential ingredient of conference management . In our model , membership interactions are only coupled to existing conference members and newly joining conference members . There are various design options : – Conference membership management can be initiator - based or joiner - based [ Edwa94 ] . In initiator - based conference membership management , conference membership actions can only be issued by existing conference members 42 ( AddMember , DeleteMember ) . In joiner - based conference management , users are allowed to take the initiative to determine their own membership in a conference ( JoinConference , LeaveConference ) . To join a conference , people either must be able to browse the set of ongoing conferences by using some conference directory service ( which can be modelled as a super - conference ( see also the description of A multiconference on page 125 ) ) , or users must happen to 42 For simplicity , the initiator of a conference that requires two or more members for its existence , is regarded as a member of that conference , that is allowed to issue AddMember in combination with CreateConference . 124 C HAPTER 5 A REFERENCE ARCHITECTURE FOR COMPONENT GROUPWARE know the essential information to join the conference ( time , address ) through other means . – Single - user conferences may or may not be supported by conference management services . A single - user conference may be useful to do preparatory work for a multi - user conference , such as setting up a whiteboard . More in general , being able to use single - user applications as media in single - user conferences whose membership can easily be extended , can be a powerful concept to enable spontaneous cooperative work . We are aware of a few groupware systems , such as the CoMMware platform [ EnAh97 ] , that explicitly support single - user conferences . – Zero - user conferences may or may not be supported by conference management services . Supporting such zero - user conferences allows groupware users to think of a conference as a persistent place rather than a session [ FiKM96 ; GrRo98 ] , and to pre - schedule conferences . – Conference membership may be discrete or gradual . In many groupware systems , membership is a discrete option : a user is either a member of a conference , or he is not . This type of conference management creates a world in which conferences can be thought of as rooms that are surrounded by impermeable boundaries : as long as you’re not in the room , you cannot observe anything from the conference other than its existence . For many Collaborative Virtual Environments this may be unacceptable , since they often need to model the real world more closely , e . g . , with a spatial model that allows for semi - permeable walls and fading presence and awareness based on some measure of virtual distance , as supported in the Aether system [ SaBB97 ] . – Conference existence may be tightly related to conference membership , as in telephone conversations , or very loosely , as in Usenet newsgroups . Conference Media Actions A media that manipulate the set of media in a conference are a final essential ingredient of conference management . When a medium is added to a conference , all 43 members will be connected to the medium . Similarly , when a medium is deleted from a conference , all members will be disconnected . The conference management grouplet will provide medium grouplets with information about ( changes in ) the conference membership and the set of media , so that medium grouplets may take action such as transferring medium state to the newly arrived user . 43 A medium with a sub - set of the current conference members can be created in the conference hierarchy as a sub - conference with a single medium . T HE C O M E C O G ROUPWARE S ERVICE A RCHITECTURE 125 Conference Coordination Policies Actions A coordination are optional actions that manipulate the set of coordination policies and the application of these coordination policies to media . The conference management grouplet will provide coordination grouplets with information about ( changes in ) the conference membership and set of media , so that coordination grouplets may take action to keep mappings of policies to conference members ( with the relation HasRole , see Definition 5 - 5 on page 132 ) and mappings of policies to media ( with the relation IsPolicyAction , see Definition 5 - 6 on page 133 ) up to date . Conference Navigation Actions A navigate are optional actions that can manipulate the presence and awareness of a member ( of all media ) in a conference . In some cases , conference management have been designed as if there is only one conference that users need to worry about and these actions have been omitted . However , conference members will not always be focused on one conference , but they may be engaged in other conferences , or single - user applications . With the actions focus and defocus , which often can be derived from window actions such as window selection / deselection and window minimisation / maximisation , a user can navigate through conferences : – For the defocused conference , the member’s presence and awareness of all media in the conference is lowered to pre - defined levels ( e . g . , by lowering the audio level and microphone gain , loosening the coupling in a shared document medium , etc . ) and other conference members are notified that a user is not focused on the conference any longer . – For the focused conference , the member’s presence and awareness of all media in the conference is raised to pre - defined levels ( e . g . , by raising the audio level and microphone gain , tightening the coupling in a shared document medium , etc . ) and other conference members are notified that the user is focused again on the conference . Conference Hierarchies Actions A multiconference are optional actions that manipulate conference hierarchies . It may be useful to relate a set of conferences in a hierarchy , where a ( super ) conference is allowed to have one or more sub - conferences . Conference hierarchies may be used to reflect the way people organise cooperative work in hierarchically structured cooperative work contexts [ VeVi91 ] , such as breakout sessions as part of larger sessions ; small workshops as part of larger conferences ; lectures , tutorials , laboratory sessions and exams and as part of a university course ; work packages as part of projects , and private conversations as part of meetings . If a conference management grouplet service provides support for conference hierarchies , with actions EmbedAsSubConference , 126 C HAPTER 5 A REFERENCE ARCHITECTURE FOR COMPONENT GROUPWARE RemoveAsSubConference , MoveConference , SplitConference , MergeConferences , various services can be provided , e . g . : – Existential relations between a super - conference and its sub - conferences could be automatically maintained . For example , when the super - conference is deleted , all sub - conferences are deleted if this is specified in existential relations . – A sub - conference could be created from the context of the parent conference . Conference members and media could be inherited from the super - conference ; by overriding , the actual conference members and media could be picked . – Conference navigation could be provided relative to conference hierarchies , as opposed to navigation through a flat list of conferences . Moreover , the traditional conference problems of bootstrapping conferences and the problem of integrating a groupware system in existing single - user oriented computing environments can be solved elegantly with the conference hierarchy concept . The problem of bootstrapping a conference occurs both in joiner - based conference management and in initiator - based conference management . In joiner - based conference management , one needs information about conferences that can be joined . Such information can be provided by conference directories such as the MBone session directory [ Scho96 ] or the GroupKit registrar [ RoGr96 ] . In initiator - based conferences , one needs the addresses of other users to send the invitations to . Such information can be provided by ( name ) directory services , such as X . 500 and DNS [ Scho96 ] . Services such as session and user directories can be regarded as long - term super - conferences from which sub - conferences can be started easily . Some examples of joining such high - level long - term super - conferences are logging on to the Internet , or logging on to a company - wide network ( which , of course must be preceded by events to join very - high level super - conferences such as getting an Internet account , getting a user account on the company - wide network , etc . ) . Using this perspective , creating sub - conferences from a super - conference becomes the rule , rather than the exception . For example , creating conference applications in GroupKit is done from the Registrar super - conference . Creating and joining this super - conference is done from within the context of the intranet or Internet super - conference . This super - conference , in turn , is joined when one gets an intranet or Internet account . At a certain level , we arrive at some root - level super - conference that is still maintained within a computing environment . Such conferences can only be joined by using other contexts , such as the postal system , the telephone system or face - to - face communication . T HE C O M E C O G ROUPWARE S ERVICE A RCHITECTURE 127 Though modelling this way may seem farfetched , it allows us to pinpoint an important point at which groupware services must relate to existing environments : conference management services should be well - integrated in any super - conferences people use for their daily work . Such integration is a critical success factor for collaborative systems [ NoPe93 ] , a point well - taken in the design of conference management standards such as IETF mmusic [ Scho96 ] . Hence , conference management grouplets may have to provide for integration with Internet , intranet and other local or wide - area infrastructures so that : – familiar addresses can be used to identify conference members , – sub - conferences can be started based on actions in super - conferences , e . g . , browsing the web or opening files in a shared file system [ Edwa94 ] . Conference Persistence Actions A persistence are optional actions that allow a conference cx to be suspended in a state s cxcm ( t ) = ( PC cx ( t ) , MC cx ( t ) , ACC cx ( t ) ) to which participants can return later . To be more precise , a suspended conference is a zero - user conference , which maintains a list of members which should join the conference upon resumption . The actions SuspendConference and ResumeConference may be used by conference members to save expensive or scarce resources such as communication bandwidth , screen estate , computer processor cycles , and , last but not least , human attention , in idle periods . Conference Templates Actions A conftemplate are optional actions that facilitate the creation of conferences based on conference templates , which are collections of conference parameter settings with some blanks for , e . g . , the actual conference participants . Similar to macros and templates in word processing systems , conference templates may be created based on existing conferences and may be adapted . In this way , re - use of satisfactory conference settings and a gradual co - evolution of support and working processes may be supported . Design Options for User Interfaces of Conference Management Grouplet Services There are many options for the design of conference management user interfaces . We will use a few examples to highlight the options . In DIVA , a 2D room metaphor is used to present conferences , as illustrated in Figure 5 - 2 [ SoCh94 ] . The upper left corner of the figure shows a room window , in which media and members are represented . Media user interfaces are handled in separate windows , as shown in the 128 C HAPTER 5 A REFERENCE ARCHITECTURE FOR COMPONENT GROUPWARE upper right window . A window representing all conferences is visible below these windows . Some systems , notably Collaborative Virtual Environments , use a 3D room metaphor to present the conference management user interface , integrated with the media interface . For example , the DIVE rooms , as illustrated in Figure 5 - 3 [ Hags96 ] , are inhabited by members and media , such as shared whiteboards that are attached to the wall . Figure 5 - 2 DIVA virtual office interface ( from [ SoCh94 ] ) Figure 5 - 3 A DIVE conference room ( from [ Hags96 ] ) T HE C O M E C O G ROUPWARE S ERVICE A RCHITECTURE 129 Other systems , such as the MESH system , use a more abstract interface for conference management , as illustrated in Figure 5 - 4 . Such abstract interfaces tend to use less screen estate . Apart from these explicit user interfaces for conference management , there are also more document - centric conference management approaches , in which conference management is integrated with existing elements from user interfaces that are based on the desktop metaphor . For example , connecting to a shared file system is mapped to joining a ( super ) conference . Existing actions on such a super - conference are mapped as much as possible onto appropriate conference management actions ( e . g . , open document  JoinConference ( a sub - conference for that document ) , close document  LeaveConference , minimise  DeFocus , maximise  Focus and changing window focus  DeFocus , Focus ) . Another example of this approach can be found in the SEPIA shared editing system ( see page 20 ) , where opening a node in a shared hypermedia document is mapped onto joining a tightly coupled sub - conference for that node . Figure 5 - 4 MESH conference management user interface with members ( rows ) and media ( columns ) 130 C HAPTER 5 A REFERENCE ARCHITECTURE FOR COMPONENT GROUPWARE 5 . 2 . 2 Medium Grouplet Services A medium grouplet service provides all services as described in the generic groupware service model in section 4 . 2 , as far as required to support the interactions of a single medium . Due to separation of conference management and coordination functions , the way users specify elements of interactions can be simplified ; the only item the initiator needs to specify explicitly for each interaction ( see also Definition 4 - 9 ) is the action : – p i , the initiator , is specified implicitly ; the groupware system can determine who initiated the interaction ; – a i , the action , is specified explicitly , e . g . , by a keystroke , a mouse click on a specific menu item , etc . ; – m i , the medium , is specified implicitly , e . g . , by the window that is active while an action is specified ; – s i ( t ) , the medium state , is specified implicitly ; it is the medium state at the time at which the action is initiated ; – O i , the observer group , is specified implicitly ; it is determined by : – the membership of the conference the medium is part of : for example , if the status of conference cx , s cxcm ( t ) = ( PC cx ( t ) , MC cx ( t ) , ACC cx ( t ) ) and m i (cid:4) MC cx ( t ) , then O i = PC cx ( t ) \ p i ; – settings for PresFlt , AwareFlt , CouplingFlt , PresAggFlt , AwareAggFlt , CouplingAggFlt , and the medium consistency policy . – α T i , is specified implicitly , and is determined by PresFlt , AwareFlt , CouplingFlt , PresAggFlt , AwareAggFlt , CouplingAggFlt , and the medium consistency policy . Relations Between Conference Management and Media The relation between conference management grouplet services and medium grouplet services is restricted to a few conference management actions . Medium grouplets need to be informed of the following actions by conference management grouplets , so that medium grouplet services can be changed appropriately : – Actions A media , in order to initiate and terminate media ; – Actions A membership , in order to support latecoming , e . g . , to bring the new conference member up to date ; – Actions A navigate , in order to adjust various filters in a medium to pre - determined settings for focused and defocused state ; – Actions A persistence , in order to write medium state to persistent storage and restore medium state from persistent storage when a conference is suspended and later resumed . T HE C O M E C O G ROUPWARE S ERVICE A RCHITECTURE 131 Cooperation Support Versus Conversation Support Unlike earlier work [ HoLH96 ] , we do not make a rigorous distinction between conversation media , i . e . , media such as audio and video channels that provide support for ‘direct’ interaction and cooperation media , i . e . , media such as shared whiteboards and collaborative editors that provide support for “indirect” interaction . The problem with using such a dichotomy is not the classification of media that fall near the extremes like the examples used above , but the classification of some media that are somewhere in between , such as computer conferencing media ( see also section 2 . 1 . 1 ) . Similar distinctions , such as explicit versus implicit interaction [ Rude93 ] , information exchange versus information sharing [ Rodd93 ] suffer from the same problem . As an example , consider sending an E - mail , which is usually regarded an outstanding example of information exchange . Modelled in terms of information sharing , sending E - mail can also be regarded as a coupled action on a shared E - mail document that , as a result , gives someone else access to ( a copy of ) a that shared E - mail document . This duality between information exchange and information sharing can be exploited at a technological level : E - mail systems ( usually regarded as an information exchange service ) can both be implemented with a message transfer system ( such as SMTP ) and with a shared file system ( such as NFS ) . A shared calendar system ( usually regarded as an information sharing system ) can also both be implemented with a message transfer system and with a shared file system . Moreover , forcing a separation between , e . g . , information exchange media and information sharing media , would hinder the construction of media that allow both sharing and exchange of media . For example , it would hinder “sending” a document that is edited with a collaborative editor with that editor , and it would hinder the exchange of recorded videoconferencing sessions with a single record - replay medium as proposed in [ MaPr95 ] . So , instead of using the dichotomies such as conversation media versus cooperation media , direct versus indirect media , explicit interaction versus implicit interaction and information exchange versus information sharing , we regard these as opposite points on a multidimensional map of media with a continuous scale . Fundamentally , media are characterised by expressing their coordinates in all dimensions , viz . medium state and actions , presence , awareness and coupling filters , aggregation filters , medium action order and medium consistency policy . Naming frequently used points or areas in this groupware media map is regarded as a matter of convenience , not as a fundamental distinction . 132 C HAPTER 5 A REFERENCE ARCHITECTURE FOR COMPONENT GROUPWARE 5 . 2 . 3 Coordination Grouplet Services In section 5 . 1 . 2 , we introduced a separation of coordination from media . The resulting coordination policy grouplet services can be modelled as media . A specific property of such coordination media is that they can be “applied” to other media . In applied form , a coordination policy defines medium coordination ( Coord , see Definition 4 - 31 on page 100 ) that specifies which conference members may or must perform which medium actions at which moment . In order to make coordination policies re - usable , i . e . , applicable to various conferences and various media , a coordination policy should abstract from the actual conference members and actual media actions . – we use roles as placeholders for conference members ; – we use coordination policy actions as placeholders for media actions . Hence , we define a coordination policy as an abstraction that describes which roles are not allowed to perform which coordination policy actions at which moment . Using these constraints , rights and obligations of roles can be defined . Let R cp be a set of roles and let A cp be a set of coordination policy actions , let S cp be a set of coordination policy states , then A coordination policy is a relation cp (cid:1) R ⌠ A cp ⌠ S cp , where ( r , a cp , s cp ( t ) ) (cid:3) cp means : action a cp is dis abled for role r in state s cp ( t ) Coordination support is concerned with applying coordination policies to media in conferences ; it amounts to establishing and maintaining two mappings : HasRole and IsPolicyAction . Coordination support is not concerned with creating and editing coordination policies ; this aspect can be dealt with by regular ( collaborative ) editors , which may treat a coordination policy is just like any other editable abstraction . Roles A role is a collection of rights and obligations in a coordination policy that may be associated with a particular conference member . Let R cp be the set of roles of coordination policy cp , and let PC cx be the set of members of conference cx , then A role mapping is a relation HasRole (cid:1) PC cx ⌠ R cp , where ( px , r ) (cid:3) HasRole means person px has the coordination rights and obligations of role r . Various groupware systems use roles . For example , a floor control policy in an application sharing system usually distinguishes the roles chairman and Definition 5 - 4 Coordination Policy ( cp ) Definition 5 - 5 Role mapping ( HasRole ) T HE C O M E C O G ROUPWARE S ERVICE A RCHITECTURE 133 participant . Based on a study of how people write together , Baecker et al . [ BNP + 93 ] identified a set of roles for group writing , viz . writer , consultant , editor , and reviewer . The co - authoring system Quilt ( see page 18 ) used a role hierarchy comprising co - author , commenter and reader , and allowed more roles to be defined in terms of rights to perform particular actions . Quilt further allowed the definition of multiple “styles” which may be applied to a document writing process . Each style may use the same roles , but with slightly different rights . In the co - authoring system PREP , roles are used as a set of pre - defined , yet tailorable parameters that define rights to document units [ NKC + 94 ] . Coordination Policy Actions Similar to the way roles are mapped on to actual conference members , coordination policy actions must be mapped onto medium - specific actions . Let A cp bet the set of actions in a coordination policy , let A m be the set of actions on medium m , then A coordination policy action mapping is a relation IsPolicyAction (cid:2) A m ⌠ A cp , where ( a m , a cp ) (cid:4) IsPolicyAction means medium action a m is mapped on coordination policy action a cp . Applying a coordination policy to a medium in a conference amounts to combining it with a role mapping and coordination policy action mapping . Let cp be a coordination policy , let HasRole be a role mapping , and let IsPolicyAction be a coordination policy action mapping , let AO m be the medium action order of medium m , and let PC cx be the set of members of conference cx , then an applied coordination policy is a relation APC (cid:2) PC cx ⌠ S cp ⌠ AO m , where ( px , s cp , ( s ( t ) , a ) ) (cid:4) APC , if and only if Α r (cid:4) R cp Α a cp (cid:4) A cp : ( r , a cp , s ( t ) ) (cid:4) cp (cid:7) ( px , r ) (cid:4) HasRole (cid:7) ( a , a cp ) (cid:4) IsPolicyAction (cid:7) ( s ( t ) , a ) (cid:4) AO m When ( px , s cp , ( s ( t ) , a ) ) (cid:4) APC , action a is dis abled for person px in medium state s ( t ) and coordination policy state s cp . Hence , an applied coordination policy is equivalent to a form of medium coordination that is extended with coordination policy state ( Locks in appendix A is an example of the latter ) . Definition 5 - 6 Coordination policy action mapping ( IsPolicyAction ) Definition 5 - 7 Applied coordination policy ( APC ) 134 C HAPTER 5 A REFERENCE ARCHITECTURE FOR COMPONENT GROUPWARE Relations Between Conference Management and Coordination Policy When new members join or leave the conference , a conference management grouplet must inform coordination grouplets so that it can adjust the role mapping relation HasRole . Relations Between Coordination Policy and Media Medium grouplets should allow ( e . g . , by consulting ) a coordination policy grouplet to check and possibly reject actions , based on the coordination policy that is applied to the medium . We distinguish two main forms of applying coordination policy : permissive and restrictive . Permissive coordination policies do not reject medium actions ; they only inform users of their rights and obligations , in order to encourage compliance with the policy . Restrictive coordination policies , on the other hand , enforce rights and obligations in a coordination policy by denying certain actions by certain conference members at certain moments . 5 . 2 . 4 Modelling Existing Categories of Groupware with CoMeCo Below , we describe how the service of various categories of groupware systems ( as described in section 2 . 1 . 1 ) can be expressed in terms of the CoMeCo grouplet services conference management , media and coordination policies . – Computer conferencing systems focus on providing a conversation medium in which the interactions are sending and reading messages . Early systems only supported textual messages , but increasingly , other data types than text are also supported . Aggregation is read - action based , i . e . , feedthrough of message - send interactions only occur when a read action occurs . Message - read interactions are never coupled . Conferences , indicated as “newsgroups” or “lists” , are usually topic - based , have a long life - time ( months to years ) , support huge - scale membership and can be joined by subscription . Conference membership actions ( e . g . , subscribe , unsubscribe ) are not coupled . Single - user and zero - user conferences are supported . Conferences are organised in a hierarchy to facilitate navigation , but no existence or membership relations between conferences in a hierarchy are present . Some computer conferencing systems ( e . g . , Lotus Notes , which has computer conferencing as a core service [ KBH + 92 ] ) allow for the definition of additional coordination policies that govern the exchange of messages . – Videoconferencing systems provide support for conferences that exist only when two or more members are present . Conference management is typically initiator - based . Videoconferencing systems primarily focus on audio - visual conversation media , which support ( periodically and T HE C O M E C O G ROUPWARE S ERVICE A RCHITECTURE 135 automatically initiated ) actions such as contributing video frames and audio samples . These actions are coupled , with consistency policies that specify real - time requirements . Some videoconferencing systems provide floor control coordination policies that can be applied to the audio and / or visual part of the audiovisual medium . – Shared whiteboards provide support for conferences comprising a two - dimensional shared workspace that contains bitmap - based or vector - based graphical objects . Conference management services are usually initiator - based . Coupling varies : most shared whiteboards support coupling of actions on the shared whiteboard content and coupling of pointer movement actions ( telepointing ) ; some shared whiteboards support coupling of scrollbar actions ( e . g . , a GroupKit - based shared whiteboard ) . Medium consistency policies vary : bitmapped shared whiteboards typically do not try to avoid inconsistencies , whereas object - based shared whiteboards avoid inconsistencies with locking , or allow inconsistencies in combination with inconsistency detection and re - synchronisation through operational transformation and undo / redo strategies ( cf . Definition 4 - 34 ) . Coordination support varies : some object - based shared whiteboards support per - object or per - workspace floor control as a means to implement the locking consistency policy , some do not provide any coordination support at all . – Workflow management systems typically focus on providing support for coordination policies , and less on conference management and media . Conferences in workflow management are implicitly present as “workflows” . Media in a workflow management system are implicitly present as the shared artefact that represents the status of the case the members cooperate on . The core of workflow services are restrictive coordination policies ( “process definitions” ) that enforce which actions on the case are to be made by which members at which moments . – Co - authoring systems typically focus on providing a groupware medium that supports cooperation on a document . There is a huge variation in the types of coupling supported : some co - authoring systems only support coupling of save or annotate actions , others support coupling of actions such as insertions of individual letter , and yet others provide a range of coupling settings , ranging from user interface actions to save actions . Some co - authoring systems support other media such as audio , video and / or textual media , in order to support discussion about the shared document . Conference management support tends to get less attention in co - authoring systems , with the notable exception of SEPIA , which supports hierarchical conferences . Many co - authoring systems provide coordination policies that govern which user ( s ) are allowed to perform operations ( e . g . , write , modify , annotate ) on parts of the shared document . 136 C HAPTER 5 A REFERENCE ARCHITECTURE FOR COMPONENT GROUPWARE 5 . 2 . 5 Comparing CoMeCo with Related Architectures A few groupware service models and architectures have been described in the literature that can be compared to CoMeCo . Below , we briefly review the main differences and similarities . Olsen et al . [ OMK + 93 ] describe a scheme for analysing the functionality of synchronous groupware systems , which distinguishes four clusters of support : task , interface , session and environment and identifies associated operations . Compared to this model , CoMeCo does not separate task and interface functions ; instead , it recommends integrating these as different coupling levels within each medium . Olsen et al . ’s session functions roughly correspond to CoMeCo’s conference management functions . Olsen et al . ’s environment functions support integration of personal and group work as well as integration of group work with the broader world . In CoMeCo , the former is supported by CoMeCo’s uniform treatment of individual work and group work , and its uniform treatment of asynchronous work and synchronous work , whereas the latter is modelled in CoMeCo with the super - conference concept . Separation of coordination policies is not present in Olsen et al . ’s analysis . In his PhD book [ Rude93 ] , Rüdebusch describes a comprehensive service model of groupware functionality that served as a basis for CoMeCo in many respects . In particular , the decisions to use interactions as a central concept and the orthogonal modelling of coordination and interaction are inspired by his work . However , whereas Rüdebusch separates ‘explicit interaction’ from ‘implicit interaction’ , we do not , as described in section 5 . 2 . 2 . In addition , Rüdebusch does not explicitly consider separation of conference management from other grouplet services ( he does not preclude it either ) , whereas this is an essential part of the CoMeCo architecture . Finally , Rüdebusch distinguishes between micro - coordination and macro - coordination , where the former is used to avoid inconsistencies and the latter is used to coordinate contributions of members to media . In CoMeCo , any form of restriction that causes different members to have different rights at the same moment , is considered coordination . The fact that coordination that provides mutual exclusion ( including both Rüdebusch’ “micro” and “macro” coordination ) can be used to avoid inconsistencies is a secondary issue in the CoMeCo model . A further difference between Rüdebusch’ model and CoMeCo is that the former argues for a separation of team - relevant coordination aspects ( e . g . , team - relevant roles ) and task - relevant coordination aspects ( e . g . , task - relevant roles ) , which is not prescribed in CoMeCo ; we considered the need for this too specific for certain types of groupware to prescribe it . Ellis and Wainer [ ElWa94 ] describe a conceptual model of groupware functionality , which distinguishes “ontological model” ( roughly equivalent C ONCLUSIONS 137 to an abstract data type ) , “coordination model” and “user interface model” . Again , compared to this model , CoMeCo does not separate functions to manipulate the ontological model and the user interface model ; instead , it recommends integrating these as different coupling levels within each medium . Separating coordination from other services , however is also employed in CoMeCo . Dewan’s multi - user architecture [ DeCS94 ; Dewa96 ] , finally , inspired us in the way we model coupling and coupling control in the CoMeCo architecture . The main difference with CoMeCo is that the latter adds a service architecture that caters for explicit attention to conference management and coordination services . 5 . 3 Conclusions The CoMeCo groupware service architecture distinguishes three types of grouplet services : – conference management grouplet services , – medium grouplet services , and – coordination grouplet services . CoMeCo meets the decomposition criteria identified earlier as follows : – Easy composition . In the CoMeCo groupware service architecture , end - user composition of groupware services is as simple as selecting a conference manager , one or more media and , possibly , applying coordination policies to media . For complex configurations of conference hierarchies , users may use multiple conference managers and conference template facilities , if provided . The number of grouplet services users employ for composition is in the same order of magnitude as the number of applications users now deal with in single - user application environments . – Orthogonality . Arbitrary combinations of conference management services and media services are possible , i . e . , one conference manager can be used with all groupware media and one groupware medium can be used with all conference managers . Through the construct of role and action mappings , coordination policies can be applied to many media . Arbitrary combinations are not possible , though : some simple coordination policies , such as floor control , may be usefully applied to many media ( i . e . , they can be used to regulate the floor to the entire audio medium , or to objects in a shared whiteboard ) , but some more complex coordination policies , such as workflows , may not be usefully applied to other media than the media they were designed for . 138 C HAPTER 5 A REFERENCE ARCHITECTURE FOR COMPONENT GROUPWARE – The guidelines for design decisions about the location of particular functionality are relatively straightforward : – functionality to manage conference abstractions ( i . e . , sets of people , media and applied coordination policies ) should be put in conference management services ; – functionality to coordinate user actions should be put in coordination policies , which can be used as a restrictive overlay over groupware media ; – the remaining groupware services should be provided by groupware media , which enable actions for all users alike . – Integrating single user applications is facilitated by modelling them as separate media . – Extending a system with coordination services only requires mapping roles and coordination policy actions to a medium in a conference . Chapter 6 6 . Collaborative Compound Document Editing In this chapter , we propose ‘collaborative compound document editing’ ( CoCoDoc ) , as a new paradigm for extensible and composable collaborative editing systems that can provide both comprehensive editing support and comprehensive collaboration support . Following the CoMeCo architecture defined in chapter 5 , co - authoring services ( see also section 2 . 1 . 1 ) can be decomposed into three types of grouplet services , viz . conference management services , media services and coordination services . In this chapter , we focus on structuring guidelines and architectures for media services for collaborative document editing . Other co - authoring services , such as conference management services , coordination services and media that do not contain ( parts of ) the shared document but that , e . g . , support audiovisual conversation about the document , are not discussed in this chapter . In contrast with chapters 4 and 5 , which only focused on the service level , this chapter contributes structuring guidelines and architectures at all three abstraction levels we distinguished in section 3 . 2 . 4 , viz . service level , logical level and distributed level . The structure of this chapter is as follows . In section 6 . 1 , we present structuring guidelines and architectures for collaborative compound document editing services at service and logical level . Subsequently , in section , 6 . 2 , we describe the design of the CoCoDoc framework , i . e . , a platform that supports developers in constructing grouplets that conform to the service and logical architecture . Subsequently , in section 6 . 3 , we focus on structuring guidelines and architectures at the distributed level . In section 6 . 4 , we describe platform support for the development of distributed grouplets , such as support for intra - grouplet interaction by a grouplet bus . 140 C HAPTER 6 C OLLABORATIVE C OMPOUND D OCUMENT E DITING 6 . 1 CoCoDoc Service and Logical Architecture The service architecture and logical architecture of CoCoDoc are inspired by applying structuring guidelines and architectures that are derived from compound document editing to collaborative document editing . In section 6 . 1 . 1 , we describe the service architecture and logical architecture of contemporary collaborative document editing media , the structuring guidelines that can be derived from them and identify the problems of extending and composing them . Subsequently , in section 6 . 1 . 2 , we describe the compound document editing paradigm and the structuring guidelines and architectures that can be derived from it . Finally , in section 6 . 1 . 3 , we describe the service and logical architecture of CoCoDoc and the advantages of CoCoDoc that result from applying compound document editing structuring guidelines to collaborative document editing media . 6 . 1 . 1 Collaborative Document Editing A collaborative document editing service can be modelled as a medium grouplet service . Its main functions are : – mediate interactions on a shared document between users ; – provide feedthrough to enable awareness of other user’s actions ; – provide particular forms of collaborative consistency management for the document , in the face of different actions by different users ; – allow coordination grouplet services to govern interactions , at times when it is desirable that not all users can perform all actions at any moment , e . g . , avoid conflicts when two users want to edit the same region of a document . From analysis of existing collaborative editing prototypes and commercial products [ Hoft96 ] , three logical architectures for collaborative document editing systems emerged , each of which gives rise to a different class of collaborative document editing service : – the shared file system architecture and service ; – the collaboration - aware architecture and service ; – the shared user interface architecture and service . C O C O D OC S ERVICE AND L OGICAL A RCHITECTURE 141 file system application user interface In each architecture , a different part of a typical single - user software architecture — which consists of a file system , an editing application and a user interface system ( cf . Figure 6 - 1 ) — is made collaboration - aware . The shared file system and shared user interface architecture both employ editors that are collaboration - transparent [ LaLa90 ] ( i . e . , as opposed to collaboration - aware editors , they do not contain collaboration - specific code ) and combine them with application - independent collaboration services . This approach allows for existing single - user editors to be used in collaborative settings . Shared File System Logical Architecture In the shared file system architecture , an unmodified single - user editor application ( e . g . , MS Word ) is combined with a shared file system ( e . g . , NFS ) , as illustrated in Figure 6 - 2 . shared file system application user interface application user interface In this architecture , only file system actions are coupled , in particular file save actions : as soon as one user saves the document , the shared file is updated and other users can observe the updated document . Various collaborative consistency policies can be employed in this architecture . When files are locked to avoid inconsistencies , an exclusive shared file editing service results . Other systems employ consistency policies that do Figure 6 - 1 Standard logical architecture for editors Figure 6 - 2 Shared file system software architecture 142 C HAPTER 6 C OLLABORATIVE C OMPOUND D OCUMENT E DITING not avoid inconsistencies , but allow multiple versions to emerge and provide rudimentary version navigation and / or version merging services . Shared User Interface Logical Architecture In the shared user interface architecture , an unmodified single - user editor application ( e . g . , Xemacs ) is combined with an application sharing system , ( e . g . , SharedX ) , as illustrated in Figure 6 - 3 . In fact , this architecture allows sharing the user interface of any type of application , not only editors . file system application shared user interface With a shared user interface architecture , actions on the user interface are coupled : as soon as one user performs an action on the user interface , such as moving the mouse , the user interface state is updated and all users can observe the updated user interface . The resulting coupling in the groupware service is also known as WYSIWIS ( What You See Is What I See ) [ SBF + 87 ] . The medium consistency policies employed in this architecture typically consists of inconsistency avoidance using locks , in combination with a floor control coordination service that can be used to pass the lock , i . e . , the exclusive privilege of performing actions on the shared application , from user to user . Collaboration - Aware Logical Architecture A collaboration - aware editor can offer more forms of collaboration support . For example , a collaboration - aware text editor may allow simultaneous access to a document : different users may simultaneously edit different sentences in the same document , or different users may simultaneously edit the same sentence . In addition , collaboration - aware editors can provide users with awareness of who is editing what , who has modified what , at what time , etc . Figure 6 - 4 illustrates a collaboration - aware software architecture . Figure 6 - 3 Shared user interface software architecture C O C O D OC S ERVICE AND L OGICAL A RCHITECTURE 143 file system user interface collaboration - aware application user interface However , development of such applications is complex . In fact , researchers approached the complexity of the problem from either the shared file system approach or from the shared user interface approach . – The collaborative editing tools Quilt [ FKL + 88 ; LeFK88 ] ( see also section 2 . 1 . 1 , p . 13 ) and PREP [ NCK + 90 ] are typical examples of early collaboration - aware editors that exploit shared file systems or shared databases . Quilt and PREP offer support for annotations , for communicating comments and intentions , and revisions , as well as role - based access . They only couple committed changes made by other users , while carefully avoiding the complexities involved in providing simultaneous access to documents and records . – Another approach was taken in the design of GROVE [ ElGR90 ] ( see also section 2 . 1 . 1 , p . 13 ) and DistEdit [ KnPr90 ] . These are examples of collaborative editing tools that support sessions of simultaneous access to a shared document as well as coupling of actions on the shared document . – Later , ‘multi - synchronous’ collaborative editing tools have emerged that support various levels of coupling such as , SEPIA [ HaWi92 ] ( see also section 2 . 1 . 1 , p . 14 ) . Generalised Logical Architecture : the Collaborative Zipper Architecture Each of the above architectures supports a particular range of coupling levels for collaborative editing : the shared file architecture supports coupling of actions at file level , the shared user interface architecture supports coupling of actions at user interface level and the collaboration - aware architecture can support coupling of actions of various levels in between . When we generalise these architectures , a pattern emerges in which coupling levels correspond with layers in a logical architecture , as illustrated in Figure 6 - 5 . Because of its resemblance to a zipper , we also refer to this architecture as the collaborative zipper architecture . Figure 6 - 4 A collaboration - aware software architecture 144 C HAPTER 6 C OLLABORATIVE C OMPOUND D OCUMENT E DITING user interface display view model file system A collaborative zipper consists of various levels ; each level comprises a part of the medium state . The lower levels of the zipper architecture barely abstract from the physical user interface . For example , in Patterson’s zipper [ Patt95 ] , at display level , user actions are represented as typed keys , mouse movements and the medium is represented in terms of , e . g . , pixels or other graphic primitives to be drawn on the screen . Medium state at higher levels abstract much more from such user interface details . For example , at Patterson’s view level , the medium state represents the kind of view that is selected , e . g . , a WYSIWYG view of a document versus a an outline view of a document and user actions indicate changes in that status . At Patterson’s model level , the medium state represents a shared artefact ( e . g . , a shared document ) in an abstract data type and user actions are represented as abstract actions on the abstract data type . At file level , finally , the persistent state of a document is represented and user actions ( e . g . , save ) indicate changes in the persistent document state . Like a zipper , one contiguous range of levels is coupled , and the rest of the levels is uncoupled ( in our case , the zipper closes downwards and opens upwards ) . If a level is coupled , then all actions belonging to that level are coupled , i . e . , they are observable for all conference members . If a level is uncoupled , then all actions belonging to that level are unrelated , i . e . , inconsistency is not avoided and each user has its own version . Patterson , who was the first to describe the zipper architecture , distinguished four levels : file , model , view and display [ Patt95 ] . Later , Karsenty and Beaudouin - Lafon [ KaBe95 ] introduced a seven - level Figure 6 - 5 A four - level collaborative zipper architecture , similar to [ Patt95 ] ; the upper two levels are coupled C O C O D OC S ERVICE AND L OGICAL A RCHITECTURE 145 collaborative zipper architecture and Dewan introduced a generalised zipper architecture with an arbitrary number of levels [ Dewa96 ] . As an example of possible levels and associated operations , we refer to Table 6 - 1 , which describes the logical ( zipper ) architecture of the shared whiteboard service that is described in appendix A . It distinguishes three levels , that correspond to coupling levels in the shared whiteboard , ranging from actions that only affect the mouse state interface to operations affecting the document . Zipper level State ( s x ) Actions ( A x ) model editing state of document ( m model ) CreateObj ( ) , DeleteObj ( ) , LockObj ( ) , UnlockObj ( ) , MoveObj ( ) , ResizeObj ( ) , SetFillColour ( ) , SetOutlineColour ( ) scroll scrollbar state ( m scroll ) ScrollHorizontal ( ) , ScrollVertical ( ) , Zoom ( ) pointer mouse position ( m point ) MoveMouse ( ) , MouseDown ( ) , MouseUp ( ) Limitations of Contemporary Collaborative Editing Media As may be observed by the diversity of co - authoring applications described in section 2 . 1 . 1 , the CoMeCo parameters for coupling and consistency management in collaborative document editing media can be set in many ways . In addition , there are many possible types of data in documents that could be edited collaboratively , e . g . , text , formatted text , graphics , images , spreadsheets , project plans , audio and video . Due to the complexity of developing collaborative document editing media , developers up to now covered only small regions of the huge design space . They typically focused on either : – single - user editing functions , using a collaboration - transparent architecture , i . e . , provide rich support for many types of data in documents and editing operations on these types of data ; the collaborative aspect of the service is typically added using file sharing or user interface sharing ; – collaborative functions using a collaboration - aware architecture , i . e . , provide rich support for coupling of operations and control over coupling ; the number of single - user editing features that is be provided is typically smaller than in the collaboration - transparent architecture , given the time and resources that went into dealing with the complexities of a collaboration - aware architecture . By using structuring guidelines and architectures from the compound document editing paradigm ( see section 6 . 1 . 2 ) , the choice between collaboration transparent and collaboration aware architectures can be made for smaller parts of the document independently , which provides various advantages ( see section 6 . 1 . 3 ) . Table 6 - 1 Example of a collaborative zipper for a shared whiteboard : state and operations per level 146 C HAPTER 6 C OLLABORATIVE C OMPOUND D OCUMENT E DITING 6 . 1 . 2 Compound Document Editing Recently , various compound document editing approaches emerged , such as : – OpenDoc [ Nels95 ; OrHE96 ] , – Object Linking and Embedding ( OLE ) 2 . 0 [ OrHE96 ] ( recently re - labelled ActiveX documents ) [ ChLi97 ] , – CommonPoint’s compound document framework [ OrHE96 ; Myer95 ] , – the “Glasgow 44 ” version of JavaBeans , the extension of the JavaBeans component software standard that provides rudimentary support for compound document handling [ CaBl98 ; Cabl97 ; CaSh98 ] . Though details differ , the main idea behind these compound document architectures is largely the same . A compound document consists of a hierarchy of parts 45 that may embed other parts . Each part has intrinsic content of a particular part type ( e . g . , an abstract data type , such as text , audio , video , HTML , spreadsheet data , or any other editable abstract data type ) . In addition to having intrinsic content , a part may embed other parts . The part at the top of a compound document hierarchy is called the root part . A frame maintains the relation between an embedding part ( ‘parent’ ) and an embedded part ( ‘child’ ) . A frame becomes visible as space that the ( presentation of the ) embedded part has in the ( presentation of the ) embedding part . Each part is handled ( i . e . , displayed , edited , stored , printed ) by its own part handler , a software component that resembles a sort of mini - application . When a user embeds a picture into a text document , it is the picture’s part handler that gets ‘embedded’ into the text part handler . That is , once the picture is embedded in the document , the picture part handler is still responsible for handling ( i . e . , displaying , editing , storing , printing ) the embedded picture . Another crucial user interface characteristic of compound document editing is in - place editing : embedded parts can be handled completely at the location in which they are inserted in the document , not in a separate window . Figure 6 - 6 illustrates a compound document editor user interface . Thus , in a compound document editing service , different part handler services cooperate to create the illusion of one seamlessly integrated document editing service that allows editing of a seamlessly integrated compound document . 44 At the time of writing , this version of the JavaBeans standard only had this code name , a version number was not determined yet . Up - to - date information is available at http : / / java . sun . com / beans / glasgow / 45 We will use OpenDoc terminology here , given our choice to use OpenDoc as a basis for implementation , as explained in chapter 7 . C O C O D OC S ERVICE AND L OGICAL A RCHITECTURE 147 Word part clock part drawing part ( root ; active ) part - specific menus In retrospect , the structuring guideline that appears to have been the basis for the compound document editing approach is a descendant of the “information hiding” principle that has driven modular programming [ Parn72 ] , and the “encapsulation” principle in object - oriented design , which essentially tells a designer to hide implementation details of data structures , i . e . , to keep knowledge about the way data is stored in memory local to one module or object , respectively . In compound document editing , this structuring guideline is applied to data types in a document : the knowledge about the way a particular data type in a document ( e . g . , text , spreadsheet , audio , image , drawing , video , etc . ) is stored in memory , displayed on screen and / or printed on paper must be kept local to as few components as possible , preferably one . This structuring guideline requires a logical architecture that contains a well - defined inter - part handler interface , across which part handlers can negotiate about their relations , e . g . , inter - part relations that exist because screen space , menu bars , and file storage are shared between various part handlers that are active in the context of a document . In the logical architecture of conventional editing applications , the inter - application interface is of a very different nature , viz . one that is predominantly focused on transfer of data between applications ( i . e . , exporting , importing and converting data ) . Each data type has its own application in which it is created and edited and there is typically one application that contains the entire final document . This application takes care of displaying , printing , storing and ( limited ) editing of embedded data , that is usually cut , converted and pasted into the application . This approach does not scale well to large numbers of data types : the numerous conversion filters that are to be included in applications soon become problematic . Moreover , updates in contained data require dynamic update mechanisms , such as the Windows Dynamic Data Exchange ( DDE ) mechanism . Figure 6 - 6 Annotated snapshot of a compound document editing user interface 148 C HAPTER 6 C OLLABORATIVE C OMPOUND D OCUMENT E DITING Hence , compared to the conventional editing approach , the compound document approach provides many benefits for extensibility , including : less need for conversion filters , no loss of fidelity ( each data type is edited by its native application ) and polymorphic embedding : once a part handler can embed another part handler , it can embed all part handlers , including future part handlers that conform to the inter - part handler interface . 6 . 1 . 3 Collaborative Compound Document Editing In the collaborative compound document editing approach , the structuring guidelines and architectures that are the basis of compound document editing are applied to collaborative editing , a combination that has hardly 46 been studied up to our publication [ HoLu97 ] . The logical architecture of CoCoDoc defines a collaborative compound document editing medium grouplet to be a composition of smaller CoCoDoc grouplets . A CoCoDoc grouplet is a part handler that not only has features for data editing ( as any other part handler ) but also for collaborative editing . In the CoCoDoc logical architecture , collaboration - transparent and collaboration - aware CoCoDoc grouplets can peacefully coexist . They may even be used in combination to implement the collaborative editing service of a single document . For example , the high - level outline of a document may be edited with a collaboration - aware CoCoDoc grouplet that provides a service similar to GROVE ( see the section entitled “Co - authoring systems” in section 2 . 1 . 1 ) , while embedded content parts may be handled e . g . , by a CoCoDoc grouplet based on the collaboration - transparent MS - Word and a shared file system . Each CoCoDoc grouplet of a compound document has its own zipper . This may be a rather inflexible zipper with one or two coupling modes that can be realised with collaboration - transparent editing , ( cf . Figure 6 - 2 and Figure 6 - 3 ) , or a more flexible zipper with more coupling modes that can be realised with collaboration - aware editing only ( cf . Figure 6 - 7 ) . As a jump - start for constructing a collaborative compound document editing system , existing collaboration - transparent part handlers ( e . g . , OLE 2 . 0 based applications , such as MS Word , Corel Draw and Lotus Freelance Graphics ) can be used as a CoCoDoc grouplet . When such part handlers are combined with facilities such as an application sharing system ( see Figure 6 - 3 ) or a shared file system ( see Figure 6 - 2 ) , these part handlers can provide support for simple forms of collaborative editing such as shared user interface editing and shared file editing . 46 To our knowledge only Apple [ DPC + 95 ] , Taligent [ OrHE96 , p . 307 ] ) and the Technical University of Munich [ Koch95 ; Schl96 ] have done some preliminary work in this area . C O C O D OC S ERVICE AND L OGICAL A RCHITECTURE 149 interfacecoupling viewcoupling editcoupling filecoupling Tight coupling Loose coupling = uncoupled state Legend : = coupled state edit status file status view control status user interface control status A collaborative compound document editing system can migrate over time , by extending it with newly developed or upgraded versions of CoCoDoc grouplets , thus extending the collaborative editing service with features to handle new data types and / or new features for collaborative editing ( cf . Figure 6 - 8 ) . data types t e x t s p r e a d s h ee t i m a g e d r a w i n g a u d i o v i d e o shared user interface shared file collaboration aware Figure 6 - 7 A collaborative zipper with four coupling levels ( rows ) ; users can choose between four coupling modes ( columns ) Figure 6 - 8 Extension of a collaborative compound document editing system : adding new CoCoDoc grouplets ( indicated by lighter squares ) with new editing features ( i . e . , data types ) and / or new collaborative features 150 C HAPTER 6 C OLLABORATIVE C OMPOUND D OCUMENT E DITING For developers , the collaborative compound document editing paradigm and architecture offer the following benefits : – Reduced development effort : Developers can concentrate on providing editing functionality in small , manageable chunks ; they do not have to provide an entire editing environment to have a marketable product . For example , vendors could concentrate on developing a CoCoDoc grouplet for a data type in which they are specialised ( e . g . , a spreadsheet ) , leaving editing of other data types in a document to other vendors . – Decide on collaborative features on a grouplet - by - grouplet basis : The needs for collaborative features often depend on the data type . Decisions on collaboration - awareness or collaboration - transparency can be taken on a grouplet - by - grouplet basis . For a group of collaborating users , the collaborative compound document editing paradigm offers the following benefits : – Coupling setting per grouplet : With flexible CoCoDoc grouplets , users could decide to collaborate more tightly over some grouplets ( e . g . , scrollbar coupling in a shared drawing ) , and to collaborate more loosely over other grouplets ( e . g . , file coupling for other grouplets ) . – Less steep learning curve : For most users , using collaborative editing services requires learning to use new features related to collaboration . A collaborative compound document editing environment can start with one or more editors that users are already familiar with , thus minimising the need to learn new features . When collaborative features are added stepwise , learning can also be done stepwise . – Increased composability and extensibility : Last , but not least , the collaborative compound document editing service can be tailored to the group’s needs , by extending the installed base with the required CoCoDoc grouplets and allowing users to select from the installed base only those CoCoDoc grouplets that are actually needed . Open standards for inter - grouplet interaction for CoCoDoc grouplets , e . g . , one based on the Distributed Document Component Facility ( DDCF ) standard of OMG [ ACI + 95 ] , would facilitate combined use of different CoCoDoc grouplets from different vendors within a collaborative compound document editing system . Moreover , open standards for grouplet kinds ( i . e . , formats for persistent storage or data transfer of data types of document grouplets , similar to MIME types ) would allow for the emergence of a software components market , from which users can choose the CoCoDoc grouplet on the market for a particular grouplet kind that best suits their needs . T HE C O C O D OC F RAMEWORK 151 6 . 2 The CoCoDoc Framework In this section , we identify services that should be provided by a platform , which we coined the CoCoDoc framework , in order to assist developers to structure their medium grouplets according to the CoCoDoc logical architecture . A framework is an object oriented software infrastructure that can be reused within a particular application domain [ FaSc97 ] . It contains generic functionality for that domain , but it requires specialisation by a developer in order to get the functionality required for a specific application , or , in this case , a specific CoCoDoc grouplet . In section 6 . 2 . 1 , we focus on requirements for compound document editing support and in section 6 . 2 . 2 , we focus on requirements for collaborative document editing support . In this section , we do not describe the implementation details of the CoCoDoc framework ; these can be found in section 7 . 4 6 . 2 . 1 Compound Document Editing Support A collaborative compound document editing system consists of a number of CoCoDoc grouplets , each devoted to editing a particular document part ( e . g . , a text part or a spreadsheet part ) , in close cooperation with other CoCoDoc grouplets , as illustrated in Figure 6 - 9 . compound file system grouplet compound user interface grouplet The compound document editing support that CoCoDoc needs to provide is primarily concerned with inter - grouplet relations , i . e . , relations between different CoCoDoc grouplets involved in editing a document . – Embedding relations between CoCoDoc grouplets . The CoCoDoc framework needs to support embedding relations between parts ( and consequently : between CoCoDoc grouplets ) ; this involves creation and deletion of frames and negotiation about screen space . – Compound document storage . CoCoDoc grouplets need to be supported in sharing document storage with each other ( e . g . , sharing a file that stores a compound document ) . Figure 6 - 9 Compound view : inter - grouplet relations 152 C HAPTER 6 C OLLABORATIVE C OMPOUND D OCUMENT E DITING – Compound document user interface : CoCoDoc grouplets need to be supported in sharing a document editing user interface . This involves CoCoDoc grouplet activation and dispatching input to CoCoDoc grouplets , and sharing user interface objects such as menus ( e . g . , making sure that the menu bar always displays the menu bar of the active CoCoDoc grouplet ) . – Document - wide view control . Setting the view type for each CoCoDoc grouplet independently may not always be desirable ; instead users may want to set the view type for the entire document with a single action . This requires standardisation of some view types in CoCoDoc . Some candidates are : normal view , outline view ( for hierarchically structured documents ) , and timeline view ( for multimedia documents that have a temporal dimension ) . 6 . 2 . 2 Collaborative Document Editing Support The collaborative document editing support that CoCoDoc needs to provide consists of : – Shared file editing support for CoCoDoc grouplets ( cf . Figure 6 - 2 ) . A CoCoDoc grouplet requires collaborative storage for its data . In addition to conventional network file system services , support should be provided for compound document storage and support may be provided for collaborative storage services such as change notifications , multiple versions and version merging . This support is generic , i . e . , it can be used by all types of CoCoDoc grouplets , including collaboration - transparent part handlers . – Shared user interface editing ( WYSIWIS ) support for CoCoDoc grouplets ( cf . Figure 6 - 3 ) . This support is generic , i . e . , it can be used by all types of CoCoDoc grouplets , including collaboration - transparent part handlers . – Support for collaboration - transparent part handlers . Using existing single - user part handlers in a collaborative compound document editing system requires support that instantiates part handlers where needed , connects them to shared file services and / or shared user interface services and supports latecomers ( see also section 2 . 2 . 1 ) . – Support for collaboration - aware CoCoDoc grouplets . Developing collaboration - aware grouplets requires — in addition to shared file system support and shared user interface support — support for intra - grouplet relations , e . g . , relations between various grouplet entities that may constitute a grouplet ( cf . Figure 6 - 10 ) . This comprises support such as creating grouplet entities where needed , support for latecomers , support for multiple levels of coupling in a grouplet editor , and support for coupling control on a grouplet - by - grouplet basis . C O C O D OC D ISTRIBUTED A RCHITECTURE 153 – Document - wide coupling control . Setting the coupling level for each CoCoDoc grouplet independently may not always be desirable ; instead users may want to set the coupling level for the entire document with a single action . This requires standardisation of a few coupling levels in CoCoDoc , that each collaboration - aware CoCoDoc grouplet should at least implement . Some candidates are : file coupling , edit coupling , view coupling and user interface coupling . collaborative file system user interface grouplet entity user interface grouplet entity Support for multiple levels of coupling in a grouplet and grouplet coupling control can be provided by a collaborative object group platform ( see section 6 . 4 ) , which provides support for the CoCoDoc distributed architecture ( see section 6 . 3 ) . 6 . 3 CoCoDoc Distributed Architecture In this section , we focus on design decisions regarding physical distribution of grouplets . Many qualities of groupware systems depend on the way grouplets are distributed , including : performance , reliability , and availability . In order to illustrate the design issues involved , we first provide an example ( see section 6 . 3 . 1 ) . Then , in order to find appropriate structuring guidelines for the distributed architecture of grouplets ( section 6 . 3 . 6 ) , we address the following questions in the rest of this section ( see also Figure 6 - 11 ) : – What is a distributed groupware system and what are the units of physical distribution ? ( section 6 . 3 . 2 ) – What are the options for distribution ? ( section 6 . 3 . 3 ) – What are the options for distributing the collaborative zipper architecture ? ( section 6 . 3 . 4 ) – What are the factors that affect distribution decisions ? ( section 6 . 3 . 5 ) Figure 6 - 10 Collaborative view : intra - grouplet relations units of physical distribution units in logical architecture options factors Figure 6 - 11 Physical distribution decisions 154 C HAPTER 6 C OLLABORATIVE C OMPOUND D OCUMENT E DITING 6 . 3 . 1 Example : Distribution Issues in Application Sharing Systems The physical distribution of application sharing systems ( cf . section 2 . 1 . 1 ) has been — and still is — the subject of considerable debate in groupware literature ( e . g . , [ SaGr85 ; LJL + 90 ; CMB + 90 ; AhEL90 ; BeSS97 ] ) . Since this debate nicely illustrates some of the trade - offs in design decisions on the distribution of groupware systems , we will discuss some of the issues below . Suppose , there are two users , user A and user B , who want to share an application ( i . e . , couple it at user interface level ) . Each user has a computer that is responsible for representing the user interface to its user . The computers are connected to each other via a network , to which some other computers are connected as well . The logical architecture of an application sharing system distinguishes three subsystems : the user interface subsystem ( e . g . , an X window server [ ScGe86 ] ) , the application program ( e . g . , an X window client that implements a vector - based drawing program ) and an application sharing subsystem . Basically , designers have two options for distribution : using a centralised or using a replicated application sharing architecture : – In a centralised application sharing architecture ( see Figure 6 - 12 ) , only a single instance of the application program is running on one computer . This may be user A’s computer or user B’s computer ( or another computer connected via the network to both user A’s and user B’s computer ( as illustrated in the right part of Figure 6 - 12 ) ) . This application program is connected to multiple user interfaces , through functions in the application sharing subsystem that combine the input events of different users into a single stream of input events that is handled by the application program and through functions that distribute the output events of the application program to the user interfaces of both users . C O C O D OC D ISTRIBUTED A RCHITECTURE 155 user A user B appl . user interface user interface computer A computer B user A user B appl . user interface user interface comp . A computer C comp . B – In a replicated application sharing architecture , ( see Figure 6 - 13 ) , an instance of the application program ( an application replica ) runs on each user computer . These application replicas are connected to multiple user interfaces , through functions in the application sharing subsystem that distribute ( cf . multicasting in section 6 . 4 . 5 ) the input of each user to each of the application replicas , functions that combine the input of different users into a single stream of input events that is handled by an application replica ( cf . collation in section 6 . 4 . 5 ) ; the output of an application replica goes directly to the local user interface . computer A computer B user A user B appl . user interface user interface appl . Both architectures have their advantages and disadvantages . – A replicated application sharing architecture typically provides better response and notification times than a centralised application sharing architecture . In the centralised architecture , both input to and output Figure 6 - 12 Centralised application sharing architectures : the application is running on of the one user’s computer ( left ) or on another computer ( right ) Figure 6 - 13 A replicated application sharing architecture 156 C HAPTER 6 C OLLABORATIVE C OMPOUND D OCUMENT E DITING from the application have to be sent across the network 47 . In the replicated architecture , only input events need to be sent across the network , whereas output events are generated locally and do not have to be sent across the network . For many applications , output events dwarf input events in terms of volume and frequency ( see e . g . , [ BeSS97 ] , which cite an analysis that found that the ratio of output to input was nearly 10 : 1 ) . This implies that the replicated architecture typically requires much less network communication than the centralised architecture . Combined with experience that suggests that network communication overhead in general and network latency in particular typically is the dominating factor ( see e . g . , [ AhEl90 ; GrUN96b ] ) for performance measures such as response time and notification time for computationally inexpensive actions such as inserting a letter in a document and dragging a rectangle , this explains why a replicated application sharing architecture typically provides better response and notification times . – In the replicated architecture , care must be taken to ensure that the application replicas and the output of the application to each user remain consistent . This requires special precautions , e . g . , to ensure that equivalent application logic is present at all replicas , that the initial application state is equivalent , that all input events from all users are delivered to all application replicas in equivalent order and that applications are deterministic 48 . For latecomers , it requires a state transfer service 49 that updates the application replica of the newly joined conference member and that makes sure that all events later than the join ( i . e . , events that were not incorporated in the state that was transferred ) are delivered also to the application replica of the newly joined conference member . In the centralised architecture , ensuring consistency of application replicas is trivial ( since there is only one instance ) and ensuring the consistency of the output of the application to each user is relatively simple : output events sent from the centralised application to the user interfaces should be received in the same order as they were sent . However , output events may have to be customised for each user interface individually ( e . g . , application sharing systems 47 That is , for all users other than the user , if any , on whose computer the sole instance of the application is running . 48 Applications are deterministic if , given identical initial state and identical sequence of input events , they always produce the same result . Some examples of non - deterministic behaviour are , e . g . , timing - dependent behaviour such as scrolling continuously while a button is depressed , or discarding all pending events upon reaching some part of the code [ CMB + 90 ; LJL + 90 ] . 49 We will return to this issue in section 6 . 4 . 9 . C O C O D OC D ISTRIBUTED A RCHITECTURE 157 based on the X window system may need to customise resource identifiers for items such as windows and graphical contexts [ WoFS95 ] ) . – The replicated architecture requires more computational resources than a centralised architecture . This may be problematic in case of heavily loaded computers , or with applications that require extensive computational resources . – Some legacy application programs may only run on particular computing platforms , which may not be available to all conference members , thus preventing using a replicated architecture . – The centralised architecture has a single point of failure , viz . the computer that runs the shared application . This may be unacceptable when high reliability is required . – The centralised architecture requires specific mechanisms to migrate the application [ ChDe96 ] when the computer on which it runs becomes inaccessible , e . g . , because its user leaves the conference or disconnects from the network . – Some applications may produce effects that require single - execution semantics [ LJL + 90 ] . Unlike display updates , such effects should not be replicated . For example , when sharing a replicated application that can send E - mail or manage control rods in a nuclear power plant , repetitively sending the E - mail to an addressee or repetitively raising the rods by 10 cm would typically not be the desired semantics of a single action . A replicated architecture requires specific measures to prevent such repetitive actions , or to collate such repetitive actions into a single action . – The centralised architecture requires capturing output events ( so they can be multicast to different users ) before they are delivered to the user interface , which may be difficult in some windowing systems [ AKK + 97 ] . From this example , we can conclude that there is no optimal distributed application sharing architecture for all occasions . This is reflected in the architectures adopted by existing application sharing systems : some application sharing systems are based on a centralised architecture ( e . g . , XTV [ AbFe91 ] , Rapport [ AhEL90 ] , Dialogo [ LaLa90 ] and SharedX [ GaWY94 ] ) , whereas other application sharing systems are based on a replicated architecture ( e . g . , MMConf [ CMB + 90 ] , CECED [ CLF + 93 ] , JCE [ AKK + 97 ] and a recent version of XTV [ AKK + 97b ] ) . The optimal architecture depends on the qualities of the application sharing service that are to be optimised and the context in which the architecture operates . 158 C HAPTER 6 C OLLABORATIVE C OMPOUND D OCUMENT E DITING 6 . 3 . 2 A Model of Distributed Groupware Systems Deciding on the way grouplets are distributed means deciding on the allocation of grouplet functions to units of distribution in a distributed system . As illustrated by the application sharing example , these units of distribution may be computers that are interconnected by a network . The units of distribution may also be smaller units , such as processes on a single computer , which are interconnected by inter - process communication , or larger units , such as clusters of interconnected computers on a LAN , which are interconnected via a WAN . In order to make our analysis that leads to structuring guidelines for distribution more generic , we abstract from particular details of the actual unit of distribution , viz . we abstract from the fact whether the unit of distribution is a computer , a process on a single computer , or a larger cluster of tightly interconnected computers , retaining only the essential assumptions that should be made about units of distribution in a distributed system . Such assumptions can be captured in a model of distributed groupware systems . In particular , such a model should express the assumptions that developers should make about the distributed system , which may be radically different from a non - distributed system , as observed in the ANSA project : “ In a distributed system , a number of assumptions that may be made for a centralised system are not valid . Being able both to cope with the problems and to exploit the opportunities of a distributed system requires a different set of assumptions “ [ Rees94 ] . The ANSA computational model identifies areas that require different assumptions , including : communication latency , concurrency , failures , heterogeneity , autonomy of administration , evolution and scaling . In our model of distributed groupware systems , we focus primarily on communication latency , concurrency , and failures , which seem to cause the most problems for developers of distributed groupware systems 50 . We model a distributed groupware system as a collection of processes 51 , which are the units of distribution . The following assumptions can be made about processes in a distributed groupware system . – Communication between processes ( e . g . , network communication ) is computationally much more expensive than communication within a process ( e . g . , procedure calls ) . – Events in different processes may be concurrent , whereas events within a process are not concurrent . To be more precise , we use Lamport’s model of a distributed system [ Lamp78 ] , as will be defined in more 50 More on this in section 6 . 3 . 5 . 51 These abstract processes denote units of distribution that may map to concrete processes in a computing environment , but also to larger units of distribution , such as computers or clusters of interconnected computers . C O C O D OC D ISTRIBUTED A RCHITECTURE 159 detail in appendix B . Concurrency may be the result of true concurrency , e . g . , because each process runs on a different processor , or it may be the result of pre - emptive scheduling of processes on a single processor . Concurrency allows different processes to make progress independently of each other . In a non - concurrent system , e . g . , a system in which different processes make progress in lock - step , heavily loaded or slow processors could easily bring down the responsiveness of the whole system , or handling of computationally expensive uncoupled actions of a single user may temporarily freeze the whole system , which causes discomfort for other users [ Patt91 ] . By developing a distributed system under the assumption of concurrency , such undesirable behaviour can be prevented and responsiveness of the system can be improved . However , dealing with concurrency requires developers to synchronise the progress in different processes when necessary . – Processes may become temporarily inaccessible . Processors or networks may fail , which is a common assumption in fault - tolerant computing . More importantly for groupware systems , processes may become inaccessible , because a user leaves the conference , or because a conference member disconnects from a network . Despite this , the groupware system should typically provide its service for the remaining conference members and support later rejoin or reconnection of the user . With the model as described above , many distributed groupware systems can be adequately captured . However , dealing with these assumptions in the development of groupware systems is very complex and error - prone . 6 . 3 . 3 Options for Distribution Now we have defined distribution in a distributed groupware system as mapping the functions of grouplets onto processes , we focus in more detail on the options for this mapping , that are available for groupware developers . Centralised and replicated distribution , the two main distribution options for application sharing systems ( see section 6 . 3 . 1 ) , are also the two extremes for the distribution of grouplets in general : – in a fully centralised architecture , only a single copy of the grouplet is present at one of the processes ; – in a fully replicated architecture , there is a process for each user that runs one copy of the grouplet ; each copy receives the input and calculates state changes and outputs . As we observed from the application sharing example , no single architecture is optimal for all occasions . Various options in between these 160 C HAPTER 6 C OLLABORATIVE C OMPOUND D OCUMENT E DITING two extremes exist , that can soften the dilemma between the centralised and the replicated architecture : – Centralised architecture with migration : Only a single copy of the grouplet is present at one of the processes , but it can migrate to another process ( see [ ChDe96 ] ) . Migration can be initiated in response to , e . g . , changes in the load on the computer hosting the grouplet process , a user with a computer that hosts the grouplet process leaving the conference , or a user with a powerful computer joining the conference . – Coordinator / cohort replication [ LaMa97 ] ( also known as passive replication [ OsEd94 ] ) : One grouplet entity , the coordinator , receives input , calculates state updates and sends it to all others , who only process state updates . This style of replication is primarily suited to optimise response times when calculating state updates is computationally expensive relative to communication or when the computational load of the coordinator function for different grouplets can be handled by different processes . – Coordinator / cohort replication with migration : This option is similar to coordinator / cohort replication , but the coordinator can migrate to another process dynamically . Another option that can soften the dilemma between the centralised and the replicated architecture is to decompose the grouplet into smaller objects and to take distribution decisions for each of these objects separately . This option is further explored in the following section . 6 . 3 . 4 Distribution in the Collaborative Zipper Architecture In the distributed collaborative zipper architecture , which adds distribution decisions to the to the collaborative zipper architecture ( see also Figure 6 - 5 and Figure 6 - 7 ) , we distinguish two kinds of distribution : horizontal distribution and vertical distribution . Horizontal Distribution Instead of deciding on distribution options for grouplets as a whole , the distributed collaborative zipper architecture allows programmers to decide on distribution for each level separately , based on factors that may differ per level , such as the performance requirements , consistency requirements and the frequency and nature of the actions at that level ( for more factors , see section 6 . 3 . 5 ) . Thus , semi - replicated architectures may emerge , in which some levels are replicated and some centralised . In principle , all combinations are possible , although in practice , the lowest level , which C O C O D OC D ISTRIBUTED A RCHITECTURE 161 handles the physical user interface , will typically be replicated , since the user interface of each user is typically handled by a separate computer 52 . The type of distribution chosen at a zipper level determines which options are available for coupling of actions . Centralisation at a particular zipper level in practice implies coupling 53 at this level and at higher levels . For example , is makes no sense to have uncoupled document models ( which implies that the status that results from edit actions may be different ) , while view control status such as scrollbar status is coupled . Figure 6 - 14 illustrates the distributed architecture and the coupling modes of a grouplet that result from design decisions to centralise grouplet file status and to replicate all other levels in a four - level collaborative zipper architecture ( cf . Figure 6 - 7 ) . interfacecoupling viewcoupling editcoupling filecoupling Tight coupling Loose coupling uncoupled state ; replicated Legend : strictly coupled state : centralised grouplet edit status grouplet file status grouplet view control status grouplet user interface control status process strictly coupled state : replicated Note , that a zipper level that uses a replicated architecture allows for coupling and uncoupling of that level . Vertical Distribution In addition to horizontal distribution , adjacent levels of the collaborative zipper architecture may be vertically distributed , i . e . , they run in different processes ( cf . Figure 6 - 12 ( right ) , Figure 6 - 16 and Figure 6 - 17 ) , instead of in the same process ( cf . Figure 6 - 12 ( left ) and Figure 6 - 14 ) . For example , 52 The exception to this rule being the co - authoring system MMM , which presented the user interfaces for all users at a single computer [ Bier91 ] . 53 The exception to this rule being the groupware toolkit Rendezvous [ PHR + 90 ] , which allowed each user to have a different view , yet handled all of them on one computer . Figure 6 - 14 Distributed architecture of a grouplet with four coupling levels ( rows ) ; the distribution choices at each level ( cf . Figure 6 - 7 ) allow users to choose between four kinds of coupling ( columns ) 162 C HAPTER 6 C OLLABORATIVE C OMPOUND D OCUMENT E DITING one zipper level may be horizontally replicated and may run on desktop computers , whereas another zipper level runs centralised on a server computer , similar to contemporary client - server or multi - tier applications . There may be several reasons to distribute the zipper vertically across multiple processes , including : – Using processes that have a longer lifetime than processes that are devoted to a single user . This requires distributing the zipper across multiple computers , in order to include servers that are always up and running . Processes on user computers may cease to exist when its user leaves the conference ( e . g . , by switching off his PC ) . – Using powerful machines for computationally expensive actions , such as executing pattern recognition algorithms on a shared X - ray image in a diagnostic conference between medical specialists . – Using a central file server for storage and retrieval of CoCoDoc grouplet file status 54 , which may be more reliable than storing files on user PCs . – Using a central directory server for conferences ( applies to conference management grouplets only ) . Existing Architectures and the Distributed Collaborative Zipper Architecture The distributed collaborative zipper architecture is more abstract and general than most distributed groupware architectures , such as those found in many groupware platforms : their concrete distributed architectures can be obtained by varying the number and nature of the levels , and the horizontal and vertical distribution decisions . Below , we provide a few examples . As illustrated in Figure 6 - 15 , a GroupKit conference application ( which corresponds to a grouplet ) uses a fully replicated architecture at all levels : – X servers , which handle low - level user interface aspects , are replicated ; – GroupKit widgets , which handle high - level user interface aspects , based on Tcl / Tk widget library , are replicated , and – the functional core of a GroupKit application is replicated [ RoGr96 ] . The only centralised component of GroupKit is the registrar , GroupKit’s conference management grouplet for a super - conference from which conferences can be started ( not shown in Figure 6 - 15 ) . Some other groupware platforms that use a fully replicated architecture include MMConf [ CMB + 90 ] , DistEdit [ KnPr90 ] , GINA [ BeGe93 ] , 54 Note that horizontal distribution decisions are orthogonal to vertical distribution decisions : the file server may be either centralised or replicated . Using a replicated file server in this case implies that a file server replica is not handled in the same process as the process that handles the other levels . C O C O D OC D ISTRIBUTED A RCHITECTURE 163 SCOOT [ CFS + 94 ] , ObjectWorld [ TBE + 94 ] , COCOON [ Koll95 ] , Multiware [ CoMa96 ] and Corona [ HMJ + 96 ] . process A process B user A user B X server multi - user widgetsTcl / Tk conf . appl . X server multi - user widgetsTcl / Tk conf . appl . A groupware system implemented on top of Clock [ GrUN96b ] uses a collaborative variant of the Model - View - Controller ( MVC ) [ KrPo88 ] single - user application architecture . As illustrated in Figure 6 - 16 , Clock - based systems use a centralised architecture at model level , whereas view and controller together constitute a single zipper level , which uses a replicated architecture . The model on the one hand and the view / controller on the other hand are vertically distributed : the model process runs at a central server computer , whereas view / controller processes run at client computers of each conference member . Clock does not provide any facilities for view or controller coupling . However , this is possible with this distribution architecture , as demonstrated by the groupware platforms Jupiter [ NCD + 95 ] and Suite [ DeCh95 ] . process A process B user A user B X server view / controller X server view / controller model process C Figure 6 - 15 GroupKit distributed architecture Figure 6 - 16 Clock distributed architecture 164 C HAPTER 6 C OLLABORATIVE C OMPOUND D OCUMENT E DITING A groupware system implemented on top of Rendezvous [ PHR + 90 ; HBR + 94 ] also uses a collaborative variant of the MVC architecture . As illustrated in Figure 6 - 17 , Rendezvous - based systems use both a centralised model layer ( an “abstraction” in Rendezvous terminology ) and centralised view layer , whereas low - level user interface handling ( with X window servers ) is replicated . In the centralised view layer , which runs on a single computer , a lightweight process is instantiated for each conference member 55 , in order to handle that member’s view . Both coupled views as well as different , i . e . , uncoupled views , are possible in Rendezvous . The model and view level on the one hand and the low - level user interface handling level on the other hand are vertically distributed : the model and views run on a central server computer , whereas low - level user interface processes run at client computers of each conference member . process A process B user A user B X server view / controller X server view / controller abstraction process C 6 . 3 . 5 Factors in Distribution Decisions Both for application sharing systems ( section 6 . 3 . 1 ) and various levels in a collaborative zipper architecture ( section 6 . 3 . 4 ) , it seems that there is no optimal distribution choice for all occasions . Instead , the optimal distribution architecture depends on various factors . Below , we summarise the various factors that we derived from literature that influence the choice for a particular distribution architecture , viz . : – qualities of a grouplet service that may be optimised ( see Table 6 - 2 ) ; – characteristics of the underlying computing and communication infrastructure ( see Table 6 - 3 ) ; 55 Hence , at another level of granularity , the rendezvous view layer is replicated . Figure 6 - 17 Rendezvous distributed architecture C O C O D OC D ISTRIBUTED A RCHITECTURE 165 – facilities that a grouplet bus ( and in particular , its intra - grouplet interaction functions ) can provide on top of the underlying infrastructure ( see Table 6 - 4 ) . Quality Description performance The extent to which a grouplet service provides short response and notification times for actions and high throughput of series of actions . fairness The extent to which all conference members see roughly equal performance , including the extent to which a grouplet service can prevent one user’s action to slow down unrelated actions of other users , thus providing predictable response times ( cf . [ Patt91 ] ) . consistency The extent to which various collaborative consistency management policies can be provided , e . g . , inconsistency avoidance , inconsistency detection , slicing , operational transformation , diff & merge , or no consistency management at all . flexible consistency The extent to which consistency management can be changed during a conference , e . g . , to change the coupling level ( also known as flexible coupling ) . reliability The extent to which a grouplet service behaves correctly ( e . g . , according to its specification and without deadlock ) , despite partial failures such as processor and network faults . availability The extent to which a grouplet service is available to conference members , e . g . , despite other conference members leaving or disconnecting from the conference , or despite partial failures 56 . scalability The extent to which a grouplet service’s performance is not affected by a growing number of conference members . single - execution semantics The extent to which a grouplet service is able to provide single - execution semantics for particular non - idempotent 57 actions that operate on a single object . Quality Description communication - related Factors such as latency , jitter , throughput , reliability , and disconnection . processing - related Factors such as processing power and memory capacity available to grouplet processes of the various processors on which the processes run . heterogeneity In heterogeneous computing environments , ( legacy or other non - Java ) applications and grouplets are not portable ( or migratable , for that matter ) . 56 Reliability and availability are different : a reliable service can make system temporarily unavailable . 57 Non - idempotent actions are actions a (cid:1) S m , for which Α s (cid:1) S m : a ( a ( s ) )  a ( s ) , i . e . , that do not result in the same result if executed repetitively on a single object . Table 6 - 2 Target factors : desired qualities of the grouplet service Table 6 - 3 Source factors : the underlying infrastructure 166 C HAPTER 6 C OLLABORATIVE C OMPOUND D OCUMENT E DITING Quality Descriptions ease of programming Factors such as the extent to which programmers can maintain conventional ( single - user , non - distributed ) assumptions about programming to implement correct and well - performing grouplets , and the extent to which programmers are only selectively exposed to multi - user distribution issues in order to get better grouplet services . grouplet independence The range of grouplets the platform can support effectively and efficiently . infrastructure independence The range of underlying infrastructures on top of which the platform can function effectively and efficiently . The relations between grouplet service requirements , underlying infrastructure , intra - grouplet interaction support and distribution decisions are complex . Without trying to be complete , we derived the following conclusions from groupware literature about the relations between these factors , which will help us derive structuring guidelines for distribution and requirements for platform support for intra - grouplet interaction in a grouplet bus . – Performance requirements , consistency requirements , latency of the underlying communication infrastructure and ease of programming are the determining factors in choosing a distribution architecture . – High performance , high availability on the one hand and strict consistency on the other hand are conflicting requirements [ SoPr94 ] , especially when latency of the underlying communication infrastructure is high . The fundamental problem here is that , in general , preventing the emergence of inconsistency requires communication with other processes in order to determine whether a locally initiated action can be delivered immediately , or has to be delayed 58 . Hence , when latency is high , response times may become unacceptably large . To deal with this problem , many groupware systems and platforms that assume high - latency in the underlying communication infrastructure , provide services for optimistic collaborative consistency management , which allow for temporal inconsistencies that can later be repaired automatically with operational transformation or interactively with diff & merge mechanisms ( see , e . g . , [ BeGe93 ; SuZY95 ; NCD + 95 ; KaBe93 ; SPD + 97 ; SKS + 96 ; ReNG96 ; Kana97 ] ) . Groupware systems that are designed to operate in 58 Unless all actions are commutative ; or unless in a centralised architecture , the process that initiates a state changing action is at the same side of the network as the centralised object that is to be changed ; or , in a replicated architecture , the process that initiates a state changing action happens to posses the lock , or the total ordering token , as will be described in section 10 . This is , however , not always the case . Table 6 - 4 Platform factors : grouplet bus support for intra - grouplet interaction C O C O D OC D ISTRIBUTED A RCHITECTURE 167 disconnected environments ( which can be modelled as networks with occasional very high latency ) , invariably use a replicated architecture and provide optimistic forms of collaborative consistency management , in order to achieve availability ( e . g . , Lotus Notes [ KBH + 92 ] , COCOON [ Koll95 ] , IRIS [ Koch96 ] , Sync [ MuDe97 ] and Timewarp [ EdMy97 ] ) . – On the one hand , the complexity of implementing correct and well - performing replicated architectures is often mentioned as a motivation not to choose a replicated architecture ( see , e . g . , [ LJL + 90 ] ) . On the other hand , many groupware systems and platforms recently have adopted ideas from fault - tolerant computing research , such as techniques and platforms for causally and totally ordered group communication , in order to support collaborative consistency management . Examples of such groupware systems and platforms are : DistEdit [ KnPr90 ] , COCOON [ Koll95 ] , COLA [ TrRB95 ] , NavTech [ CoVe95 ] , Multiware [ CoMa96 ] , DAgora [ SPD + 97 ] , CCTL [ RCH + 97 ] ; Ensemble [ Voge97 ] and Caelum [ ACD + 97 ] . – Performance of naïve implementations versus optimised implementations of distributed groupware systems can differ drastically . For example , developers of the Clock groupware platform implemented both a naïve and an optimised version of their platform . While each version offered the same computational model for application programmers , the applications on top of the optimised platform performed up to a factor 60 better in high - latency environments [ GrUN96b ] . Similarly , group communication services and optimistic concurrency control services can provide performance improvements for replicated architectures while maintaining the simple computational model of single - user , non - distributed architectures for application programmers . Implementing such services correctly and efficiently is very complex , which suggests that such services should be subsumed in the groupware platform [ BiJo87 ] . 6 . 3 . 6 Structuring Guidelines for Distribution Based on the factors identified in the previous section , no single optimal architecture for the distribution of grouplets can be identified . The relations between the various factors involved in distribution decisions still require further research . For each object in a grouplet ( e . g . , for each zipper level in the grouplet ) , developers need to make their own decision , based on the factors in their specific context . To facilitate distribution decisions , we advise the following structuring guidelines , that can be applied to each zipper level in a grouplet : 168 C HAPTER 6 C OLLABORATIVE C OMPOUND D OCUMENT E DITING – use a replicated architecture for a zipper level in a grouplet , particularly when that level should be flexibly couplable and uncouplable ( e . g . , in order to provide coupling control to users ) , but – use a centralised architecture for a zipper level in a grouplet , – when that level requires specialised or excessive processing power that prevents replication , or – when that level is always strictly coupled ( e . g . , will never be uncoupled ) and achievable response and notification times are adequate and fair . 6 . 4 Platform Support for Distributed Grouplets As we observed in the section 6 . 3 . 5 , the complexity of developing groupware systems with a replicated architecture may deter developers from choosing this architecture . Hence , if the structuring guidelines in the previous section are to be useful , a grouplet bus ( which supports generic intra - grouplet interaction ; see section 3 . 2 . 4 ) is required that supports both replicated architectures , centralised architectures and architectures that are partly replicated and partly centralised . In this section , we identify requirements ( section 6 . 4 . 1 ) , useful transparencies ( section 6 . 4 . 2 ) , a computational model ( section 6 . 4 . 3 ) and a small set of key services of a grouplet bus as a platform for distributed grouplets that together enable the construction of both replicated and centralised grouplets in any mix , with a wide range of collaborative consistency management policies ( sections 6 . 4 . 4 - 6 . 4 . 11 ) . 6 . 4 . 1 Platform Requirements To support intra - grouplet interaction , a grouplet bus should : – support replicated , centralised and mixed architectures , as argued above ; – support flexible collaborative consistency management in grouplets ; in particular , it should facilitate the development of grouplets with a zipper that can be dynamically tightened or loosened ( cf . structuring guideline to keep together different forms of coupling and aggregation in a medium in the same grouplet service , on page chap 5 , p . 44 ) ; – support high - latency , high - jitter , low - bandwidth occasionally disconnected communication infrastructures such as the Internet , in addition to low - latency , low - jitter , high - bandwidth , rarely disconnected infrastructures such as LANs ; – provide a gradual learning curve for application programmers , who are not used to programming replicated , or even distributed architectures ; for the most part , programmers should be shielded from these complexities P LATFORM S UPPORT FOR D ISTRIBUTED G ROUPLETS 169 and be able to achieve well - performing correct grouplets ; yet , the platform should allow expert programmers to tailor the behaviour of the platform in order to achieve high - performance for specific grouplets . 6 . 4 . 2 Transparencies To program grouplets , programmers need a computational model , i . e . , a set of assumptions about the way programs are executed . As already mentioned in section 6 . 3 . 2 , the computational model of a distributed systems is much more complex than that of a non - distributed system . A transparency is a feature provided by a platform that allows a programmer not to be concerned with particular details of a computational environment . For example , the ANSA project identified several distribution transparencies ( see Table 6 - 5 ) that may be provided by a platform , which allows programmers to maintain their conventional , non - distributed assumptions about programs and computations . Hence , transparencies can be used as means to simplify the computational model and to achieve a gradual learning curve for application programmers . Transparency Central Issue Result of Transparency Techniques Location The location of an object Programmer unaware of the location of services Naming service Access The method of access to objects All objects are accessed in the same way Remote procedure call Migration The re - location of an object Objects may move without the programmer being aware Load balancing Concurrency Simultaneous access to shared objects Programmers do not have to deal with problems of concurrent access Distributed transactions Replication Maintaining copies of an object System deals with the consistency of copies of data Group communication Failure Partial failures Problems of failure are masked from the programmer Distributed transactions , Group communication As Rodden et al . noted [ RoBl92b ] , due to the different nature of groupware systems compared to conventional distributed systems , desirable transparencies for groupware systems may differ from transparencies that have been identified for distributed systems . In order to find useful transparencies for groupware systems and to see if they are different from the general distribution transparencies , we first focus on application sharing systems ( cf . section 6 . 3 . 1 ) , which may be considered a platform for sharing applications . Application sharing systems in general and replicated application sharing systems in particular Table 6 - 5 Distribution transparencies identified by ANSA ( adapted from [ RoBl92b ] ) 170 C HAPTER 6 C OLLABORATIVE C OMPOUND D OCUMENT E DITING demonstrate a number of interesting transparencies , some for programmers of shared applications and some for users of shared applications : – Replication transparency – To programmers , implementing a replicated application is largely indistinguishable from implementing a conventional application ( except for the few cases that non - determinism or single - execution semantics must be enforced ) . This is also known as member replication transparency . In order to share unmodified existing applications , this is a transparency that must be provided by a platform . – To users , the services provided by shared applications under the centralised architecture or the replicated architecture are largely indistinguishable ( except for QoS features such as performance and availability ) . This is also known as server replication transparency . – Concurrency transparency – To a programmer , developing an implementation of an application that will be used concurrently by multiple users is indistinguishable from developing an application that will be used by a single user . A specific form of concurrency transparency may be found in application sharing systems . Such systems provide collaboration transparency [ LaLa90 ] for unmodified single - user applications : to the application it seems as if there is only a single user . – To a user of a shared application , only partial concurrency transparency can be provided : due to collaborative consistency management or coordination policies that regulate concurrent access , users may have to perform special actions or wait before they can access the application . Full concurrency transparency would mean that users are not aware that other users are concurrently using the application , which would be contrary to the goal of many groupware systems . These transparencies are also useful inside a grouplet at many points in a distributed collaborative zipper architecture : for example , as illustrated in Figure 6 - 18 , at the point where a set of user interface objects ( cf . users ) may use shared artefact objects ( cf . shared application ) . User interface objects Shared artefact objects Figure 6 - 18 Objects sharing other ( replicated ) objects P LATFORM S UPPORT FOR D ISTRIBUTED G ROUPLETS 171 Traditionally , replication transparency has been used in fault tolerant computing and served two goals : – to hide the existence of multiple replicas ; – to hide the existence of multiple versions , i . e . , to hide divergence and to prevent inconsistency between replicas . The policies that are used in fault - tolerant systems to implement the latter transparency do not match well with the requirements of groupware systems . In fault - tolerant systems , inconsistency is a failure that should be resolved as quickly as possible . In groupware systems , temporal inconsistency may be an accepted consequence in high - latency environments in order to get an acceptable response time , or inconsistency may be desired in order to represent multiple versions , which may exist for longer periods . Groupware programmers need more support in order to be able to deal with a much wider range of consistency policies ( cf . section 4 . 2 . 7 ) , ranging from ‘pessimistic’ forms of consistency management such as inconsistency avoidance , to optimistic forms such as inconsistency detection , slicing , operational transformation and diff & merge . Moreover , the consistency policies may change during a the lifetime of a shared object . Therefore , we argue that groupware programmers require two separate transparencies when using shared objects : – Replication transparency , which allows a programmer to abstract from the question whether multiple replicas of state are present in multiple processes , or not ( i . e . , just a single copy of state is present in a single process ) ; – Consistency transparency , which allows a programmer to abstract from the particular collaborative consistency management policy ( and in particular : whether there are multiple versions or not ) and changes in consistency policy . Consistency transparency is always semi - transparent , since programmers may use shared objects and should be able to change the consistency policy of those shared objects dynamically . Hence , consistency transparency suggests that shared objects should present two faces 59 to programmers : a consistency policy - transparent face and a consistency policy - aware face that allows changing the consistency policy . 6 . 4 . 3 Computational Model : Collaborative Object Groups In this subsection , we propose a computational model that provides the transparencies identified in the previous section . It is centred around the notion of collaborative object groups . 59 In some object oriented systems , this may indeed translate to two interfaces . 172 C HAPTER 6 C OLLABORATIVE C OMPOUND D OCUMENT E DITING A collaborative object group is — as its name implies — a collaborative variant of an object group [ ISIS93 ; OsEd94 ; Maff95b ; FaLo96 ; FaLo97 ] . Object groups originate from research into group communication [ GrCo96 ] on the one hand and research into distributed object computing such as CORBA [ OrHE96 ] on the other hand . An object group consists of a number of replicas : the member objects . Basically , an object group provides replication transparency that allows programmers to treat such a collection of member objects as if it were a single object . For example , an invocation of an object group behaves similar to an invocation of a single object . Many groupware systems and platforms have used group communication techniques in general and object groups in particular [ KnPr90 ; Trev94b ; TrRB95 ; Koll95 ; CoVe95 ; CoMa96 ; SPD + 97 ; RCH + 97 ; Voge97 ; ACD + 97 ; HoLu97b ] . Object groups , however , do not provide consistency transparency . Collaborative object groups , in addition to replication transparency , provide consistency transparency : a collaborative object group allows for multiple collaborative consistency management policies and dynamic switching between different policies during its lifetime . For example , during one phase in its lifetime , a collaborative object group may be strictly coupled , i . e . , employ a collaborative consistency management policy that avoids inconsistency , which corresponds to the consistency management policy that has been traditionally supported by object groups . During such phases , a collaborative object group behaves as if it were a single object . During another phase , a collaborative object group may be completely uncoupled , i . e . , allow different versions to emerge and persist . During such phases , a collaborative object group behaves as if each member object is a separate object . Transitions between the various phases are supported by the platform ( see also section 6 . 4 . 8 ) . This facilitates the development of advanced groupware systems in which the coupling level can be varied by changing the collaborative consistency policy of one or more collaborative object groups ( cf . Figure 6 - 14 ) , thus supporting users to collaborate more loosely during some phases in collaborative work and more tightly during other phases of work . Most of the transparencies provided by collaborative object groups can be illustrated by invocations between collaborative object groups . We distinguish four extreme forms of collaborative object groups ( leaving out the intermediary forms of replication identified in section 6 . 3 . 3 ) : – replicated , strictly coupled ; – replicated , completely uncoupled ; – centralised , strictly coupled ; – centralised , completely uncoupled ( we treat the same as centralised , strictly coupled ) . P LATFORM S UPPORT FOR D ISTRIBUTED G ROUPLETS 173 This provides us with 16 possible invocation styles between the four extreme forms of collaborative object groups , as illustrated in Figure 6 - 19 . strictly coupled client replicated server centralised client strictly coupled server uncoupled client strictly coupled server strictly coupled client centralised server centralised client replicated server replicated client uncoupled server uncoupled client centralised server replicated client uncoupled server Collaborative object groups provide programmers with a number of transparencies for such invocations , as identified in Table 6 - 6 . Figure 6 - 19 Theoretically possible invocations between collaborative object groups 174 C HAPTER 6 C OLLABORATIVE C OMPOUND D OCUMENT E DITING Transparency For May abstract from Result of Transparency Server replication transparency client object ( s ) that initiate an invocation replication of the server collaborative object group client object ( s ) may be unaware that server is replicated Client replication transparency server object ( s ) that respond to an invocation replication of the client collaborative object group server object ( s ) may be unaware that client is replicated Member replication transparency group member ( s ) existence of peer objects member objects of a collaborative object group may be unaware of other group members ; creation and deletion of members when users join or leave are handled by the platform Server consistency transparency client object ( s ) consistency policy applied at the server collaborative object group client object ( s ) may be largely 60 unaware of the consistency policy applied at the server object ( s ) ; e . g . , if the latter is strictly coupled , the platform will treat the server collaborative object group as a singleton 61 Client consistency transparency server object ( s ) consistency policy applied at the client collaborative object group server object ( s ) may be unaware of the consistency policy applied at the client object ( s ) ; e . g . , if the latter is strictly coupled , the platform will treat the client collaborative object group as a singleton Member consistency transparency group member ( s ) consistency policy applied in this collaborative object group member objects of a collaborative object group may be unaware of other versions in other group members Concurrency transparency 62 client object ( s ) concurrent activity of other clients client object ( s ) may be unaware of other client object ( s ) invoking actions concurrently on the same collaborative object group 60 As explained in section 6 . 4 . 2 , a client that wants to change the consistency policy must use consistency - policy aware functions of the collaborative object group . 61 When we want to distinguish between an object group that behave as a single object and an object that is a single object , we refer to the latter as a ‘singleton’ . 62 As be explained in section 6 . 4 . 11 , it is not always possible to provide complete concurrency transparency . For example , clients may have to use the collaborative object group’s token service . This is consistent with the incomplete concurrency transparency for users that can be provided by application sharing systems , as described in section 6 . 3 . 1 . Table 6 - 6 Transparencies provided by collaborative object groups P LATFORM S UPPORT FOR D ISTRIBUTED G ROUPLETS 175 These transparencies allow programmers to implement all theoretically possible invocation styles ( cf . Figure 6 - 19 ) as if they were traditional procedure calls ( cf . Figure 6 - 20 ) , while the underlying platform takes care of efficient and reliable execution of the desired form of collaborative consistency management . collaborative object group ( server ) collaborative object group ( client ) 6 . 4 . 4 Platform Support for Collaborative Object Groups In order to support programming with collaborative object groups , a platform must provide support for : – collaborative object group invocations ( see section 6 . 4 . 5 ) : invocations between collaborative object groups and between collaborative object groups and ordinary objects , according to a wide range of collaborative consistency management policies ; – existence management ( see section 6 . 4 . 6 ) : creation and deletion of collaborative object groups ; – membership management ( see section 6 . 4 . 7 ) : members joining , leaving , disconnecting and reconnecting to collaborative object groups ; – flexible collaborative consistency management ( see section 6 . 4 . 8 ) : changing the collaborative consistency management policy of collaborative object groups ; – state transfer ( see section 6 . 4 . 9 ) : bringing members up to date ; – reference mapping ( see section 6 . 4 . 10 ) : referring to collaborative object groups , e . g . , in invocations , and in externalised state ; – exclusive privileges ( see section 6 . 4 . 11 ) : getting exclusive privileges to collaborative object groups . Below , we describe each of these services in more detail . Figure 6 - 20 Replication and consistency transparent invocation between collaborative object groups ( dashed lines indicate consistency transparency , grey ovals indicate replication transparency ) 176 C HAPTER 6 C OLLABORATIVE C OMPOUND D OCUMENT E DITING 6 . 4 . 5 Collaborative Object Group Invocations In order to perform an action , a collaborative object group , which we will call the client 63 , invokes a method on an other collaborative object group , which we will call the server . In the most general case , such an invocation may consist of a request , which causes the server to compute a state change and a response , as illustrated in Figure 6 - 21 . request ( s ) collaborative object group ( client ) collation multicast collation multicast collaborative object group ( server ) response ( s ) Requests and responses are sent using messages . In the most general case , the platform should take care of the following issues : – multicast of messages ( see page 176 ) : in what way is a message originating from one sender multicast to multiple recipients ? – reliable message delivery ( see page 177 ) : which guarantees can be provided ? – ordered delivery of messages ( see page 178 ) : in what order should messages be delivered ? – collation of messages ( see page 180 ) : in what way are messages coming from multiple senders collated into one message ? – mapping of invocations on messages ( see page 181 ) : how does the platform implement invocations with messages ? Multicasting Messages Multicasting is the process of sending a single message to multiple destinations . In order to provide server and client replication transparency ( cf . Table 6 - 6 ) , the platform should multicast request messages and response messages , respectively , from a singleton ( or an uncoupled replicated collaborative object group or a centralised collaborative object group ) to a coupled replicated collaborative object group in a single message , as illustrated in Figure 6 - 22 . 63 The terms client and server only indicate a role in one invocation ; the same collaborative object group may be a server or client , respectively , in other invocations . Figure 6 - 21 Requests and responses in an invocation between collaborative object groups P LATFORM S UPPORT FOR D ISTRIBUTED G ROUPLETS 177 request ( s ) collaborative object group ( client ) multicast multicast collaborative object group ( server ) response ( s ) Note , that multicasting of request and response messages in invocations from one replicated coupled object group to another replicated coupled object group is not needed , since replicated collaborative object groups have the same number of members . Instead of multicasting , each member may send request and response message only to the local member of the server and client collaborative object group , respectively . The platform should exploit network multicast services such as ATM multicast , or IP multicast , if possible . Otherwise , it should simulate multicast for the object by sending multiple messages . Some invocations on a collaborative object group are read - only , i . e . , do not update the status of a collaborative object group . The platform should provide a way to programmers to specify this read - only property of invocations , since these requests do not need to be multicast to all members of a coupled collaborative object group , which would all give the same answer . Invoking the local member should suffice when the requirement for reliability and performance are not too strict . Reliable Message Delivery Messages may be lost in transit due to , e . g . , network errors , buffers that overflow , etc . Moreover , messages may not be delivered to all receivers due to crashed senders or receivers . The platform should provide services to deal with such failures , e . g . , by providing : – Negative - acknowledgement - based retransmission . When senders tag their messages with sequence numbers , receivers can detect missing messages . Instead of the positive acknowledgement - based schemes commonly used for point - to - point messages — which send acknowledgements only when ( a series of ) messages is correctly received — multicast protocols such as Amoeba [ KaTa96 ] , XTP [ StDW92 ] and Horus [ ReHB94 ] use a negative acknowledgement scheme — which send Figure 6 - 22 Multicasting in an invocation between collaborative object groups 178 C HAPTER 6 C OLLABORATIVE C OMPOUND D OCUMENT E DITING acknowledgements only when messages are missing — in order to avoid a huge volumes of positive acknowledgements from many receivers . – K - reliable delivery 64 To survive k - 1 simultaneous failures of members ( i . e . , crashes that cause a member to cease processing ) , the platform needs to ensure that k members have received the message before any of them act upon it . When k - 1 members crash , there is still one member that can retransmit the messages to recovering systems . Groupware implementations that allow conference members to leave the conference abruptly , may use k - reliable delivery to survive k - 1 simultaneous abrupt member leaves . Ordered Message Delivery The order in which series of messages from client objects are delivered to server objects in a collaborative object group is crucial for correct and efficient implementation of collaborative consistency management policies . In a distributed environment , messages to objects are delayed due to network latency , processing time and queuing time , causing messages to arrive in different orders at different collaborative object group members . r B ( m 1 ) r C ( m 1 ) r A ( m 1 ) s A ( m 1 ) B r C ( m 2 ) r A ( m 2 ) r B ( m 2 ) s C ( m 2 ) r C ( m 4 ) s A ( m 4 ) r B ( m 4 ) r A ( m 4 ) C A r C ( m 3 ) r A ( m 3 ) s B ( m 3 ) r B ( m 3 ) globaltime As illustrated in Figure 6 - 23 , various ordering anomalies may occur . Group communication research has identified three fundamental types of ordering anomalies , each violating a particular type of ordering : – messages may overtake each other ( r C ( m 4 ) < r C ( m 1 ) ) 65 , which is a violation of first - in - first - out ( FIFO ) ordered delivery ( see section B . 1 in appendix B ) ; 64 This is also known as “quorum processing” in some contexts , e . g . , [ OsEd94 ; FaLo96 ] 65 This is a shorthand notation for “message m 4 is delivered to object C before message m 1 ” . See appendix B for more details . Figure 6 - 23 Example of various ordering anomalies , showing messages m 1 - m 4 ( indicated with arrows ) , and their send ( s ) and receive events ( r ) at three processes ( A , B , C ) P LATFORM S UPPORT FOR D ISTRIBUTED G ROUPLETS 179 – messages that may be a reaction to other messages ( m 3 may be a response to m 1 ) , may be received earlier than the message that carries the action ( r C ( m 3 ) < r C ( m 1 ) ) , which is a violation of CAUSAL ordered delivery ( see section B . 2 in appendix B ) ; – delivery of the same messages may be ordered differently at different sites , e . g . , r C ( m 2 ) < r C ( m 1 ) , whereas r B ( m 1 ) < r B ( m 2 ) , which is a violation of TOTAL ordered delivery ( see section B . 3 in appendix B ) . A platform may provide support to prevent such ordering anomalies . Since we want to provide platform support on top of communication infrastructures that include high - latency , low - bandwidth communication infrastructures such as the Internet ( see section 6 . 4 . 1 ) , we have to assume message latency and jitter may be high ( but finite ) , which implies that performance may be seriously deteriorated by communicating more often than strictly required to achieve the desired form of collaborative consistency . Message delivery according to FIFO , CAUSAL and TOTAL order can be provided by a platform without knowledge of the type of invocations that need to be ordered . Each of the orders FIFO , CAUSAL and TOTAL incurs a increasing communication cost , has a increasing sensitivity to network latency and has increasing requirements for centralised components . Moreover , each of these types of ordering is both necessary and sufficient for a particular class of algorithms . Therefore , each of these types of ordered delivery should be provided by the collaborative object group platform , so developers may choose the appropriate type of ordering for a particular setting . To these three types of ordering , groupware research has added a fourth type of ordering ( TRANSFORMED order ; see section B . 4 in appendix B ) . This ordering , which is based on operational transformation and which exploits knowledge about the type of invocation , can provide better performance than FIFO , CAUSAL and TOTAL ordering in high - latency and disconnected networks , in exchange for less strict consistency ( viz . possible temporary divergence in combination with guaranteed consistency at system quiescence ) . In appendix B , we define and describe FIFO , CAUSAL , TOTAL and TRANSFORMED order in more detail . For each order , we give a definition , present a time - sequence diagram in which ordered delivery and violation of ordered delivery is illustrated and give an impression of the ( communication ) overhead of implementations that deliver messages according to that particular ordering . 180 C HAPTER 6 C OLLABORATIVE C OMPOUND D OCUMENT E DITING Collation of Messages Collation is the process of delivering multiple messages that originate from a coupled replicated object group to a single object . In order to provide server and client replication transparency ( cf . Table 6 - 6 ) , the platform should collate response messages and request messages , respectively , from a coupled replicated collaborative object group into a single message to a singleton ( or an uncoupled replicated collaborative object group or a centralised collaborative object group ) , as illustrated in Figure 6 - 24 . request ( s ) collaborative object group ( client ) collation collation collaborative object group ( server ) response ( s ) Collation in invocations between collaborative object groups usually is trivial . Only when single executing semantics is to be enforced ( cf . section 6 . 3 . 5 ) , e . g . , when a coupled replicated collaborative object group invokes a centralised object group or a singleton object , request collation is required : the first request message that arrives should be delivered , the others can be discarded . For all other cases : sending a message to or from the local member is sufficient : – In fault - tolerant computing , each server object group member should send a response to a client object , which collates the answers into a single or a list of responses according to policies such as unanimous vote , majority vote , majority within time limit , first response , etc . [ OsEd94 ; FaLo97 ] ; this ensures the availability of the service of an object group despite partial failures . For a groupware platform , such strong robustness is usually not required . Hence , in a groupware platform , a collation policy that just sends the response of the local member of a collaborative object group to the client object ( e . g . , a singleton , or a member of a centralised or an uncoupled object group ) will usually suffice . For read - only requests that are not multicast , this is even the only policy possible . – For the same reason , requests from coupled collaborative object groups to uncoupled object groups ( e . g . , a ‘downward’ request in the collaborative zipper architecture that notifies a view object that the Figure 6 - 24 Collation in an invocation between collaborative object groups P LATFORM S UPPORT FOR D ISTRIBUTED G ROUPLETS 181 model has changed ) can use a similar simple collation policy : each member of the client just sends a request to the local member of the uncoupled server object group . – Collation of request and response messages in invocations from one replicated coupled object group to another replicated coupled object group is not needed , since replicated collaborative object groups have the same number of members . Instead , each request and response message is sent only to the local member of the server and client collaborative object group , respectively . Mapping Invocations on Messages In this section , we describe the way a platform should map invocations between object groups on messages . First , we derive the required ordering of messages from the semantics of conventional method invocations . Then , we describe how a platform could provide significantly improved performance of invocations between collaborative object groups in high - latency environments under slightly weaker semantics , viz . one - way invocation semantics . Suppose an object A makes two invocations ( i1 and i2 ) on a method of an object B . A programmer of object A can think of these as two indivisible events . In reality , execution of an invocation takes time . A refined model of an invocation usually models each invocation as two events : a request and a response , as illustrated in the left part of Figure 6 - 25 ( e . g . , invocation i1 consists of two events : i1 rq and i1 rsp ) . In a distributed system , requests and responses are sent with messages , which may take considerable time to reach their destination . Therefore , messages in a distributed system are modelled with two events : a send event and a receipt event , as illustrated in the right part of Figure 6 - 25 ( e . g . , invocation i1 rq consists of two events : s A ( i1 rq ) and r B ( i1 rq ) ) . B A i2 rq i2 rsp i1 rq i1 rsp B A r A ( i2 rsp ) r B ( i2 rq ) s A ( i2 rq ) s B ( i2 rsp ) r B ( i1 rq ) s A ( i1 rq ) s B ( i1 rsp ) r A ( i1 rsp ) Figure 6 - 25 Conventional representation of two invocations ( left ) and their representation as ordered events in a distributed system ( right ) 182 C HAPTER 6 C OLLABORATIVE C OMPOUND D OCUMENT E DITING The conventional semantics of such a sequence of invocations ( i1 < i2 ) and their implications for the ordering of messages are : 1 . the execution of i2 at object B starts after the completion of the execution of i1 on object B , which implies s B ( i1 rsp ) < r B ( i2 rq ) ; 2 . object A is blocked until the execution of i1 has terminated and the results are available at object A , so that the second invocation can use the results of the first , which implies r A ( i1 rsp ) < s A ( i2 rq ) . When object B in reality is a replicated collaborative object group that consists of members B 1 and B 2 , then , in order to provide full server replication transparency , the platform needs to make sure that i1 rq and i1 rq are both multicast to B 1 and B 2 with TOTAL 66 order , which will insure that r B1 ( i1 rq ) < r B1 ( i2 rq ) and r B2 ( i1 rq ) < r B2 ( i2 rq ) , which , together with the fact that B 1 and B 2 are single - threaded , will ensure that s B1 ( i1 rsp ) < r B1 ( i2 rq ) and s B2 ( i1 rsp ) < r B2 ( i2 rq ) . Assuming both B 1 and B 2 produce the same result , the platform only needs to make sure that r A ( i1 rspB1 ) < s A ( i2 rq ) or r A ( i1 rspB2 ) < s A ( i2 rq ) . Assuming B 1 is co - located with A , the platform will only send s B1 ( i1 rsp ) , as discussed earlier and as illustrated in the right part of Figure 6 - 26 . B A i2 rq i2 rsp i1 rq i1 rsp B 1 A B 2 r A ( i2 rsp ) s B2 ( i2 rsp ) r B2 ( i2 rq ) r B1 ( i2 rq ) s A ( i2 rq ) s B1 ( i2 rsp ) r A ( i2 rsp ) s B2 ( i1 rsp ) r B2 ( i1 rq ) r B1 ( i1 rq ) s A ( i1 rq ) s B1 ( i1 rsp ) r A ( i1 rsp ) r A ( i1 rsp ) When the second invocation at object A does not use the results of the first , e . g . , as in adding letters at the end of a text , or as in sending a series of mouse movements , the platform does not have to make sure that 66 Actually , FIFO will do if there is only one object A that makes requests as in this case , even if i1 and i2 are non - commutative ; however in general , there may be more objects issuing requests on the collaborative object group B concurrently , which requires TOTAL order , when no TRANSFORMED order service is available . Figure 6 - 26 Programmer view of invocations on a replicated object group ( left ) and their implementation ( right ) P LATFORM S UPPORT FOR D ISTRIBUTED G ROUPLETS 183 r A ( i1 rsp ) < s A ( i2 rq ) , leaving on only s B ( i1 rsp ) < r B ( i2 rq ) to be assured . This allows for performance improvement by using one - way invocations 67 , which do not wait for responses . Instead , responses can be omitted , while TOTAL ordering guarantees the required ordering , as illustrated in Figure 6 - 27 . B A i2 rq i1 rq B 1 A B 2 r B2 ( i2 rq ) r B1 ( i2 rq ) s A ( i2 rq ) r B2 ( i1 rq ) r B1 ( i1 rq ) s A ( i1 rq ) Using such one - way invocations , the platform can support a considerably higher number of invocations per second , particularly when the one - way network latency is considerably higher than the total time needed in a single invocation to send away the request and response messages across the network (  ( size request + size response ) / network throughput ) plus the time needed to process the invocation (  time between r Bx ( i rq ) and s Bx ( i rsp ) ) , x = { 1 , 2 } , as suggested 68 by Figure 6 - 27 . Although tempting , it would be incorrect for a platform to use the lack of result parameters and out parameters in a method signature in an interface specification of a collaborative object group as an indication that one - way invocation semantics can be applied , since parameters of a subsequent invocation ( i2 ) may causally depend in an intricate way on the results of a previous invocation ( i1 ) . For example , i2 may use the value of a global variable set by i1 or an object variable that has been set by a direct or 67 These are also known more generally as asynchronous remote procedure calls , or , in ANSA and ODP as announcements [ OsEd94 ; FaLo97 ] . 68 Note that Figure 6 - 27 does not correctly represent a situation in which communication delays to one member of the invokes object group is significantly smaller than to the others . When a token - based implementation of TOTAL ordering is used as described in appendix B ( with a migrating arbitrator ) and responses from other members are discarded , the optimisation that can be achieved through one - way invocation semantics , is insignificant for invocations other than the first in a series . Figure 6 - 27 Programmer view of one - way invocations on a replicated object group ( left ) and their optimised implementation ( right ) 184 C HAPTER 6 C OLLABORATIVE C OMPOUND D OCUMENT E DITING indirect invocation back to the object that invoked i1 , as illustrated in Figure 6 - 28 . Unless a platform can trace such hidden causal dependencies , it is best to have one - way invocation semantics declared by the programmer . i1 rq i1b rq B A i1b rsp i1 rsp i2 rq i2 rsp B A r B ( i2 rq ) s A ( i2 rq ) s B ( i1b rq ) r B ( i1 rq ) s A ( i1 rq ) r A ( i1b rq ) 6 . 4 . 6 Existence Management of Collaborative Object Groups Replicated collaborative object groups are created based on some existing object 69 and an object group factory . Collaborative object group creation is a three - stage process : 1 . The object , say O , that is to be turned into a replicated collaborative object group is invoked to do so . One of the parameters is a reference to the collaborative object group factory , say OGF , that should be used . 2 . O invokes OGF  which is a collaborative object group with specific factory capabilities  to create the required other members ( i . e . , one for each user , except for O , which already exists ) . The factory must itself be a collaborative object group ( in order to be able ask its peers to create a replica ) . Each medium that is added to a conference ( see also section 5 . 2 . 1 . ) always creates a default collaborative object group factory , which can be used to create other collaborative object groups . 3 . OGF asks O for a an image of the object state and instructs its peers to create the required member objects , and to initialise it with the state update obtained from O . This requires that O be able to participate in 69 This allows turning objects into collaborative object groups that are created and initialised by collaboration - transparent frameworks . Taking specific action such as turning an object into an object group can generally be done at the earliest when the object’s initialisation method is called by the framework . We used this feature to make the OpenDoc framework collaborative ( see also section 7 ) . Figure 6 - 28 Hidden causality between i1 and i2 through a call - back ( i1b ) that sets an object variable ( left ) and an incorrect implementation according to one - way optimisation ( right ) P LATFORM S UPPORT FOR D ISTRIBUTED G ROUPLETS 185 state transfer , which is also required when members are added or deleted from the conference , and when the collaborative consistency policy is changed ( see section 6 . 4 . 9 ) . When an object group is created , at first , it is strictly coupled . During its lifetime , the consistency policy can be changed dynamically , as described in section 6 . 4 . 9 . 6 . 4 . 7 Membership Management of Collaborative Object Groups When a new participant joins a running conference that contains a medium that uses collaborative object groups , the medium must be instantiated for the new participant and brought up to date . This requires instantiation of a new collaborative object group member for each replicated collaborative object group that is used in the medium . Moreover , depending on the collaborative consistency policy employed for an collaborative object group , a new object group member may have to receive a state update ( see section 6 . 4 . 9 ) . The join ( and leave ) of a object group member should be totally ordered with respect to other , regular messages . When a participant leaves a conference , all local members of replicated collaborative object groups should be deleted . When the last participant leaves the conference , the platform should notify the collaborative object group member , so it can write the state of the object group to persistent storage if appropriate , e . g . , to allow the conference to be resumed or restarted with the medium in the same state . 6 . 4 . 8 Flexible Consistency Management In order to support consistency transparency and flexible coupling in the distributed zipper architecture , the platform should at least support dynamic switching between the following collaborative consistency policies during the lifetime of a collaborative object group : – strictly coupled ( also known as “coupled” ) ; – uncoupled . In addition , to support improved flexibility and better performance in high - latency environments , the platform should support ( see also the section entitled “ Allowing Inconsistency and Re - establishing Consistency ” in section 4 . 2 . 7 and section B . 4 in appendix B ) : – operational transformation ; – slicing . 186 C HAPTER 6 C OLLABORATIVE C OMPOUND D OCUMENT E DITING The different collaborative consistency management policies have the following effects on the collaborative object group’s behaviour , as indicated in Table 6 - 7 . Consistency policy Description Updates Ordering used strictly coupled no inconsistency multicast TOTAL operational transformation consistency at system quiescence multicast TRANSFORMED slicing syntactic consistency multicast CAUSAL uncoupled unconstrained divergence not multicast : local execution none The collaborative consistency management policy of a collaborative object group can be changed dynamically by other objects using a special invocation that is always executed under TOTAL order . When a collaborative object group is requested to switch to strict coupling , or when an uncoupled collaborative object group is requested to switch to operational transformation consistency , the states of the members should become the same . There are two main approaches to achieve this : – The state of a single member becomes the global state , e . g . , when a teacher couples the views of all students to his own view in order to show something , or to a student’s view to let the student show something in a distributed class ; this requires the state of a single member to be multicast to others as a single state update . – The state of all members should be multicast to all other members as state updates and merged , e . g . , when authors have worked uncoupled on a piece of text for a while . When an uncoupled collaborative object group is requested to switch to sliced consistency , the state of all members should be multicast to all other members as state updates and merged syntactically . 6 . 4 . 9 State Transfer State transfer , i . e . , sending state updates is necessary in a variety of circumstances : 1 . when a collaborative object group is created ; 2 . when new members are added to a collaborative object group , and 3 . when a collaborative object group is requested to switch to a tighter form of collaborative consistency management . Table 6 - 7 Collaborative consistency management policies P LATFORM S UPPORT FOR D ISTRIBUTED G ROUPLETS 187 There are two main approaches to state transfer : – Send a buffered sequence of update messages . This strategy may use the same way of buffering and garbage collecting actions as the TRANSFORMED ordering algorithm ( see section B . 4 in appendix B ) , though for state transfer , which happens relatively infrequently , the buffer is typically stored on disk . When it takes very long until state transfer is required , the buffer may grow rapidly and sending the buffered messages may take long . Moreover , duration and side effects other that calculating new state of replaying messages may be problematic [ ChDe96 ; OsEd94 ] . In such cases case , the second strategy may be used . – Send an image ( also known as a checkpoint ) of the current state . In order to use this approach , a collaborative object group member must be able to externalise its status into , e . g . , an octet stream . Moreover , it needs to be able to internalise such externalised status . The state of an object consists of the values of its attributes and relations with other objects . For state transfer , the values of attributes can be externalised , transferred and internalised using standard mechanisms . References to other objects must be treated differently : simply transferring an object reference to other members may lead to meaningless references , if object references with local significance are used . Similar to requesting persistent references for objects from a platform , in order to store its state persistently , a collaborative object group member should request an externalised object reference from the platform , in order to externalise its state for state transfer . 6 . 4 . 10 Mapping Collaborative Object Group References In order to achieve server replication transparency , a collaborative object group should be referred to as if it were a single object . When collaborative object group references are used that have local significance only ( i . e . , the reference to the local object group member is used as a reference to the collaborative object group ) , mapping of collaborative object group references is required for a variety of situations : – references to a collaborative object group used as a target of method invocation should be expanded into a multicast address to which a message should be send ; – references to a collaborative object group as a ( part of a ) parameter in an invocation to another collaborative object group should be mapped on the object reference of the corresponding local member object ( for replicated collaborative object groups ) or proxy object ( for centralised collaborative object groups ) ; 188 C HAPTER 6 C OLLABORATIVE C OMPOUND D OCUMENT E DITING – references to a collaborative object group in an externalised stream ( e . g . , for persistent storage , or for state transfer ) should be mapped by the objects that make the streams by requesting an appropriate reference from the platform . 6 . 4 . 11 Obtaining Exclusive Privileges with a Token Service Token services for collaborative object groups provide their users  i . e . , client objects and , indirectly , human users  with temporary exclusive privileges . Such services are required in situations where concurrent , totally ordered invocations on collaborative object groups result in behaviour that is  although consistent ( i . e . , equivalent for all object group members )  not the desired behaviour . Such situations may arise both at user level and at program level : – Suppose , two users are concurrently editing a text , with a service that couples each individual insertion and deletion of a letter with totally ordered invocations on a coupled replicated collaborative object group . Although the text will remain consistent despite concurrent actions , unwanted conflicts may occur when the two users change the same sentence or start typing at the same position . To deal with such cases , programmers should have mechanisms to give users temporary exclusive privileges to parts of the text , in a response to explicit or implicit user request . For this purpose , a programmer can create a number of tokens on an object group ( such as a sentence lock token or a word lock token ) , which can be given to client objects . – Suppose , that dragging an object on a shared whiteboard is implemented with an action set _ position ( x , y ) , where x and y are the new coordinates of the centre of the object . When two users are dragging the same object simultaneously in opposite directions and each small drag action is coupled to other users using totally ordered delivery , this may result in the object frantically moving between two positions , while in the end , the last user to release the mouse will “win” [ GrMa94 ] . This behaviour clearly signals concurrent use of the same object . Would the drag action have been implemented as an incremental action move _ position ( dx , dy ) , then the same user actions would result in a smooth drag of the object that “adds” the movements proposed by both users . This behaviour does not signal concurrent use as clearly as the former behaviour , but it allows both users to contribute . Another alternative is to use a coordination service that uses a token service to give the privilege of dragging the mouse to a single user at a time . Depending on the circumstances , either of the above implementations may be the desired one . This example further shows that complete concurrency transparency for the implementation of collaborative object P LATFORM S UPPORT FOR D ISTRIBUTED G ROUPLETS 189 groups is virtually impossible : a different implementation of a collaborative object group that would have resulted in equivalent behaviour for single - user use may give completely different behaviour for multi - user use . – Totally ordered delivery of invocations does not prevent the possibility of deadlock . Suppose , that two clients , client1 and client2 , concurrently issue a series of three requests on a collaborative object group ( which may be either replicated or centralised ) , in order to execute a request from their respective users . The first two requests reserve resources : resource A and resource B , which are required in order to execute the third request . When the client1 first requests resource A and then resource B , and the second client first request resource B and then resource A , totally ordered delivery does not prevent reserve ( client1 , resource B ) to be delivered directly after reserve ( client2 , resource A ) . When all resources were free in the beginning and are always granted when they are free , both clients may now be waiting until the other releases the required resource , i . e . , the system is in deadlock . As may be observed from the first two examples , token services will often be used as a mechanism to implement coordination services , such as floor control , locking of objects in shared whiteboards , and locking of sections in text . For each collaborative object group , programmers can create a number of tokens . The token service ( which can be based on the service primitives create _ token , destroy _ token , request _ token , release _ token , give _ token , take _ token [ GSS + 93 ] ) only makes sure that a token is possessed by at most one client at all times . It is up to the user of the token service , i . e . , the grouplet programmer , to make sure that the client objects that use the token service respect the semantics of the tokens they created . For example , in a shared whiteboard that uses a number of coloured markers to draw annotations on an overlay , a programmer might create one token for each marker , e . g . , GREEN _ MARKER _ TOKEN , a RED _ MARKER _ TOKEN and a BLUE _ MARKER _ TOKEN ; the token service only makes sure that each token is possessed by at most a single client at all times ; it does not prevent a client from invoking the actions on the collaborative object group that holds the whiteboard state , such as draw _ line ( green , x1 , y1 , x2 , y2 ) ; preventing this is the responsibility of the client , not the responsibility of the token service . The token service can offer two special tokens for each collaborative object group , which deliver a special service : – The WRITE - LOCK token can be used by clients to get the exclusive privilege of issuing invocations other than read - only invocations on the collaborative object group . When the WRITE - LOCK token is created and 190 C HAPTER 6 C OLLABORATIVE C OMPOUND D OCUMENT E DITING is possessed by a client , the token service will deny all invocations , except invocations that are declared as read - only invocations , from clients that do not have the WRITE - LOCK token . Totally ordered delivery of invocations , in combination with the WRITE - LOCK token is implemented on top of CAUSAL delivery of messages , in combination with a total order token ( see also section B . 3 in appendix B ) that follows the WRITE - LOCK wherever it goes . The total order token will stay with the client that has the WRITE - LOCK token , until the latter is released , given to some other client , or taken by another client . Invocations that are declared with read - only semantics , even those for which totally ordered delivery is requested , do not wait for the total order token . Instead , they will be sent with CAUSAL order semantics , which optimises the performance of read - only invocations ( without the WRITE - LOCK , they would have to wait until the total order token arrives ) . – The READ - LOCK token can be used by clients to get the exclusive privilege of issuing read - only invocations on the collaborative object group . The implementation of the read - lock token is similar to the write - lock token . The READ - LOCK token will almost invariably be requested by clients in combination the WRITE - LOCK token , in order to get temporary exclusive access to the collaborative object group . This can be used to achieve ordered delivery of invocations on collaborative object groups that is not interleaved by delivery of other invocations , which could occur with TOTAL order [ ChSk93 ] . Such a grouped delivery order that is also known as atomic order [ Koll95 ] . This order may be useful for a series of actions that constitute a transaction on a collaborative object group , such as a series of actions that is needed to book an event in a set of individual shared calendars . In order to allow the programmer to avoid deadlock that could occur when multiple tokens on a single collaborative object group are required , e . g . , both the WRITE - LOCK token and the READ - LOCK token , multiple tokens can be requested with a single token primitive . Similarly , when multiple tokens on multiple collaborative object groups are needed , as may be the case in the shared calendar example in the previous paragraph , multiple tokens on different collaborative object groups can be requested with a single token primitive . 6 . 5 Conclusions In this chapter , we proposed collaborative compound document editing as a new paradigm for editing documents . As the foundations of CoCoDoc , we presented structuring guidelines and architectures for the design of C ONCLUSIONS 191 extensible and composable collaborative document editing media , for each of the three levels of design identified in chapter 3 , i . e . , service level , logical level and distributed level . In addition , we described a compound document editing platform and a collaborative object group platform that support the development and use of CoCoDoc grouplets , which are the units of design , extension and composition in a collaborative compound document editing medium that conforms to the presented structuring guidelines and architectures . At the service level , we found that extensible and composable collaborative document editing media services can be designed by using structuring guidelines that may be derived from contemporary compound document editing architectures . This combination , which we coined collaborative compound document editing , allows for composition of the services of collaboration - transparent and collaboration - aware CoCoDoc grouplets in a collaborative editing service for a single document . Unmodified single - user editing applications , such as OLE 2 . 0 based applications , may be re - used as collaboration - transparent CoCoDoc grouplets , which combine the feature - rich single - user editing services with file coupling and user interface coupling as rudimentary collaboration services . Collaboration - aware CoCoDoc grouplets , which may provide richer forms of collaboration , such as more coupling levels , have to be developed specifically for the CoCoDoc context . The ability to compose both collaboration - transparent and collaboration - aware CoCoDoc grouplets represents an important contribution to compound document editing : whereas compound document editing only supports step - wise migration towards editing new media types , collaborative compound document editing in addition enables a step - wise migration from an installed base of single - user editors with rich editing features and rudimentary collaborative features , towards an environment that includes CoCoDoc grouplets with more advanced features for collaboration . Thus , CoCoDoc facilitates a gradual migration towards collaborative editing systems that are both rich in editing support and rich in collaboration support . At the logical level , we presented the collaborative zipper architecture , which facilitates the construction of CoCoDoc grouplets that can provide many coupling levels and can give users extensive control over coupling . At the distributed level , we presented the distributed collaborative zipper architecture , which allows both for vertical distribution between zipper levels and for horizontal distribution within a zipper level . We found that neither centralised nor replicated architectures for horizontal distribution are optimal for all occasions . The ideal choice depends mainly on performance requirements , collaborative consistency management requirements and ease of programming . However , we also found that 192 C HAPTER 6 C OLLABORATIVE C OMPOUND D OCUMENT E DITING replication is almost invariably needed for grouplets that should support flexible coupling , for grouplets that should perform well on top of high - latency and low - bandwidth communication infrastructures such as the Internet and for grouplets that should be available despite disconnection . However , distribution in general and replication in particular , do not match well with the assumptions programmers can make in conventional computational environments . Combining this with requirements for flexible collaborative consistency management , grouplet programmers are faced with a very complex and error - prone task . Two related platforms have been proposed to support this task . The first , the CoCoDoc framework , primarily focuses on support for the service and logical architecture of collaborative compound document editing media . It should support embedding relations between CoCoDoc grouplets , compound document storage , compound document user interfaces , document - wide coupling control and view control , shared file editing , shared user interface editing , encapsulating single - user editors as CoCoDoc grouplets and it should provide support to develop new collaboration - aware editors , based on distribution support for grouplets provided by the second platform , the collaborative object group platform . The collaborative object group platform should support a computational model of collaborative object groups , and should provide replication and consistency transparency for programming with such collaborative object groups . Thus , programmers are free to decide on the horizontal distribution , i . e . , either centralised or replicated , that best fits their needs , for each level of the collaborative zipper architecture separately . The platform should support invocations between collaborative object groups ( i . e . , mapping invocations on messages and multicasting , reliable delivery , ordered delivery , and collation of messages ) , existence and membership management of collaborative object groups , reference mapping , state transfer , and obtaining exclusive privileges to collaborative object groups . In addition to these services , which originate from research into fault - tolerant systems , the platform should provide support flexible consistency management , which is a new contribution , as far as we know . Together , these platform services allow grouplet programmers to use a programming style that is largely similar to the conventional single - user synchronous procedure - call oriented style of programming ( except for the few cases in which non - determinism or single - execution semantics must be enforced ) , while the platform handles grouplet - independent , error - prone and performance - critical aspects . Thus , grouplet programmers can focus on grouplet - specific aspects , instead of on the intrinsics of distribution , replication and collaborative consistency management . Chapter 7 7 . Implementation In the research projects Platinum and MESH , three related prototypes of platforms were implemented that demonstrate the feasibility of the architectures and platforms that are proposed in chapters 5 and 6 : – MediaBuilder , an early prototype of a CoMeCo platform ( cf . chapter 5 ) , – Multicast Object Request Broker ( MORB ) , a prototype of a platform for collaborative object groups ( cf . section 6 . 3 - 6 . 4 ) – CoCoDoc , a prototype of a collaborative compound document editing framework ( cf . section 6 . 1 - 6 . 2 ) . A simple collaborative compound outline editor , CoCoTree , was implemented in order to demonstrate the CoCoDoc platform and to experiment in pilot settings . In this chapter , we first describe briefly the context in which the prototypes were implemented , viz . the research projects Platinum and MESH . Then , we describe , in a bottom - up fashion , the implementation and functionality of the prototypes MediaBuilder , MORB , CoCoDoc and CoCoTree . Finally , based on our experiences with these prototypes , we describe recommendations for future research and development and present conclusions . 7 . 1 Context : the Projects Platinum and MESH The implementation of the prototypes took place within the context of the research projects Platinum and MESH . The Platinum 70 project was a joint research project of AT & T Network Systems Netherlands , AT & T Wireless Communication and Networking 70 Platinum is an acronym of “ Plat form providing I ntegrated services to N ew U sers of M ultimedia” ; for more details , see http : / / www . telin . nl / projects / platinum . htm 194 C HAPTER 7 I MPLEMENTATION Division ( now both part of Lucent Technologies ) , AT & T Global Information Systems ( now NCR ) , the Centre for Telematics and Information Technology ( CTIT ) at the University of Twente , Deutsche Telekom and the Telematics Research Centre ( TRC , now the Telematica Instituut ) . The project was conducted between January 1995 and July 1996 and consumed a total effort of 80 man - years . Its successor , the MESH 71 project , is a joint research project of Lucent Technologies , CTIT , Surfnet , KPN Research and the Telematica Instituut . The project is conducted between November 1996 and November1998 and amounts to a total effort of 72 man - years . The goal of both projects is to design and implement groupware applications that use broadband network technologies , and to investigate their use in pilot settings . In particular , research in the projects focuses on the design and use of groupware applications that include high - quality desktop video conferencing , based on native , switched Asynchronous Transfer Mode ( ATM ) network connections to the desktop , that support bandwidths as high as 155 Mb / s . One of the unique features of the Platinum and MESH projects is the combination of development of network infrastructure , advanced groupware applications and pilot studies in a single project . In order to facilitate the development and adjustment of groupware systems for the pilots , a platform upon which groupware applications can be developed quickly , was considered essential . Thus , a rapid cycle can be created of research that informs design , which in turn can inform research , which in turn can inform design , etc . Developing structuring guidelines , architectures and platforms for extensible and composable groupware systems — the subject of this book — is a small , but crucial , element in the Platinum and MESH projects . The relation between the projects Platinum and MESH on the one hand and the structuring guidelines and proposed architectures and platforms in this book is twofold : – First and foremost , ( early versions of ) the structuring guidelines , architectures and proposed platform services partially shaped the architecture and functions of the platforms that have been developed in Platinum and MESH . – Second , the experience and insight gained from the implementation has shaped the final form of the structuring guidelines and the proposed architectures and platforms , as described in chapter 5 and 6 . As may be observed from the descriptions of the prototypes below , only a subset of the proposed platform features has been implemented . 71 MESH is an acronym of “ M ultimedia services on the E lectronic S uper H ighway” ; for more details , see http : / / www . mesh . nl M EDIA B UILDER : A C O M E C O P ROTOTYPE 195 7 . 2 MediaBuilder : a CoMeCo Prototype MediaBuilder is a multimedia groupware platform that provides basic support for conference management and medium grouplets on top of Windows NT and switched high - speed ATM networks . Early versions of the CoMeCo architecture influenced the design of MediaBuilder [ BCD + 95 ] . In particular , the separation between conference management and media in MediaBuilder was inspired by an early version of the CoMeCo architecture . The design of MediaBuilder was a joint effort by all Platinum project partners . Most of the implementation work of MediaBuilder was done at Lucent Technologies . MediaBuilder offers groupware developers some support for building groupware applications according to the CoMeCo architecture . MediaBuilder’s support for conference management ( cf . section 5 . 2 . 1 ) , also known as ‘session management’ in MediaBuilder , is implemented on top of call handler functions that provide services to establish , release and modify multiparty multimedia calls on an extended ATM control plane signalling protocol . This protocol , Q . 2931ext , an extension of the standardised ITU Q . 2931 signalling protocol [ ITU95 ] , was earlier developed in the RACE II project MAGIC ( R2044 ) [ SHR + 94 ] . MediaBuilder’s conference management comprises full support for existence management ( cf . A existence in section 5 . 2 . 1 ) , membership management ( A membership ) , conference media management ( A media ) , and conference templates ( A conftemplate , without ChangeTemplate ) . Existence management is direct . Membership management is discrete . Both initiator - based and joiner - based membership management are supported . Single - user conferences and zero - user conferences ( A persistence ) , coordination policies ( A coordination ) and conference navigation ( A navigate ) are not supported . A limited form of conference hierarchy ( A multiconference ) is supported , viz . – A MESH control centre , which is a top - level administrative super - conference that is primarily used as a mechanism to bootstrap conferences , similar to GroupKit’s registrar [ RoGr96 ] . It is joined when a user starts a conference management application . – Conferences ( also known as ‘meetings’ ) , which contain conference members and one or more MediaBuilder media . – MediaBuilder media , which contain a subset of the conference members and one medium . Membership of a MediaBuilder medium is only possible when a user is a member of the conference in which the medium is embedded . Expressed in terms of the CoMeCo model , MediaBuilder media are CoMeCo sub - conferences that can only contain a single CoMeCo medium . 196 C HAPTER 7 I MPLEMENTATION MediaBuilder’s support for media comprises ( for more details , we refer to [ BrCo97 ] ) basic support for medium grouplets in the form of : – TransportAdapters , which map a specific transport protocol , such as ATM or TCP / IP , to a common transport interface . Various transport adapters have been implemented , including an ATM transport adapter and a TCP / IP transport adapter . – PresenterAdapters , which provide a common interface to devices such as microphones , loudspeakers , video windows and , more in general , grouplets that provide interaction with users . In some situations , transport adapters are directly connected to a presenter adapter of a multimedia device . For example , an ATM video stream may be directly connected to a video window . This configuration is used to display video streams directly on the Montage video board [ GaAh95 ] , a special video board developed by Lucent Technologies that is able to display 32 full - motion video streams simultaneously . In other situations , transport adapters are connected to grouplets such as a shared object collection . This configuration is used in the realisation of the shared whiteboard application . MediaBuilder’s support for coordination support is limited : separation between coordination on the one hand and media and conference management on the other hand is not supported by MediaBuilder . ATM , TCP / IP network MediaBuilder middleware grouplets shared object collection shared wb . video conf . conference management CoCoDoc MORB On top of MediaBuilder , various grouplets have been implemented : a conference management grouplet [ HLM + 96 ] , and various medium grouplets , including an audio , video , chat , shared whiteboard [ SiCP96 ] and a collaborative compound document editor grouplet , as illustrated in Figure 7 - 1 and Figure 7 - 2 . Figure 7 - 1 MediaBuilder in context M EDIA B UILDER : A C O M E C O P ROTOTYPE 197 Initially , it was planned that all medium grouplets would be directly implemented on top of the MediaBuilder platform . However , halfway through the Platinum project , we realised that at least for discrete media , such as the shared whiteboard and collaborative compound document editors , much leverage could come from using industry standards for distributed object computing such as the Common Object Request Broker Architecture ( CORBA ) . We decided to follow a two - track approach for discrete media : one track focused on building a shared whiteboard application on top of MediaBuilder without use of CORBA ( this track is not further described here ) , the other track , which ran in parallel , focused on a more generic approach : building a CORBA - based collaborative object group service ( MORB , see section 7 . 3 ) that could be used as a basis for a framework for collaborative compound document editing ( CoCoDoc , see section 7 . 4 ) . The reason we did not build all the grouplets , i . e . , including the shared whiteboard , on top of the MORB and CoCoDoc , which would have provided better composability of CoCoDoc grouplets and the shared whiteboard , was that the CoCoDoc track involved the combination of various existing software infrastructures , which made its planning uncertain . Figure 7 - 2 Snapshot of various MediaBuilder grouplets in action in a conference between Barcelona , Spain and two locations in Enschede , the Netherlands : a video conferencing grouplet ( top three windows ) , a shared whiteboard grouplet ( lower left ) and a conference management grouplet ( lower right ) 198 C HAPTER 7 I MPLEMENTATION 7 . 3 MORB : a Prototype Collaborative Object Group Platform The Multicast Object Request Broker ( MORB 72 ) is a prototype multicast object request broker that extends the services of a CORBA object request broker ( ORB ) with support for collaborative object groups . MORB supports only two collaborative consistency management policies , viz . coupled and uncoupled . We also refer to this particular form of collaborative object groups as couplable object groups . The MORB was designed and implemented in the Platinum and MESH projects at the Telematica Instituut on top of : – the MediaBuilder platform ; – the MediaBuilder shared object collection , and – System Object Model ( SOM ) v2 . 14 , IBM’s implementation of an ORB that complies with the CORBA 1 . 2 standard . Below , we first describe CORBA and the MediaBuilder shared object collection . Then , we describe how we integrated CORBA and the MediaBuilder shared object collection . Finally , we describe the functionality provided by the MORB . 7 . 3 . 1 CORBA CORBA is currently one of the most widely supported standards for distributed object computing [ OrHE96 ] . At the core of the CORBA standards is the Object Request Broker ( ORB ) . An ORB mediates object invocations and supports interoperability between objects across process and network boundaries by providing location - transparent invocation of objects , while hiding low - level details such as communication protocols , transport encodings , and bridging heterogeneity in operating systems and programming languages . For example , when invoking a CORBA - compliant object , a programmer does not need to know in which programming language the other object is implemented and where ( e . g . , in which process or on which machine ) an object that is being invoked is running ( i . e . , to the programmer , the left and the right situation in Figure 7 - 3 are functionally indistinguishable ) . For this purpose , developers specify object interfaces in the standardised and programming - language independent CORBA Interface Definition Language ( IDL ) . 72 To be pronounced as “em - orb” . MORB : A P ROTOTYPE C OLLABORATIVE O BJECT G ROUP P LATFORM 199 process B A Object Request Broker ( ORB ) process 1 process 2 B A Object Request Broker ( ORB ) In addition to a standard for ORBs [ OMG97 ] , the Object Management Group ( OMG ) , an industry consortium of over 800 companies , has recently adopted various other related standards for distributed object computing , which populate the Object Management Architecture ( OMA ) Reference Model , as illustrated in Figure 7 - 4 . Object Request Broker ( ORB ) Domaininterfaces Application interfaces CORBAfacilities CORBAservices The OMA reference model consists of five parts ; OMG standards typically cover one or more of these parts : – an Object Request Broker ( ORB ) , which mediates invocations between objects , as described earlier ; – CORBAservices , which are general services that are likely to be used in any program based on distributed objects . The services are implemented as CORBA objects and have standardised interfaces that are specified in IDL . Adopted CORBAservices include [ OMG97b ] Naming , Event , Persistent Object , Life Cycle , Concurrency Control , Externalization , Relationship , Transaction , Query , Licensing , Property , Time , Security , Object Trader and Collection services . – CORBAfacilities , which are general end - user - oriented facilities applicable to most application domains . Adopted CORBAfacilities include a facility Figure 7 - 3 Mediating intra - process and inter - process object invocations with an ORB : the invocation seems direct ( solid arrow ) , but in reality , it is mediated through the ORB ( dashed arrow ) Figure 7 - 4 OMA reference architecture 200 C HAPTER 7 I MPLEMENTATION for compound document editing based on OpenDoc , known as the Distributed Document Component Facility ( DDCF ) , or the compound presentation and compound interchange facilities [ ACI + 95 ] . – Domain Interfaces are application domain - specific interfaces . Currently , domain interfaces are being developed for Finance , Healthcare , Manufacturing , Telecom , Electronic Commerce , and Transportation . – Application Interfaces are non - standardised application - specific interfaces . These are defined by application developers . CORBA standards currently do not support replication transparency , let alone consistency transparency , despite the fact that object groups have been proposed at an early stage of the CORBA standardisation process [ ISIS93 ] . Some CORBAservices that have recently been adopted seem appropriate at first sight to support replication transparency and object groups . In particular , this applies to the CORBA Collection service and the CORBA Event Service . The Collection service , however , provides a service that is aimed at managing collections . Examples of collections are sets , queues , stacks , lists , binary , and trees . The purpose of the Collection Object Service is to provide a uniform way to create and manipulate the most common collections generically . It does not provide replication transparency . The CORBA Event Service provides a limited form of replication transparency : a sender object that sends events to an event channel is not aware how many consumer objects are subscribed to an event channel ; the Event Service takes care of one - to - many communication . However , the CORBA Event Service standard does not support ordered delivery ( even FIFO order is not guaranteed ) , state transfer , and two - way invocations [ FeGS97 ; FeGS98 ] , which are required in order to support object groups . Provision of replication transparency seems to be planned in a future CORBA Replication Service [ OMG97b ] . The ORB implementation we used in the MORB prototype is a stripped - down version of SOM v2 . 14 , IBM’s implementation of the CORBA 1 . 2 standard . This stripped - down version was part of the OpenDoc for Windows Software Development Kit version 1 . 1 ( OpenDoc Win95 / NT SDK 1 . 1 ) , which was chosen as a basis for the implementation of CoCoDoc . SOM v2 . 14 had specific non - CORBA compliant features , such as a metaclass facility , that were mandated by the OpenDoc Win95 / NT SDK 1 . 1 . The version of SOM we used did not implement the Event Service , which was not part of the CORBA 1 . 2 . standard . It also lacked the Replication SOM ( RSOM ) framework [ Lau95 , pp . 174 - 215 ] , a non - CORBA compliant part of the full SOM 2 . 14 platform that provides replication transparency . Even if we had been able to explore the use of the RSOM framework or an implementation of the Event Service , we would still have faced the MORB : A P ROTOTYPE C OLLABORATIVE O BJECT G ROUP P LATFORM 201 problem of integrating it with the MediaBuilder support for conference management and network transport . In contrast , the MediaBuilder shared object collection was available and well - integrated with MediaBuilder’s support for conference management and network transport . Therefore , we decided to use the MediaBuilder shared object collection as a basis for the implementation of the MORB prototype . 7 . 3 . 2 MediaBuilder Shared Object Collection Both the MORB implementation track and the shared whiteboard implementation track in the Platinum and MESH projects used a simple shared object collection service that was implemented on top of MediaBuilder early in the Platinum project [ SiCP96 ] . The shared object collection provides invocations with TOTAL order on replicated object groups called “shared objects” . The TOTAL ordered delivery of invocations in the shared object collection service was implemented with a centralised arbitrator approach ( see section B . 3 in appendix B ) . The arbitrator is located at the process that initiates the MediaBuilder medium in which the shared object collection is used . Migration of the token - arbitrator was not implemented ; the medium is deleted when the user that initiated the medium leaves the medium . When new members join the MediaBuilder medium that uses the shared object collection , the shared object collection initiates the creation of new replicas at the newcomer’s site and will transfer the current state to the newly created objects . Replicas are deleted when a member leaves the conference . The interface to and the service of the shared object collection service are briefly described in Table 7 - 1 . Object Method Service Shared object collection add ( ) a new shared object is added to the collection delete ( ) a shared object is deleted from the collection Shared object modify ( ) the status of the shared object is modified select ( ) the client requests the write - lock on the shared object unselect ( ) the client releases the write - lock on the shared object encode ( ) the shared object externalises its status in a sequence of bytes decode ( ) the share object sets its status based on a sequence of bytes Table 7 - 1 Shared object collection interface and service 202 C HAPTER 7 I MPLEMENTATION 7 . 3 . 3 Integration of CORBA and the Shared Object Collection One of the primary features of MORB , compared to a normal ORB , is that it provides replication transparency for client objects that invoke replicated object groups , as illustrated in Figure 7 - 5 . process 1 process 2 B 1 B 2 A Multicast Object Request Broker ( MORB ) We distinguish two approaches for the implementation of an MORB based on an existing ORB : – In the in - line multicast bridge approach ( cf . Figure 7 - 6 ) , an ORB’s communication subsystem is replaced with one that supports group communication , as done in Orbix + ISIS and Electra [ LaMa97 ] . In Orbix + ISIS , the communication subsystem of Orbix is replaced by the group communication toolkit ISIS . Electra does not use an existing ORB , but it is an ORB implementation that is built on top of a virtual group communication subsystem . This communication subsystem can be implemented by an existing group communication system in combination with an Electra adapter . Electra adapters have been implemented for the group communication systems ISIS and Horus [ ReBM96 ] . To use this approach , the MORB implementer must have access to the ORB internals to ‘plug in’ the communication subsystem . process 1 process 2 B 1 B 2 A MORB group communication toolkit – In the inter - ORB request - level multicast bridge approach ( cf . Figure 7 - 7 ) , various ORBs are interconnected with a bridge that is capable of Figure 7 - 5 Mediating object group invocations with an MORB Figure 7 - 6 The in - line multicast bridge approach MORB : A P ROTOTYPE C OLLABORATIVE O BJECT G ROUP P LATFORM 203 multicasting . This approach , first reported briefly in [ HoLB96 ] , was inspired by [ StUZ96 ] , which gives an overview of the possible ways for building an inter - ORB bridge that resides at the boundary between ORBs . Such a ( non - multicast ) inter - ORB bridge transparently mediates object invocations between two objects that reside in different ORB domains [ BEI + 94 ] . To the client ( cf . A ) and the client ORB ( cf . ORB1 ) , it seems as if a server object is invoked ( cf . B 1 or B 2 ) . In reality , however , a proxy object in the bridge is invoked . To the server object ( cf . B 1 or B 2 ) and the server ORB , it seems as if it is being invoked by a client object ( cf . A ) . In reality , however , it is being invoked by a proxy object in the bridge . To the standard inter - ORB bridge approach , we added the idea of multicasting , which resulted in a bridge that is capable of multicasting to multiple proxy objects . Such a bridge can be used to support invocations between object groups , where each object group member of the same object group resides in a different ORB domain and all object group members ( of different object groups ) that belong to the same conference member reside in the same ORB domain ( cf . Figure 6 - 20 ) . For example , such a multicast bridge can transform a request from a singleton in a particular source ORB domain to multiple calls on all object group members in multiple destination ORB domains , as illustrated in Figure 7 - 7 . The main advantage of this approach is that it uses a request - level bridge , which implies that only external interfaces of an ORB are used . Consequently , it allows for the construction of a multicast ORB without changing existing ORB implementations . process 1 process 2 B 1 B 2 A ORB1 ORB2 bridge We used the inter - ORB request - level multicast bridge approach to implement the MORB , since we did not have easy access to the internals of the SOM ORB . Our MORB bridge implementation consists of two major elements : 1 . the MediaBuilder shared object collection ; 2 . the baseclasses GroupableObject and CouplableObject . Figure 7 - 7 Inter - ORB multicasting bridge approach 204 C HAPTER 7 I MPLEMENTATION Roughly , the cooperation between these two elements of the MORB proceeds as follows . In order to be used as a member of a couplable object group , an object must inherit from the baseclass CouplableObject . For each object that derives from this baseclass , as soon as it is initialised , a corresponding ObjectGroupProxy shared object is created in the MediaBuilder shared object collection . Such an ObjectGroupProxy is a replicated object group . As the metaclass of the baseclass CouplableObject , we used the SOM BeforeAfter metaclass , which makes sure that before invocations on an object that derives from CouplableObject are actually invoked on the object , the SommBeforeMethod ( ) of the object is invoked first . In the implementation of this method , we invoke the methods select ( ) , modify ( ) and unselect ( ) on its corresponding ObjectGroupProxy object in the shared object collection . The method name and parameters of the original invocation are marshalled into a parameter of the modify ( ) invocation . This parameter is a sequence of bytes . The clients of the shared object determine the syntax and semantics of this sequence of bytes . At the other replicas of the ObjectGroupProxy object , the modify parameter is demarshalled into a method name and parameters , which are used to reconstruct a method invocation , that is subsequently issued to the object for which the remote replica is a proxy . To issue an invocation that is indistinguishable for a server object from a normal invocation we use the SOM Dispatch mechanism . We used various SOM - specific mechanisms in the implementation of the MORB that do not comply with the CORBA 2 . 0 standard , such as the BeforeAfter metaclass and the SOM Dispatch mechanism . In ORBs that do comply with the CORBA 2 . 0 standard or newer , these functions may be replaced by the Dynamic Skeleton Interface ( DSI ) and the Dynamic Invocation Interface ( DII ) , respectively , as demonstrated by the CORBA object group service implementation that was recently described in [ FeGS98 ] . 7 . 3 . 4 MORB Functionality Below , we briefly describe the functionality , as provided by the MESH release 1 . 1 implementation of the MORB . In this description , we use the structure as presented in section 6 . 4 . The MORB supports various forms of collaborative object group invocation ( cf . section 6 . 4 . 5 ) . However , the MORB does not support all variants mentioned in Figure 6 - 19 , as indicated in Figure 7 - 8 . MORB : A P ROTOTYPE C OLLABORATIVE O BJECT G ROUP P LATFORM 205 1111 B BB B 4444 3333 2222 strictly coupled client replicated server centralised client strictly coupled server uncoupled client strictly coupled server strictly coupled client centralised server centralised client replicated server replicated client uncoupled server uncoupled client centralised server replicated client uncoupled server CCCC DDDD AAAA In particular , the MORB does not support : – object invocations that involve a coupled centralised collaborative object group ( the cells A2 , A4 , B3 , B4 , C2 , and C4 ) ; – most invocations that involve a replicated , coupled collaborative object group as a client ; only when the server is an uncoupled replicated object group , the invocation is supported ( A1 , A3 , and C3 are not supported ) ; – some invocations between uncoupled collaborative object groups , if there is no server object in the same ORB domain as the client object ( D3 and D4 are not supported if the objects are not located in the same domain ) ; this implies that the MORB bridge is not a full inter - ORB request - level bridge according to [ BEI + 94 ] . Figure 7 - 8 Invocations between collaborative object groups that are supported by MORB ( indicated without bar ) 206 C HAPTER 7 I MPLEMENTATION The object invocations that are supported , include the types of invocations we need in the implementation of a collaborative zipper architecture , provided that it is replicated at all levels : – invocations between a singleton 73 as a client and a replicated collaborative object group as a server ( B2 and D2 are supported ) ; – invocations between an uncoupled replicated collaborative object group and a replicated collaborative object group as a server ( in both directions : B1 and C1 are supported ) ; – some invocations between uncoupled collaborative object groups , if there is a server object in the same ORB domain as the client object ( D1 and D2 are supported , D3 is supported in some cases , and D4 is supported only if the objects are not located in the same domain ) . With respect to ordering , only TOTAL order is supported ; CAUSAL , FIFO , and TRANSFORMED order are not supported ( see also appendix B ) . Multicasting is supported indirectly by the MORB : an invocation on a CouplableObject is mapped on a modify ( ) method of its corresponding ObjectGroupProxy object in the multicast bridge ; the MediaBuilder shared object collection will take care of multicasting this operation . The MORB provides programmers with an “exempt” - mechanism to indicate whether a method should be multicast or not : each CouplableObject may override the exemptMethod ( ) , which takes a method name as input and produces a Boolean value as output that indicates whether a method should not be multicast . Typically , programmers will use this mechanism to prevent the multicasting of read - only methods . A similar exempt - mechanism has been implemented earlier in the Replication SOM ( RSOM ) framework . With respect to reliable message delivery , the MORB depends on the reliability of the shared object collection . An early version of the shared object collection only provided best - effort delivery , which seemed to be based on the assumption [ SiCP96 , p . 9 ] that modern ATM networks have a low error - rate . Transmission errors that were due to overflow of local buffers , however , forced the implementation of a simple retransmission protocol . This simple retransmission protocol was based on positive acknowledgements , not on the more complicated negative acknowledgements approach that has been proposed in section 6 . 4 . 5 . The MORB provides a simple , “local - response” collation policy : only the response from the local replica of an invocation to a replicated coupled object group is used to construct the response to the client ; the other responses are discarded by the remote ObjectGroupProxy replicas . The MORB does not support request collation ; this is the reason why the MORB does 73 In Figure 7 - 8 we treat uncoupled centralised client objects as if they are client singletons . MORB : A P ROTOTYPE C OLLABORATIVE O BJECT G ROUP P LATFORM 207 not support invocations with single - execution semantics from a replicated coupled object group to a centralised object group or a singleton . The MORB maps invocations on messages only indirectly : invocations on collaborative object groups are mapped on invocations on ObjectGroupProxy objects in the inter - ORB multicast bridge ; the MediaBuilder shared object collection takes care of mapping invocations on messages . The MORB support for existence management of collaborative object groups ( cf . section 6 . 4 . 6 ) consists of two parts : – a factory that is used to create new replicated collaborative object groups ; – baseclass methods that initialise an object as a collaborative object group . The MORB supports two types of collaborative object groups that both derive from the abstract baseclass GroupableObject : GroupableObjectFactory and CouplableObject ( see also Figure 7 - 17 on page 217 ) . Any GroupableObject ( i . e . , also objects of type CouplableObject and GroupableObjectFactory ) can be turned into a replicated object group by invoking its createObjectGroup ( ) method and specifying the appropriate GroupableObjectFactory object 74 . The GroupableObjectFactory object will contact its peers to create the other replicas of the object group that is being created ; subsequently , the MORB will invoke the method objectGroupCreated ( ) of each of the members of the newly formed object group 75 . Programmers may override this method with class - specific behaviour . In contrast with the recommendation in section 6 . 4 . 6 , a newly formed object group is not coupled . Hence , state transfer is not required as part of the object group creation . Invoking the method deleteObjectGroup ( ) on an object group will disband the object group : members continue their existence as singletons . In addition , the MORB will invoke the method objectGroupDeleted ( ) on each of the members . Programmers may override this method with specific behaviour , e . g . , to delete the member . The current implementation of the MORB does not yet support membership management ( cf . section 6 . 4 . 7 ) . To be more precise , dynamic membership management ( joining and leaving of conference members ) is not supported , since the creation of new object group members in an order in which factories are created first and dealing with references to object groups whose new member have not yet been created , have not yet been resolved . 74 This must be a replicated object group . The first object group in a medium may be created by using the default object group factory . 75 As soon as the method objectGroupCreated ( ) is invoked , a GroupableObject becomes an “object group” ; e . g . , from this moment on , it may be used as factory to create other object groups . 208 C HAPTER 7 I MPLEMENTATION The MORB support for flexible collaborative consistency management ( cf . section 6 . 4 . 8 ) consists of support for two collaborative consistency policies for objects that are derived from CouplableObject : uncoupled and coupled ( also indicated as strictly coupled ) , and support to switch between these policies . When a replicated collaborative object group is coupled , invocations will be multicast to all member objects ; when it is uncoupled , the invocations will not be multicast , but only the local object group member will be invoked . The baseclass CouplableObject implements the methods for coupleObjectGroup ( ) and uncoupleObjectGroup ( ) , which can be invoked to switch to one of the two policies . In response to an invocation of coupleObjectGroup ( ) , the MORB will initiate a state transfer where the state of the local replica will be transferred to the other replicas : the MORB will invoke the method externalizeStatus ( ) on the local replica , it will transfer the externalised state and it will invoke the method internalizeStatus ( ) with the externalised state as a parameter on all other object group members . Subsequently , it will invoke startCouple ( ) on all other object group members , as a notification . In response to an invocation of uncoupleObjectGroup ( ) , the MORB will stop multicasting and invoke the method stopCouple ( ) on all object group members . Subclasses of CouplableObject must override the methods externalizeStatus ( ) , internalizeStatus ( ) , startCouple ( ) and stopCouple ( ) with class - specific implementations . The MORB support for state transfer ( cf . section 6 . 4 . 9 ) consists of the methods externalizeStatus ( ) and internalizeStatus ( ) . These methods may be called by the MORB on a CouplableObject , e . g . , in response to a change in collaborative consistency management policy . Programmers must override these methods with a class - specific implementation . In this implementation , programmers may use reference mapping functions offered by MORB . The MORB fully supports reference mapping for replicated collaborative object groups ( cf . section 6 . 4 . 10 ) : – As a reference to a replicated collaborative object group , the reference to the local member object is used . The MORB will make sure that invocations are multicast when appropriate . – References to replicated collaborative object groups in parameters of invocations to coupled replicated collaborative object groups will be mapped onto the corresponding local references in the actual invocations at the various replicas . – The MORB offers application programmers the functions externalizeObjectRef ( ) and internalizeObjectRef ( ) . The function externalizeObjectRef ( ) may be used to obtain a valid reference to a replicated collaborative object group that may be used in an externalised byte stream that is constructed for state - transfer purposes . Similarly , the function MORB : A P ROTOTYPE C OLLABORATIVE O BJECT G ROUP P LATFORM 209 internalizeObjectRef ( ) may be used to obtain a valid reference to a replicated collaborative object group based on a part of a byte stream that contains an externalised replicated collaborative object group reference . Reference mapping for singleton objects is not supported . As a consequence , when the state of an object group contains references to singleton objects , this state cannot be fully externalised . The MORB provides limited support for exclusive privileges ( cf . section 6 . 4 . 11 ) : programmers may use the CouplableObject baseclass functions createObjectGroupToken ( ) , deleteObjectGroupToken ( ) , requestObjectGroupToken ( ) and releaseObjectGroupToken ( ) to access the main token services . Requesting multiple tokens simultaneously is not yet supported . An overview of the main MORB functions may be found in Table 7 - 2 . Object Method Service GroupableObject createObjectGroup ( ) create a replicated collaborative object group based on this GroupableObject ; invokes createObjectGroupMember ( ) at the members of the indicated GroupableObjectFactory to create the other members deleteObjectGroup ( ) remove the relation between the members of the replicated collaborative object group externalizeObjectRef ( ) convert a reference to a replicated collaborative object group into a reference that may be used to produce status for externalizeStatus ( ) internalizeObjectRef ( ) convert a reference that is received from internalizeStatus ( ) into a reference to a replicated collaborative object group CouplableObject coupleObjectGroup ( ) switch to ( strictly ) coupled behaviour ; invokes state transfer functions externalizeStatus ( ) and internalizeStatus ( ) , and invokes startCouple ( ) when done uncoupleObjectGroup ( ) switch to uncoupled behaviour ; invokes stopCouple ( ) when done createObjectGroupToken ( ) create a named object group token for this CouplableObject deleteObjectGroupToken ( ) delete a named object group token for this CouplableObject requestObjectGroupToken ( ) request the exclusive ownership of a named object group token for this CouplableObject releaseObjectGroupToken ( ) release the exclusive ownership of a named object group token for this CouplableObject Table 7 - 2 Overview of the major MORB functions , accessible as baseclass methods of GroupableObject and CouplableObject 210 C HAPTER 7 I MPLEMENTATION 7 . 4 CoCoDoc Prototype For the prototype implementation of the CoCoDoc platform ( cf . section 6 . 2 . 1 ) , we considered implementing it as : – a collaborative document editing extension of an existing compound document editing platform ( cf . section 6 . 1 . 2 ) ; – a compound document editing extension of a collaborative document editing platform ( such as DistEdit [ KnPr90 ] , GroupIE [ Rude95 ] or IRIS [ Koch95 ] ) ; – an extension of Taligent’s implementation of a rudimentary collaborative compound document editing framework ; – a system that is developed from scratch . We chose the first approach , since it provided the best possibilities for integration of existing single - user editors . As a basis for the design and implementation of the CoCoDoc prototype , we decided 76 to use OpenDoc [ Nels95 ; OrHE96 ] , a new industry standard for compound document editing , which has been adopted as the basis for the OMG standard for the CORBA Distributed Document Component Facility ( DDCF ) [ ACI + 95 ] . Our current prototype implementation of CoCoDoc is based on OpenDoc Win95 / NT SDK 1 . 1 , which is not fully CORBA / DDCF - compliant . One of the features the OpenDoc platform provides is an adapter for OLE 2 . 0 compliant editors , which allows these editors to be used as OpenDoc parts in documents . This allows using a wide range of existing editors that are in use in many office environments , such MS Word and Excel , to be embedded as a part in an OpenDoc - based document . In CoCoDoc , grouplet development is very similar to part editor development in OpenDoc . In OpenDoc , part developers must implement a subclass of the OpenDoc abstract baseclass ODPart , by overriding a minimum of 6 and a maximum of 60 methods defined in the interface of ODPart [ OrHE96 , pp . 346 - 350 ] . These methods are invoked by the OpenDoc framework and cover areas such as embedding , user interface event handling , initialisation and termination , frames , imaging and linking . 76 We took our decision to use OpenDoc at the end of 1995 . At the end of 1996 , Apple and IBM , the main developers of OpenDoc , announced to discontinue further development of OpenDoc . As described in section 7 . 6 , we are currently considering switching to another compound document editing platform . C O C O D OC P ROTOTYPE 211 In CoCoDoc , grouplet developers must implement a subclass of the CoCoDoc abstract baseclass CoCoDocPart . The methods that CoCoDocPart subclass developers must override are very similar to those of ODPart ; except for a few methods which have been replaced by CCD _ variants and a few additional CCD _ methods which must be implemented , in the areas of ( see Table 7 - 3 ) : ( I ) collaborative part life cycle support ; ( II ) shared file editing support for parts ; ( III ) document - wide coupling control ; ( IV ) document - wide outline control . CoCoDocPart method that needs to be implemented When called by the platform ; support provided by CoCoDoc I CCD _ InitPart ( ) , CCD _ InitPartFromStorage ( ) These methods are called at part creation : the CoCoDoc platform makes sure storage units are coupled ; and takes care of interaction with conference management facilities . CCD _ createObjectGroupMember ( ) This method is called when the part needs to act as factory for an object group member . II CCD _ storageUnitChanged ( ) This method is called when the part’s coupled storage unit is updated , e . g . , when another user “saved” this part of the document . III CCD _ setCouplingLevel ( ) This method is called recursively over all parts when a user selects a document - wide coupling level from the standard CoCoDoc ‘Collaboration’ menu : file coupling , edit coupling , view coupling and user interface coupling . IV CCD _ setOutline ( ) This method is called recursively over all parts when a user selects a document - wide outline level from the standard CoCoDoc menu . To achieve minimal additional learning efforts from OpenDoc programmers to use CoCoDoc , the CoCoDocPart interface closely resembles the ODPart interface . For example , the implementation requirements for CCD _ methods such as CCD _ InitPart ( ) closely resemble those of their OpenDoc relatives , i . e . , InitPart ( ) . Moreover , other interface extensions ( such as those for document - wide coupling and outline control ) are kept to a minimum . The CoCoDocPart baseclass , which is part of the CoCoDoc platform , was implemented as a subclass that inherits both from ODPart ( an OpenDoc baseclass ) and GroupableObjectFactory ( an MORB baseclass ) ; see also Figure 7 - 17 on page 217 . The baseclass makes sure that a CoCoDoc grouplet is always instantiated as a replicated object group and that a CoCoDoc grouplet can be used as a factory for other replicated object groups . Table 7 - 3 Overview of major CoCoDocPart methods 212 C HAPTER 7 I MPLEMENTATION Furthermore , no changes were made to the OpenDoc shell , which acts as a container for an entire OpenDoc document . This arrangement required a relatively complex implementation of initiation of a CoCoDoc medium as a replicated object group that contains various OpenDoc shells as members . The current CoCoDoc implementation supports all compound document editing features mentioned in section 6 . 2 . 1 and most of the collaborative document editing features mentioned in section 6 . 2 . 2 , except shared user interface editing ( WYSIWIS ) for grouplets , multiple versions and version merging . 7 . 5 CoCoTree : a Simple Collaborative Outline Editor On top of the CoCoDoc platform , we developed CoCoTree , a simple collaborative outline editor [ MoTB97 ] . In this section , we briefly describe the version that was demonstrated at the ECSCW’97 conference [ HBL + 97 ] . 7 . 5 . 1 CoCoTree Service CoCoTree grouplets provide a collaborative compound outline editing service to their users . An outline is a document representation that visualises the hierarchical structure of a document , as illustrated in Figure 7 - 9 . In CoCoTree , the document consists of units . Units may contain other units . The hierarchy of units may be of arbitrary depth . A unit that does not contain other units is called a leaf unit . Non - leaf CoCoTree units can contain a single line of text ( also known as the unit title ) as well as other CoCoTree units . Leaf CoCoTree units can contain both a title and content of any type of data for which an OLE 2 . 0 - compliant component editor is installed , e . g . , an MS Word text , a graph , video clip , wave sound , etc . C O C O T REE : A S IMPLE C OLLABORATIVE O UTLINE E DITOR 213 Collapse / expand button Expanded leaf unit Collapsed unit Expanded unit Collapsed leaf unit Documentediting functions Functions for e . g . collapse , expand Functions to switch coupling levels Border of selected unit Attached OLE content Unit title Icon shows : edit coupling CoCoTree provides services to edit the structure , e . g . , to insert units and delete units , to move units , to edit units , to collapse and expand units and to collapse and expand all units up to a certain depth . When a unit ( either a leaf unit or a non - leaf unit ) is collapsed , only the title is displayed . When a unit is expanded , both the line of text as well as any contained units or OLE content are shown . In addition to these single - user outline editing features , CoCoTree provides coupling at various levels . CoCoTree distinguishes three coupling levels ( two for CoCoTree units and one for attached OLE content ) : – edit coupling : when a CoCoTree unit is coupled at edit level , each modification of the title ( insertions and deletions of letters ) and each modification of the list of contained units , are coupled ; this is the default setting for CoCoTree units ; – view coupling : when a CoCoTree unit is coupled at view level , not only edit actions are coupled , but also view actions , such as actions to collapse and expand a unit . – file coupling : when attached OLE content is saved , ( e . g . , through an explicit “update” action ) , other users can observe the changes made . 7 . 5 . 2 CoCoTree in Use Below , we illustrate the different coupling levels of CoCoTree with user interface snapshots taken from a collaborative outline editing session that involves two users . Initially , edit coupling mode is chosen for all units . As illustrated in Figure 7 - 10 , each user may be busy editing different units ( note that each Figure 7 - 9 Annotated user interface snapshot of CoCoTree 214 C HAPTER 7 I MPLEMENTATION user selected a different unit ) and users may collapse and expand units independently ( note that the left user collapsed the unit entitled “ The CoCoDoc Framework ” , whereas the right user expanded this unit ) . At a certain point , the left user starts to change the title “ Cooperative Editing ” into “ Collaborative Editing ” . Since the unit is coupled at edit level , each letter that is typed can be observed by the right user , as illustrated in Figure 7 - 11 . Now , the users decide ( e . g . , after communication across an audio medium ) , that , in order to review a part of the outline together , they want the unit entitled “ Collaborative Editing ” to be coupled at view level , so each user sees the same view of this unit . To switch to view level coupling for the unit entitled “ Collaborative Editing ” and all sub - units , the left user selects the “ Sub Tree coupling ” , “ View coupling ” option under the “ Collaboration ” menu , as illustrated in Figure 7 - 12 . Note that , instead of changing the coupling settings for a Figure 7 - 10 CoCoTree edit coupling ( 1 ) Figure 7 - 11 CoCoTree edit coupling ( 2 ) C O C O T REE : A S IMPLE C OLLABORATIVE O UTLINE E DITOR 215 sub - tree , CoCoTree also allows changing the coupling setting for the entire document , or for a single unit 77 . As a result , the unit entitled “ Collaborative Editing ” is collapsed for the right user also , as illustrated in Figure 7 - 13 . Now , the unit entitled “ Collaborative Editing ” and all its sub - units are coupled at view level . To indicate the change to view coupling , the insertion sign on the unit icon changed to a pair of binoculars . The right user expands the unit entitled “ Collaborative Editing ” , to see the subunits again and then returns to the unit entitled “ The CoDoDoc Framework ” . 77 CoCoTree was mainly designed as a test and demonstration grouplet for CoCoDoc . Which granularity of coupling control should be provided to users is subject of further research outside the scope of this book . Figure 7 - 12 Switching to view coupling for a sub tree Figure 7 - 13 One unit is coupled at view level 216 C HAPTER 7 I MPLEMENTATION As a result , the unit entitled “ Collaborative Editing ” is expanded for the left user also , as illustrated in Figure 7 - 14 . Note , that the other units are still coupled at edit level : the unit entitled “ The CoCoDoc Framework ” is collapsed for the left user , and expanded for the right user . Now , the left user attaches a picture as content to the unit that is entitled ” Shared file system architecture ” . He selects the “ Create New ” option and “ Microsoft Word Picture ” as OLE type , as illustrated in Figure 7 - 15 . Since OLE content can only be file coupled , the right user will only see the result when the right user finishes drawing . The final result is illustrated in Figure 7 - 16 . Figure 7 - 14 Simultaneous expand of a single unit . Figure 7 - 15 Attaching a picture to a leaf unit C O C O T REE : A S IMPLE C OLLABORATIVE O UTLINE E DITOR 217 7 . 5 . 3 CoCoTree Implementation We decided to implement each unit in CoCoTree as a separate instance of a CoCoDoc grouplet . Using this approach provides the easiest way to make sure that the coupling setting for different CoCoTree units can be set independently , since the CoCoDoc platform already supports setting the coupling of different CoCoDoc grouplets independently . CoCoTreeData CoCoTreeView CoCoTreePart CoCoDocPart ODPart GroupableObjectFactory CouplableObject GroupableObject 1 1 To implement CoCoTree , we first defined the class CoCoTreePart as a subclass of the CoCoDoc baseclass CoCoDocPart ( see also Figure 7 - 17 ) . Implementing CoCoTreePart is quite similar to implementing a normal subclass of ODPart , the OpenDoc abstract baseclass for part editors [ OrHE96 , pp . 346 - 350 ] . Since Figure 7 - 16 The left user has finished editing the picture Figure 7 - 17 Class diagram , showing inheritance relations for CoCoTreePart , CoCoTreeData and CoCoTreeView : upward pointing arrows indicate inheritance , horizontal arrows indicate class uses another class ( number indicates cardinality of relation ) 218 C HAPTER 7 I MPLEMENTATION CoCoTreeParts must be able to embed other parts ( e . g . , other CoCoTreeParts , since we decided that each CoCoTreePart handles only one unit in an outline , and delegates the handling of sub - units to other parts ) , the optional ODPart methods related to embedding must be implemented . The most significant differences compared to OpenDoc programming are the implementation of the CoCoDoc - specific methods CCD _ createObjectGroupMember ( ) , CCD _ storageUnitChanged ( ) , CCD _ setOutline ( ) and CCD _ setCouplingLevel ( ) on the one hand ( cf . Table 7 - 3 ) and the implementation of edit coupling and view coupling by using collaborative object groups on the other hand . We will focus primarily on the latter . First , we partition the CoCoTreePart status in subsets ( cf . section 4 . 2 . 7 ) that can be coupled and uncoupled for each individual CoCoTreePart independently . Thus we get file status , edit status and view control status ( see also Table 7 - 4 ) . Then , we define separate collaborative object groups for these subsets . There is no need to define a separate object group for file coupling ; this is already provided by the CoCoDoc framework in the form of coupled storage units ( CouplableStorageUnit ) . So , we define a collaborative object group ( i . e . , a subclass of the baseclass CouplableObject ) CoCoTreeData that encapsulates the editing state of the CoCoTreePart , and a collaborative object group CoCoTreeView that encapsulates the view control state of the CoCoTreePart . For each collaborative object group , we define methods that can update its status ( see the second and third row of the last column in Table 7 - 4 ) . All the newly defined methods of CoCoTreeData and CoCoTreeView must be implemented , including overridden baseclass methods from CouplableObject , such as externalizeStatus ( ) , startCouple ( ) and stopCouple ( ) . Coupling level Status subset Status subset Status subset Status subset CouplableObject subclass Update Methods file coupling file status : stored state of unit CouplableStorageUnit ( provided by the CoCoDoc platform ) externalize ( ) edit coupling edit status : editable state of unit CoCoTreeData insertLetter ( ) , deleteLetter ( ) , insertUnit ( ) , deleteUnit ( ) , attachContent ( ) , detachContent ( ) , view coupling view control status : whether unit is collapsed / expanded CoCoTreeView collapseUnit ( ) , expandUnit ( ) Table 7 - 4 CoCoTree coupling levels , status subsets and update methods D IRECTIONS FOR F URTHER D EVELOPMENT 219 The CoCoTreePart is responsible for creation of the object groups CoCoTreeData and CoCoTreeView ; this must be implemented in CCD _ InitPart ( ) and CCD _ InitPartFromStorage ( ) by instantiating the proper subclass and calling its createObjectGroup ( ) method , while indicating in a parameter the object group that serves as factory ( itself , in this case ) . This will result in a call to CCD _ createObjectGroupMember ( ) at all peer factories ( its peer parts , in this case ) . For flexible coupling , we added code to implement additional menu options under the ‘Collaboration’ menu , such as ‘unit edit coupling’ and ‘unit view coupling’ . Handling these menu selections for part coupling as well as handling CCD _ setCouplingLevel ( ) is implemented in the same way , viz . with calls to coupleObjectGroup ( ) and uncoupleObjectGroup ( ) on the appropriate collaborative object groups . Being able to embed OLE content requires only a minimal implementation effort for CoCoTree ; most of the embedding code is already implemented for embedding outline sub - trees . Since OLE components can be embedded in OpenDoc parts as if they were OpenDoc parts , we can use a large variety of content from existing applications ( e . g . , MS Word ) as unit content of our simple collaborative outline editor . 7 . 6 Directions for Further Development Based on our initial experiences with MediaBuilder , the shared object collection , MORB , CoCoDoc and CoCoTree , we provide a number of suggestions for further research and development . MediaBuilder Features that are lacking in release 1 of MediaBuilder , but that should be considered in release 2 are to support : – single - user conferences , as well as transitions to and from these by joining and leaving conferences , which will facilitate the integration of individual work and collaborative work ; – conference persistence , i . e . , suspending and later resuming a conference , which enhances the support for long - term collaborative work ; – conference hierarchies , i . e . , support more than the current restriction to three levels in the MediaBuilder conference hierarchy ; this enhances the support for more complex conference structures such as long - term collaborations ; – conference directories , i . e . , super - conferences that list conferences that can be joined , which enhances joiner - based conference management ; – the world wide web and shared file systems as long - term super - conferences from which MediaBuilder conferences may be started , which enhances the integration of conferences in existing computing environments ; 220 C HAPTER 7 I MPLEMENTATION – separation of coordination support from media and conference management support ; which will provide a better re - usability of coordination policies ; – ( industry ) standards , such as CORBA and TINA , which will allow developing different media using different compilers and programming languages ; – collaborative object groups in the implementation of MediaBuilder , not only as a basis for media , but also as a basis for conference management and coordination support , which simplifies the software architecture . Shared Object Collection Our current MORB implementation shows that it is possible to use the shared object collection as a basis for an inter - ORB request - level bridge . However , we ran into the following restrictions that hinder the implementation of an MORB with more extensive functionality and / or better performance : – The shared object collection is single - threaded and proxy objects block when they invoke their object group member . As a consequence , this prevents members of a coupled object group , when invoked from an object in another ORB domain , to invoke a coupled collaborative object group ( which would require communication across the inter - ORB multicasting bridge , which is blocked ) . This complicated the implementation of the mechanism to create replicated collaborative object groups . – To get totally ordered delivery of invocations to ObjectGroupProxy objects in the shared object collection , the shared object collection requires invocation of select ( ) , modify ( ) , and unselect ( ) . As a consequence , in a series of invocations , each invocation of a replicated collaborative object group requires at least six times the one - way network latency per invocation ( two messages for each invocation on the shared object ) . An implementation according to the token - based approach can bring this down to one time the one - way network latency per invocation , as described in section B . 3 in appendix B . This may provide a speedup of throughput of collaborative object group invocations of up to 600 % . MORB Features that are lacking in release 1 of the MORB , but that should be considered in release 2 are : – Support join and leave of conference members . – Support more forms of collation , in particular those that allow replicated collaborative object groups to invoke singletons and centralised collaborative object groups with single - execution semantics . D IRECTIONS FOR F URTHER D EVELOPMENT 221 – Support invocations between replicated collaborative object groups . This will enable invocations between two coupled replicated collaborative object groups , e . g . , between a CoCoTreeView and CoCoTreeData . At present , only invocations between CoCoTreePart and CoCoTreeView and between CoCoTreePart and CoCoTreeData are allowed . Moreover , it will facilitate the creation of a single replicated object group from the initialisation method of a newly created replicated collaborative object group . At present , such a replicated object group has to elect a single member to initiate the creation of the other group , in order to prevent repetitive creation of a replicated object group . – Support CAUSAL , and TRANSFORMED order . – Support more forms of version merging . Currently , only the state of the member that initiated the coupleObjectGroup ( ) invocation is transferred to all others when a collaborative object group switches from the uncoupled to the coupled collaborative consistency management policy . By transferring the state of other or all members to all members , different forms of version merging may be supported . – Support requesting multiple tokens simultaneously and support the WRITE - LOCK and READ - LOCK token . This may be used to prevent deadlock and optimise performance , as described in section 6 . 4 . 11 . – Support ( industry ) standards . The current MORB implementation uses SOM - specific mechanisms , which could be replaced with mechanisms that are based on CORBA 2 . 0 or 2 . 1 , Java - RMI or DCOM . CoCoDoc Features that are lacking in release 1 of CoCoDoc , but that should be considered in release 2 are : – Support user interface sharing for grouplets . – Support a coupled clipboard . This would allow one user to cut something to the coupled clipboard and another user to paste it from the coupled clipboard . – Use the ActiveX compound document model , or the JavaBeans component model and the JavaBeans Glasgow specifications as a basis for the implementation of a collaborative compound document editing platform . Now further development of OpenDoc has been discontinued by Apple and IBM , different component models and compound document models should be considered as the basis for CoCoDoc . – Extend CoCoDoc with support for timeframes as a means to enable editing of multimedia documents with temporal relations between document parts , e . g . , to facilitate collaborative timeline editing of multimedia documents , similar to [ HaRB93 ] . 222 C HAPTER 7 I MPLEMENTATION CoCoTree Features that are lacking in release 1 of CoCoTree , but that should be considered in release 2 are : – support for a normal view ; currently , only an outline view is supported ; – improve the user interface of CoCoTree , based on user comments . Finally , based on user requirements in , e . g . , pilot settings , implementation of additional CoCoDoc grouplets should be considered , such as CoCoDraw , a CoCoDoc version of a shared whiteboard , which allows collaborative editing of vector - based drawings , either as a separate medium or as part of a CoCoTree document , and CoCoShow , a CoCoDoc grouplet that allows collaborative construction of a presentation by embedding OLE content and that supports distributed presentations . Developments of such grouplets can also provide a better insight in the efficiency of developing grouplets on top of CoCoDoc . 7 . 7 Conclusions With the implementation of CoCoTreePart , we demonstrated that it is feasible to implement a simple composable and extensible collaborative compound outline editing service on top of the CoCoDoc platform , MORB and MediaBuilder . CoCoTreePart , a collaboration - aware grouplet with two coupling levels ( edit and view coupling ) , can easily be composed in a document hierarchy with other CoCoTreeParts and with a wide range of existing collaboration - transparent OLE 2 . 0 compliant editors . Composition of grouplets is done automatically by the platform as a result of user actions such as inserting units and attaching OLE content . Newly developed OLE 2 . 0 compliant editors and newly developed CoCoDoc grouplets may be used to extend the CoCoTree collaborative outline editing system : after installation , they can be used in CoCoTree documents . CoCoTreePart was developed on top of CoCoDoc , a prototype platform for collaborative compound document editing that was implemented as a collaborative extension of the OpenDoc compound document editing framework . This collaborative extension was realised with the MORB , a prototype platform for couplable object groups , i . e . , collaborative object groups that only support coupled and uncoupled as collaborative consistency management policies . The MORB was implemented on top of SOM , IBM’s CORBA 1 . 2 implementation , and the MediaBuilder shared object collection , using the inter - ORB request - level multicasting bridge approach . The MediaBuilder shared object collection , in turn , was implemented on top of MediaBuilder , a prototype platform for multimedia groupware C ONCLUSIONS 223 applications over ATM and IP networks that has been implemented in the Platinum and MESH projects . To our knowledge , CoCoDoc and MORB provide a few unique features that are not found in other platforms : – CoCoDoc is the first platform that supports collaborative compound document editing with flexible coupling and that allows integration of a large variety of existing single - user editors as simple collaborative component editors . We are aware of co - authoring platforms that support flexible coupling , such as SEPIA [ HaWi92 ] and Suite [ DeCh91 ; Dewa96 ] , but these platforms do not support compound document editing . We are also aware of Taligent’s rudimentary collaborative compound document editing framework [ OrHe96 ] , but this platform does not support flexible coupling . – MORB is the first platform that supports not only replication transparency , but also consistency transparency and several collaborative consistency management policies for object groups that can be changed dynamically during the lifetime of an object group . Other object group platforms ( see section 6 . 4 . 3 ) , only support replication transparency . In addition , as far as we know , MORB is the only platform that provides a simple mechanism , viz . the object group factory mechanism , that facilitates the creation of a replicated object group at the initiative of a single object . In other object group approaches , e . g . , Corona [ HMJ + 96 ] and Electra [ LaMa97 ] , objects have to join object groups to become object group members . In this chapter , we only demonstrated the feasibility of the development process that has been proposed in this book , viz . developing extensible and composable groupware on top of platforms that are based on the structuring guidelines and architectures that were proposed in this book . Drawing firm conclusions about the efficiency and satisfaction of this development process , or about the effectiveness , efficiency and satisfaction of the use of the result of this development process , i . e . , extensible and composable groupware systems , is beyond the scope of this book . However , we can report that the results of our research and development have been used as a basis for further research and development in this direction : – Research has been started in the MESH project that studies the effectiveness , efficiency and satisfaction of the use of MESH groupware applications , i . e . , various combinations of conference management , video conferencing , shared whiteboard , chat and CoCoTree grouplet services , which are used in a tele - education and a medical tele - consultation pilot . 224 C HAPTER 7 I MPLEMENTATION – Based on a comparison between the current implementation of MediaBuilder and the structuring guidelines , architectures and platforms proposed in chapter 5 and 6 , changes are being considered for release 2 of the MESH MediaBuilder platform [ Hoft98b ] . – Based on the structuring guidelines , architectures and platforms proposed in chapter 5 and 6 , changes are being considered for release 2 of the MORB and CoCoDoc . Chapter 8 8 . Conclusions and Further Research In this book , we investigated the following research question : How should groupware systems be structured , in order to achieve extensibility and composability ? To answer this question , we provided structuring guidelines for the design of groupware systems at three levels of abstraction — service design , logical design and distributed design — which are summarised below . A service - level design of a groupware system focuses on the behaviour of a groupware system as observable by users and abstracts from internal structure and distribution of the system . Service level designs should be decomposed into units that we coined grouplet services , according to the following structuring guidelines : 1 . Separate different media in different grouplet services . 2 . Keep together different forms of coupling and aggregation in a medium . 3 . Encapsulate a single - user application in a grouplet service . 4 . Separate conference management services from other groupware services . 5 . Separate coordination services from other groupware services . Based on these structuring guidelines and a generic model of groupware services , we proposed the CoMeCo reference architecture for component groupware services . CoMeCo identifies three types of grouplet services , describes their main design parameters and characterises the relation between these three types of grouplet services , viz . : – conference management grouplet services ; – medium grouplet services ; – coordination grouplet services . 226 C HAPTER 8 C ONCLUSIONS AND F URTHER R ESEARCH To achieve extensibility and composability at a finer level of granularity , a medium grouplet service for collaborative compound document editing should be decomposed into smaller grouplet services that we coined CoCoDoc grouplet services , according to structuring guidelines that are derived from compound document editing . Each CoCoDoc grouplet service is devoted to editing a single abstract data type and may be hierarchically composed with other CoCoDoc grouplet services in order to provide a collaborative editing service for a compound document . A logical - level design of a groupware system conforms to its service - level design . It reveals how the functions of grouplet services are distributed across units of logical design , extension and composition , but it abstracts from physical distribution of the system . Logical - level designs should be decomposed into units that we coined grouplets . Each grouplet implements a single grouplet service in the service - level design . We distinguish between three types of grouplets , viz . conference management grouplets , medium grouplets and coordination grouplets . To keep together different forms of coupling and aggregation in a single CoCoDoc grouplet service , CoCoDoc grouplets should be logically decomposed according to the collaborative zipper architecture , into various layers of state that can be coupled independently . This facilitates the construction of CoCoDoc grouplets that can provide many coupling levels and can give users extensive control over coupling . A distributed design of a medium grouplet conforms to its logical - level design and in addition reveals how the functions of grouplets are physically distributed across processes such as computers . These designs should be decomposed into units we coined grouplet entities , according to the distributed collaborative zipper architecture . The distributed collaborative zipper architecture allows both for vertical distribution between zipper levels and for horizontal distribution within a zipper level . We found that neither a centralised nor a replicated architecture for horizontal distribution is optimal for all occasions . However , we found that replication is almost invariably needed for grouplets that should support flexible coupling , for grouplets that should perform well on top of high - latency or low - bandwidth communication infrastructures and for grouplets that should be available despite disconnection . C ONCLUSIONS 227 Evidence is insufficient at this stage to draw firm conclusions about the effectiveness , efficiency and satisfaction of applying these structuring guidelines and architectures in the design of extensible and composable groupware systems . Yet , the following observations can be made : – First of all , the structuring guidelines and architectures we proposed in this book are generic . In section 5 . 2 . 4 , we showed how a wide variety of groupware systems that were described in section 2 . 1 . 1 , can be described as specialisations of the CoMeCo architecture , i . e . , as a combination of specific grouplet services for conference management , media and coordination . Similarly , in section 6 . 3 . 4 , we showed how various distributed architectures of existing groupware systems can be described as specialisations of the distributed collaborative zipper architecture . – Moreover , the structuring guidelines and architectures allow for easy end - user composition of various grouplet services , which may be as simple as selecting a conference management grouplet service , one or more medium grouplet services and possibly , applying coordination policies to media . Within a CoCoDoc medium , composition of CoCoDoc grouplet services is handled transparently for the user , as a result of user actions such as inserting units and attaching OLE content . – Based on our design of the CoCoDoc platform , the collaborative object group platform and the CoMeCo platform , and our implementation of their respective prototypes , viz . CoCoDoc framework , MORB and MediaBuilder , we can conclude that the development of groupware systems according to the structuring guidelines and architectures can be supported with platforms , in a way that allows grouplet programmers to use a programming style that is largely similar to the conventional single - user procedure - call oriented style of programming , while the platform handles grouplet - independent , error - prone and performance - critical aspects . Thus , grouplet programmers can focus on grouplet - specific aspects , instead of on the intrinsics of distribution , replication and collaborative consistency management . – Last but not least , we can conclude that it is feasible to develop an extensible and composable groupware system according to the structuring guidelines , on top of the platforms CoCoDoc framework , MORB and MediaBuilder , as shown by our implementation of CoCoTree , a simple collaborative compound outline editor with two coupling levels per outline unit and the possibility to use arbitrary OLE 2 . 0 compliant editors to edit embedded content in file coupling 228 C HAPTER 8 C ONCLUSIONS AND F URTHER R ESEARCH mode . In particular , this shows how a collaborative editing environment can be given a jump - start by combining a simple collaboration - aware grouplet that can support flexible forms of coupling , with a large variety of unmodified existing single - user collaboration - transparent editors that can only support limited forms of coupling . 8 . 1 Contributions of This Book In this book , we made the following contributions : – A comprehensive and coherent set of structuring guidelines , architectures and platforms for the design of component groupware systems . Various elements have been inspired by previous research , as indicated with references throughout this book . However , the comprehensive and coherent combination is new . – Collaborative compound document editing with flexible coupling on a per - grouplet basis . As far as we know , we have been the first to design and implement a platform that supports : – combining the collaborative zipper architecture with the compound document editing architecture ; – combining collaboration - aware grouplets with existing single - user collaboration - transparent editors in a single compound document . – Collaborative object groups , which support various collaborative consistency management policies and dynamic switching between these policies during the lifetime of a collaborative object group . As far as we know , we are the first to : – define the groupware - specific notion of consistency transparency , separate from the traditional notion of replication transparency ; – demonstrate a working implementation of a platform , viz . MORB , which uses the inter - ORB request level multicast bridge approach in order to support couplable object groups , i . e . , collaborative object groups that support two elementary collaborative consistency management policies , viz . coupled and uncoupled . – A comprehensive formal model of groupware services , which uses standard set theory and logic to define various concepts for the specification of groupware services , including collaborative interaction , medium , state , action , feedback , feedthrough , presence , awareness , coupling , coupling levels , aggregation , medium coordination and consistency contexts . In this book , we used the model primarily as a precise basis for a reference D IRECTIONS FOR F URTHER R ESEARCH AND D EVELOPMENT 229 architecture for component groupware services ; its syntax and semantics are not intended to be used as a formal specification language that allows for , e . g . , program transformations . We were not the first to propose a formal model of groupware services ( see , e . g . , [ Rude93 ; RaVV95 ] ) . However , as far as we know , the combined definition of collaborative interactions , coupling and consistency contexts in single formal model is new . 8 . 2 Directions for Further Research and Development This book only reports our first step of research into the design of component groupware , viz . the development of structuring guidelines , architectures and platforms , and a demonstration of the feasibility of achieving extensibility and composability on top of these . Based on these foundations , the next step in this research may consist of investigations in the following directions : – Measure to what extent the structuring guidelines , architectures and platforms that are described in book are perceived to be effective , efficient and satisfactory according to developers of component groupware systems . – Find appropriate ways to offer extensibility , composability and flexible coupling to users for the purpose of tailoring groupware to the situation in which it is used . – Investigate the significance of extensibility and composability for the process of co - evolution of user organisations and groupware systems . – Extend the current platform prototypes , as indicated in section 7 . 6 . – Use the results of this book in mainstream computing environments , e . g . : – as a basis for a future Java , CORBA or DCOM based standard for a replication service that supports collaborative object groups ; – as a basis for a JavaBeans , CORBA , or ActiveX based standard for a collaborative compound document editing service . Appendix A 9 . Ser vice Specification of a Simple Shared Whiteboard In this appendix , we describe a model of a shared whiteboard groupware service , applying the modelling concepts defined in chapter 4 . Simple _ object - based _ shared _ whiteboard _ groupware _ service = CouplingAggFlt  CouplingFlt  CoordFlt m  CC m  AO m , where m = ( S , A ) , i . e . , our shared whiteboard medium is denoted by m . The set of medium actions is defined as follows : A m = CreateObj ( ) (cid:1) DeleteObj ( ) (cid:1) LockObj ( ) (cid:1) UnlockObj ( ) (cid:1) MoveObj ( ) (cid:1) ResizeObj ( ) (cid:1) SetFillColour ( ) (cid:1) SetOutlineColour ( ) (cid:1) ScrollHorizontal ( ) (cid:1) ScrollVertical ( ) (cid:1) Zoom ( ) (cid:1) MoveMouse ( ) (cid:1) MouseDown ( ) (cid:1) MouseUp ( ) where CreateObj ( ) represents a class of actions that can create various types of objects with various parameter values , DeleteObj ( ) , represents … , etc . Each different combination of type and parameter values formally represents a different action , but for convenience , we denote such sets as , e . g . , CreateObj ( ) . The parameters of CreateObj ( ) actions are as follows : – ( rectangle , objid , layer , x1 , x2 , y1 , y2 , fillcolour , outlinecolour ) , – ( ellipse , objid , layer , x1 , x2 , y1 , y2 , fillcolour , outlinecolour ) , – ( line , objid , layer , x1 , x2 , y1 , y2 , outlinecolour ) , where objid is a unique object identifier , layer defines the number of the objects in the foreground / background order , x1 , x2 , y1 , y2 , hold the coordinates of the bounding box of the object in the 2 - dimensional whiteboard’s space , and fillcolour and outlinecolour hold the colour definition for the object’s fill , and outline , respectively . The medium state traces of the form [ s ( 0 ) , s ( 1 ) , … , s ( n ) ] , where ? t (cid:4) [ 0 , … , n ] : s ( t ) (cid:4) S m , i . e . , the medium state trace is a sequence of medium states . The 232 A PPENDIX A S ERVICE S PECIFICATION OF A S IMPLE S HARED W HITEBOARD medium specification does not describe an actual medium state trace , since this is determined by the users and the medium together , when the medium is actually used . The specification of the shared whiteboard medium only specifies constraints imposed by the medium on the possible medium state traces . First , we define the medium state space : S m = Pointer ⌠ Viewport ⌠ Objects ⌠ Locks , where Objects = { Obj 1 , Obj 2 , … , Obj n , } , where Obj 1 , Obj 2 , … , Obj n , (cid:3) { rectangle ( objid , layer , x1 , x2 , y1 , y2 , fillcolour , outlinecolour ) , ellipse ( objid , layer , x1 , x2 , y1 , y2 , fillcolour , outlinecolour ) , line ( objid , layer , x1 , x2 , y1 , y2 , outlinecolour ) } , Locks = P ⌠ ObjectIds , where P = the set of all possible user identifiers ObjectIds = the set of all possible object identifiers Viewport = viewport ( x1 , x2 , y1 , y2 ) , where x1 , x2 , y1 , y2 represents the bounding box of the area of the 2 - dimensional whiteboard space that that user can observe , and Pointer = pointer ( x , y ) , where x , y represent the pointer’s coordinates in the 2 - dimensional whiteboard space . This first constraint on medium state traces of m is : they should conform to the partial order AO m , which specifies that all actions are allowed in the medium action order , except deleting objects that do not exist : AO m = ( S m ⌠ A m ) \ (cid:1) s (cid:1) Sm (cid:2) objid (cid:1) Ids ( Objects ( s ) ) ( noexistobj ( objid ) ⌠ DeleteObj ( objid ) ) , where Ids is a function that extracts object identifiers from a set of objects , Objects is a function that extracts the set of objects from a medium state noexistobj ( objid ) = { s | s (cid:3) S m (cid:4) ? Obj (cid:3) s : objid (cid:6) Ids ( Objects ( s ) ) } , DeleteObj ( objid ) = the subset of delete actions that operate on the object with object identifier objid . A PPENDIX A 233 Another constraint on medium state traces of m is that they should conform to the coordination filter of the shared whiteboard , which prevents any user other than the lock holder to initiate an action on a locked object . The coordination filter can be derived from the specification of Coord m , which is given below . Coord m = { ( p , ( s , a ) ) | s (cid:3) S m (cid:4) objid (cid:3) Ids ( Objects ( s ) ) (cid:4) ( p , objid ) (cid:6) Locks ( s ) (cid:4) ( Α o (cid:3) P : o  p (cid:4) ( o , objid ) (cid:3) Locks ( s ) ) (cid:4) a (cid:3) A m ( objid ) } , where A m ( objid ) denotes the subset of A m that operate on the object with object identifier objid . In order to define coupling and medium consistency policy , we first define consistent medium and action partitionings : MP = { s model , s scroll , s point } , where s model = Objects ⌠ Locks ; s scroll = Viewport , s point = Pointer AP = { A model , A scroll , A point } , where A model = CreateObj ( ) (cid:1) DeleteObj ( ) (cid:1) LockObj ( ) (cid:1) UnlockObj ( ) (cid:1) MoveObj ( ) (cid:1) ResizeObj ( ) (cid:1) SetFillColour ( ) (cid:1) SetOutlineColour ( ) , A scroll = ScrollHorizontal ( ) (cid:1) ScrollVertical ( ) (cid:1) Zoom ( ) , A point = MoveMouse ( ) (cid:1) MouseDown ( ) (cid:1) MouseUp ( ) Our shared whiteboard supports three coupling levels , with symmetrical coupling and full awareness of another user’s presence : ? p1 , p2 : CouplingFlt ( p1 , p2 , m ) = modelcoupling | scrollcoupling | pointercoupling , where modelcoupling = A model , scrollcoupling = A model (cid:1) A scroll , pointercoupling = A model (cid:1) A scroll (cid:1) MoveMouse ( ) Our shared whiteboard does not support aggregated coupling , i . e . : ? p1 , p2 : CouplingAggFlt ( p1 , p2 , m , R PresAgg ( A x ) , R AwareAgg ( A x ) ) = Id , where Id is the identity function , i . e . , ? y : Id ( y ) = y . The medium consistency policy CC m of our shared whiteboard is fully defined by : – ? p1 , p2 : CC ( p1 , p2 , s model ) = ( 0 , ( lock , no _ detect , no _ synchronise ) ) , which implies that inconsistency is avoided by using a locking strategy ; this locking strategy is defined in Coord m . – ? p1 , p2 : CC ( p1 , p2 , s scroll ) = ( 0 , ( no _ avoid , detect _ automatically , slice ) ) , which is the consistency policy for a system that will automatically detect if users want to scroll to different areas ; it will then slice the scrollbars so that 234 A PPENDIX A S ERVICE S PECIFICATION OF A S IMPLE S HARED W HITEBOARD each user gets his own personal scrollbar , which will be observable for other users ( see also Figure 4 - 9 on page 108 ) . – ? p1 , p2 : CC ( p1 , p2 , s point ) = ( 0 , ( no _ avoid , detect _ automatically , slice ) ) , which is the consistency policy for a system that will automatically detect if users want to point to different areas ; it will then slice the pointers so that each user gets his own personal pointer , which will be observable for other users as a telepointer . Appendix B 10 . Ordered Message Deliver y In this appendix , we define and describe four types of ordering that can be provided by a collaborative object group platform : – FIFO order ( see section B . 1 ) ; – CAUSAL order ( see section B . 2 ) ; – TOTAL order ( see section B . 3 ) ; – TRANSFORMED order ( see section B . 4 ) . For each type ordering , we give a definition , present a time - sequence diagram in which ordered delivery and violation of ordered delivery is illustrated and give an impression of the ( communication ) overhead of implementations that deliver messages according to that particular ordering . As a basis for all ordering definitions , we assume that a system of collaborative object groups consists of a collection of ( member ) objects 78 , e . g . , PR = { pr 1 , pr 2 , pr 3 } . The objects make progress in their computation independently , do not use shared memory and communicate solely by passing messages . The communication latency is finite but unpredictable . We also assume that these objects do not share a closely synchronised clock that they can access instantaneously . For our model , only two types of events in an object are relevant , viz . message send events and message receive events . The sending of a message m by an object pr to one or more objects is denoted as a single event s pr ( m ) . The receipt of a message m by an object pr is denoted as a single event r pr ( m ) . Two events in a single object never happen at the same time , i . e . , one always occurs before the other ; in 78 Our notion ‘object’ corresponds one ‘process’ in a ‘process group’ in group communication literature , e . g . , [ Lamp78 ; Rasi96 ] . Our notion or ‘process’ in chapter 6 ( cf . a grey square in the figures of chapter 6 ) corresponds , e . g . , to a user’s computer , that contains all the member objects of the various replicated collaborative object groups in which the user is involved . 236 A PPENDIX B O RDERED M ESSAGE D ELIVERY other words , the ordering relation < pr , which describes the order of events in an object pr , defines a total order . For convenience , we first define a partial order < msg as follows : for each message m that is sent : s ( m ) < msg r ( m ) . This corresponds to the natural order of send and receive events in a distributed system . In Figure B - 1 , we illustrate unordered delivery of four messages in a distributed system . Example of unordered delivery r B ( m 1 ) r C ( m 1 ) r A ( m 1 ) s A ( m 1 ) B r C ( m 2 ) r A ( m 2 ) r B ( m 2 ) s C ( m 2 ) r C ( m 4 ) s A ( m 4 ) r B ( m 4 ) r A ( m 4 ) C A r C ( m 3 ) r A ( m 3 ) s B ( m 3 ) r B ( m 3 ) globaltime B . 1 F IFO Order Let m 1 and m 2 be messages , then First - In - First - Out ( FIFO ) order is a partial ordering of events < FIFO that satisfies ( Α pr (cid:2) PR : s pr ( m 1 ) < pr s pr ( m 2 ) ) (cid:3) ( ? pr (cid:2) PR : r pr ( m 1 ) < FIFO r pr ( m 2 ) ) . Delivery of messages to a collaborative object group according to FIFO order implies that messages from the same sender to the same receiver “cannot overtake each other” . Implementing FIFO ordered delivery in a platform can be done with , e . g . , an algorithm that adds a sender - specific sequence number and a sender identifier to the message and that defers delivery of messages until all messages with smaller sequence numbers from the same sender have been delivered . The implementation can deliver messages that have been received in FIFO order immediately ; it requires no centralised components and the overhead added to messages is a single sequence number and a sender identifier . Figure B - 1 Example of unordered delivery Definition B - 1 FIFO order A PPENDIX B 237 An example of trivially ordered delivery of messages that violates FIFO order and delivery of the same messages according to FIFO order is illustrated in Figure B - 2 . r B ( m 1 ) r C ( m 1 ) r A ( m 1 ) s A ( m 1 ) B C A r C ( m 4 ) s A ( m 4 ) r B ( m 4 ) r A ( m 4 ) r B ( m 1 ) r C ( m 1 ) r A ( m 1 ) s A ( m 1 ) s A ( m 4 ) r A ( m 4 ) r C ( m 4 ) B r B ( m 4 ) C A B . 2 C AUSAL Order Next , we define causal ordering based on Lamport’s happened before relation [ Lamp78 ] . Let m a and m b be messages , then CAUSAL order is a partial ordering of messages < happened before , where < happened before is the transitive closure 79 of the relation m a < hb m b , where m a < hb m b (cid:5) s ( m a ) < msg r ( m b ) (cid:6) m a = m b (cid:7)Α pr (cid:2) PR : r pr ( m a ) < pr s pr ( m b ) (cid:6) m a  m b . The causal order is a partial ordering , which implies there may be messages for which no relative order is determined . Such messages ( e . g . , m 2 and m 1 in Figure B - 1 ) are called concurrent . 79 A transitive closure O * of an ordering relation O , is an ordering relation that also orders elements that are only ordered indirectly in O . For example , when O = < pr and s pr ( m 2 ) < pr s pr ( m 3 ) and s pr ( m 3 ) < pr s pr ( m 5 ) , then O * will include the ordering relation s pr ( m 2 ) < pr s pr ( m 5 ) Figure B - 2 Example of a violation of FIFO ordered delivery ( left ) its solution ( right ) Definition B - 2 CAUSAL order 238 A PPENDIX B O RDERED M ESSAGE D ELIVERY Let m a and m b be messages , then two messages are concurrent , if neither m a < happened before m b , nor m b < happened before m a . Delivery of messages to a collaborative object group according to CAUSAL order implies that messages are delivered in FIFO order and that if a member after receiving message m 1 sends another message m 3 ( cf . Figure B - 3 ) , it is guaranteed that all members that both receive m 3 and m 1 will receive m 3 after m 1 . A well - known violation of causal order sometimes occurs in Usenet newsgroups : a reply to an inquiry is sometimes received before the inquiry itself is received . An example of FIFO ordered delivery of messages that violates 80 CAUSAL order and delivery of the same messages according to CAUSAL order is illustrated in Figure B - 3 . r B ( m 1 ) r C ( m 1 ) r A ( m 1 ) s A ( m 1 ) B C A r C ( m 3 ) r A ( m 3 ) s B ( m 3 ) r B ( m 3 ) s A ( m 4 ) r B ( m 4 ) r C ( m 4 ) r A ( m 4 ) r B ( m 1 ) r C ( m 1 ) r A ( m 1 ) s A ( m 1 ) B C A r C ( m 3 ) r A ( m 3 ) s B ( m 3 ) r B ( m 3 ) s A ( m 4 ) r B ( m 4 ) r C ( m 4 ) r A ( m 4 ) Causally ordered delivery of messages to replicated collaborative object groups can be implemented in a platform by , e . g . , a system of vector clocks 81 . Here we only describe the outline of the vector clock algorithms ; details may be found in [ RaSi96 ] . Each object maintains its own vector clock . Each element of an object’s clock vector represents that object’s latest knowledge of another object’s local logical time , which is updated based on timestamps on received messages . One element in the vector 80 ( r B ( m 1 ) < B s B ( m 3 ) ) (cid:1) ( m 1 < hb m 3 ) (cid:1) ( m 1 < happened before m 3 ) ; this order is violated by the delivery order r C ( m 3 ) < C r C ( m 1 ) 81 For completeness , we note that causally ordered delivery can also be implemented with a system of scalar clocks ( e . g . , each object maintains an integer as a clock value [ Lamp78 ] ) , which are smaller and incur less overhead when added as a timestamp to messages . However , scalar clocks do not satisfy the strong consistency property defined in [ Rasi96 ] , which means that concurrency of events can not be inferred by comparing clock values . The interested reader is referred to [ RaSi96 ] . Definition B - 3 Concurrent messages Figure B - 3 Example of a violation of causally ordered delivery ( left ) its solution ( right ) A PPENDIX B 239 represents its own logical time , that is incremented by one each time before a message is sent . Each message sent by an object is timestamped with the sender’s current vector clock value . Message delivery at receivers is deferred until all messages with smaller vector timestamps have been delivered . This vector clock implementation can deliver messages that have been received in CAUSAL order immediately , requires no centralised components and the overhead added to messages is proportional to the number of objects that send causally ordered messages to each other ( although in many cases , optimisations are possible [ RaSi96 ] ) . Causally ordered delivery has some limitations . In Usenet news , it may not be problematic when message delivery does not respect causal order ; often a response message contains parts of the original inquiry message , so it can be understood even while the inquiry has not been delivered . Enforcing causally ordered delivery would only add unnecessary overhead to messages in this situation . Moreover , the name CAUSAL order is misleading in a sense : just because m 1 is received at B before m 3 is sent ( cf . Figure B - 3 ) , does not mean r B ( m 1 ) caused s B ( m 3 ) in a semantic sense , which may be suggested by CAUSAL order , since r B ( m 1 ) < B s B ( m 3 ) . In reality , these events may be completely independent , e . g . , r B ( m 1 ) is the receipt of a request to change the colour of a circle on a whiteboard and s B ( m 3 ) is the sending of a request to change the colour of a square on the same whiteboard . Delaying r C ( m 3 ) in order to deliver according to CAUSAL order , which specifies m 1 < happened before m 3 would not be needed , but this is “unknown” to CAUSAL order . The CAUSAL order does not rely on grouplet - specific knowledge about real causal relations between messages . Hence , to be more precise , CAUSAL order only captures potential causal relations . Moreover , causally ordered delivery does not prevent two concurrent messages to be delivered in different order to different objects . If these messages represent two non - commutative update actions on a replicated collaborative object group , the group members may become inconsistent . A way to avoid inconsistency in such situations is to use a TOTAL order , as defined in Definition B - 4 . Despite these limitations , causally ordered delivery of messages is a powerful concept that is both necessary and sufficient for various distributed algorithms [ RaSi96 ] . For collaborative object groups in groupware systems , it can be used as a basis for the implementation of a token service , as illustrated in Figure B - 6 , and as a basis for the implementation of efficient totally ordered delivery . Moreover , it allows immediate delivery of messages to local objects ( since these are always received in CAUSAL order ) , which is a good basis to implement collaborative consistency management services that use operational transformation , which may be used in high - latency of disconnected environments , as will be described in later in this section when we describe TRANSFORMED order . 240 A PPENDIX B O RDERED M ESSAGE D ELIVERY B . 3 T OTAL Order Let m 1 and m 2 be messages , then a TOTAL order 82 is an ordering < TOTAL that satisfies the following properties ( Α pr (cid:2) PR : r pr ( m 1 ) < pr r pr ( m 2 ) ) (cid:3) ( ? pr (cid:2) PR : r pr ( m 1 ) < TOTAL r pr ( m 2 ) ) and ( Α pr (cid:2) PR : s pr ( m 1 ) < pr s pr ( m 2 ) ) (cid:3) ( ? pr (cid:2) PR : r pr ( m 1 ) < TOTAL r pr ( m 2 ) ) 83 Delivery of messages to a collaborative object group according to TOTAL order implies that all member objects receive messages , including concurrent messages , in the same order . r B ( m 1 ) r C ( m 1 ) r A ( m 1 ) s A ( m 1 ) B C A r C ( m 3 ) r A ( m 3 ) s B ( m 3 ) r B ( m 3 ) s A ( m 4 ) r B ( m 4 ) r C ( m 4 ) r A ( m 4 ) r B ( m 1 ) r C ( m 1 ) r A ( m 1 ) s A ( m 1 ) B C A r A ( m 3 ) s B ( m 3 ) s A ( m 4 ) r B ( m 4 ) r C ( m 4 ) r A ( m 4 ) r B ( m 3 ) r C ( m 3 ) Totally ordered delivery can be used to avoid the emergence of inconsistency , provided that states of the shared object replicas are initially consistent and that state changes in a replica are calculated by a 82 Note , that this ordering only defines a total order for all message receive events . Still , this ordering is called total , because , in contrast to message send - receive ordering , FIFO ordering and causal ordering , this ordering defines an ordering for all message receive events , which is the subset of events in a distributed system that needs to be ordered . 83 In the mathematical sense , a total ordering of message receive events does not imply FIFO ordering as defined here : when an object first sends m 1 ( e . g . , a request to insert the letter ‘o’ ) and then sends m 2 ( e . g . , a request to insert the letter ‘n’ ) , an arbitrary total order may deliver m 2 before m 1 at all sites . Though results may be consistent ( e . g . , an insertion of ‘no’ at all collaborative object group members ) , they may be contrary to programmer or user expectation . Most systems that provide totally ordered message delivery , deliver according to a total order that also respects FIFO order , i . e . , a delivery according to a TOTAL order defined in Definition B - 4 . Unless specified otherwise , we only consider totally ordered delivery according to a TOTAL order . Definition B - 4 TOTAL order Figure B - 4 Example of a violation of totally ordered delivery ( left ) and its solution ( right ) A PPENDIX B 241 deterministic algorithm that only uses the current replica state and received message as input ( and not , e . g . , references to local preferences , which might be different ) . Moreover , totally ordered delivery allows programmers to think of applications running in lockstep : events appear to be delivered to all members in a collaborative object group at the same moment , as illustrated in Figure B - 5 r B ( m 1 ) r C ( m 1 ) r A ( m 1 ) s A ( m 1 ) B C A r A ( m 3 ) s B ( m 3 ) s A ( m 4 ) r B ( m 4 ) r C ( m 4 ) r A ( m 4 ) r B ( m 3 ) r C ( m 3 ) r B ( m 1 ) r C ( m 1 ) r A ( m 1 ) s A ( m 1 ) B C A r A ( m 3 ) s B ( m 3 ) s A ( m 4 ) r B ( m 4 ) r C ( m 4 ) r A ( m 4 ) r B ( m 3 ) r C ( m 3 ) Different approaches exist to implement totally ordered delivery of messages to a replicated collaborative object group ; each approach incurs a different overhead and optimises performance for different message patterns . We distinguish and briefly describe three main approaches , based on the distribution 84 of the arbitrator function , i . e . , the function that decides on delivery order of concurrent messages : – the fully centralised arbitrator approach ; – the token - based arbitrator approach ; – the fully replicated arbitrator approach . In the fully centralised arbitrator approach , one member object is elected as the arbitrator ( e . g . , the object located at the site of the conference initiator ) . The arbitrator then determines the total delivery order for all members based on the order of receipt of messages at the arbitrator . For example , senders may multicast all messages to all collaborative object group members , the arbitrator delivers messages immediately , whereas non - arbitrators delay delivery until they receive a special multicast message from 84 These options are roughly similar to the distribution options for grouplets described in section 6 . 3 . 3 . Figure B - 5 Equivalent totally ordered executions 242 A PPENDIX B O RDERED M ESSAGE D ELIVERY the arbitrator that contains information how the arbitrator decided to order that particular message with respect to other messages [ KaTV93 ] . This protocol requires FIFO ordered delivery of protocol messages . The protocol is not fair ( the user with the shortest communication time to the centralised arbitrator always gets a better performance ) . Moreover , when the member object that has the arbitrator function leaves the collaborative object group ( e . g . , because the user that initiated the conference leaves the conference ) , the arbitrator needs to migrate to another member . In the token - based arbitrator approach ( which can also be described as a centralised arbitrator with migration approach ) , the communication platform maintains one arbitrator token for each collaborative object group , which can be passed with a special message ( or piggybacked on another message ) to other member objects . An object that receives such a message is the arbitrator ( an initial arbitrator can be chosen with the same algorithm as in the previous approach ) . The arbitrator is the only object in the collaborative object group that can give a total order token to other objects ( including non - member objects ) that want to send a totally ordered message to the collaborative object group . Typically , this will be used to give tokens to objects that are at short communication distance , such as members of other replicated collaborative object groups at the same computer . Totally ordered delivery can be achieved , for example , by buffering messages at a sender object until the total order token is acquired by that sender object . It then sends the message and gives the token back to the arbitrator . In order to deliver according to TOTAL order , causally ordered delivery of protocol messages of this protocol is both necessary — Figure B - 6 shows a sequence of non - totally ordered delivery that can arise without causally ordered delivery of protocol messages — and sufficient — COCOON [ Koll95 ] and Horus [ ReHB94 ] both employ a token protocol on top of causally ordered delivery in order to deliver messages in TOTAL order . A PPENDIX B 243 r ( do1 ) r ( do1 ) r ( do1 ) s ( do1 ) B C A r ( do2 ) r ( do2 ) s ( do2 ) r ( do2 ) s ( tgive ) r ( tgive ) r ( tgive ) r ( do1 ) s ( do1 ) r ( do2 ) s ( tgive ) r ( do1 ) r ( do1 ) B C A r ( do2 ) s ( do2 ) r ( do2 ) r ( tgive ) r ( tgive ) This token - based protocol optimises performance of totally ordered delivery when relatively few messages are sent concurrently , e . g . , when senders send messages in bursts that do not overlap much . This will often be the case when people access a shared object such as a shared telepointer , where people will naturally tend to take turns in controlling the movement of the shared telepointer . The first message in a series of messages from the same sender requires migration of the arbitrator to the collaborative object group member that is closest to the sender ( in a typical situation , it will move to a collaborative object group member on the computer of the sender ) . Delivery of this first message at lease takes three times the one - way network latency : one multicast message is needed to request the token , another message is needed to transfer the token and migrate the arbitrator and a third message is needed to send the actual message ( the latter message incurs no network latency for local delivery , hence local delivery time is at least two times the network latency ) . Subsequent messages from the same sender ( until the arbitrator must be migrated again in order to allow other objects to send messages ) at least take once the one - way network latency : messages can be multicast directly ( again , the latter message incurs no network latency for local delivery , so local delivery of subsequent messages may be even faster ) . Other arbitrator migration strategies exist that optimise total delivery of other message patterns ( see , e . g . , [ CoMi95 ] ) . In the fully replicated arbitrator approach , all objects arbitrate total order themselves . Implementation of causally ordered delivery of messages can implemented with a protocol that delivers messages in CAUSAL order with a vector clock implementation . For concurrent messages , an extra tie - break algorithm is needed that reach consistent decisions at all members about the order of concurrent messages . Lamport suggested to use an arbitrary Figure B - 6 Token - based arbitrator approach , without CAUSAL ordering ( left ) and with CAUSAL ordering ( right ) 244 A PPENDIX B O RDERED M ESSAGE D ELIVERY total ordering of the senders [ Lamp78 ] , e . g . , an order that is defined and redefined each time a member joins or leaves the group . This approach is problematic when senders stop sending for a while , since delivery of a message that is received should be delayed until it is certain that no concurrent messages from senders with lower sender - order are still on their way in the network ( remember , we assumed the communication latency is finite but unpredictable ) . So , this approach requires all senders to multicast messages regularly , otherwise a single silent sender can bring the system to a ( temporary ) halt . For a grouplet bus , the token - based approach with migrating arbitrator function is by far the most promising option : it allows members to join and leave the a conference freely and it is optimised for patterns of messages to a collaborative object group in which senders send messages in non - concurrent bursts . Unlike other approaches , it imposes only a minimal overhead when a user is working with an object alone for a while . Moreover , assuming that each collaborative object group has its own arbitrator function , this approach automatically load - balances the resources needed for arbitrator functionality during periods when different users work on different objects . B . 4 T RANSFORMED Order In addition to FIFO , CAUSAL and TOTAL order , a platform should provide TRANSFORMED order , which is based on operational transformation , when network latency is high ( e . g . , in intercontinental Internet connections , or in congested networks ) , or extremely high ( e . g . , when mobile computer disconnect from the network or when people voluntarily or involuntarily get disconnected from the group ) . In such circumstances , it may take very long to determine the TOTAL order ( e . g . , because it takes very long to obtain the total order token ) . In order to make progress and to allow a grouplet to make its service available ( though in a “degraded” form ) , the platform should deliver messages only in CAUSAL order , which allows direct delivery of received messages to local 85 collaborative object group members . This implies that delivery may be out of the TOTAL order . Due to out - of - order delivery , the collaborative object group may become inconsistent . However , in many cases the platform may be able to support re - establishing consistency at system quiescence , i . e . , when all messages at all sites have been delivered and executed ( which , for 85 Local should be taken here as “serving the same user” , which usually implies computationally inexpensive communication distance . A PPENDIX B 245 disconnected computer means that they have to get connected again ) . Essentially , this requires that the platform : – buffers messages that have been delivered locally in a history buffer , in order to take action when other messages arrive that should have been delivered earlier than recently delivered messages ; – buffers messages that have been sent by an object to other objects , but that have not been sent across the network yet ( in case of disconnected operation ) ; – buffers messages that have been received out of CAUSAL order . Moreover , it requires that a grouplet informs the platform how to recognise particular actions in messages and which transformation functions in the grouplet may be invoked to transform pairs of concurrent messages . For example , when a and b are two actions in concurrent messages ( i . e . , messages that may be delivered out of TOTAL order ) , and when ( a , b )  ( a b , b a ) is a consistent transformation ( cf . L - transformation in [ ReNG96 ] ) of a into a b and b into b a , i . e . , a transformation that satisfies ? s (cid:4) S m : a b ( b ( s ) ) = b a ( a ( s ) ) , then achieving consistency at quiescence is possible . We will not describe the entire algorithm ( for more details and proof of correctness , particularly for cases when messages are received multiple positions out of order , we refer to [ ReNG96 ] and [ Kana97 ] , which describe similar algorithms ) , but only sketch the main idea behind such algorithms . Suppose two sites both receive two concurrent messages , one contains the action a and the other action b , and suppose a grouplet specifies the consistent transformation ( a , b )  ( a b , b a ) , then , as illustrated in Figure B - 7 : – when a is received first and b next , the message containing a is delivered by the platform immediately , whereas the message containing b is delivered as b a ( e . g . , as special transform request message containing the original messages for b and a ) ; – when b is received first and a next , the message containing b is delivered by the platform immediately , whereas the message containing a is delivered as a b ( e . g . , as special transform request message containing the original messages for a and b ) ; Particular types of consistent transformations should be recognised and exploited by the platform to optimise its behaviour and to remove unnecessary 86 information from its buffers when possible : – Two actions are commutative ( denoted as a  b ) when their consistent transformation function is specified as ( a , b )  ( a , b ) , which implies ? s (cid:4) S m : a ( b ( s ) ) = b ( a ( s ) ) ) , i . e . , the order of execution does not affect 86 For the purpose of reaching consistency at system quiescence , that is . b a b a a b Figure B - 7 Consistent transformation : ( a , b )  ( a b , b a ) : either path reaches the same state ( adapted from [ ReNG96 ] ) 246 A PPENDIX B O RDERED M ESSAGE D ELIVERY the net final state . For example , moving an object on a whiteboard and changing its colour may be specified to commute . Commutativity implies that no transformation of delivered messages is necessary to achieve consistency at system quiescence . – Two actions may be masking . There are two cases . In the first case b masks a ( denoted as a Œ b ) , when their consistent transformation function is specified 87 as ( a , b )  ( id , b ) , which implies ? s (cid:4) S m : b ( s ) = b ( a ( s ) ) , i . e . , executing b after a has the same net effect as executing b only . For example , deleting an object after moving it has the same net effect as deleting it . When b is received first and then a , action a need not be executed and can be deleted from the history list . In the second case , a masks b ( denoted as a Õ b ) , when their consistent transformation function is specified as ( a , b )  ( a , id ) , which implies ? s (cid:4) S m : a ( b ( s ) ) = a ( s ) , i . e . , executing a after b has the same net effect as executing a only . When a is received first and then b , action b need not be executed and can be deleted from the history list . A special case of masking can be found in memoryless actions [ SHP + 97 ] , ( denoted as ŒŒ b ) ) , i . e . , actions with a property that is defined as ŒŒ b (cid:7) Α y (cid:4) S m ? s (cid:4) S m : b ( s ) = y . Hence , ŒŒ b implies ? a (cid:4) A m ? s (cid:4) S m : b ( a ( s ) ) = y = b ( s ) (cid:7) ? a (cid:4) A m : a Œ b , i . e . , a memoryless action masks all previous actions . For example , actions set _ state and load are typically memoryless actions . This property may be used to delete all previous actions from a history buffer . – Two actions conflict with each other ( denoted as a N b ) , when their consistent transformation function does not specify commutativity or masking , i . e . , a N b (cid:7) (cid:9) ( a  b ) (cid:10) (cid:9) ( a Œ b ) (cid:10) (cid:9) ( a Õ b ) . For example , an action to insert text in a string at position 5 and an action to insert text in a string at position 7 typically will be specified to be conflicting ; this requires specification of a consistent transformation ( a , b )  ( a b , b a ) . 87 We use id to denote the identity function , i . e . , ? s (cid:3) S m : id ( s ) = s . A PPENDIX B 247 For a single pair of actions ( a , b ) , many consistent transformations may exist . Finding the transformation that matches the expectations of users is a complex , grouplet - specific issue . For example , when two users concurrently insert the letter at the end of the word “ groupwar ” , say one inserts “ e ” and the other inserts “ s ” , the set of consistent transformations from which a developer may choose , includes : – ( ins ( “e” ) , ins ( “s” ) )  ( ( backsp ; ins ( “e” ) ; ins ( “s” ) ) , ins ( “s” ) ) , which results in “ groupwares ” at system quiescence ; – ( ins ( “e” ) , ins ( “s” ) )  ( ( ins ( “e” ) , ( backsp ; ins ( “s” ) ; ins ( “e” ) ) ) , which results in “ groupwarse ” at system quiescence ; – ( ins ( “e” ) , ins ( “s” ) )  ( ( backsp ; ins ( “e” ) , id ) , which results in “ groupware ” at system quiescence ; – ( ins ( “e” ) , ins ( “s” ) )  ( id , ( backsp ; ins ( “s” ) ) , which results in “ groupwars ” at system quiescence ; – ( ins ( “e” ) , ins ( “s” ) )  ( backsp , backsp ) , which results in “ groupwar ” at system quiescence ; – ( ins ( “e” ) , ins ( “s” ) )  ( ( backsp ; ins ( “OOPS” ) ) , ( backsp ; ins ( “OOPS” ) ) ) , which results in “ groupwarOOPS ” . As can be observed from the above example , when actions can be undone , e . g . , when there is a undo action b - 1 for b such that ? s (cid:4) S m : b - 1 ( b ( s ) ) = s , a consistent transformation of the form ( a , b )  ( ( b  a  b - 1 ) , b ) may be found . This transformation uses an undo / redo strategy : when a is received later than b is delivered , it may be possible to undo b ( i . e . , perform the action b - 1 ) , then execute a and then re - execute b [ SuZY95 ] . Similarly , undo actions a - 1 may allow specification of a consistent transformation of the form ( a , b )  ( a , ( a  b  a - 1 ) ) . In some cases , operational transformation should result in uncoupling and the emergence of parallel versions ( cf . slicing or the calculation of diffs in section 4 . 2 . 7 ; semantic merging is done later by the users , through a version merging function offered by the grouplet ) . The operational transformation only specifies that the history at each site forks as a consequence of slicing and that two parallel versions are available . Such a transformation may be represented as – ( ins ( “e” ) , ins ( “s” ) )  ( ( backsp ; version _ ins ( 1 , “e” ) ; version _ ins ( 2 , “s” ) ) , backsp ; version _ ins ( 1 , “e” ) ; version _ ins ( 2 , “s” ) ) , which may result in results in a versioned state at system quiescence ” groupware { e } 1 { s } 2 ” , where { } n represents a part of the string that is particular to version n . The grouplet may then decide to display version 1 , version 2 , or a diff of both versions , e . g . , “ groupwares ” . Whereas delivery orders FIFO , CAUSAL and TOTAL can all be implemented with mechanisms that only rely on the order in which messages are sent and 248 A PPENDIX B O RDERED M ESSAGE D ELIVERY received , and not on the messages themselves , operational transformation requires that the grouplet makes actions in messages recognisable for the platform and that the grouplet implements transformation functions that can be invoked by the platform instead of normal message delivery . Grouplet developers may decide themselves whether to use operational transformation or not . Despite the potential use of grouplet - dependent information , the platform itself is still grouplet - independent . In theory , advanced combinations of TOTAL ordering and operational transformation are possible . Research has shown that human perception of immediate causality is complete below 50 ms , begins to degrade at 50 ms end ends at 100 ms [ Cars90 ; CaMN83 ] . Hence , optimising response times below 50 ms is useless and optimising it below 100 ms is at least questionable . Hence , a protocol may be implemented that does not deliver local messages immediately , but waits for a certain small amount ( e . g . , 50 ms minus the time the system typically needs to process user input into a message that can be send and to compute output based on a delivered message ) . When this timer expires and the total order token has not arrived , the message is delivered out of total order , relying on operational transformation to achieve consistency at system quiescence . Such a protocol can avoid the computational overhead of operational transformation when network conditions allow it . Samenvatting In organisaties wordt steeds vaker in teams gewerkt . Ook vinden we er in toenemende mate computers die onderling zijn verbonden door netwerken . Deze trends hebben de laatste jaren geleid tot de opkomst van computer - ondersteund samenwerken als een veelbelovende werkvorm voor het uitvoeren van groepstaken . Desondanks is de computerondersteuning voor het samenwerken , groupware , vaak niet voldoende voor de samenwerkingsvormen die in de dagelijkse praktijk voorkomen . Onderzoek heeft aangetoond dat productief gebruik van groupware gehinderd wordt doordat : – de ondersteuning vaak alleen geschikt is voor heel specifieke vormen van samenwerken , – de ondersteuning te veel beperkingen oplegt aan de gebruikers , of – er een gebrek aan integratie bestaat tussen de verschillende vormen van ondersteuning . Deze problemen kunnen worden gereduceerd door het spanningsveld te verminderen tussen de zware gebruikerseisen enerzijds en de complexiteit van groupware - ontwikkeling anderzijds . Groupware - ontwikkelaars worden geconfronteerd met veelomvattende gebruikerseisen ten aanzien van groupware - diensten . Dit komt doordat samenwerken vele vormen kan hebben , afhankelijk van factoren zoals taak , groep , duur en context . Deze vormen wijzigen vaak na verloop van tijd . De gebruikerseisen voor groupware variëren bijvoorbeeld tussen ondersteuning voor : – gelijktijdig of op verschillende tijdstippen samenwerken ; – op dezelfde plaats of op verschillende plaatsen samenwerken ; – enkelvoudige , discrete media zoals tekst en tekeningen , en meervoudige media , inclusief continue media zoals geluid en video ; – veel vrijheid in de acties van gebruikers ( tolerante ondersteuning ) en coördinatie van de acties van gebruikers ( restrictieve ondersteuning ) . 250 S AMENVATTING Om dergelijke dynamische omgevingen te kunnen ondersteunen , moet groupware meestal veelomvattend en flexibel zijn . Het ontwikkelen van groupware - systemen is daarnaast bijzonder ingewikkeld : vergeleken met het ontwikkelen van toepassingen voor individuele gebruikers vergt het ontwikkelen van groupware - systemen namelijk ook aandacht voor technische zaken zoals replicatie , consistentie , gelijktijdige toegang en communicatieprotocollen . Om het hierboven geschetste spanningsveld tussen de vraagzijde en aanbodzijde van groupware - ontwikkeling te verminderen , stellen we in dit boek het bereiken van twee eigenschappen van groupware - systemen centraal : componeerbaarheid en uitbreidbaarheid . Groupware die componeerbaar is , stelt gebruikers in staat om groupware - componenten naar believen te selecteren en combineren , zodat de groupware kan worden toegesneden op de situatie waarin de ondersteuning wordt gebruikt . Groupware die uitbreidbaar is , stelt gebruikers in staat om groupware - componenten naar believen toe te voegen , zodra deze beschikbaar zijn of zodra deze nodig zijn . Samen zorgen componeerbaarheid en uitbreidbaarheid ervoor dat ontwikkelaars zich kunnen concentreren op het ontwikkelen van groupware - componenten , ofwel relatief kleine brokstukken groupware - functionaliteit . Een ontwerptraject van complexe systemen zoals component groupware behelst het maken van verschillende , onderling gerelateerde ontwerpen , waarin bijvoorbeeld steeds meer detail wordt toegevoegd . Het bepalen van de structuur voor ieder van die ontwerpen is een van de meest uitdagende ontwerpbeslissingen . De gemaakte keuze heeft namelijk vaak een verstrekkende invloed op de uitbreidbaarheid en de componeerbaarheid van een systeem . Het belangrijkste doel dat we in dit boek dan ook nastreven , is het beantwoorden van de volgende onderzoeksvraag : Hoe moeten groupware - systemen worden gestructureerd , om uitbreidbaarheid en componeerbaarheid te bereiken ? In hoofdstuk 2 beschrijven we allereerst de achtergrond van deze onderzoeksvraag door een overzicht van verschillende bestaande typen groupware - systemen te beschrijven en de complexiteit aan te geven waarmee ontwikkelaars van groupware zich geconfronteerd zien . We motiveren de behoefte aan uitbreidbare en componeerbare groupware - systemen op basis van resultaten van studies naar computerondersteund samenwerken . S AMENVATTING 251 Om de onderzoeksvraag te preciseren , definiëren we in hoofdstuk 3 verschillende concepten voor het ontwerp van component groupware , zoals uitbreidbaarheid en componeerbaarheid ( de doel - eigenschappen waarnaar gestreefd wordt ) , concepten voor het ontwerpen van groupware - systemen ( de context waarin deze eigenschappen nagestreefd worden ) , en structureringsrichtlijnen , generieke architecturen en platformen ( de middelen voor het bereiken van uitbreidbaarheid en componeerbaarheid ) . Aan de hand van drie abstractieniveaus delen we in hoofdstuk 3 het ontwerptraject van groupware - systemen op in delen die leiden tot het ontwerp van de dienst , het logisch ontwerp en het gedistribueerd ontwerp . In hoofdstuk 4 beschrijven we een generiek model waarmee groupware - diensten kunnen worden beschreven . Het is gebaseerd op een grote reeks groupware - toepassingen en op een conceptueel model van samenwerken . Het model wordt op zowel informele als formele wijze gedefinieerd . Voor het formele model maken we gebruik van verzamelingenleer en logica om verschillende concepten voor de specificatie van groupware - diensten te definiëren , zoals samenwerkingsinteractie , medium , actie , terugkoppeling , doorkoppeling , aanwezigheid , gewaarwording , koppeling , koppelingsniveaus , aggregatie , mediumcoördinatie en consistentiecontexten . Dit model van groupware - diensten vormt de basis voor de CoMeCo referentie - architectuur voor component groupware in hoofdstuk 5 , die het generieke model van groupware - diensten onderverdeelt in drie typen grouplets , die drie typen grouplet - diensten leveren : – conferentiebeheer ; – medium ; – coördinatie . De groupware - diensten die zijn beschreven in hoofdstuk 2 blijken uitgedrukt te kunnen worden als specifieke combinaties van specifieke grouplet - diensten voor conferentieheer , media en coördinatie . In hoofdstuk 6 beschrijven we collaborative compound document editing . Dit hoofdstuk beperkt zich tot grouplet - diensten van het type medium voor het bewerken van samengestelde documenten , ook wel bekend als ‘compound documents’ . Het beschrijft hoe uitbreidbaarheid en componeerbaarheid binnen dergelijke medium grouplet - diensten bereikt kunnen worden . Een grouplet - dienst voor collaborative compound document editing wordt volgens de compound document benadering onderverdeeld in kleinere ‘CoCoDoc grouplet - diensten’ . Iedere CoCoDoc grouplet - dienst richt zich daarbij op het bieden van een dienst voor het gezamenlijk bewerken van één abstract datatype en kan hiërarchisch gecombineerd worden met andere 252 S AMENVATTING CoCoDoc grouplet - diensten . Zo ontstaat een gemeenschappelijke editor voor een samengesteld document dat uit verschillende typen gegevens bestaat . Het reeds bestaande compound document editing ondersteunt al stapsgewijze migratie naar het bewerken van nieuwe typen gegevens in documenten . Collaborative compound document editing voegt de mogelijkheid toe voor stapsgewijze migratie vanuit een situatie waarin bestaande componenten worden gebruikt met beperkte mogelijkheden voor het samenwerken aan documenten , naar een situatie waarin ook meer geavanceerde CoCoDoc grouplets gebruikt kunnen worden . In aanvulling op deze structureringsrichtlijnen en architecturen op dienstniveau beschrijft dit hoofdstuk ook structuren voor collaborative compound document editing op logisch en gedistribueerd niveau . Om verschillende vormen van koppeling te kunnen bieden , moeten CoCoDoc grouplets logisch gestructureerd worden volgens de collaborative zipper architectuur . Deze architectuur onderscheidt verschillende lagen van statusinformatie die ieder afzonderlijk gekoppeld en ontkoppeld kunnen worden . Dit vereenvoudigt bijvoorbeeld het maken van CoCoDoc grouplets die verschillende niveaus van koppeling kunnen ondersteunen en CoCoDoc grouplets die gebruikers uitgebreide controle over het niveau van koppeling van acties kunnen geven . In hoofdstuk 6 beschrijven we eveneens hoe een gedistribueerd ontwerp van een grouplet moet worden onderverdeeld in grouplet entiteiten volgens de gedistribueerde collaborative zipper architectuur . Deze architectuur onderscheidt verschillende vormen van distributie . Noch een gecentraliseerde architectuur noch een gerepliceerde architectuur voor horizontale distributie blijkt optimaal voor alle gevallen . Replicatie blijkt echter vrijwel in alle gevallen nodig voor grouplets die : – flexibele koppeling moeten ondersteunen ; – goede prestaties moeten kunnen leveren bovenop communicatie - infrastructuren met grote vertragingen of kleine bandbreedte ; – beschikbaar moeten zijn ondanks niet altijd aanwezige netwerkverbindingen . Ter ondersteuning van het maken van gedistribueerde grouplets stellen we een platform voor dat gebaseerd is op collaborative object groups . Dit zijn groepen van gerepliceerde objecten die zich kunnen gedragen alsof ze één object zijn . Collaborative object groups hebben daarbij de bijzondere eigenschap dat ze gedurende hun levensduur kunnen omschakelen tussen het gedrag als één object en het gedrag als een verzameling onafhankelijke objecten . Deze eigenschap is handig in de gedistribueerde collaborative zipper architectuur voor het dynamisch kunnen koppelen en ontkoppelen van acties in een conferentie . S AMENVATTING 253 In hoofdstuk 7 beschrijven we prototypes van drie gerelateerde platformen die het implementeren van groupware - systemen volgens de voorgestelde structureringsrichtlijnen en architecturen vereenvoudigen : – MediaBuilder , een prototype van een platform voor multimedia groupware - toepassingen over ATM - en IP - netwerken . MediaBuilder is gebaseerd op een vroege versie van de CoMeCo referentie - architectuur voor component groupware . – MORB , een prototype van een op CORBA gebaseerd platform voor couplable object groups . Deze beperkte vorm van collaborative object groups ondersteunt alleen volledige koppeling en volledige ontkoppeling en transities daartussen . De MORB is geïmplementeerd boven op een CORBA Object Request Broker en de MediaBuilder shared object collection . – CoCoDoc , een prototype van een collaborative compound document editing framework op basis van OpenDoc en CORBA . Boven op deze platformen hebben we CoCoTree geïmplementeerd . CoCoTree is een eenvoudige collaborative outline editor met twee koppelingsniveaus per outline item en de mogelijkheid om OLE 2 . 0 compatibele editors te gebruiken voor het bewerken van ge - embedde inhoud . In het bijzonder demonstreert CoCoTree hoe een systeem voor het gemeenschappelijk bewerken van documenten een vliegende start gegeven kan worden door de combinatie van een eenvoudige CoCoDoc grouplet ( die flexibele vormen van koppeling ondersteunt ) met een grote variëteit aan ongewijzigde toepassingen voor individueel gebruik ( die slechts beperkte vormen van koppeling kunnen ondersteunen ) . De platformen staan programmeurs toe een traditionele programmeerstijl te gebruiken , terwijl de platformen zelf de grouplet - onafhankelijke , foutgevoelige en prestatie - kritische aspecten afhandelen . Zo kunnen programmeurs zich concentreren op de grouplet - specifieke aspecten , in plaats van op de details van distributie , replicatie en consistentiebeheer . Onze ervaringen met het implementeren van CoCoTree boven op CoCoDoc , MORB en MediaBuilder laten zien dat het bereiken van uitbreidbaarheid en componeerbaarheid bij het maken van groupware - systemen effectief ondersteund kan worden met de structureringsrichtlijnen , architecturen en platformen die in dit boek worden aangedragen . References URLs are provided , where available , for easy access to online versions of works cited . See http : / / www . telin . nl / publicaties / 1998 / wat / refs . htm for a clickable and up - to - date version of this reference list . For the full text of some of the cited works , you may need an account for the ACM Digital Library or the IEEE Computer Society Digital Library . [ ABF + 92 ] Arango , M . , P . Bates , R . Fish , G . Gopal , N . Griffeth , G . Herman , T . Hickey , W . Leland , C . Lowery , V . Mak , J . Patterson , L . Ruston , M . Segal , M . Vecchi , A . Weinrib and S . Wuu , ' Touring machine : A software platform for distributed multimedia applications ' . In G . Neufeld and B . Plattner ( eds . ) , Upper layer protocols , architectures and applications : proceedings of the IFIP TC / WG6 . 5 International Conference on Upper Layer Protocols , Architectures , and Applications , Vancouver , B . C . , Canada , 27 - 29 May , 1992 , vol . C - 7 , IFIP Transactions C : Communication Systems . North - Holland , Amsterdam , 1992 , p . 3 - 15 . [ AbFe91 ] Abdel - Wahab , H . M . and M . A . Feit , ' XTV : A framework for sharing X window clients in remote synchronous collaboration ' . In Proceedings of IEEE Tricomm ' 91 : Communications for distributed applications & systems , Chapel Hill , NC , USA , 1991 . IEEE Computer Society Press , Los Alamitos , CA , USA , 1991 , p . 159 - 167 . [ ACD + 97 ] Anker , T . , G . V . Chockler , D . Dolev and I . Keidar , ' The Caelum toolkit for CSCW : The sky is the limit ' . In NGITS ' 97 : Proceedings of the third international workshop on next generation information technologies and systems , Neve Ilan , Israel , June 30 - July 3 , 1997 , 1997 , ftp : / / ftp . cs . huji . ac . il / users / transis / ngits97 . ps . gz . [ ACI + 95 ] Apple Computer , Component Integration Laboratories , IBM and Novell , OMG RFP submission : Compound presentation and compound interchange facilities . Object Management Group , Framingham , MA , USA , 1995 . OMG document , 95 - 12 - 30 , http : / / www . omg . org / docs / 1995 / 95 - 12 - 30 . pdf . [ ADH + 93 ] Altenhofen , M . , J . Dittrich , R . Hammerschmidt , T . Käppner , C . Kruschel , A . Kückes and T . Steining , ' The BERKOM multimedia collaboration service ' . In Proceedings of ACM Multimedia 93 , Anaheim , CA , USA , August 1 - 6 , 1993 . Association for Computing Machinery , New York , 1993 , p . 457 - 463 . [ AhEH88 ] Ahuja , S . R . , J . R . Ensor and D . N . Horn , ' The rapport multimedia conferencing system ' . In R . B . Allen ( ed . ) , Conference on office information systems , March 23 - 25 , 1988 , Palo Alto , CA , USA , vol . 9 ( 2 & 3 ) , SIGOIS Bulletin . ACM Press , New York , 1988 , p . 1 - 8 . 256 R EFERENCES [ AhEL90 ] Ahuja , S . R . , J . R . Ensor and S . E . Lucco , ' A comparison of application sharing mechanisms in real - time desktop conferencing systems ' . In F . H . Lochovsky and R . B . Allen ( eds . ) , Conference on office information systems , April 25 - 27 , 1990 , Cambridge , Massachusetts , vol . 11 ( 2 , 3 ) , SIGOIS bulletin . ACM Press , New York , 1990 , p . 238 - 248 . [ AKK + 97 ] Abdel - Wahab , H . M . , B . Kvande , O . Kim and J . P . Favreau , ' An internet collaborative environment for sharing Java applications ' . In FTDCS ' 97 : Proceedings of the sixth IEEE computer society workshop on future trends of distributed computing systems , Tunis , Tunesia , October 29 - 31 , 1997 . IEEE Computer Society Press , Los Alamitos , CA , USA , 1997 , p . 112 - 117 , http : / / snad . ncsl . nist . gov / madvtg / Java / ftdcs97 . ps . [ AKK + 97b ] Abdel - Wahab , H . M . , B . Kabore , O . Kim and J . P . Favreau , Replicated architecture for application sharing in desktop conferencing systems . Old Dominion University , Norfolk , VI , USA , submitted for publication , http : / / snad . ncsl . nist . gov / madvtg / Java / replication . ps . [ AlNT90 ] Altenhofen , M . , B . Neidecker - Lutz and P . Tallett , ' Upgrading a window system for tutoring functions ' . In Proceedings of the European X window system conference , London , November 12 - 14 , 1990 . CEP Consultants , Edinburgh , UK , 1990 , p . 37 - 44 . [ ApKN86 ] Applegate , L . M . , B . R . Konsynski and J . F . Nunamaker , ' A group decision support system for idea generation and issue analysis in organization planning ' . In [ CSCW86 ] , p . 16 - 34 . [ BaDF96 ] Bandinelli , S . , E . Di Nitto and A . Fugetta , ' Supporting cooperation in the SPADE - 1 environment ' . IEEE Transactions on software engineering , 22 ( December 1996 ) , 12 , p . 841 - 885 , http : / / computer . org / tse / ts1996 / e0841abs . htm . [ BaGP93 ] Baldeschwieler , J . E . , T . Gutekunst and B . Plattner , ' A survey of X protocol multiplexors ' . ACM SIGCOMM Computer Communication Review , 23 ( April 1993 ) , 2 , p . 16 - 24 . [ Bakk94 ] Bakker , H . , Object - oriented modelling of information systems : The INCA conceptual object model . Ph . D . Thesis , published by the author , 1994 . [ BCD + 95 ] van den Broecke , J . , Ph . Chimento , B . van Driel , H . Eertink , G . H . ter Hofte , M . J . van Sinderen , J . T . van der Veen and J . P . C . Verhoosel , Middleware software architecture . B . van Driel ( ed . ) . Lucent Technologies , Huizen , the Netherlands , 1995 , PLATINUM / T2 . 1 / N035 / V06 . [ Beau94b ] Beaudouin - Lafon , M . , ' Beyond the workstation : Mediaspaces and augmented reality ' . In G . Cockton , S . W . Draper and G . R . S . Weir ( eds . ) , Proceedings of HCI ' 94 , Glasgow , 1994 , vol . IX , People and computers . Cambridge University Press , Cambridge , 1994 , p . 9 - 18 . [ BeBe93 ] Beck , E . E . and V . M . E . Belotti , ' Informed opportunism as strategy : Supporting coordination in distributed collaborative writing ' . In G . de Michelis , C . Simone and K . Schmidt ( eds . ) , Proceedings of the third European conference on computer - supported cooperative work , September 13 - 17 , 1993 , Milan , Italy . Kluwer Academic , Dordrecht , the Netherlands , 1993 , p . 233 - 248 . [ BeDo95 ] Bentley , R . and P . Dourish , ' Medium versus mechanism : Supporting collaboration through customisation ' . In [ ECSCW95 ] , p . 133 - 148 , ftp : / / shell4 . ba . best . com / pub / jpd / papers / ecscw95 - customisation . ps . [ BeGe93 ] Berlage , T . and A . Genau , ' A framework for shared applications with a replicated architecture ' . In UIST ' 93 : Proceedings of the sixth annual ACM symposium on user interface software and technology , Atlanta , GA , USA , 1993 . ACM Press , 1993 , p . 249 - 257 , http : / / www . acm . org / pubs / articles / proceedings / uist / 168642 / p249 - berlage / p249 - berlage . pdf . [ BEI + 94 ] BNR Europe , Expersoft , IBM , ICL , IONA Technologies and SunSoft , ORB 2 . 0 RFP submission : Universal Networked Objects . Object Management Group , Framingham , MA , USA , 1994 . OMG document , 4 . 9 . 32 , http : / / www . omg . org / docs / 1994 / 94 - 09 - 32 . pdf . R EFERENCES 257 [ Bent94 ] Bentley , R . M . , Supporting multi - user interface development for cooperative systems . Ph . D . thesis , Department of Computing , Lancaster University , Lancaster , UK , 1994 , ftp : / / ftp . comp . lancs . ac . uk / pub / reports / ThesisRB . ps . Z . [ Berg96 ] Berger , M . , ' CoNus - A CSCW system supporting synchronous , asynchronous and autonomous collaborative work ' . In A . Schill , O . Spaniol , C . Mittasch and C . Popien ( eds . ) , ICDP ' 96 : IFIP / IEEE international conference on distributed platforms : Industrial Stream / poster session . Technische Universität Bergakademie Freiberg , Freiberg , D , 1996 , p . 27 - 39 . [ BeSS97 ] Begole , J . , C . A . Struble and C . A . Shaffer , ' Leveraging Java applets : toward collaboration transparency in Java ' . IEEE Internet Computing , 1 ( 1997 ) , 2 , p . 57 - 64 , http : / / pdf . computer . org / ic / books / ic1997 / pdf / w2057 . pdf . [ Bier91 ] Bier , E . A . , ' MMM : A user interface architecture for shared editors on a single screen ' . In UIST ' 91 : Proceedings of the fourth ACM symposium on user interface software and technology , Hilton Head , SC , USA , November 11 - 13 , 1991 . ACM Press , New York , 1991 , p . 79 - 86 , http : / / www . acm . org / pubs / articles / proceedings / uist / 120782 / p79 - bier / p79 - bier . pdf . [ BiJo87 ] Birman , K . P . and T . A . Joseph , ' Reliable communication in the presence of failures ' . ACM Transactions of Computer Systems , 5 ( February 1987 ) , 1 , p . 47 - 76 . [ Birm93 ] Birman , K . P . , ' The reliable process group approach to reliable distributed computing ' . Communications of the ACM , 36 ( December 1993 ) , 12 , p . 37 - 53 , 103 , http : / / www . acm . org / pubs / articles / journals / cacm / 1993 - 36 - 12 / p37 - birman / p37 - birman . pdf . [ BNP + 93 ] Baecker , R . M . , D . Nastor , I . R . Posner and K . L . Mawby , ' The user - centred iterative design of collaborative writing software ' . In S . Ashlund , K . Mullet , A . Henderson and T . White ( eds . ) , Human factors in computing systems : INTERCHI ' 93 . ACM Press , New York , 1993 , p . 399 - 405 , http : / / www . acm . org / pubs / articles / proceedings / chi / 169059 / p399 - baecker / p399 - baecker . pdf . [ BoCR88 ] Bowers , J . M . , J . Churcher and T . Roberts , ' Structuring computer - mediated communication in COSMOS ' . In R . Speth ( ed . ) , Research into networks and distributed applications : Proceedings of European teleinformatics conference - EUTECO ' 88 on research into networks and distributed applications , Vienna , Austria , April 20 - 22 , 1988 . North - Holland , Amsterdam , 1988 , p . 195 - 209 . [ BrCo97 ] van den Broecke , J . A . and J . O . Coplien , ' Using patterns to build a framework for multimedia networking ' . Bell Labs Technical Journal , 2 ( 1997 ) , 1 , p . 166 - 187 , http : / / www . lucent . com / ideas2 / perspectives / bltj / winter _ 97 / pdf / paper13 . pdf . [ BrGo92 ] Brinck , T . and L . M . Gomez , ' A collaborative medium for the support of conversational props ' . In [ CSCW92 ] , p . 171 - 178 , http : / / www . acm . org / pubs / articles / proceedings / cscw / 143457 / p171 - brinck / p171 - brinck . pdf . [ BRS + 94 ] Bentley , R . , T . Rodden , P . Sawyer and I . Sommerville , ' Architectural support for cooperative multi - user interfaces ' . Computer , 27 ( May 1994 ) , 5 , p . 37 - 45 , ftp : / / ftp . comp . lancs . ac . uk / pub / reports / 1993 / CSCW . 11 . 93 . ps . Z . [ BrSM90 ] Brothers , L . , V . Sembugamoorthy and M . Muller , ' ICICLE : Groupware for code inspection ' . In [ CSCW90 ] , p . 169 - 181 . [ BSS + 92 ] Benford , S . D . , H . Smith , A . Sheperd , A . Bullock and H . Howidy , ' Information sharing approach to CSCW : The Grace project ' . Computer communications , 15 ( 1992 ) , 8 , p . 502 - 509 . [ BTB + 96 ] Bogia , D . , W . J . Tolone , C . Bignoli and S . M . Kaplan , ' Issues in the design of collaborative systems : Lessons from ConversationBuilder ' . In D . Shapiro , M . J . Tauber and R . Traunmüller ( eds . ) , The design of computer supported cooperative work and groupware systems , vol . 12 , Human factors in information technology . Elsevier , Amsterdam , 1996 , p . 401 - 422 , ftp : / / cs . uiuc . edu / pub / cb / papers / schaerding - 93 . ps . gz . 258 R EFERENCES [ BuBe93 ] Bullen , C . V . and J . L . Bennett , ' Groupware in practice : An interpretation of work experiences ' . In R . M . Baecker ( ed . ) , Readings in groupware and computer - supported cooperative work : Assisting human - human collaboration . Morgan Kaufmann , San Mateo , CA , USA , 1993 , p . 69 - 84 . [ Cabl97 ] Cable , L . P . G . , Proposal for a drag and drop subsystem for the Java foundation classes : Draft : 0 . 95 . Sun Microsystems , Mountain View , CA , USA , December 10 , 1997 , http : / / java . sun . com / beans / glasgow / dnd . pdf . [ Cabl98 ] Cable , L . P . G . , A draft proposal to define an extensible runtime containment and services protocol for JavaBeans ( version 0 . 98 ) . Sun Microsystems , Mountain View , CA , USA , January 9 , 1998 , http : / / java . sun . com / beans / glasgow / context98 _ maker . pdf . [ CaMN83 ] Card , S . K . , T . P . Moran and A . Newell , The psychology of human - computer interaction . Lawrence Erbaum , Hillsdale , NJ , USA , 1983 . [ Cars90 ] Carson , G . S . , ' Graphics , networking and distributed computing ' . In D . B . Arnold , R . A . Day , D . A . Duce , J . R . Gallop , R . Maybury and D . C . Sutcliffe ( eds . ) , Proceedings of an international workshop on graphics and communications , Breuberg , Germany , October 15 - 17 , 1990 . Springer - Verlag , Berlin , 1990 , p . 39 - 47 . [ CaSh98 ] Calder , B . and B . Shannon , JavaBeans activation framework specification : Version 1 . 0 . Sun Microsystems , Mountain View , CA , USA , March 16 , 1998 , http : / / java . sun . com / beans / glasgow / jaf _ spec . pdf . [ CFS + 94 ] Craighill , E . , M . W . Fong , K . Skinner , R . E . Lang and K . Greneveldt , ' SCOOT : An object - oriented toolkit for multimedia collaboration ' . In ACM Multimedia ' 94 : Proceedings of Second ACM international conference on multimedia , San Francisco , CA , USA , October 15 - 20 , 1994 . ACM , New York , 1994 , p . 41 - 49 , http : / / www . acm . org / pubs / articles / proceedings / multimedia / 192593 / p41 - craighill / p41 - craighill . pdf . [ ChCe96 ] Churcher , N . and C . Cerecke , ' GroupCRC : Exploring CSCW support for software engineering ' . In J . C . Grundy and M . D . Apperley ( eds . ) , OzCHI ' 96 : Proceedings of Sixth Australian conference on computer - human interaction , Hamilton , New Zealand , November 24 - 27 , 1996 . IEEE Computer Society Press , Los Alamitos , CA , USA , 1996 , p . 62 - 68 , http : / / www . cosc . canterbury . ac . nz / ~ neville / papers / groupCRC . ps . [ ChDe96 ] Chung , G . and P . Dewan , ' A mechanism for supporting client migration in a shared window system ' . In UIST ' 96 : Proceedings of ACM symposium on user interface software and technology , Seattle , WA , USA , November 6 - 8 , 1996 . ACM Press , New York , 1996 , p . 11 - 20 , http : / / www . acm . org / pubs / articles / proceedings / uist / 237091 / p11 - chung / p11 - chung . pdf . [ ChLi97 ] Chappell , D . and D . S . Linthicum , ' ActiveX demystified ' . Byte , 22 ( September 1997 ) , 9 , p . 56 - 62 , 64 , http : / / www . byte . com / art / 9709 / sec5 / sec5 . htm . [ ChSk93 ] Cheriton , D . R . and D . Skeen , ' Understanding the limitations of causally and totally ordered communication ' . In SIGOPS ' 93 : Proceedings of the 14th ACM symposium on operating system principles , Asheville , NC , USA , December 5 - 8 , 1993 . ACM , New York , 1993 , p . 44 - 57 . [ Clar94 ] Clark , W . J . , ' Protocols for multimedia conferencing - An introduction to the ITU - T T . 120 series ' . In D . Hutchinson ( ed . ) , Multimedia : Proceedings of International COST 237 workshop , Vienna , Austria , 1994 , vol . 882 , Lecture notes in computer science . Springer - Verlag , Berlin , 1994 , p . 322 - 333 . [ ClBr91 ] Clark , H . H . and S . E . Brennan , ' Grounding in communication ' . In L . B . Resnick , J . M . Levine and S . D . Behrend ( eds . ) , Perspectives on socially shared cognition . American Psychological Association , Washington , DC , USA , 1991 , p . 127 - 149 . R EFERENCES 259 [ CLF + 93 ] Craighill , E . , R . E . Lang , M . W . Fong and K . Skinner , ' CECED : A system for informal multimedia collaboration ' . In Proceedings of ACM Multimedia 93 , Anaheim , CA , USA , August 1 - 6 , 1993 . Association for Computing Machinery , New York , 1993 , p . 437 - 445 , http : / / www . acm . org / pubs / articles / proceedings / multimedia / 166266 / p437 - craighill / p437 - craighill . pdf . [ CMB + 90 ] Crowley , T . , P . Milazzo , E . Baker , H . Forsdick and R . Tomlinson , ' MMConf : An infrastructure for building shared multimedia applications ' . In [ CSCW90 ] , p . 329 - 342 . [ CMS + 86 ] De Cindo , F . , G . De Michelis , C . Simone , R . Vassalio and A . M . Zanaboni , ' CHAOS as a coordination technology ' . In [ CSCW86 ] , p . 325 - 342 . [ CoBe88 ] Conklin , J . and M . L . Begeman , ' gIBIS : A hypertext tool for exploratory policy discussion ' . ACM transactions on office information systems , 6 ( 1988 ) , 4 , p . 303 - 331 . [ Cock93 ] Cockburn , A . J . G . , Groupware design : Principles , prototypes and systems . Ph . D . Thesis , Department of Computing Science and Mathematics , University of Stirling , UK , 1993 . [ CoGh96 ] Comair , C . and P . Ghali , ' The skeleton of a video game curriculum ' . In A . Verbraeck ( ed . ) , Telematics in a multimedia environment : Proceedings of Euromedia 96 , Featuring WEBTEC - MEDIATEC - COMTEC - APTEC , London , United Kingdom , December 19 - 21 , 1996 . Society for Computer Simulation International , Ghent , Belgium , 1996 , p . V - IX . [ CoMa96 ] Costa , F . M . and E . R . M . Madeirea , ' An object model and its implementation to support cooperative applications on CORBA ' . In A . Schill , C . Mittasch , O . Spaniol and C . Popien ( eds . ) , Distributed Platforms : Proceedings of IFIP / IEEE international conference on distributed platforms : client / server and beyond : DCE , CORBA , ODP and advanced distributed applications , Dresden , February 1996 . Chapman & Hall , London , UK , 1996 , p . 213 - 228 . [ CoMi95 ] Cortes , M . and P . Mishra , ' Replicated servers for on - line groupware ' . In Concurrent engineering : A global perspective : Proceedings of the concurrent engineering 1995 conference , McLean , Virginia , USA , August 23 - 25 , 1995 . Concurrent Technologies Corporation , Johnstown , PA , USA , 1995 , p . 261 - 271 , http : / / www . cs . sunysb . edu / ~ mcortes / papers / dynserv . ver6 . ps . Z . [ CoMi96 ] Cortes , M . and P . Mishra , ' DCWPL : A programming language for describing collaborative work ' . In [ CSCW96 ] , p . 21 - 29 , http : / / www . cs . sunysb . edu / ~ mcortes / papers / cscw96 . ps . Z . [ Cort94 ] Cortes , M . , CSCW Survey : Concepts , Applications and Programming Tools . Department of Computer Science , State University of New York Stony Brook , New York , 1994 . Technical Report , TR - 006 - 94 , http : / / www . cs . sunysb . edu / ~ mcortes / papers / techrep . 94 - 006 . ps . Z . [ CoVe95 ] Cosquer , F . and P . Veríssimo , ' The impact of group communication paradigms on groupware support ' . In Proceedings of the 5th Workshop on Future Trends of Distributed Computing Systems , Cheju Island , Korea , August 28 - 30 , 1995 , 1995 , ftp : / / www . navigators . di . fc . ul . pt / pub / Navigators / ImpactGrCom . ps . gz . [ CSCW86 ] Greif , I . , ( ed . ) , CSCW ' 86 : Proceedings of the conference on computer - supported cooperative work , December 3 - 5 , 1986 , Austin , Texas , USA . Association for Computing Machinery , New York , 1986 . [ CSCW88 ] Suchman , L . , ( ed . ) , CSCW 88 : Proceedings of the conference on computer - supported cooperative work , September 26 - 29 , 1988 , Portland , Oregon . Association for Computing Machinery , New York , 1988 . [ CSCW90 ] Halasz , F . , ( ed . ) , CSCW ' 90 : Proceedings of the conference on computer - supported cooperative work , October 7 - 10 , 1990 , Los Angeles , CA , USA . Association for Computing Machinery , New York , 1990 . [ CSCW92 ] Turner , J . and R . E . Kraut ( eds . ) , CSCW ' 92 : Proceedings of the conference on computer - supported cooperative work , October 31 to November 4 1992 , Toronto , Canada . Association for Computing Machinery , New York , 1992 , http : / / www . acm . org / pubs / contents / proceedings / cscw / 143457 / index . html . 260 R EFERENCES [ CSCW94 ] Furuta , R . and C . M . Neuwirth ( eds . ) , CSCW ' 94 : Proceedings of the conference on computer supported cooperative work , October 22 - 26 , 1994 , Chapel Hill , NC , USA . ACM Press , New York , 1994 , http : / / www . acm . org / pubs / contents / proceedings / cscw / 192844 / index . html . [ CSCW96 ] Ackerman , M . S . , ( Ed . ) , CSCW ' 96 , Proceedings of the ACM 1996 conference on computer supported cooperative work , Boston , MA , November 16 - 20 , 1996 . ACM Press , New York , 1996 , http : / / www . acm . org / pubs / contents / proceedings / cscw / 240080 / index . html . [ DeCh91 ] Dewan , P . and R . Choudhary , ' Flexible user interface coupling in a collaborative system ' . In S . P . Robertson , G . M . Olson and J . S . Olson ( eds . ) , Human factors in computing systems : reaching through technology : Proceedings of CHI ' 91 , New Orleans , Louisiana , USA , April 27 - May 2 , 1991 . Addison - Wesley , Reading , MA , USA , 1991 , p . 41 - 48 , http : / / www . acm . org / pubs / articles / proceedings / chi / 108844 / p41 - dewan / p41 - dewan . pdf . [ DeCh92 ] Dewan , P . and R . Choudhary , ' A high - level and flexible framework for implementing multiuser interfaces ' . ACM Transactions of Information Systems , 10 ( October 1992 ) , 4 , p . 345 - 380 , ftp : / / ftp . cs . unc . edu / pub / users / dewan / papers / framework . ps . Z . [ DeCh95 ] Dewan , P . and R . Choudhary , ' Coupling the user interfaces of a multiuser program ' . ACM Transactions on Computer - Human Interaction , 2 ( March 1995 ) , 1 , p . 1 - 39 , ftp : / / ftp . cs . unc . edu / pub / users / dewan / papers / coupling . ps . Z . [ DeCS94 ] Dewan , P . , R . Choudhary and H . Shen , ' An editing - based characterization of the design space of multiuser applications ' . In Proceedings of the fourth conference on organizational computing , coordination and collaboration : theories and technologies for computer - supported work , Austin , TX , USA , March 1993 , vol . 4 ( 3 ) , Journal of Organizational Computing , 1994 , p . 219 - 239 , ftp : / / ftp . cs . unc . edu / pub / users / dewan / papers / edit . ps . Z . [ Dewa93b ] Dewan , P . , ' Tools for implementing multiuser user interfaces ' . In L . Bass and P . Dewan ( eds . ) , User interface software , vol . 1 , Trends in software . John Wiley & Sons , Chichester , UK , 1993 , p . 149 - 174 , ftp : / / ftp . cs . unc . edu / pub / users / dewan / papers / trends . ps . Z . [ Dewa96 ] Dewan , P . , ' Multiuser architectures ' . In C . Unger and L . J . Bass ( eds . ) , Engineering for HCI : Proceedings of IFIP WG2 . 7 Working Conference on Engineering for Human - Computer Interaction , Grand Targhee Resort , Wyoming , USA , August 14 - 18 , 1995 . Chapman & Hall , London , UK , 1996 , p . 247 - 270 , ftp : / / ftp . cs . unc . edu / pub / users / dewan / papers / arch . ps . Z . [ DoBe92 ] Dourish , P . and V . M . E . Belotti , ' Awareness and coordination in shared workspaces ' . In [ CSCW92 ] , p . 107 - 114 , ftp : / / shell4 . ba . best . com / pub / jpd / papers / cscw92 - awareness . ps . [ DoGa97 ] Dommel , H . P . and J . J . Garcia - Luna - Aceves , ' Floor control for multimedia conferencing and collaboration ' . Multimedia systems , 5 ( 1997 ) , 1 , p . 23 - 38 , http : / / link . springer . de / link / service / journals / 00530 / papers / 7005001 / 70050023 . pdf . [ Dour95 ] Dourish , P . , ' The parting of the ways : Divergence , data management and collaborative work ' . In [ ECSCW95 ] , p . 215 - 230 , ftp : / / shell4 . ba . best . com / pub / jpd / papers / ecscw95 - divergence . ps . [ Dour96a ] Dourish , P . , Open implementation and flexibility in CSCW toolkits . Ph . D . Thesis , Department of Computer Science , University College London , London , UK , 1996 , ftp : / / shell4 . ba . best . com / pub / jpd / thesis / thesis . pdf . [ Dour96b ] Dourish , P . , ' Consistency guarantees : Exploiting application semantics for consistency management in a collaboration toolkit ' . In [ CSCW96 ] , p . 268 - 277 , ftp : / / shell4 . ba . best . com / pub / jpd / papers / cscw96 - consistency . ps . R EFERENCES 261 [ DPC + 95 ] Dykstra - Erickson , E . , K . Piersol , D . Curbow , G . Schuller and K . Ortega , ' OpenDoc , A standard foundation for collaboration ' . In Y . Sundblad , K . Tollmar , T . Reigner , L . Fahlén and J . Forsyth ( eds . ) , ECSCW ' 95 Conference Supplement : Proceedings of the fourth European conference on computer - supported cooperative work , Stockholm , Sweden , September 10 - 14 , 1995 . KTH , Stockholm , Sweden , 1995 , p . 21 - 22 , http : / / www . best . com / ~ curbow / dave / papers / ecscw95 / poster . html . [ DPP + 86 ] Danielsen , T . , U . Pankoke - Babatz , W . Prinz , A . Patel , P . A . Pays , K . Smaaland and R . Speth , ' The AMIGO project : Advanced group communication model for computer - based communication environment ' . In [ CSCW86 ] , p . 115 - 142 . [ ECSCW89 ] EC - CSCW ' 89 : Proceedings of the first European conference on computer supported cooperative work , 13th - 15th September , 1989 , Gatwick , London , UK . unpublished , 1989 . [ ECSCW91 ] Bannon , L . , M . Robinson and K . Schmidt ( Eds . ) , ECSCW ' 91 : Proceedings of the second European conference on computer - supported cooperative work . Kluwer Academic , Dordrecht , the Netherlands , 1991 . [ ECSCW93 ] de Michelis , G . , C . Simone and K . Schmidt ( Eds . ) , ECSCW ' 93 : Proceedings of the third European conference on computer - supported cooperative work , 13 - 17 September 1993 , Milan , Italy . Kluwer Academic , Dordrecht , the Netherlands , 1993 . [ ECSCW95 ] Marmolin , H . , Y . Sundblad and K . Schmidt ( eds . ) , ECSCW ' 95 : Proceedings of the fourth European conference on computer - supported cooperative work , 10 - 14 September 1995 , Stockholm , Sweden . Kluwer Academic , Dordrecht , the Netherlands , 1995 . [ ECSCW97 ] Hughes , J . A . , W . Prinz , T . Rodden and K . Schmidt ( eds . ) , ECSCW ' 97 conference proceedings . Kluwer Academic , Dordrecht , the Netherlands , 1997 . [ EdMy97 ] Edwards , W . K . and E . D . Mynatt , ' Timewarp : Techniques for autonomous collaboration ' . In Human factors in computing systems : Proceedings of CHI ' 97 , March 22 - 27 , 1997 . Addison - Wesley , Reading , MA , USA , 1997 , http : / / www . parc . xerox . com / csl / members / kedwards / pubs / autonomous . pdf . [ Edwa94 ] Edwards , W . K . , ' Session management for collaborative applications ' . In [ CSCW94 ] , p . 323 - 330 , http : / / www . parc . xerox . com / csl / members / kedwards / pubs / session - mgmt . pdf . [ Egid88 ] Egido , C . , ' Videoconferencing as a technology : A review of its failures ' . In [ CSCW88 ] , p . 13 - 24 . [ ElGi89 ] Ellis , C . A . and S . J . Gibbs , ' Concurrency control in groupware systems ' . In J . Clifford , B . Lindsday and D . Maier ( eds . ) , Proceedings of the ACM SIGMOD ' 89 conference on the management of data , Seattle , WA , USA , May 2 - 4 , 1989 . ACM Press , New York , 1989 , p . 399 - 407 . [ ElGR90 ] Ellis , C . A . , S . J . Gibbs and G . L . Rein , ' Design and use of a group editor ' . In G . Cockton ( ed . ) , Engineering for human - computer interaction : proceedings of the IFIP TC2 / WG2 . 7 working conference on engineering for human - computer interaction , Napa - Valley , CA , USA , 21 - 25 August 1989 . North - Holland , Amsterdam , 1990 , p . 13 - 28 . [ ElGR91 ] Ellis , C . A . , S . J . Gibbs and G . L . Rein , ' Groupware : Some issues and experiences ' . Communications of the ACM , 34 ( 1991 ) , 1 , p . 38 - 58 . [ ElWa94 ] Ellis , C . A . and J . Wainer , ' A conceptual model of groupware ' . In [ CSCW94 ] , p . 79 - 88 , http : / / www . dcc . unicamp . br / ~ wainer / papers / cscw94 . ps . gz . [ EnAh97 ] Ensor , J . R . and S . R . Ahuja , ' Communication middleware for multi - party multimedia applications ' . Bell Labs Technical Journal , 2 ( 1997 ) , 1 , p . 74 - 85 , http : / / www . lucent . com / ideas2 / perspectives / bltj / winter _ 97 / pdf / paper06 . pdf . 262 R EFERENCES [ EnEn68 ] Engelbart , D . C . and W . K . English , ' A research center for augmenting human intellect ' . In Proceedings of Fall Joint Computer Conference , San Francisco , USA , December 1968 , vol . 33 , AFIPS conference proceedings , 1968 , p . 395 - 410 , http : / / www . histech . rwth - aachen . de / www / quellen / engelbart / ResearchCenter1968 . html . [ Enge75 ] Engelbart , D . C . , ' NLS teleconferencing features : The journal , and shared - screen telephoning ' . In CompCon75 Digest , September 9 - 11 , 1975 . IEEE , Los Alamitos , CA , USA , 1975 , p . 173 - 176 , http : / / www . bootstrap . org / augment - 33076 . htm . [ Enge78 ] Engelbart , D . C . , ' Toward integrated , evolutionary office automation systems ' . In Proceedings of engineering management in the computer age , Denver , CO , USA , October 16 - 18 , 1978 . IEEE , New York , 1978 , p . 63 - 68 , http : / / www . bootstrap . org / augment - 71279 . htm . [ FaLo96 ] Farooqui , K . and L . Logrippo , ' Group communication models ' . Computer communications , 19 ( 1996 ) , p . 1276 - 1288 . [ FaLo97 ] Farooqui , K . and L . Logrippo , ' Group interrogation : A group programming primitive ' . In J . Rolia , J . Slonim and J . Botsford ( eds . ) , Open distributed processing and distributed platforms : Proceedings of the IFIP / IEEEE international conference on open distributed processing and distributed platforms , Toronto , Canada , May 26 - 30 , 1997 . Chapman & Hall , London , 1997 , p . 34 - 47 , http : / / www . csi . uottawa . ca / ~ farooqui / ICODP97 . ps . [ FaSc97 ] Fayad , M . E . and D . C . Schmidt , ' Object - oriented application frameworks ' . Communications of the ACM , 40 ( October 1997 ) , 10 , p . 32 - 38 . [ FeGS97 ] Felber , P . , R . Guerraoui and A . Schiper , ' Replicating objects using the CORBA event service ? ' . In FTDCS ' 97 : Proceedings of future trends of distributed computing systems , Tunis , Tunisia , October 29 - 31 , 1997 . IEEE Computer Society Press , Los Alamitos , CA , USA , 1997 , p . 14 - 19 , http : / / lsewww . epfl . ch / ~ rachid / papers / ftdcs97 . ps . [ FeGS98 ] Felber , P . , R . Guerraoui and A . Schiper , ' Implementation of a CORBA object group service ' . Theory and Practice of Object Systems ( 1998 , to appear ) , http : / / lsewww . epfl . ch / ~ rachid / papers / tr - cor - 97 . ps . [ FiKC90 ] Fish , R . S . , R . E . Kraut and B . L . Chafonte , ' The VideoWindow system in informal communications ' . In [ CSCW90 ] , p . 1 - 11 . [ FiKM96 ] Fitzpatrick , G . , S . M . Kaplan and T . Mansfield , ' Physical spaces , virtual places and social worlds : A study of work in the virtual ' . In [ CSCW96 ] , p . 334 - 343 , http : / / www . dstc . edu . au / TU / wOrlds / Papers / cscw96 - places . ps . gz . [ FiKT95 ] Fitzpatrick , G . , S . M . Kaplan and W . J . Tolone , ' Work , locales and distributed social wOrlds ' . In [ ECSCW95 ] , p . 1 - 16 , http : / / www . dstc . edu . au / TU / wOrlds / Papers / ecscw - 95 . ps . gz . [ FKL + 88 ] Fish , R . S . , R . E . Kraut , M . D . P . Leland and M . Cohen , ' Quilt : A collaborative tool for cooperative writing ' . In R . B . Allen ( ed . ) , Conference on office information systems , March 23 - 25 , 1988 , Palo Alto , CA , USA , vol . 9 ( 2 & 3 ) , SIGOIS bulletin . ACM Press , New York , 1988 , p . 30 - 37 . [ GaAh95 ] Gaglianello , R . D . and S . R . Ahuja , ' Montage : Multipoint video and audio for PCI based PC ' s ' . In Electronic proceedings : Proceedings of ACM Multimedia 95 , San Francisco , CA , USA , November 5 - 9 , 1995 . Association for Computing Machinery , New York , 1995 , p . 315 - 316 . [ GaKr90 ] Galegher , J . and R . E . Kraut , ' Technology for intellectual teamwork : Perspectives on research and design ' . In J . Galegher , R . E . Kraut and C . Egido ( eds . ) , Intellectual teamwork : social and technological foundations of cooperative work . Lawrence Erbaum Associates , Hillsdale , NJ , USA , 1990 , p . 1 - 20 . [ GaWY94 ] Garfinkel , D . , B . C . Welti and T . W . Yip , ' HP SharedX : A tool for real - time collaboration ' . Hewlett - Packard Journal , 45 ( April 1994 ) , 2 , p . 23 - 36 , http : / / www . hp . com / hpj / 94apr / 23to36 . pdf . R EFERENCES 263 [ GrCo96 ] Powell , D . , ' Group communication ( special issue ) ' . Communications of the ACM , 29 ( 1996 ) , 4 , p . 50 - 97 , http : / / www . acm . org / pubs / articles / journals / cacm / 1996 - 39 - 4 / p50 - powell / p50 - powell . pdf . [ Gree91b ] Greenberg , S . , ' Personalizable groupware : Accommodating individual roles and group differences ' . In [ ECSCW91 ] , p . 17 - 31 , http : / / www . cpsc . ucalgary . ca / projects / grouplab / papers / 91 . PersGw . ECSCW / 91 - PersGw . ECSCW . ps . zip . [ Gree97 ] Greenhalgh , C . , ' Creating large - scale collaborative virtual environments ' . In [ HoLu97b ] , p . 85 - 86 , http : / / www . telin . nl / events / ecscw97oogp / papers / greenhalgh . pdf . [ GrHM96 ] Grundy , J . C . , J . G . Hosking and W . B . Mugridge , ' Low - level and high - level CSCW support in the serendipity process modelling environment ' . In J . C . Grundy and M . D . Apperley ( eds . ) , OzCHI ' 96 : Proceedings of Sixth Australian conference on computer - human interaction , Hamilton , New Zealand , November 24 - 27 , 1996 . IEEE Computer Society Press , Los Alamitos , CA , USA , 1996 , p . 69 - 76 . [ GrHR95 ] Greenberg , S . , S . Hayne and R . Rada ( eds . ) , Groupware for real - time drawing : A designer ' s guide . McGraw - Hill , New York , 1995 , http : / / www . cpsc . ucalgary . ca / projects / grouplab / papers / 95 - GWDrawing . McGrawHill / abstract . html . [ GrMa94 ] Greenberg , S . and D . Marwood , ' Real time groupware as a distributed system : Concurrency control and its effect on the interface ' . In [ CSCW94 ] , p . 207 - 217 , http : / / www . cpsc . ucalgary . ca / projects / grouplab / papers / 94 - Concurrency . CSCW / concurrency . CSCW . pz . zip . [ GrRo98 ] Greenberg , S . and M . Roseman , ' Groupware toolkits for synchronous work ' . In M . Beaudouin - Lafon ( ed . ) , Trends in CSCW . Wiley , forthcoming , http : / / www . cpsc . ucalgary . ca / projects / grouplab / papers / 98 - GroupwareToolkits . Wiley / Report96 - 589 - 09 / Report96 - 589 - 09 . ps . zip . [ Grud88 ] Grudin , J . , ' Why CSCW applications fail : Problems in the design and evaluation of organizational interfaces ' . In [ CSCW88 ] , p . 85 - 93 . [ GrUN96b ] Graham , T . C . N . , T . Urnes and R . Nejabi , ' Efficient distributed implementation of semi - replicated synchronous groupware ' . In UIST ' 96 : Proceedings of ACM symposium on user interface software and technology , Seattle , WA , USA , November 6 - 8 , 1996 . ACM Press , New York , 1996 , p . 1 - 10 , http : / / www . acm . org / pubs / articles / proceedings / uist / 237091 / p1 - graham / p1 - graham . pdf . [ GRW + 92 ] Greenberg , S . , M . Roseman , D . Webster and R . Bohnet , ' Human and technical factors of distributed group drawing tools ' . Interacting with computers , 4 ( 1992 ) , 1 , p . 364 - 392 , http : / / www . cpsc . ucalgary . ca / projects / grouplab / papers / 92 - HumanTech . IWC / 92 - HumanTech . IWC . ps . zip . [ GSS + 93 ] Gutekunst , T . , T . Schmidt , G . Schulze , J . Schweitzer and M . Weber , ' A distributed multimedia joint viewing and tele - operation service for heterogeneous workstation environments ' . In W . Effelsberg and K . Rothermel ( eds . ) , Verteilte Multimediasysteme : Proceedings of GI / ITG - Arbeitstreffen , Stuttgart , Germany , February 18 - 19 , 1993 . K . G . Saur , München , Germany , 1993 , p . 145 - 159 . [ GuRG96 ] Gutwin , C . , M . Roseman and S . Greenberg , ' A usability study of awareness widgets in a shared workspace groupware system ' . In [ CSCW96 ] , p . 258 - 267 , http : / / www . cpsc . ucalgary . ca / projects / grouplab / papers / 96 - Usability . CSCW / Report96 - 585 - 05 / 96 - 585 - 05 . ps . zip . [ Hags96 ] Hagsand , O . , ' Interactive multiuser VEs in the DIVE system ' . IEEE Multimedia , 3 ( 1996 ) , 1 , p . 30 - 39 , http : / / computer . org / multimedia / mu1996 / u1030abs . htm . [ HaHa93 ] Haake , A . and J . M . Haake , ' Take CoVer : Exploiting version support in cooperative systems ' . In S . Ashlund , K . Mullet , A . Henderson and T . White ( eds . ) , Human factors in computing systems : INTERCHI ' 93 . ACM Press , New York , 1993 , p . 406 - 413 , http : / / www . acm . org / pubs / articles / proceedings / chi / 169059 / p406 - haake / p406 - haake . pdf . 264 R EFERENCES [ Hami97 ] Hamilton , G . , JavaBeans . Sun Microsystems , Palo Alto , CA , USA , July 24 , 1997 , http : / / java . sun . com / beans / docs / beans . 101 . pdf . [ HaRB93 ] Hardman , L . , G . van Rossum and D . C . A . Bulterman , ' Structured multimedia authoring ' . In Proceedings of ACM Multimedia 93 , Anaheim , CA , USA , August 1 - 6 , 1993 . Association for Computing Machinery , New York , 1993 , p . 283 - 289 , http : / / www . cwi . nl / ftp / mmpapers / sma . ps . gz . [ HaWi92 ] Haake , J . M . and B . Wilson , ' Supporting collaborative writing of hyperdocuments in SEPIA ' . In [ CSCW92 ] , p . 138 - 146 , http : / / www . acm . org / pubs / articles / proceedings / cscw / 143457 / p138 - haake / p138 - haake . pdf . [ HBL + 97 ] ter Hofte , G . H . , H . Bakker , H . J . van der Lugt , M . Wibbels , R . A . A . Otte , F . Moelaert - El Hadidy and W . B . Teeuw , ' Collaborative compound document editing : the CoCoDoc framework and its applications ' . In J . Forsyth , J . Mariani , M . Twidale , P . Dourish , Y . Rogers , C . Simone and J . Pycock ( eds . ) , Conference supplement ECSCW ' 97 . Lancaster University , Lancaster , UK , 1997 , p . 17 - 18 , http : / / www . telin . nl / publicaties / 1997 / ccdemo . pdf . [ HBP + 93 ] Hill , R . D . , T . Brinck , J . F . Patterson , S . L . Rohall and W . T . Wilner , ' The rendezvous language ' . Communications of the ACM , 36 ( January 1993 ) , 1 , p . 63 - 67 . [ HBR + 94 ] Hill , R . D . , T . Brinck , S . L . Rohall , J . F . Patterson and W . Wilner , ' the rendezvous architecture and language for constructing multiuser applications ' . ACM Transactions on Computer - Human Interaction , 1 ( June 1994 ) , 2 , p . 81 - 125 , http : / / www . acm . org / pubs / articles / journals / tochi / 1994 - 1 - 2 / p81 - hill / p81 - hill . pdf . [ Heer96 ] Heeren , E . , Technology support for collaborative distance learning . Ph . D . thesis , University of Twente , Enschede , the Netherlands , 1996 , file : / / ftp . cs . utwente . nl / pub / doc / ctit / phd / heeren / heeren . zip . [ Hewi96 ] Hewitt , K . , DT5 : Desktop video conferencing product survey , 1996 ( WWW - document ) , http : / / www3 . ncsu . edu / dox / video / survey . html . [ Hins98 ] Hinssen , P . J . H . , What difference does it make ? The use of groupware in small groups . Telematica Instituut Fundamental Research Series , vol . 002 . Telematica Instituut , Enschede , the Netherlands , in press , http : / / www . telin . nl / publicaties / 1998 / scout / scout . htm . [ HiTu78 ] Hiltz , S . R . and M . Turoff , The network nation : Human communication via computer . Addison - Wesley , London , 1978 . [ HJE + 91 ] Hahn , U . , M . Jarke , S . Eherer and K . Kreplin , ' CoAUTHOR : A hypermedia group authoring environment ' . In J . M . Bowers and S . D . Benford ( eds . ) , Studies in computer supported cooperative work : theory , practice and design . North - Holland , Amsterdam , 1991 , p . 79 - 100 . [ HLM + 96 ] Huis in ' t Veld , R . J . , A . - N . Ladhani , F . Moelaert - El Hadidy , J . P . C . Verhoosel , B . van der Waaij and I . A . Widya , ' Developing a conference application on top of an advanced signalling infrastructure ' . In G . Ventre , J . Domingo - Pascual and A . Danthine ( eds . ) , Multimedia , telecommunications , and applications : Proceedings of the third international COST 237 workshop , Barcelona , Spain , November 25 - 27 , 1996 , vol . 1185 , Lecture notes in computer science . Springer - Verlag , Berlin , 1996 , p . 201 - 215 . [ HMJ + 96 ] Hall , R . W . , A . Mathur , F . Jahanian , A . Prakash and C . Rasmussen , ' Corona : A communication service for scalable , reliable group collaboration systems ' . In [ CSCW96 ] , p . 140 - 149 , ftp : / / ftp . eecs . umich . edu / people / aprakash / collaboration / papers / corona - cscw96 . ps . gz . [ HoAd87 ] Horton , M . and R . Adams , Standard for interchange of USENET messages , 1987 , RFC 1036 , http : / / ds . internic . net / rfc / rfc1036 . txt . [ Hoft96 ] ter Hofte , G . H . , Generic service features of CSCW applications : An analysis of co - authoring tools . Telematics Research Centre , Enschede , the Netherlands , 1996 . Platinum Deliverable D2 . 2 / 011 , PLATINUM / N008 / V00 . R EFERENCES 265 [ Hoft98b ] ter Hofte , G . H . , MESH should be more than multiparty telephony plus video over PC and ATM : Architectural guidelines for MESH release 2 . Telematica Instituut , Enschede , the Netherlands , 1998 . MESH Deliverable D1 . 1 . 3 . 3 , MESH / N011 / V01 . [ HoLB96 ] ter Hofte , G . H . , H . J . van der Lugt and H . Bakker , ' A CORBA platform for component groupware ' . In J . C . Grundy ( ed . ) , Proceedings of OzCHI ' 96 workshop on the next generation of CSCW systems , Hamilton , New Zealand , November 25 , 1996 . Department of Computer Science , the University of Waikato , Hamilton , New Zealand , 1996 , p . 31 - 36 , http : / / www . telin . nl / publicaties / 1996 / ozchi96 . pdf . [ HoLH96 ] ter Hofte , G . H . , H . J . van der Lugt and M . A . W . Houtsma , ' Co4 , a comprehensive model for groupware functionality ' . In A . Verbraeck ( ed . ) , Telematics in a multimedia environment : Proceedings of Euromedia 96 , Featuring WEBTEC - MEDIATEC - COMTEC - APTEC , London , United Kingdom , December 19 - 21 , 1996 . Society for Computer Simulation International , Ghent , Belgium , 1996 , p . 231 - 238 , http : / / www . telin . nl / publicaties / 1996 / co4fin . pdf . [ Holl94 ] Hollingsworth , D . , The workflow reference model . Workflow Management Coalition , Brussels , Belgium , November 29 , 1994 , TC00 - 1003 , ftp : / / ftp . aiai . ed . ac . uk / pub / projects / WfMC / refmodel / rmv1 - 16 . pdf . [ HoLu97 ] ter Hofte , G . H . and H . J . van der Lugt , ' CoCoDoc : A framework for collaborative compound document editing based on OpenDoc and CORBA ' . In J . Rolia , J . Slonim and J . Botsford ( eds . ) , Open distributed processing and distributed platforms : Proceedings of the IFIP / IEEE international conference on open distributed processing and distributed platforms , Toronto , Canada , May 26 - 30 , 1997 . Chapman & Hall , London , 1997 , p . 15 - 33 , http : / / www . telin . nl / publicaties / 1997 / cocodoc . pdf . [ HoLu97b ] ter Hofte , G . H . and H . J . van der Lugt ( Eds . ) , Advance proceedings of OOGP ' 97 , the international workshop on object oriented groupware platforms , Lancaster , UK , 7 September 1997 . Telematics Research Centre , Enschede , the Netherlands , 1997 , http : / / www . telin . nl / events / ecscw97oogp / papers / oogp97pr . pdf . [ HoSa91b ] Hornung , C . and A . Santos , ' CoMEdiA , a Cooperative hyperMedia Editing Architecture : The problem of the cooperative access ' . In L . Kjelldahl ( ed . ) , Multimedia : Systems , interaction and application , 1st Eurographics workshop , Stockholm , Sweden , April 18 / 19 , 1991 . Springer - Verlag , Berlin , 1991 , p . 208 - 222 . [ Ishi90 ] Ishii , H . , ' TeamWorkStation : Towards a seamless shared workspace ' . In [ CSCW90 ] , p . 13 - 26 . [ ISIS93 ] ISIS Distributed Systems , Object groups : A response to the ORB 2 . 0 RFI . Object Management Group , Framingham , MA , USA , 1993 . OMG document , 94 - 03 - 01 , http : / / www . omg . org / docs / 1993 / 93 - 04 - 11 . pdf . [ IsKG92 ] Ishii , H . , M Kobayashi and J . Grudin , ' Integration of inter - personal space and shared workspace : ClearBoard design and experiments ' . In [ CSCW92 ] , p . 33 - 42 . [ ITU95 ] International Telecomunications Union , ITU Q . 2931 : Broadband integrated services digital network ( B - ISDN ) - Digital subscriber signalling no . 2 ( DSS 2 ) . User network interface layer 3 specification for basic call / connection control . International Telecommunications Union , Geneva , Switzerland , 1995 , http : / / www . itu . int / itudoc / itu - t / rec / q / q1000up / q2931 _ 29825 . html . [ Joha88b ] Johansen , R . , ' Current user approaches to groupware ' . In R . Johansen ( ed . ) , Groupware : Computer support for business teams . Free Press , New York , 1988 , p . 12 - 44 . [ JRV + 89 ] Johnson , J . , T . L . Roberts , W . Verplank , D . C . Smith , C . H . Irby , M . Beard and K . Mackay , ' The Xerox Star : A retrospective ' . Computer , 22 ( September 1989 ) , p . 11 - 29 . 266 R EFERENCES [ KaBe93 ] Karsenty , A . and M . Beaudouin - Lafon , ' An algorithm for distributed groupware applications ' . In ICDCS ' 93 : Proceedings of the 13th International Conference on Distributed Computing Systems , Pittsburgh , USA , May 25 - 28 , 1993 . IEEE , Los Alamitos , CA , USA , 1993 , p . 195 - 202 , http : / / www . eurecom . fr / ~ karsenty / Papers / ICDCS93 . ps . gz . [ KaBe95 ] Karsenty , A . and M . Beaudouin - Lafon , ' Slice : A logical model for shared editors ' . In S . Greenberg , S . Hayne and R . Rada ( eds . ) , Groupware for real time drawing : A designer ' s guide . McGraw - Hill , New York , 1995 , p . 156 - 173 , http : / / www . eurecom . fr / ~ karsenty / Papers / cscw - book . ps . gz . [ KaCa92 ] Kaplan , S . M . and A . M . Caroll , ' Supporting collaborative processes with Conversation Builder ' . Computer communications , 15 ( 1992 ) , 8 , p . 489 - 501 . [ Kana97 ] Kanawati , R . , ' LICRA : A replicated - data management algorithm for distributed synchronous groupware applications ' . Parallel computing , 22 ( 1997 ) , p . 1733 - 1746 . [ KaTa96 ] Kaashoek , M . F . and A . S . Tanenbaum , ' An Evaluation of the Amoeba Group Communication System ' . In Proceedings of the 16th International Conference on Distributed Computing Systems , Hong Kong , May 27 - 30 , 1996 . IEEE Computer Society Press , Los Alamitos , CA , USA , 1996 , p . 436 - 447 , http : / / www . pdos . lcs . mit . edu / papers / group - dcs16 . ps . [ KaTV93 ] Kaashoek , M . F . , A . S . Tanenbaum and K . Verstoep , ' Group communication in Amoeba and its applications ' . Distributed systems engineeging , 1 ( September 1993 ) , 1 , p . 48 - 58 , http : / / www . pdos . lcs . mit . edu / ~ kaashoek / papers / amoeba - grp . ps . [ KBA + 94 ] Kazman , R . , L . Bass , G . Abowd and M . Webb , ' SAAM : A method for analyzing the properties of software architectures ' . In ICSE ' 94 : Proceedings of 16th International conference on software engineering , Sorrento , Italy , May 1994 , 1994 , p . 81 - 90 , http : / / www . cgl . uwaterloo . ca / ~ rnkazman / ICSE . ps . [ KBH + 92 ] Kawell , L . jr . , S . Beckhardt , T . Halvorsen , R . Ozzie and I . Greif , ' Replicated document management in a group communication system ' . In D . Marca , G . Bock ( eds . ) , Groupware : software for computer - supported cooperative work . IEEE Computer Society Press , Los Alamitos , CA , USA , 1992 , p . 226 - 235 . [ KnPr90 ] Knister , M . J . and A . Prakash , ' DistEdit : A distributed toolkit for supporting multiple group editors ' . In [ CSCW90 ] , p . 343 - 354 . [ KnPr93 ] Knister , M . J . and A . Prakash , ' Issues in the design of a toolkit for supporting multiple group editors ' . Computing systems : The journal of the USENIX Association , 6 ( 1993 ) , 2 , p . 135 - 166 , ftp : / / ftp . eecs . umich . edu / people / aprakash / collaboration / papers / distedit93 . ps . Z . [ Koch95 ] Koch , M . , The collaborative multi - user editor project IRIS . Institut für Informatik , Technische Universität München , München , D , April 24 , 1995 . Technical Report , TUM - I9524 , ftp : / / hpschlichter18 . informatik . tu - muenchen . de / pub / papers / koch95 . ps . gz . [ Koch96 ] Koch , M . , ' Design issues for a distributed multi - user Editor ' . Computer Supported Cooperative Work ( CSCW ) , 3 ( 1995 ) , 3 - 4 , p . 359 - 378 , ftp : / / ftp11 . informatik . tu - muenchen . de / pub / papers / koch95b . ps . gz . [ Koch97 ] Koch , M . , Unterstützung kooperativer Dokumentenbearbeitung in Weitverkehrsnetzen . Ph . D . Thesis , Technischen Universität München , München , 1997 , ftp : / / ftp11 . informatik . tu - muenchen . de / pub / misc / all . ps . gz . [ Koll95 ] Kolland , M . , ' Support for information sharing in CSCW based on causally and totally ordered group communication ' . In K . P . Birman , F . Mattern and A . Schiper ( eds . ) , Proceedings of theory and practice in distributed systems : International workshop , Dagstuhl Castle , Germany , September 5 - 9 , 1995 , Lecture notes in computer science . Springer - Verlag , Berlin , 1995 , p . 64 - 82 . R EFERENCES 267 [ KrKi86 ] Kraemer , K . L . and J . L . King , ' Computer - based systems for cooperative work and group decision making : Status of use and problems in development ' . In [ CSCW86 ] , p . 353 - 375 . [ KrPo88 ] Krasner , G . E . and S . T . Pope , ' A cookbook for using the model - view - controller interface paradigm in smalltalk - 80 ' . Journal of Object - Oriented Programming , 1 ( 1988 ) , 3 , p . 26 - 41 , 48 , 49 . [ KrSe94 ] Kranz , M . E . and V . I . Sessa , ' Meeting makeovers : Electronic meeting support ' . PC Magazine , 13 ( June 14 , 1994 ) , 11 , p . 205 - 207 , 210 - 212 . [ Labr94 ] Labriola , D . , ' Remote possibilities : Whiteboard software ' . PC Magazine , 13 ( June 14 , 1994 ) , 11 , p . 223 - 228 . [ LaBr95 ] LaLiberte , D . and A . Braverman , A protocol for scalable group and public annotations , 1995 . NCSA , http : / / union . ncsa . uiuc . edu / ~ liberte / www / scalable - annotations . html . [ LaLa90 ] Lauwers , J . C . and K . A . Lantz , ' Collaboration awareness in support of collaboration transparency : Requirements for the next generation of shared window systems ' . In J . C . Chew and J . Whiteside ( eds . ) , Human factors in computing systems : CHI ' 90 , " Empowering people " , conference , SIGCHI bulletin . ACM Press , New York , 1990 , p . 303 - 311 . [ LaMa97 ] Landis , S . and S . Maffeis , ' Building reliable distributed systems with CORBA ' . Theory and Practice of Object Systems , 3 ( 1997 ) , 1 , p . 31 - 43 , ftp : / / ftp . olsen . ch / users / maffeis / electra / reliable _ corba . ps . gz . [ Lamp78 ] Lamport , L . , ' Time , clocks and the ordering of events in a distributed system ' . Communications of the ACM , 21 ( July 1978 ) , 7 , p . 558 - 565 . [ Lant86 ] Lantz , K . A . , ' An experiment in integrated multimedia conferencing ' . In [ CSCW86 ] , p . 267 - 275 . [ Lau95 ] Lau , C . , Object oriented programming using SOM and DSOM . John Wiley & Sons , New York , 1995 . [ LeFK88 ] Leland , M . D . P . , R . S . Fish and R . E . Kraut , ' Collaborative document production using Quilt ' . In [ CSCW88 ] , p . 206 - 215 . [ LJL + 90 ] Lauwers , J . C . , T . A . Joseph , K . A . Lantz and A . R . Romanow , ' Replicated archi tecture for shared window systems : A critique ' . In F . H . Lochovsky and R . B . Allen ( eds . ) , Conference on office information systems , April 25 - 27 , 1990 , Cambridge , Massachusetts , vol . 11 ( 2 , 3 ) , SIGOIS bulletin . ACM Press , New York , 1990 , p . 249 - 260 . [ MaAs97 ] Magnusson , B . and U . Asklund , ' The COOP / Orm as a framework ' . In [ HoLu97b ] , p . 42 - 43 , http : / / www . telin . nl / events / ecscw97oogp / papers / magnusson . pdf . [ MaCo90 ] Markus , M . L . and T . Connoly , ' Why CSCW applications fail : Problems in the adoption of interdependent work tools ' . In [ CSCW90 ] , p . 371 - 380 . [ Maff95b ] Maffeis , S . , ' Adding group communication and fault - tolerance to CORBA ' . In USENIX association ( ed . ) , Proceedings of USENIX conference on object - oriented technologies ( COOTS ) , Monterey , CA , USA , June 26 - 29 , 1995 . USENIX association , Berkeley , CA , USA , 1995 , p . 136 - 145 , ftp : / / ftp . olsen . ch / users / maffeis / electra / electra _ corba . ps . gz . [ MaLF92 ] Malone , T . , K . Y . Lai and C . Fry , ' Experiments with Oval : A radically tailorable tool for cooperative work ' . In [ CSCW92 ] , p . 289 - 297 , http : / / www . acm . org / pubs / articles / proceedings / cscw / 143457 / p289 - malone / p289 - malone . pdf . [ Malm94 ] Malm , P . S . , CSCW and groupware , a classification of CSCW - systems in a technological perspective . ( only available in Norwegian ) , University of Tromso , Tromso , Norway , 1994 . [ Malm94b ] Malm , P . S . , The unOfficial Yellow Pages of CSCW ( CSCW - YP ) , 1994 ( WWW - document ; part of [ Malm94 ] ) , http : / / www . telekoopeation . de / cscw / yp / . 268 R EFERENCES [ MaOl94 ] Mandviwalla , M . and L . Olfman , ' What do groups need ? A proposed set of generic groupware requirements ' . ACM Transactions on Computer - Human Interaction , 1 ( 1994 ) , 3 , p . 245 - 268 , http : / / www . acm . org / pubs / articles / journals / tochi / 1994 - 1 - 3 / p245 - mandviwalla / p245 - mandviwalla . pdf . [ MaPr95 ] Manohar , N . R . and A . Prakash , ' The session capture and replay paradigm for asynchronous collaboration ' . In [ ECSCW95 ] , p . 149 - 164 , http : / / www . eecs . umich . edu / ~ nelsonr / postscript - docs / ecscw95 . ps . [ McCa94 ] McCarthy , J . C . , ' The state - of - the - art of CSCW : CSCW systems , cooperative work and organization ' . Journal of Information Technology , 9 ( 1994 ) , p . 73 - 83 . [ MiBl91 ] Minneman , S . and S . A . Bly , ' Managing à trois : A study of a multi - user drawing tool in distributed design work ' . In S . P . Robertson , G . M . Olson and J . S . Olson ( eds . ) , Human factors in computing systems : reaching through technology : Proceedings of CHI ' 91 , New Orleans , Louisiana , USA , April 27 - May 2 , 1991 . Addison - Wesley , Reading , MA , USA , 1991 , p . 217 - 224 , http : / / www . acm . org / pubs / articles / proceedings / chi / 108844 / p217 - minneman / p217 - minneman . pdf . [ MiMa93 ] Minor , S . and B . Magnusson , ' A model for semi - ( a ) synchronous collaborative editing ' . In [ ECSCW93 ] , p . 219 - 231 . [ MiRa96 ] Michailidis , A . and R . Rada , ' A review of collaborative authoring tools ' . In R . Rada ( ed . ) , Groupware and authoring . Academic Press , London , 1996 , p . 9 - 43 . [ MMD + 93 ] Miles , V . C . , J . C . McCarthy , A . J . Dix , M . D . Harrison and A . F . Monk , ' Reviewing designs for a synchronous - asynchronous group editing environment ' . In M . Sharples ( ed . ) , Computer supported collaborative writing . Springer - Verlag , London , 1993 , p . 137 - 160 . [ MoTB97 ] Moelaert - El Hadidy , F . , W . B . Teeuw and H . Bakker , ' An innovative approach for designing collaborative applications using OpenDoc : from theory to practice ' . In SEE ' 97 : Proceedings of the 8th conference on software engineering environments , Cottbus , Germany , April 8 - 9 , 1997 . IEEE Computer Society Press , Los Alamitos , CA , USA , 1997 , p . 42 - 52 . [ MSA + 94 ] Miller , M . J . , G . Shaffer , R . Ayre , B . Z . Gottesman , J . Salemi , M . E . Kranz , V . I . Sessa , D . Labriola , B . Machrone , M . A . Bragen and L . Grunin , ' The changing office ' . PC Magazine , 13 ( June 14 , 1994 ) , 11 , p . 112 - 319 . [ MuDe96 ] Munson , J . P . and P . Dewan , ' A concurrency control framework for collaborative systems ' . In [ CSCW96 ] , p . 278 - 287 , http : / / www . acm . org / pubs / articles / proceedings / cscw / 240080 / p278 - munson / p278 - munson . pdf . [ MuDe97 ] Munson , J . P . and P . Dewan , ' Sync : A Java framework for mobile collaborative applications ' . Computer , 30 ( June 1997 ) , 6 , p . 59 - 66 , http : / / pdf . computer . org / co / books / co1997 / pdf / r6059 . pdf . [ Myer95 ] Myers , W . , ' Taligent ' s CommonPoint : the promise of objects ' . Computer , ( March 1995 ) , p . 78 - 83 . [ NaPR93 ] Navarro , L . , W . Prinz and T . Rodden , ' CSCW requires open systems ' . Computer communications , 16 ( 1993 ) , 4 , p . 288 - 297 . [ NCD + 95 ] Nichols , D . A . , P . Curtis , M . Dixon and J . Lamping , ' High - latency , low - bandwidth windowing in the Jupiter collaboration system ' . In UIST ' 95 : Proceedings of the 8th ACM symposium on user interface software and technology , Pittsburgh , PA , USA , November 14 - 17 , 1995 . ACM Press , New York , 1995 , p . 111 - 120 , http : / / www . acm . org / pubs / articles / proceedings / uist / 215585 / p111 - nichols / p111 - nichols . pdf . R EFERENCES 269 [ NCK + 90 ] Neuwirth , C . M . , D . S . Kaufer , R . Chandhok and J . H . Morris , ' Issues in the design of computer support for co - authoring and commenting ' . In [ CSCW90 ] , p . 183 - 195 . [ NCK + 92 ] Neuwirth , C . M . , R . Chandhok , D . S . Kaufer , P . Erion , J . H . Morris and D . Miller , ' Flexible diff - ing in a collaborative writing system ' . In [ CSCW92 ] , p . 147 - 154 , http : / / www . acm . org / pubs / articles / proceedings / cscw / 143457 / p147 - neuwirth / p147 - neuwirth . pdf . [ NDV + 91 ] Nunamaker , J . F . , A . R . Dennis , J . S . Valacich , D . R . Vogel and J . F . George , ' Electronic meeting systems to support group work ' . Communications of the ACM , 34 ( July 1991 ) , 7 , p . 40 - 61 . [ Negr95 ] Negroponte , N . , Being digital . Coronet Books , Hodder and Stoughton , London , 1995 . [ Nels95 ] Nelson , C . , ' OpenDoc and its architecture ' . The X resource , ( January 1995 ) , 13 , p . 107 - 126 . [ NKC + 94 ] Neuwirth , C . M . , D . S . Kaufer , R . Chandhok and J . H . Morris , ' Computer support for distributed collaborative writing : Defining parameters of interaction ' . In [ CSCW94 ] , p . 145 - 152 , http : / / www . acm . org / pubs / articles / proceedings / cscw / 192844 / p145 - neuwirth / p145 - neuwirth . pdf . [ NMB + 86 ] Nielsen , J . , R . J . Mack , K . H . Bergendorff and N . L . Grishkowsky , ' Integrated software usage in the professional work environment : Evidence from questionnaires and interviews ' . In Human factors in computing systems : Proceedings of CHI ' 86 , Boston , USA , April 13 - 16 , 1986 . ACM , New York , 1986 , p . 162 - 167 . [ NoPe93 ] Norris , R . and M . Pendergast , ' Critical success factors for groupware products of the 1990s ' . In D . R . Vogel ( ed . ) , Local area network applications : Leveraging the LAN ( A - 31 ) . North - Holland , Amsterdam , 1993 , p . 135 - 149 . [ OCL + 93 ] Olson , J . S . , S . K . Card , T . K . Landauer , G . M . Olson , T . Malone and J . Leggett , ' Computer - supported co - operative work : Research issues for the 90s ' . Behaviour & Information Technology , 12 ( 1993 ) , 2 , p . 115 - 129 . [ OMG97 ] Object Management Group , The common object request broker : Architecture and specification : Revision 2 . 1 . Object Management Group , Framingham , MA , USA , 1997 . OMG technical document , formal / 97 - 09 - 01 , ftp : / / ftp . omg . org / pub / docs / formal / 97 - 09 - 01 . pdf . [ OMG97b ] Object Management Group , CORBAservices : Common object services specification . Object Management Group , Framingham , MA , USA , November 1997 . OMG technical document , formal / 97 - 12 - 02 , ftp : / / ftp . omg . org / pub / docs / formal / 97 - 12 - 02 . pdf . [ OMK + 93 ] Olson , G . M . , L . J . McGuffin , E . Kunawa and J . S . Olson , ' Designing software for a group ' s needs : A functional analysis of synchronous groupware ' . In L . Bass and P . Dewan ( eds . ) , User interface software , vol . 1 , Trends in software . John Wiley & Sons , Chichester , UK , 1993 , p . 129 - 148 . [ Oppe88 ] Opper , S . , ' A groupware toolbox ' . Byte , 13 ( December 1988 ) , 3 , p . 275 - 282 . [ OrHE96 ] Orfali , R . , D . Harkey and J . Edwards , The essential distributed objects survival guide . Wiley , New York , 1996 . [ OsEd94 ] Oskiewicz , E . and N . Edwards , A model for interface groups . Architecture Projects Management Limited , Cambridge , UK , 1994 . Architecture Report , APM . 1002 . 01 , ftp : / / ftp . ansa . co . uk / phase3 - doc - root / ar / APM . 1002 . 01 . ps . gz . [ Palm93 ] Palme , J . , ' Standards for asynchronous group communication ' . Computer communications , 16 ( September 1993 ) , 9 , p . 532 - 538 . [ Parn72 ] Parnas , D . L . , ' On the criteria to be used in decomposing systems into modules ' . Communications of the ACM , 15 ( 1972 ) , 12 , p . 1053 - 1058 . 270 R EFERENCES [ Patt91 ] Patterson , J . F . , ' Comparing the programming demands of single - user and multi - user applications ' . In UIST ' 91 : Proceedings of the fourth ACM symposium on user interface software and technology , Hilton Head , SC , USA , November 11 - 13 , 1991 . ACM Press , New York , 1991 , p . 87 - 94 , http : / / www . acm . org / pubs / articles / proceedings / uist / 120782 / p87 - patterson / p87 - patterson . pdf . [ Patt95 ] Patterson , J . F . , ' A taxonomy of architectures for synchronous groupware applications ' . SIGOIS Bulletin , 15 ( April 1995 ) , 3 , p . 27 - 29 . [ Peng93 ] Peng , C . , ' Survey of collaborative drawing support tools : Design perspectives and prototypes ' . Computer Supported Cooperative Work ( CSCW ) , 1 ( 1993 ) , p . 197 - 228 . [ PHR + 90 ] Patterson , J . F . , R . D . Hill , S . L . Rohall and W . S . Meeks , ' Rendezvous : An architecture for synchronous multi - user applications ' . In [ CSCW90 ] , p . 317 - 328 . [ PoBa93 ] Posner , I . R . and R . M . Baecker , ' How people write together ' . In R . M . Baecker ( ed . ) , Readings in groupware and computer - supported cooperative work : Assisting human - human collaboration . Morgan Kaufmann , San Mateo , CA , USA , 1993 , p . 239 - 250 . [ PrKn92 ] Prakash , A . and M . J . Knister , ' Undoing actions in collaborative work ' . In [ CSCW92 ] , p . 273 - 280 , ftp : / / ftp . eecs . umich . edu / people / aprakash / collaboration / papers / cscw92 . ps . Z . [ PrKn94b ] Prakash , A . and M . J . Knister , ' A framework for undoing actions in collaborative systems ' . ACM Transactions on Computer - Human Interaction , 1 ( 1994 ) , 4 , p . 295 - 330 , ftp : / / ftp . eecs . umich . edu / people / aprakash / collaboration / papers / undo - tochi94 . ps . [ RaSi96 ] Raynal , M . and M . Singhal , ' Capturing causality in distributed systems ' . Computer , ( February 1996 ) , p . 49 - 56 , http : / / computer . org / computer / co1996 / r2049abs . htm . [ RaVV95 ] Rajan , S . , P . Venkat Rangan and H . M . Vin , ' A formal basis for structured multimedia collaborations ' . In Proceedings of the 2nd IEEE international conference on multimedia computing and systems , May 1995 . IEEE Computer Society Press , 1995 , p . 194 - 201 , http : / / www . csl . sri . com / reports / postscript / icmcs95 . ps . gz . [ RCH + 97 ] Rhee , I . , S . Y . Cheung , P . W . Hutto and V . S . Sunderam , ' Group communication support for distributed collaboration systems ' . In ICDCS ' 97 : Proceedings of the 17th international conference on distributed computer systems , Baltimore , USA , May 27 - 30 , 1997 . IEEE Computer Society Press , Los Alamitos , CA , USA , 1997 , p . 43 - 50 , http : / / emily . mathcs . emory . edu / ccf / Papers / cctl . ps . [ ReBM96 ] van Renesse , R . , K . P . Birman and S . Maffeis , ' Horus : A flexible group communication system ' . Communications of the ACM , 29 ( 1996 ) , 4 , p . 76 - 83 , http : / / www . acm . org / pubs / articles / journals / cacm / 1996 - 39 - 4 / p76 - van _ renesse / p76 - van _ renesse . pdf . [ Rees94 ] Rees , O . , The ANSA computational model . Architecture Projects Management Limited , Cambridge , UK , 1994 . Architecture Report , APM . 1001 . 01 , ftp : / / ftp . ansa . co . uk / phase3 - doc - root / ar / APM . 1001 . 01 . ps . gz . [ ReHB94 ] van Renesse , R . , T . M . Hickey and K . P . Birman , Design and performance of Horus : A lightweight group communications system . Department of Computer science , Cornell University , Ithaca , NY , USA , August 1994 . Technical report , TR 94 - 1442 , http : / / cs - tr . cs . cornell . edu / TR / CORNELLCS : TR94 - 1442 . [ ReNG96 ] Ressel , M . , D . Nitsche - Ruhrland and R . Gunzenhäuser , ' An integration , transformation - oriented approach to concurrency control and undo in group editors ' . In [ CSCW96 ] , p . 288 - 297 , http : / / www . acm . org / pubs / articles / proceedings / cscw / 240080 / p288 - ressel / p288 - ressel . pdf . R EFERENCES 271 [ RiWe94 ] Riexinger , D . and K . Werner , ' Integration of existing applications into a conference system ' . In R . Steinmetz ( ed . ) , Multimedia : Advanced teleservices and high - speed communication architectures : Proceedings of Second international workshop , IWACA ' 94 , Heidelberg , Germany , September 26 - 28 , 1994 , vol . 868 , Lecture notes in computer science . Springer - Verlag , Berlin , 1994 , p . 346 - 355 . [ RoBl92a ] Rodden , T . , J . A . Mariani and G . Blair , ' Supporting cooperative applications ' . Computer Supported Cooperative Work ( CSCW ) , 1 ( 1992 ) , p . 41 - 67 , ftp : / / ftp . comp . lancs . ac . uk / pub / reports / 1992 / CSCW . 11 . 92 . ps . Z . [ RoBl92b ] Rodden , T . and G . S . Blair , ' Distributed systems support for computer supported cooperative work ' . Computer communications , 15 ( October 1992 ) , 8 , p . 527 - 538 , ftp : / / ftp . comp . lancs . ac . uk / pub / reports / 1992 / CSCW . 7 . 92 . ps . Z . [ Rodd93 ] Rodden , T . , ' Technological support for cooperation ' . In D . Diaper and C . Sanger ( eds . ) , CSCW in practice : An introduction and case studies . Springer - Verlag , London , 1993 , p . 1 - 22 , ftp : / / ftp . comp . lancs . ac . uk / pub / reports / 1992 / CSCW . 10 . 92 . ps . Z . [ RoGr92 ] Roseman , M . and S . Greenberg , ' GroupKit : A groupware toolkit for building real - time conferencing applications ' . In [ CSCW92 ] , p . 43 - 50 , http : / / www . cpsc . ucalgary . ca / projects / grouplab / papers / 92 - Groupkit . CSCW / 93 - GroupKit . CSCW . ps . zip . [ RoGr93 ] Roseman , M . and S . Greenberg , ' Building flexible groupware through open protocols ' . In S . Kaplan ( ed . ) , Proceedings of Conference on organizational computing systems , Milpitas , CA , USA , November 1 - 4 , 1993 . ACM , New York , 1993 , p . 279 - 288 , http : / / www . cpsc . ucalgary . ca / projects / grouplab / papers / 93 - OpenProtocols . COCS / 93 - OpenProtocols . ps . zip . [ RoGr96 ] Roseman , M . and S . Greenberg , ' Building real time groupware with GroupKit , a groupware toolkit ' . ACM Transactions on Computer - Human Interaction , 3 ( March 1996 ) , 1 , p . 66 - 106 , http : / / www . cpsc . ucalgary . ca / projects / grouplab / papers / 96 - GroupKit . TOCHI / groupkit - tochi . ps . zip . [ Root88 ] Root , R . W . , ' Design of a multi - media vehicle for social browsing ' . In [ CSCW88 ] , p . 25 - 38 . [ Rude93 ] Rüdebusch , T . , CSCW : Generische Unterstützung von Teamarbeit in verteilten DV - Systemen . Ph . D . Thesis ( in German ) , Deutsche Universitäts - Verlag , Wiesbaden , D , 1993 . [ Rude95 ] Rüdebusch , T . , ' Cooperation support ' . In M . Mühlhäuser ( ed . ) , Cooperative computer - aided authoring and learning : A systems approach . Kluwer Academic , Dordrecht , the Netherlands , 1995 , p . 249 - 272 . [ SaBB97 ] Sandor , O . , C . Bogdan and J . Bowers , ' Aether : An awareness engine for CSCW ' . In [ ECSCW97 ] , p . 221 - 236 . [ SaGr85 ] Sarin , S . and I . Greif , ' Computer - based real time conferencing systems ' . Computer , 18 ( October 1985 ) , 10 , p . 33 - 45 . [ SaKu93 ] Sakamoto , Y . and E . Kuwana , ' Toward integrated support of synchronous and asynchronous communication in cooperative work : An empirical study of real group communication ' . In S . Kaplan ( ed . ) , Proceedings of Conference on organizational computing systems , Milpitas , CA , USA , November 1 - 4 , 1993 . ACM , New York , 1993 , p . 90 - 97 , http : / / www . acm . org / pubs / articles / proceedings / cocs / 168555 / p90 - sakamoto / p90 - sakamoto . pdf . [ Sale94 ] Salemi , J . , ' Let ' s interface : Conferencing software ' . PC Magazine , 13 ( June 14 , 1994 ) , 11 , p . 191 - 199 , 201 - 202 . 272 R EFERENCES [ Sant95 ] Santos , A . , Multimedia and groupware for editing . Computer graphics : Systems and applications , J . L . Encarnaçao , K . Bo , J . D . Foley , R . A . Guedj , P . J . W . ten Hagen , F . R . A . Hopgood , M . Hosaka , M . Lucas and A . G . Requicha ( eds . ) . Springer - Verlag , Berlin , 1995 . [ SaTr94 ] Santos , A . and B . Tritsch , ' Cooperative multimedia editing tool for enhanced group communication ' . Computer communications , 17 ( 1994 ) , 4 , p . 277 - 287 . [ SBF + 87 ] Stefik , M . , D . G . Bobrow , G . Foster , S . Lanning and D . Tatar , ' WYSIWIS revised : Early experiences with multiuser interfaces ' . ACM transactions on office information systems , 5 ( April 1987 ) , 2 , p . 147 - 167 . [ ScBa92 ] Schmidt , K . and L . J . Bannon , ' Taking CSCW seriously : Supporting articulation work ' . Computer Supported Cooperative Work ( CSCW ) , 1 ( 1992 ) , 1 - 2 , p . 7 - 40 . [ ScGe86 ] Scheifler , R . W . and J . Gettys , ' The X window system ' . ACM Transactions on Graphics , 5 ( April 1986 ) , 2 , p . 79 - 109 . [ Schl96 ] Schlichte , M . , Mehrbenutzerfähige Verbunddokument - Architekturen [ Multi - user compound document architectures ] , February 15 , 1996 ( Master ' s Thesis ( in German ) ) . Technische Universität München , ftp : / / ftp11 . informatik . tu - muenchen . de / pub / papers / da - schlichte96 . ps . gz . [ Scho96 ] Schooler , E . M . , ' Conferencing and collaborative computing ' . Multimedia systems , 4 ( 1996 ) , 5 , p . 210 - 225 , http : / / link . springer . de / customer / service / journals / 00530 / papers / 6004005 / 60040210 . pdf . [ ScRo96 ] Schmidt , K . and T . Rodden , ' Putting it all together : Requirements for a CSCW platform ' . In D . Shapiro , M . J . Tauber and R . Traunmüller ( eds . ) , The design of computer supported cooperative work and groupware systems , vol . 12 , Human factors in information technology . Elsevier , Amsterdam , 1996 , p . 157 - 175 , ftp : / ftp . comp . lancs . ac . uk / pub / reports / CSCW . 9 . 92 . ps . [ SFB + 87 ] Stefik , M . , G . Foster , D . G . Bobrow , K . Kahn , S . Lanning and L . Suchman , ' Beyond the chalkboard : Computer support for collaboration and problem solving in meetings ' . Communications of the ACM , 30 ( January 1987 ) , 1 , p . 32 - 47 . [ Shne83 ] Shneiderman , B . , ' Direct manipulation : a step beyond programming languages ' . Computer , 16 ( August 1983 ) , p . 57 - 69 . [ SHP + 97 ] Shim , H . S . , R . W . Hall , A . Prakash and F . Jahanian , ' Providing flexible services for managing shared state in collaborative systems ' . In [ ECSCW97 ] , p . 237 - 252 , http : / / www . eecs . umich . edu / ~ rhall / ecscw . ps . gz . [ SHR + 94 ] de Smedt , A . , P . Hellemans , L . Ronchetti and K . Täubig , ' A multilevel framework for the attribute description of telecommunication services ' . International journal of communication systems , 7 ( 1994 ) , 2 , p . 73 - 83 . [ SiCP96 ] van Sinderen , M . J . , Ph . Chimento and L . F . Pires , ' Design of a shared whiteboard component for multimedia conferencing ' . In PROMS ' 96 : Proceedings of the 3rd international workshop on protocols for multimedia systems , Madrid , Spain , October 15 - 18 , 1996 . Dpto . de Publicaciones de la ETSIT , Ciudad Universitaria , Madrid , Spain , 1996 , p . 1 - 16 , http : / / wwwhome . cs . utwente . nl / ~ sinderen / publications / selectedpub / proms96 . pdf . [ Sind95 ] Van Sinderen , M . J . , On the design of application protocols . Ph . D . thesis , University of Twente , Enschede , the Netherlands , 1995 . [ SKS + 96 ] Schuckmann , C . , L . Kirchner , J . Schümmer and J . M . Haake , ' Designing object - oriented synchronous groupware with COAST ' . In [ CSCW96 ] , p . 30 - 38 , ftp : / / ftp . darmstadt . gmd . de / pub / ocean / CSCW96 . ps . R EFERENCES 273 [ SlCa84 ] Sluizer , S . and P . Cashman , ' XCP : An experimental tool for supporting office procedures ' . In R . W . Taylor ( ed . ) , Proceedings of the IEEE first international conference on office automation , New Orleans , LA , USA , 1984 . IEEE Computer Society Press , Silver Spring , MD , USA , 1994 , p . 73 - 80 . [ SMC + 74 ] Stevens , W . P . , G . J . Myers and L . L . Constantine , ' Structured design ' . IBM Systems Journal , 13 ( 1974 ) , 2 , p . 115 - 139 . [ SoCh94 ] Sohlenkamp , M . and G . Chwelos , ' Integrating communication , cooperation , and awareness : The DIVA virtual office environment ' . In [ CSCW94 ] , p . 331 - 343 , ftp : / / ftp . gmd . de / gmd / gina / diva - p . ps . Z . [ SoPr94 ] Soparkar , N . and A . Prakash , ' Concurrency control for collaborative systems ' . In CSCW ' 94 workshop on distributed systems , multimedia , and infrastructure support in CSCW : delegate copy . unpublished , 1994 . [ SPD + 97 ] Simão , J . P . F . , N . M . R . Preguiça , H . J . L . Domingos and J . A . L . Martins , ' DAgora : A flexible , scalable and reliable object - oriented groupware platform ' . In [ HoLu97b ] , p . 27 - 32 , http : / / www . telin . nl / events / ecscw97oogp / papers / simao . pdf . [ StDW92 ] Strayer , W . T . , B . J . Dempsey and A . C . Weaver , XTP : The Xpress Transfer Protocol . Addison - Wesley , Reading , MA , USA , 1992 . [ Stie97 ] Stiemerling , O . , ' Supporting tailorability of groupware through component architectures ' . In [ HoLu97b ] , p . 54 - 60 , http : / / www . telin . nl / events / ecscw97oogp / papers / stiemerling . pdf . [ Stre94 ] Streiz , N . A . , ' Putting objects to work : Hypermedia as the subject matter and the medium for computer - supported cooperative work ' . In M . Tokoro and R . Pareschi ( eds . ) , Proceedings of the 8th European Conference on Object - Oriented Programming ( ECOOP ' 94 ) , Bologna , July 4 - 8 , 1994 , Object - Oriented Programming . Lecture Notes in Computer Science . , 1994 , p . 183 - 193 . [ StUZ96 ] Steinder , M . , A . Uszok and K . Zielinski , ' A framework for inter - ORB request - level bridge construction ' . In A . Schill , C . Mittasch , O . Spaniol and C . Popien ( eds . ) , Distributed Platforms : Proceedings of IFIP / IEEE international conference on distributed platforms : client / server and beyond : DCE , CORBA , ODP and advanced distributed applications , Dresden , February 1996 . Chapman & Hall , London , UK , 1996 , p . 86 - 99 . [ SuNo90 ] Sullivan , K . J . and D . Notkin , ' Reconciling environment integration and component independence ' . In Proceedings of 4th ACM SIGSOFT symposium on software development environments , 1990 . ACM , New York , 1990 , p . 22 - 33 . [ SuZY95 ] Sun , C . , Y . Zhang and Y . Yang , ' Distributed synchronization of group operations in cooperative editing environments ' . In Concurrent engineering : A global perspective : Proceedings of the concurrent engineering 1995 conference , McLean , Virginia , USA , August 23 - 25 , 1995 . Concurrent Technologies Corporation , Johnstown , PA , USA , 1995 , p . 279 - 290 . [ Swin91 ] Swineheart , D . , The connection architecture for the etherphone system . Xerox PARC , Palo Alto , CA , USA , 1991 . Technical Report , CSL 91 - 8 . [ TaFB91 ] Tatar , D . G . , G . Foster and D . G . Bobrow , ' Design for conversation : lessons from Cognoter ' . International journal of man - machine studies , 34 ( 1991 ) , p . 185 - 209 . [ TaIR94 ] Tang , J . C . , E . A . Isaacs and M . Rua , ' Supporting distributed groups with a montage of lightweight interactions ' . In [ CSCW94 ] , p . 23 - 34 , http : / / www . sun . com / tech / projects / coco / papers / montage / CSCW94 . ps . [ TaKi92 ] Takemura , H . and F . Kishino , ' Cooperative work environment using virtual workspace ' . In [ CSCW92 ] , p . 226 - 232 . [ Tane95 ] Tanenbaum , A . F . , Distributed operating systems . Prentice Hall , New Jersey , USA , 1995 . 274 R EFERENCES [ TBE + 94 ] Tou , I . , S . Berson , G . Estrin , Y . Eterovic and E . Wu , ' Prototyping synchronous group applications ' . Computer , 27 ( May 1994 ) , 5 , p . 48 - 56 . [ Trev94b ] Trevor , J . J . , Infrastructure support for CSCW . Ph . D . Thesis , Department of Computing , Lancaster University , Lancaster , UK , 1994 , ftp : / / ftp . comp . lancs . ac . uk / pub / reports / ThesisGS . ps . Z . [ TrRB95 ] Trevor , J . J . , T . Rodden and G . S . Blair , ' COLA : A lightweight platform for CSCW ' . Computer Supported Cooperative Work ( CSCW ) , 3 ( 1995 ) , p . 197 - 224 , ftp : / / ftp . comp . lancs . ac . uk / pub / reports / 1993 / CSCW . 5 . 93 . ps . Z . [ UrNe94 ] Urnes , T . and R . Nejabi , Tools for implementing groupware : Survey and evaluation . Department of Computer Science , York University , North York , Ontario , Canada , 1994 . Technical Report , CS - 94 - 03 , ftp : / / ftp . cs . yorku . ca / pub / clock - papers / CS - 94 - 03 . ps . Z . [ VeVi91 ] Venkat Rangan , P . and H . M . Vin , ' Multimedia conferencing as a universal paradigm for collaboration ' . In L . Kjelldahl ( ed . ) , Multimedia : Systems , interaction and application , 1st Eurographics workshop , Stockholm , Sweden , April 18 / 19 , 1991 . Springer - Verlag , Berlin , 1991 , p . 173 - 185 , http : / / www - cse . ucsd . edu / users / venkat / papers / Sweden . ps . [ ViCB93 ] Vin , H . M . , M . S . Chen and T . Barzilai , ' Collaboration management in DiCE ' . the computer journal , 36 ( 1993 ) , 1 , p . 87 - 96 . [ ViSo91 ] Victor , F . and E . Sommer , ' Supporting the design of office procedures in the DOMINO system ' . In J . M . Bowers and S . D . Benford ( eds . ) , Studies in computer supported cooperative work : theory , practice and design , vol . 8 , Human factors in information technology . North - Holland , Amsterdam , 1991 , p . 119 - 125 . [ Voge97 ] Vogels , W . , ' Object oriented groupware using the Ensemble system ' . In [ HoLu97b ] , p . 23 - 26 , http : / / www . telin . nl / events / ecscw97oogp / papers / vogels . pdf . [ WaBD94 ] Watson , R . T . , R . P . Bostrom and A . R . Dennis , ' Fragmentation to integration ' . In P . Lloyd ( ed . ) , Groupware in the 21st century : Computer supported co - operative working toward the milennium . Admintine , London , Uk , 1994 , p . 29 - 39 . [ Weis95 ] Weiser , M . , ' The computer for the 21st century ' . Scientific American , ( 1995 ) , special issue : the computer in the 21st century , p . 78 - 80 , 85 - 89 . [ Wils88 ] Wilson , P . , ' Key research in computer supported cooperative work ( CSCW ) ' . In R . Speth ( ed . ) , Research into networks and distributed applications : Proceedings of European teleinformatics conference - EUTECO ' 88 on research into networks and distributed applications , Vienna , Austria , April 20 - 22 , 1988 . North - Holland , Amsterdam , 1988 , p . 211 - 226 . [ Wils95 ] Wilson , B . , ' Wscrawl 2 . 0 : a shared whiteboard based on X - windows ' . In S . Greenberg , S . Hayne and R . Rada ( eds . ) , Groupware for real time drawing : A designer ' s guide . McGraw - Hill , New York , 1995 , p . 129 - 141 . [ Wino88 ] Winograd , T . , ' Where the action is ' . Byte , 13 ( December 1988 ) , 3 , p . 265A - 258 . [ WiPl97 ] Wilde , E . and B . Plattner , ' Transport - independent group and session management for group communication platforms ' . European transactions on telecommunications , 8 ( 1997 ) , 4 , p . 409 - 421 , ftp : / / ftp . tik . ee . ethz . ch / pub / people / wilde / papers / ett97 . pdf . [ WoFS95 ] Wulf , K . H . , K . Froitzheim and P . Schulthess , ' Multimedia application sharing in a heterogeneous environment ' . In Electronic proceedings : Proceedings of ACM Multimedia 95 , San Francisco , CA , USA , November 5 - 9 , 1995 . Association for Computing Machinery , New York , 1995 , p . 57 - 64 , http : / / www - vs . informatik . uni - ulm . de / Papers / ACM95 / Quix - M . html . [ WSM + 90 ] Watabe , K . , S . Sakata , K . Maeno , H . Fukuoka and T . Ohmori , ' Distributed multiparty desktop conferencing system : MERMAID ' . In [ CSCW90 ] , p . 27 - 38 . Index Entries in italics refer to existing groupware systems and platforms . Other entries predominantly refer to definitions . abstraction , 61 action , 85 action levels , 95 action order , 99 action type , 91 Alpha World , 25 AMIGO , 12 application sharing , 13 – 15 ; 154 – 57 architecture , 72 Aspects , 15 asynchronous groupware , 31 ATM , 28 ; 177 ; 194 ; 196 ; 206 audio conferencing , 27 . See also videoconferencing Augment , 8 . See NLS awareness aggregation filter , 97 awareness filter , 92 BERKOM MMC , 15 Caelum , 167 Calendar ( Lotus ) , 26 CAUSAL order , See order ; CAUSAL CAVECAT , 27 CCTL , 167 centralised architecture , 154 ; 159 CHAOS , 12 ; 42 chat , 11 – 12 ClearBoard , 27 Clock , 163 co - authoring , 16 – 23 ; 135 CoCoDoc , 139 ; 210 ; 221 COCOON , 41 ; 163 ; 167 ; 242 CoCoTree , 212 ; 222 COLA , 40 ; 41 ; 167 Colab , 12 software engineering , 29 – 30 collaborative consistency management , See consistency managementflexible , 185 operational transformation , See operational transformation slicing , See slicing collaborative interaction , 86 collaborative MVC . See collaborative zipper architecture collaborative object group , 171 – 75 276 I NDEX collaborative virtual environments , 24 – 26 collation , 180 CoMeCo , 113 CoMEdiA , 22 – 23 ComMentor , 24 Commune , 27 composability , 54 composition , 50 ; 65 end - user ~ , 56 programmer ~ , 72 compound document , 146 computer conferencing , 10 – 11 ; 134 conceptual system , 62 concrete system , 61 concurrent messages , 238 conference , 121 ~ hierarchy , 121 ~ management service , 122 consistency context , 110 consistency management , 34 – 37 ; 101 – 11 consistency policy , 110 ConversationBoard , 15 ConversationBuilder , 41 COOP / Orm , 109 cooperative work , 87 cooperative work context , 87 coordinated medium interaction order , 100 coordination , 100 ; 132 coordination filter , 100 coordination policy , 132 ~ action mapping , 133 applied ~ , 133 Coordinator , the , 12 ; 42 ; 48 CORBA , 39 ; 73 ; 172 ; 198 – 201 Corona , 163 COSMOS , 12 coupledsymmetrically ~ , 92 ~ actions , 90 couplingshared file ~ , 141 shared user interface ~ , 142 ; 152 . See also application sharing coupling aggregation filter , 97 coupling control filter , 92 coupling level , 95 CoVer , 109 CRUISER , 27 CU - SeeMe , 29 DAgora , 167 decomposition , 65 design , 59 ; 63 determinable action types , 91 DiCE , 115 DistEdit , 40 ; 42 ; 143 ; 162 ; 167 distributed level , 74 distributionhorizontal , 160 vertical , 161 DIVA , 127 DIVE , 128 DOMINO , 12 EIES . See EMISARI electronic meeting , 12 – 13 embedding , 58 ; 146 ; 151 ; 218 EMISARI , 8 ; 10 Ensemble , 167 extensibility , 54 Face to Face , 15 feedback , 89 feedthrough , 90 FIFO order . Zie order ; FIFO filterawareness ~ , 92 awareness aggregation ~ , 97 I NDEX 277 coordination ~ , 100 coupling aggregation ~ , 97 coupling control ~ , 92 presence , 92 presence aggregation ~ , 96 floor control , 32 ; 50 ; 101 ; 119 ; 120 ; 132 ; 135 ; 142 ; 189 formal model , 62 full awareness , 92 function , 64 functional model , 64 gIBIS , 11 ; 42 ; 48 GINA , 162 GRACE , 12 group scheduling . See scheduling GroupCRC , 29 GroupDraw , 15 GroupIE , 42 GroupKit , 25 ; 40 ; 108 ; 115 ; 126 ; 162 ; 195 grouplet entity , 74 grouplet service , 74 grouplet , 74 GroupSketch , 15 GroupSystems , 12 groupware system , 61 Groupwise Calendar ( Novell ) , 26 GROVE , 19 – 20 ; 143 ; 148 hypermedia , multi - user , 23 – 24 ICICLE , 29 IETFcalsch , 46 mmusic , 45 ; 119 RFC 1036 , 43 implementation , 65 implementation model , 65 individual work , 46 ; 81 ; 84 ; 88 ; 136 information system , 60 initiator , 84 InPerson , 29 interaction , 64 interaction group , 84 interaction order , 99 interface , 64 invocationsmapping on messages , 181 IRC , 11 IRIS , 42 ; 167 ISDN , 28 ; 29 ; 44 ISIS , 42 ITU - T T . 120 , 44 ; 115 ; 119 IVS , 27 Java , 38 ; 221 ; 229 JavaBeans , 73 ; 229 Glasgow specs , 146 ; 221 Jupiter , 163 latecoming , 37 ; 39 ; 40 ; 41 ; 130 ; 152 ; 156 . See state transfer Live ( PictureTel ) , 29 locking , 107 ; 188 logical level , 74 Lotus Notes , 11 ; 42 ; 134 ; 167 MARC , 109 MBlink , 8 ; 14 MediaBuilder , 195 ; 219 shared object collection , 201 ; 220 medium , 84 medium action order , 99 medium consistency policy , 110 278 I NDEX medium interaction order , 99 coordinated ~ , 100 members , 90 merging , 108 ; 166 MERMAID , 27 MESH , 129 ; 194 middleware , 39 MMConf , 162 model , 61 descriptive ~ , 62 formal ~ , 62 functional ~ , 64 implementation ~ , 65 prescriptive ~ , 63 Montage , 27 MORB , 198 ; 220 multicast , 176 multiplayer games , 24 – 26 multi - user interface , 40 Multiware , 163 ; 167 NavTech , 167 Netmeeting , 15 ; 29 Netscape Conference , 15 NLS , 8 ; 14 notification time , 86 object group , 172 . See also collaborative object group ObjectWorld , 41 ; 163 observer group , 84 OLE , 146 ; 148 OpenDoc , 146 ; 210 operational transformation , 108 ; 166 ; 186 order CAUSAL ~ , 237 FIFO ~ , 236 TOTAL ~ , 240 TRANSFORMED ~ , 244 ordering , 106 ; 178 ; 235 – 48 OSIGroup Communication Service ( GCS ) , 44 OVAL , 41 ; 50 Person to Person , 15 Picturephone , 27 Platinum , 193 PREP , 109 presence aggregation filter , 96 presence filter , 92 ProShare , 15 ; 29 Prospero , 41 Quake , 25 Quilt , 18 – 19 ; 133 ; 143 reference architecture , 72 reference model , 72 reliable delivery , 177 Rendezvous , 25 ; 40 ; 164 replicated architecture , 155 ; 159 response time , 86 restrictive / permissive , 32 ; 48 ; 98 role , 19 ; 132 role mapping , 132 RTCAL , 8 ; 26 Schedule + ( Microsoft ) , 26 scheduling , 26 SCOOT , 41 ; 163 SEPIA , 20 – 22 ; 23 ; 129 ; 135 ; 143 ; 223 Serendipity / SPE , 30 service level , 74 shared object , 41 ; 201 . See also object groups shared whiteboard , 15 – 16 ; 135 SharedX , 14 I NDEX 279 ShowMe , 14 ; 15 ; 29 shX , 14 slicing , 108 ; 186 SPADE , 30 state , 85 state transfer , 186 subsystem , 65 symbolic system , 62 symmetrically coupled , 92 Sync , 109 ; 167 synchronous groupware , 31 system , 60 conceptual ~ , 62 concrete ~ , 61 symbolic ~ , 62 Teamtalk , 11 Timbuktu , 15 time - place matrix , 30 Timewarp , 167 timing , 86 TOTAL order . Zie order ; TOTAL TRANSFORMED order , Zie order ; TRANSFORMED transparencyconcurrency , 170 consistency , 171 distribution , 169 replication , 170 ; 171 Usenet , 10 ; 43 ; 124 ; 238 ; 239 Vconf / Dialogo , 14 version management , 22 videoconferencing , 27 – 29 ; 134 3D ~ , 28 VideoWindow , 27 WfMC , 45 whiteboard , shared . See shared whiteboard workflow , 12 . See also coordination World Wide Web , 23 ; 24 ; 127 ; 219 Worlds Chat , 25 Wscrawl , 15 WYSIWIS , 142 XCP , 8 ; 12 XTV , 14 zipper architecture collaborative , 144 distributed collaborative ~ , 161