Fine - Grained Lineage for Safer Notebook Interactions [ Technical Report ] Stephen Macke 1 , 2 Hongpu Gong 2 Doris Jung - Lin Lee 2 Andrew Head 2 Doris Xin 2 Aditya Parameswaran 2 1 University of Illinois ( UIUC ) 2 UC Berkeley { smacke , ruiduoray , dorislee , andrewhead , dorx , adityagp } @ berkeley . edu ABSTRACT Computational notebooks have emerged as the platform of choice for data science and analytical workflows , enabling rapid iteration and ex - ploration . By keeping intermediate program state in memory and seg - menting units of execution into so - called “cells” , notebooks allow users to execute their workflows interactively and enjoy particularly tight feedback . However , as cells are added , removed , reordered , and rerun , this hidden intermediate state accumulates in a way that is not neces - sarily correlated with the notebook’s visible code , making execution be - havior difficult to reason about , and leading to errors and lack of repro - ducibility . We present nbsafety , a custom Jupyter kernel that uses run - time tracing and static analysis to automatically manage lineage asso - ciated with cell execution and global notebook state . nbsafety detects and prevents errors that users make during unaided notebook interac - tions , all while preserving the flexibility of existing notebook semantics . We evaluate nbsafety’s ability to prevent erroneous interactions by re - playing and analyzing 666 real notebook sessions . Of these , nbsafety identified117sessionswithpotentialsafetyerrors , andintheremaining 549sessions , thecellsthatnbsafetyidentifiedasresolvingsafetyissues were more than 7 × more likely to be selected by users for re - execution compared to a random baseline , even though the users were not using nbsafety and were therefore not influenced by its suggestions . 1 . INTRODUCTION Computational notebooks such as Jupyter [ 26 ] provide a flexible medium for developers , scientists , and engineers to complete program - ming tasks interactively . Notebooks , like simpler predecessor read - eval - print - loops ( REPLs ) , do not terminate after executing , but wait for the user to give additional instructions while keeping intermediate programming state in memory . Notebooks , however , are distinguished from REPLs by three key features : 1 . The atomic unit of execution in notebooks is the cell , composed of a sequence of one or more programming statements , rather than a single programming statement ; 2 . Notebooks allow users to easily refer back to previous cells to make edits and potentially re - execute ; and 3 . Notebooks typically allow code and documentation to be inter - spersed , following the literate programming [ 27 ] paradigm . As a result , the IPython Notebook project [ 43 ] , and its successor , Project Jupyter [ 26 ] , have both grown rapidly in popularity . These projects decouple the server - side kernel ( responsible for running user code ) from a browser - accessible client side ( providing the user inter - face ) . Since Jupyter uses familiar web technologies to implement the layer that facilitates communication between the UI and the kernel , it crucially allows users to run notebooks on any platform . Furthermore , Jupyter’s decoupled architecture allows users to leverage powerful server computing resources from modest client - side hardware , par - ticularly useful for coping with the ever - increasing scale of modern dataset sizes . def custom _ agg ( series ) : . . . [ 1 ] [ 4 ] agg _ by _ col = { ' A ' : ' min ' , ' B ' : custom _ agg } [ 2 ] df _ x _ agg = df _ x . agg ( agg _ by _ col ) df _ y _ agg = df _ y . agg ( agg _ by _ col ) [ 3 ] [ 5 ] Figure 1 : Example sequence of notebook interactions leading to a stale symbol usage . Symbols with timestamps ≤ 3 are shown with a blue border , while symbols with timestamps > 3 are shown with a red border . These key features , along with the natural ergonomics of interactive computing offered by the notebook interface , have led to an explo - sion in Jupyter’s usage . With more than 4 . 7 million notebooks on GitHub as of March 2019 [ 47 ] and with hosted solutions offered by a plethora of data analytics companies , Jupyter has been called “data scientists’ computational notebook of choice” [ 35 ] , and was recognized by the ACM Software System award in 2018 [ 34 ] . We focus on Jupyter here due to its popularity , but we note that our ideas are applicable to computational notebooks in general . Despite the tighter feedback enjoyed by users of computational note - books , and , in particular , by users of Jupyter , notebooks have a number of drawbacks when used for more interactive and exploratory analysis . Compared to conventional programming environments , interactions such as out - of - order cell execution , cell deletion , and cell editing and re - execution can all complicate the relationship between the code visible on screen and the resident notebook state . Managing interactions with this hidden notebook state is thus a burden shouldered by users , who must remember what they have done in the past , since these past inter - actions cannot in general be reconstructed from what is on the screen . Illustration . Consider the sequence of notebook interactions depicted in Figure 1 . Each rectangular box indicates a cell , the notebook’s unit of execution . The user first defines a custom aggregation function that , along with min , will be applied to two dataframes , df _ x and df _ y , and executes it as cell [ 1 ] . Since both aggregations will be applied to both dataframes , the user next gathers them into a function dictionary in the second cell ( executed as cell [ 2 ] ) . After running the third cell , which corresponds to applying the aggregates to df _ x and df _ y , the user realizes an error in the logic of custom _ agg and goes back to the first cell to fix the bug . They re - execute this cell after making their update , indicated as [ 4 ] . However , they forget that the old version of custom _ agg still lingers in the agg _ by _ col dictionary and rerun the third cell ( indicated as [ 5 ] ) without rerunning the second cell . We deem this an unsafe execution , because the user intended for the change to agg _ by _ col to be reflected in df _ agg _ x and df _ agg _ y , butitwasnot . Uponinspectingtheresultingdataframes df _ x _ agg and df _ y _ agg , the user may or may not realize the error . In the best case , user may identify the error and rerun the second cell . In the worst case , users may be deceived into thinking that their change had no effect , with the original error then propagating throughout the notebook . 1 a r X i v : 2012 . 06981v2 [ c s . S E ] 19 J u n 2021 Stephen Macke , Hongpu Gong , Doris Jung - Lin Lee , Andrew Head , Doris Xin , and Aditya Parameswaran This example underscores the inherent difficulty in manually man - aging notebook state , inspiring colorful criticisms such as a talk titled “I Don’t Like Notebooks” presented at JupyterCon 2018 [ 17 ] . In addition to the frustration that users experience when spending valuable time debugging state - related errors , such bugs can lead to invalid research results and hinder reproducibility , inspiring the claim that one must “restart and run all or it didn’t happen” [ 35 ] if presenting results via a notebook medium . Key Research Challenges . The goal of this paper is to develop tech - niques to automatically identify and prevent potentially unsafe cell ex - ecutions , without sacrificing existing familiar notebook semantics . We encounter a number of challenges toward this end : 1 . Automatically detecting unsafe interactions . To detect unsafe inter - actions due to symbol staleness issues , the approach that immediately suggests itself is static code analysis , but upon deeper reflection , it becomes clear that static analysis on its own is not enough . A static approach must necessarily be overly conservative when gathering lin - eagemetadata / inferringdependencies , asitmustconsiderallbranches of control flow . On the other hand , some amount of static analysis is necessary so that users can be warned before they execute an unsafe cell ( as opposed to during cell execution , by which time the damage may already be done ) ; finding the right balance is nontrivial . 2 . Automatically resolving unsafe behavior with suggested fixes . In ad - dition to detecting potentially unsafe interactions , we should ideally also identify which cells to run in order to resolve staleness issues . A simpler approach may be to automatically rerun cells when a potential staleness issue is detected ( as in Dataflow notebooks [ 28 ] ) , but in a flexible notebook environment , there could potentially be more than one cell whose re - executions would all resolve a particular staleness issue ; identifying these to present them as options to the user requires a significant amount of nontrivial static analysis . 3 . Maintaining interactive levels of performance . We must address the aforementioned challenges without introducing unacceptable latencies or memory usage . First , we must ensure that any lineage metadata we introducedoesnotgrowtoolargeinsize . Second , efficientlyidentifying cells that resolve staleness issues is also nontrivial . Suppose we are able to detect cells with staleness issues , and we have detected such issues in cell 𝑐 𝑠 . We can check whether prepending some cell 𝑐 𝑟 ( and thereby executing 𝑐 𝑟 firstbefore 𝑐 𝑠 ) wouldfixthestalenessissue ( by , e . g . , detect - ing whether the merged cell 𝑐 𝑟 ⊕ 𝑐 𝑠 has staleness issues ) , but we show in Section 5 . 2 that a direct implementation of this idea scales quadrati - cally in the number of cells in the notebook and therefore quickly loses viability . Developing an efficient approach is thus a major challenge . Despite previous attempts to address these challenges and to facil - itate safer interactions with global notebook state [ 10 , 28 , 50 ] , to our knowledge , nbsafetyisthefirsttodosowhilepreservingtheflexibility of existing notebook semantics . For example , Dataflow notebooks [ 28 ] require users to explicitly annotate cells with their dependencies , and forcethere - executionofcellswhosedependencieshavechanged . Node - book [ 50 ] andtheDatalorekernel [ 10 ] attempttoenforceatemporalor - deringofvariabledefinitionsintheorderthatcellsappear , againforcing userstocompromiseonflexibility . Inthedesignspaceofcomputational notebooks [ 29 ] , Dataflow notebooks observe reactive execution order , while Nodebook and Datalore’s kernel observe forced in - order execu - tion . However , a solution that preserves any - order execution semantics , while simultaneously helping users avoid errors that are only made possible due to such flexibility , has heretofore evaded development . Contributions . To address these challenges , we develop nbsafety , a custom Jupyter kernel and frontend for automatically detecting unsafe interactions and alerting users , all while maintaining interactive levels of performance and preserving existing notebook semantics . Installing nbsafety is easy : after running a single installation command 1 , users of both JupyterLab and traditional Jupyter notebooks can opt to use 1 pip install nbsafety Submitcellexecution Computesymbol lineageduringexecution Foreachcell : Performlivenessandinverselivenessanalysis Highlightcells Runtimetracer À Staticchecker Ã Frontend Figure2 :         workflowwitharchitecturalcomponents . [ Stephen : Indicate kernel ; givegraphicsforcellhighlights . ] scrapedfromGitHub . Wefoundthatcellshighlightedby        as unsafeduringreplaytendedtobecellsthatusersavoid , whilecellshigh - lightedby        asresolvingsafetyissuestendedtobecellsthatusersprefer , underscoringtheirutility . [ Andrew : I’mnotsureIfullyunder - standwhythisindicatesasuccessfornbsafety . Itmightneedtobespelled outabitmore . ] Furthermore , bysamplingsomeofthe 117 sessions forwhichsafetyissuesweredetected , wefoundpoignantinstancesof concreteerrorsuserscouldhaveavoidedhadtheybeenusing         . OurfreeandopensourcecodeisavailablepubliclyonGitHub [ 28 ] . RelatedWork . Error - proneinteractionswithglobalnotebookstateare well - documentedinindustryandacademiccommunities [ 9 , 16 , 19 , 22 , 25 , 26 , 33 , 34 , 37 , 41 ] . Despitepreviousattemptstofacilitate saferinteractionswithglobalnotebookstate [ 25 , 41 ] , toourknowledge ,         isthefirsttodosowhilepreservingtheflexibilityofexistingnotebooksemantics . Dataflownotebooks [ 25 ] requireuserstoexplicitlyannotatecells withtheirdependencies , while        detectsthemautomatically . Furthermore , dataflownotebooksforcethere - executionofcellswhose dependencieshavechanged ;         deferssuchdecisionstotheuser , optingfortraditionalnotebooksemantics . Nodebook [ 41 ] takesadifferentapproach , that , like         , uses programanalysistoinfervariabledependencies . Unlike         , however , Nodebookattemptstoenforceatemporalorderingofvariable definitionsintheorderthatcellsappear . Thus , nodebookcanprevent , for example , theunsafeinteractiondepictedinFigure1 , sincererunningcell 3automaticallytriggersare - executionofcell2inNodebook . However , becauseNodebooktakesapurelystaticapproach , thegranularityofthe inferredsymboldependenciescanbeunnecessarilycoarse . Forexample , consideracellthatusessymbol d [ x ] when x = = 5 . Nodebookwill detectadependencyonvariable d , while        isabletoleverage theadditionalruntimeinformationtorefinethedependencyto d [ 5 ] . Inthedesignspaceofcomputationalnotebooks [ 26 ] , Dataflownote - booksobserve reactive executionorder , whileNodebookobserves forced in - order execution .          , ontheotherhand , preservesthefamiliar anyorder semanticsoftraditionalnotebooks . WesurveyadditionalrelatedworkinSection7 . Organization . Therestofthispaperisorganizedasfollows . Section2 givesahigh - leveloverviewof        ’sarchitectureandhowitinte - gratesintoanotebookworkflow . Thenextthreesectionsdrillintoeach of        ’scomponents : Section3describeshowthetracermaintains lineagemetadata , Section4describesthestaticanalysesemployedbythe checker , andSection5describeshowthesetwocomponentsfeedintothe frontendinorderhelpusersavoidandresolvesafetyissues . Weempir - icallyvalidate        ’sabilitytohighlight ( i ) cellsthatshouldlikely beavoidedand ( ii ) cellsthatshouldlikelybere - executedinSection6 beforesurveyingrelatedworkandconcluding ( Sections7and8 ) . 2 . ARCHITECTUREOVERVIEW Wenowgiveabird’seyeviewof        ’sdifferentcomponentsandhowtheyintegrateintothetypicalnotebookworkflow . 2 . 1 Background def . . . . . . In [ 1 ] In [ 4 ] agg _ by _ col = . . . In [ 2 ] df _ x _ agg = . . . df _ y _ agg = . . . In [ 3 ] defcustom . . . . . . In [ 1 ] agg _ by _ col = . . . In [ 2 ] df _ x _ agg = . . . df _ y _ agg = . . . In [ 3 ] [ Aditya : You’llneedtointroduceruntimetracer , staticchecker , and livenessanalysisforaDBcrowd . Verybrieflyisfine . You’llalsoneed tointroducecomputationalnotebooksandthenotionof“cells” . ] The         backendiscomprisedoftwomaincomponents : a runtime tracer thatinstrumentseachexecutedlineofcodeandupdateslineage metadata [ Andrew : whatislineage ? Italsowasn’tcleartomewhen Iwasreadingthetitle , somightbeburyingthelede ] , and À a static checker thatperformsvariousprogramanalysistechniques , suchas livenessanalysis [ 3 ] aswellasanovelmethodwecall inverseliveness analysis ( § 4 . 3 ) . Theresultofthisanalysisisthenfedto Ã the         frontend , whichhighlights ( a ) potentiallyunsafecells , and ( b ) cellsthat usersmaywishtore - execute , e . g . , becausereferencedvariableswere updated , orbecausere - executionwouldresolveasafetyissue . AsdepictedinFigure2 , allcomponentsof        areinvoked uponeachandeverycellexecution . Whentheusersubmitsarequestto runacell , thetracer ( ) instrumentstheexecutedcell , updatingsymbol lineagemetadataaseachlineexecutes . Oncethecellfinishesexecution , thechecker ( À ) performslivenessandinverselivenessanalysesforevery cellinthenotebook . Bycombiningtheresultsoftheseanalyseswith thelineagemetadatacomputedbythetracer , thefrontend ( Ã ) isable tohighlightbothunsafecellsaswellascellsthatresolvesafetyissues ( § 5 ) , informationwhichtheusercanthenleveragewhendecidingthe nextactiontoperform . Tounderstandtheoperationsofeachcomponent , wefirstintroduce thenotionsofsymbolsaswellastheirtimestampsanddependencies . [ Aditya : Whynotstartwiththesepreliminariespriortothecomponents ? ] Symbols , timestamps , anddependencies . Webegindefiningouruse oftheterm symbol . Definition1 [ Symbol ] . A symbol isanypieceofdatainnotebookscope thatcanbereferencedbya ( possiblyqualified ) name . Forexample , if lst isalistwith10entries , then lst , lst [ 0 ] , and lst [ 8 ] areallsymbols . Similarly , if df isadataframewithacolumn named“col” , then df and df . col arebothsymbols .         augmentseachsymbolwithadditionallineagemetadata intheformof timestamps and dependencies . Definition2 [ Timestamp ] . Asymbol’s timestamp istheexecutioncounter ofthecellthatmostrecentlymodifiedthatsymbol . Likewise , acell’s timestampistheexecutioncountercorrespondingtothemostrecenttimethatcellwasexecuted . Forasymbol s oracell c , wedenoteitstimestampas ts ( s ) or ts ( c ) , respectively . Forexample , letting c 1 , c 2 , and c 3 denotethethree cellsinFigure1 , wehavethat ts ( custom _ agg ) D ts ( c 1 ) D 4 , since custom _ agg islastdefined / updatedin c 1 . Definition3 [ Dependencies ] . The dependencies ofsymbol s aretheset ofsymbolsthatcontributeddirectlytothecomputationof s . [ Andrew : doesthisincludebothcontroldependenciesanddatadependencies ? ] InFigure1 , agg _ by _ col dependson custom _ agg , while df _ x _ agg dependson df _ x and custom _ agg . Wewrite Par ( s ) todenotethe dependenciesof s . Similarly , if t 2 Par ( s ) , then s 2 Chd ( t ) . [ Andrew : I’mabitthrownoffbythenotation ; doesitmakesensetouse“parent” and“child”ifdataflowisoftenrepresentedasagraph ? ] 3 Submit cell execution def . . . . . . [ 1 ] [ 4 ] agg _ by _ col = . . . [ 2 ] df _ x _ agg = . . . df _ y _ agg = . . . [ 3 ] defcustom . . . . . . [ 1 ] agg _ by _ col = . . . [ 2 ] df _ x _ agg = . . . df _ y _ agg = . . . [ 3 ] Figure3 : The        frontendhighlightscellsthatareunsafetoexecutewith stalenesswarnings andcellsthatresolvesuchissueswith cleanupsuggestions . ( astandardtechniqueforfindingnon - redefinedsymbolsinaprogram ) and inverselivenessanalyses ( anewtechniquediscussedin § 4 . 3 ) for everycellinthenotebook . Bycombiningtheresultsoftheseanalyses withthelineagemetadatacomputedbythetracer , thefrontend ( Ã , § 5 ) isabletohighlightcellsthatareunsafeduetostalenessissuesoftheformseeninFigure1 , aswellascellsthatresolvesuchstalenessissues . Wenowdescribetheoperationofeachcomponentinmoredetail . Tracer . The        tracermaintainsdataflowdependenciesfor eachsymbolthatappearsinthenotebookintheformoflineagemeta - data . ItleveragesPython’sbuilt - intracingcapabilities [ 2 ] , which allowsittoruncustomcodeuponfourdifferentkindsofevents : ( i ) line events , whenalinestartstoexecute ; ( ii ) call events , when afunctioniscalled , ( iii ) return events , whenafunctionreturns , and ( iv ) exception events , whenanexceptionoccurs . Toillustrateitsoperation , considerthat , thefirsttime c 3 inFigure1 isexecuted , symbols df _ agg _ x and df _ agg _ y areundefined . Before thefirstlineruns , a line eventoccurs , therebytrappingintothetracer . Thetracerhasaccesstothelinetriggeringtheeventandparsesitasan Assign statementinPython’sgrammar , followedbyaquickstatic analysistodeterminethatthesymbols df _ x and agg _ by _ col appear ontherighthandsideoftheassignment . Thus , thesetwowillbethe dependenciesforsymbol df _ agg _ x . Since c 3 isthethirdcellexe - cuted , thetracerfurthermoregives df _ agg _ x atimestampof 3 . Similar statementsholdfor df _ agg _ y oncethesecondlineexecutes . À Checker . The        staticcheckerperformstwokindsofprogram analysis : ( i ) livenessanalysis , and ( ii ) anewtechniquethatwecall inverselivenessanalysis . The        livenesscheckerhelpstodetect safetyissuesbydeterminingwhichcellshavelivereferencestostalesymbols . Forexample , inFigure1 , agg _ by _ col , whichisstale , is livein c 3 – thisinformationcanbeusedtowarntheuserbeforethey execute c 3 . Furthermore , theinverselivenesscheckerservesasakey componentforefficientlycomputingresolutionstostalenessissues , as welatershowinSections4and5 . Ã Frontend . The        frontendusestheresultsofthestatic checkertohighlightcellsofinterest . Forexample , inFigure3 , which depictstheoriginalexamplefromFigure1 ( butbeforetheusersubmits c 3 forre - execution ) , c 3 isgivena stalenesswarning towarntheuser thatre - executioncouldhaveincorrectbehaviorduetostalenessissues . Atthesametime , c 2 isgivena cleanupsuggestion highlight , because ASTNode Example Rule Assign a = e Par ( a ) D USE Œe ç ( targetinRHS ) a = a + e Par ( a ) D Par ( a ) [ USE Œe ç AugAssign a + = e Par ( a ) D Par ( a ) [ USE Œe ç For forain e : Par ( a ) D USE Œe ç FunctionDef deff ( a = e ) : Par ( f ) D USE Œe ç ClassDef classc ( e ) : Par ( c ) D USE Œe ç Table1 : Lineagerulesusedbythe        tracer . rerunningitwouldresolvethestalenessissuepresentin c 3 . Theusercan thenleveragetheextravisualcuestomakeamoreinformeddecisionaboutwhichcelltonextexecute , possiblypreferringtoexecutecells thatresolvestalenessissuesbeforecellswithstalenessissues . Overall , eachof        ’sthreekeycomponentsplaycrucialroles inhelpingusersavoidandresolveunsafeinteractionsduetostalenessissues . Wedescribeeachcomponentindetailinthefollowingsections . 3 . LINEAGETRACKING Inthissection , wedescribehow        tracescellexecutionin ordertomaintainsymbollineagemetadata , andhowsuchmetadata aidsinthedetectionandresolutionofstalenessissues . Webeginby introducinghelpfulterminologyandformalizingournotionofstalenessbeyondtheintuitionwegavefromtheexampleinFigure1 . 3 . 1 Preliminaries Webegindefiningouruseoftheterm symbol . Definition1 [ Symbol ] . A symbol isanypieceofdatainnotebookscope thatcanbereferencedbya ( possiblyqualified ) name . Forexample , if lst isalistwith10entries , then lst , lst [ 0 ] , and lst [ 8 ] areallsymbols . Similarly , if df isadataframewitha columnnamed“col” , then df and df . col arebothsymbols . Symbols canbethoughtofasageneralizednotionofvariablesthatallowustreatdifferentnameableobjectsinPython’sdatamodelinaunifiedmanner .         augmentseachsymbolwithadditionallineagemetadata intheformof timestamps and dependencies . Definition2 [ Timestamp ] . Asymbol’s timestamp istheexecutioncounter ofthecellthatmostrecentlymodifiedthatsymbol . Likewise , acell’s timestampistheexecutioncountercorrespondingtothemostrecenttimethatcellwasexecuted . Forasymbol s oracell c , wedenoteitstimestampas ts ( s ) or ts ( c ) , respectively . Forexample , letting c 1 , c 2 , and c 3 denotethe threecellsinFigure1 , wehavethat ts ( custom _ agg ) D ts ( c 1 ) D 4 , since custom _ agg islastupdatedin c 1 , whichwasexecutedattime 4 . Definition3 [ Dependencies ] . The dependencies ofsymbol s aretheset ofsymbolsthatcontributedtothecomputationof s viadirectdataflow . InFigure1 , agg _ by _ col dependson custom _ agg , while df _ x _ agg dependson df _ x and custom _ agg . Wewrite Par ( s ) todenotethe dependenciesof s . Similarly , if t 2 Par ( s ) , then s 2 Chd ( t ) . Amajorcontributionof        istohighlightcellswithunsafeusagesof stalesymbols , whichwedefinerecursivelyasfollows : Definition4 [ Stalesymbols ] . Asymbol s iscalled stale ifthereexists some s 0 2 Par ( s ) suchthat ts ( s 0 ) > ts ( s ) , or s ’isitselfstale ; thatis , s hasaparentthatiseitheritselfstaleormoreup - to - datethan s . InFigure1 , symbol agg _ by _ col isstale , because ts ( agg _ by _ col ) D 2 , but ts ( custom _ agg ) D 4 . Stalenessgivesusarigorouscon - ceptualframeworkuponwhichtostudytheintuitivenotionthat , because custom _ agg wasupdated , weshouldalsoupdateitschild agg _ by _ col topreventcounterintuitivebehavior . Wenowdrawonthesedefinitionsaswedescribehow        maintainslineagemetadataforeachsymbolwhiletracingcellexecution . 3 Compute symbol lineage during execution For each cell : Perform liveness and initialized variable analysis Highlight cells (cid:202) Runtime tracer (cid:203) Static checker (cid:204) Frontend def . . . . . . [ 1 ] [ 4 ] agg _ by _ col = . . . [ 2 ] df _ x _ agg = . . . df _ y _ agg = . . . [ 3 ] defcustom . . . . . . [ 1 ] agg _ by _ col = . . . [ 2 ] df _ x _ agg = . . . df _ y _ agg = . . . [ 3 ] Figure3 : The        frontendhighlightscellsthatareunsafetoexecutewith stalenesswarnings andcellsthatresolvesuchissueswith cleanupsuggestions . ( astandardtechniqueforfindingnon - redefinedsymbolsinaprogram ) and inverselivenessanalyses ( anewtechniquediscussedin § 4 . 3 ) for everycellinthenotebook . Bycombiningtheresultsoftheseanalyses withthelineagemetadatacomputedbythetracer , thefrontend ( Ã , § 5 ) isabletohighlightcellsthatareunsafeduetostalenessissuesoftheformseeninFigure1 , aswellascellsthatresolvesuchstalenessissues . Wenowdescribetheoperationofeachcomponentinmoredetail . Tracer . The        tracermaintainsdataflowdependenciesfor eachsymbolthatappearsinthenotebookintheformoflineagemeta - data . ItleveragesPython’sbuilt - intracingcapabilities [ 2 ] , which allowsittoruncustomcodeuponfourdifferentkindsofevents : ( i ) line events , whenalinestartstoexecute ; ( ii ) call events , when afunctioniscalled , ( iii ) return events , whenafunctionreturns , and ( iv ) exception events , whenanexceptionoccurs . Toillustrateitsoperation , considerthat , thefirsttime c 3 inFigure1 isexecuted , symbols df _ agg _ x and df _ agg _ y areundefined . Before thefirstlineruns , a line eventoccurs , therebytrappingintothetracer . Thetracerhasaccesstothelinetriggeringtheeventandparsesitasan Assign statementinPython’sgrammar , followedbyaquickstatic analysistodeterminethatthesymbols df _ x and agg _ by _ col appear ontherighthandsideoftheassignment . Thus , thesetwowillbethe dependenciesforsymbol df _ agg _ x . Since c 3 isthethirdcellexe - cuted , thetracerfurthermoregives df _ agg _ x atimestampof 3 . Similar statementsholdfor df _ agg _ y oncethesecondlineexecutes . À Checker . The        staticcheckerperformstwokindsofprogram analysis : ( i ) livenessanalysis , and ( ii ) anewtechniquethatwecall inverselivenessanalysis . The        livenesscheckerhelpstodetect safetyissuesbydeterminingwhichcellshavelivereferencestostalesymbols . Forexample , inFigure1 , agg _ by _ col , whichisstale , is livein c 3 – thisinformationcanbeusedtowarntheuserbeforethey execute c 3 . Furthermore , theinverselivenesscheckerservesasakey componentforefficientlycomputingresolutionstostalenessissues , as welatershowinSections4and5 . Ã Frontend . The        frontendusestheresultsofthestatic checkertohighlightcellsofinterest . Forexample , inFigure3 , which depictstheoriginalexamplefromFigure1 ( butbeforetheusersubmits c 3 forre - execution ) , c 3 isgivena stalenesswarning towarntheuser thatre - executioncouldhaveincorrectbehaviorduetostalenessissues . Atthesametime , c 2 isgivena cleanupsuggestion highlight , because ASTNode Example Rule Assign a = e Par ( a ) D USE Œe ç ( targetinRHS ) a = a + e Par ( a ) D Par ( a ) [ USE Œe ç AugAssign a + = e Par ( a ) D Par ( a ) [ USE Œe ç For forain e : Par ( a ) D USE Œe ç FunctionDef deff ( a = e ) : Par ( f ) D USE Œe ç ClassDef classc ( e ) : Par ( c ) D USE Œe ç Table1 : Lineagerulesusedbythe        tracer . rerunningitwouldresolvethestalenessissuepresentin c 3 . Theusercan thenleveragetheextravisualcuestomakeamoreinformeddecisionaboutwhichcelltonextexecute , possiblypreferringtoexecutecells thatresolvestalenessissuesbeforecellswithstalenessissues . Overall , eachof        ’sthreekeycomponentsplaycrucialroles inhelpingusersavoidandresolveunsafeinteractionsduetostalenessissues . Wedescribeeachcomponentindetailinthefollowingsections . 3 . LINEAGETRACKING Inthissection , wedescribehow        tracescellexecutionin ordertomaintainsymbollineagemetadata , andhowsuchmetadata aidsinthedetectionandresolutionofstalenessissues . Webeginby introducinghelpfulterminologyandformalizingournotionofstalenessbeyondtheintuitionwegavefromtheexampleinFigure1 . 3 . 1 Preliminaries Webegindefiningouruseoftheterm symbol . Definition1 [ Symbol ] . A symbol isanypieceofdatainnotebookscope thatcanbereferencedbya ( possiblyqualified ) name . Forexample , if lst isalistwith10entries , then lst , lst [ 0 ] , and lst [ 8 ] areallsymbols . Similarly , if df isadataframewitha columnnamed“col” , then df and df . col arebothsymbols . Symbols canbethoughtofasageneralizednotionofvariablesthatallowustreatdifferentnameableobjectsinPython’sdatamodelinaunifiedmanner .         augmentseachsymbolwithadditionallineagemetadata intheformof timestamps and dependencies . Definition2 [ Timestamp ] . Asymbol’s timestamp istheexecutioncounter ofthecellthatmostrecentlymodifiedthatsymbol . Likewise , acell’s timestampistheexecutioncountercorrespondingtothemostrecenttimethatcellwasexecuted . Forasymbol s oracell c , wedenoteitstimestampas ts ( s ) or ts ( c ) , respectively . Forexample , letting c 1 , c 2 , and c 3 denotethe threecellsinFigure1 , wehavethat ts ( custom _ agg ) D ts ( c 1 ) D 4 , since custom _ agg islastupdatedin c 1 , whichwasexecutedattime 4 . Definition3 [ Dependencies ] . The dependencies ofsymbol s aretheset ofsymbolsthatcontributedtothecomputationof s viadirectdataflow . InFigure1 , agg _ by _ col dependson custom _ agg , while df _ x _ agg dependson df _ x and custom _ agg . Wewrite Par ( s ) todenotethe dependenciesof s . Similarly , if t 2 Par ( s ) , then s 2 Chd ( t ) . Amajorcontributionof        istohighlightcellswithunsafeusagesof stalesymbols , whichwedefinerecursivelyasfollows : Definition4 [ Stalesymbols ] . Asymbol s iscalled stale ifthereexists some s 0 2 Par ( s ) suchthat ts ( s 0 ) > ts ( s ) , or s ’isitselfstale ; thatis , s hasaparentthatiseitheritselfstaleormoreup - to - datethan s . InFigure1 , symbol agg _ by _ col isstale , because ts ( agg _ by _ col ) D 2 , but ts ( custom _ agg ) D 4 . Stalenessgivesusarigorouscon - ceptualframeworkuponwhichtostudytheintuitivenotionthat , because custom _ agg wasupdated , weshouldalsoupdateitschild agg _ by _ col topreventcounterintuitivebehavior . Wenowdrawonthesedefinitionsaswedescribehow        maintainslineagemetadataforeachsymbolwhiletracingcellexecution . 3 Figure 2 : nbsafety workflow with architectural components . the nbsafety kernel as a drop - in replacement for Jupyter’s built - in Python 3 kernel . nbsafety introduces two key innovations to address the challenges outlined above : 1 . Efficient and accurate detection of staleness issues in cells via novel joint dynamic and static analysis . The nbsafety kernel combines runtime tracing with static analysis in order to detect and prevent notebook interactions that are unsafe due to staleness issues of the form seen in Figure 1 . The tracer ( § 3 ) instruments each program statement so that program variable definitions are annotated with parent dependencies and cell execution timestamps . This metadata is then used by a runtime state - aware static checker ( § 4 ) that combines said metadata with static programanalysistechniquestodeterminewhetheranystalenessissuesarepresent prior to the start of cell execution . This allows nbsafety to present users with cell highlights ( § 5 ) that warn them about cells that are unsafe to execute due to staleness issues before they try exe - cuting such cells , thus preserving desirable atomicity of cell executions present in traditional notebooks . 2 . Efficient resolution of staleness issues . Beyond simply detecting stale - nessissues , wealsoshowhowtodetectcellswhosere - executionwould resolve such staleness issues — but doing so efficiently required us to leverage a lesser - known analysis technique called initialized variable analysis ( § 4 . 3 ) tailoredtothisusecase . Weshowhowinitializedanalysis brings staleness resolution complexity down from time quadratic in the number of cells in the notebook to linear , crucial for large notebooks . We validate our design choices for nbsafety by replaying and an - alyzing of a corpus of 666 execution logs of real notebook sessions , scraped from GitHub ( § 6 ) . In doing so , nbsafety identified that 117 sessions had potential safety errors , and upon sampling these for man - ual inspection , we found several with particularly egregious examples of confusion and wasted effort by real users that would have been saved with nbsafety . After analyzing the 549 remaining sessions , we found that cells suggested by nbsafety as resolving staleness issues were strongly favored by users for re - execution—more than 7 × more likely to be selected compared to random cells , even though these user interactions were originally performed without nbsafety and therefore were not influenced by its suggestions . Overall , our em - pirical study indicates that nbsafety can reduce cognitive overhead associated with manual maintenance of global notebook state under any - order execution semantics , and in doing so , allows users to focus their efforts more on the already challenging task of exploratory data analysis , and less on avoiding and fixing state - related notebook bugs . Our free and open source code is available publicly on GitHub [ 31 ] . Organization . Section 2 gives a high - level overview of nbsafety’s architecture and how it integrates into a notebook workflow . The next three sections drill into each of nbsafety’s components : Section 3 de - scribes how the tracer maintains lineage metadata , Section 4 describes the static analyses employed by the checker , and Section 5 describes how these two components feed into the frontend in order help users avoid and resolve safety issues . We empirically validate nbsafety’s ability to highlight ( i ) cells that should likely be avoided and ( ii ) cells that should likely be re - executed in Section 6 before surveying related work and concluding ( § 7 , § 8 ) . 2 . ARCHITECTURE OVERVIEW In this section , we give an overview of nbsafety’s components and how they integrate into the notebook workflow . We now describe the operation of each component in more detail . 2 Fine - Grained Lineage for Safer Notebook Interactions Figure 3 : nbsafety highlights cells that are unsafe to execute with staleness warnings and cells that resolve such issues with cleanup suggestions . Overview . nbsafety integrates into a notebook workflow according to Figure 2 . As depicted , all components of nbsafety are invoked upon each and every cell execution . When the user submits a request to run a cell , the tracer ( (cid:202) , § 3 ) instruments the executed cell , updating lineage metadata associated with each variable as each line executes . Once the cell finishes execution , the checker ( (cid:203) , § 4 ) performs liveness analysis [ 2 ] ( a standard technique for finding non - redefined symbols in a program ) and initialized variable analysis [ 32 ] ( discussed in § 4 . 3 ) for every cell in the notebook . By combining the results of these analyses with the lineage metadata computed by the tracer , the frontend ( (cid:204) , § 5 ) is able to highlight cells that are unsafe due to staleness issues of the form seen in Figure 1 , as well as cells that resolve such staleness issues . (cid:202) Tracer . The nbsafety tracer maintains dataflow dependencies for each symbol that appears in the notebook in the form of lineage metadata . It leverages Python’s built - in tracing capabilities [ 45 ] , which allows it to run custom code upon four different kinds of events : ( i ) line events , when a line starts to execute ; ( ii ) call events , when a function is called , ( iii ) return events , when a function returns , and ( iv ) exception events , when an exception occurs . To illustrate its operation , consider that , the first time 𝑐 3 in Figure 1 is executed , symbols df _ agg _ x and df _ agg _ y are undefined . Before the first line runs , a line event occurs , thereby trapping into the tracer . The tracer has access to the line of code that triggered the line event and parses it as an Assign statement in Python’s grammar , followed by a quick static analysis to determine that the symbols df _ x and agg _ by _ col appear on the right hand side of the assignment ( i . e . , these symbols appear in USE [ R . H . S . of the Assign ] ) . Thus , these two will be the dependencies for symbol df _ agg _ x . Since 𝑐 3 is the third cell executed , the tracer furthermore gives df _ agg _ x a timestamp of 3 . Similar statements hold for df _ agg _ y once the second line executes . (cid:203) Checker . The nbsafety static checker performs two kinds of pro - gram analysis : ( i ) liveness analysis , and ( ii ) initialized variable analysis . The nbsafety liveness checker helps to detect safety issues by deter - mining which cells have live references to stale symbols . For example , in Figure 1 , agg _ by _ col , which is stale , is live in 𝑐 3 —this information can be used to warn the user before they execute 𝑐 3 . Furthermore , the initialized checker serves as a key component for efficiently computing resolutions to staleness issues , as we later show in Sections 4 and 5 . (cid:204) Frontend . The nbsafety frontend uses the results of the static checker to highlight cells of interest . For example , in Figure 3 , which depicts the original example from Figure 1 ( but before the user submits 𝑐 3 for re - execution ) , 𝑐 3 is given a staleness warning highlight to warn the user that re - execution could have incorrect behavior due to staleness issues . At the same time , 𝑐 2 is given a cleanup suggestion highlight , because rerunning it would resolve the staleness in 𝑐 3 . The user can then leverage the extra visual cues to make a more informed decisionaboutwhichcelltonextexecute , possiblypreferringtoexecute cells that resolve staleness issues before cells with staleness issues . Design Philosophy . In contrast with systems that automatically re - solve staleness , such as Datalore [ 10 ] or Nodebook [ 50 ] , nbsafety is designed to be as non - intrusive as possible , while providing useful information . nbsafety thus only attempts to make a “passive observer” guarantee to ensure that existing notebook semantics are preserved , via tracing and static analyses that monitor , and do not alter , note - book behavior . We make this decision partially because program analysis in a dynamic language like Python is notoriously difficult ; as such , nbsafety’s analysis components are unable to make any formal guarantees regarding soundness or completeness , instead opting for a “best - effort” attempt to provide the user with useful information . Although the guarantee nbsafety offers regarding preservation of semantics may seem weak at first glance , we show later ( § 6 . 5 ) that both Datalore and Nodebook crash on reasonable programs due to their intrusiveness . Furthermore , we also show how existing seman - tics lend themselves to multiverse analyses [ 44 ] , and point to specific examples of such analyses in our experiments . Finally , nbsafety is not necessarily intended to be a substitute for systems like Dataflow note - books [ 28 ] that allow users to give names to cell outputs and explicitly reference them ; the two techniques can complement each other , as the issues faced by notebook users do not automatically disappear by using Dataflow notebooks . Overall , each of nbsafety’s three key components play crucial roles in helping users avoid and resolve unsafe interactions due to staleness issues without compromising existing notebook program semantics . We describe each component in detail in the following sections . 3 . LINEAGE TRACKING In this section , we describe how nbsafety traces cell execution in order to maintain symbol lineage metadata , and how such metadata aids in the detection and resolution of staleness issues . We begin by in - troducing helpful terminology and formalizing our notion of staleness beyond the intuition we gave in Figure 1 of Section 1 . 3 . 1 Preliminaries We begin defining our use of the term symbol . Definition 1 [ Symbol ] . A symbol is any piece of data in notebook scope that can be referenced by a ( possibly qualified ) name . For example , if lst is a list with 10 entries , then lst , lst [ 0 ] , and lst [ 8 ] are all symbols . Similarly , if df is a dataframe with a column named “col” , then df and df . col are both symbols . Symbols can be thought of as a generalized notion of variables that allow us treat different nameable objects in Python’s data model in a unified manner . nbsafety augments each symbol with additional lineage metadata in the form of timestamps and dependencies . Definition 2 [ Timestamp ] . A symbol’s timestamp is the execution counter of the cell that most recently modified that symbol . Likewise , a cell’s timestamp is the execution counter corresponding to the most recent time that cell was executed . For a symbol s or a cell 𝑐 , we denote its timestamp as ts ( s ) or ts ( 𝑐 ) , respectively . For example , letting 𝑐 1 , 𝑐 2 , and 𝑐 3 denote the three cells in Figure 1 , we have that ts ( custom _ agg ) = ts ( 𝑐 1 ) = 4 , since custom _ agg is last updated in 𝑐 1 , which was executed at time 4 . Definition 3 [ Dependencies ] . The dependencies of symbol s are those symbols that contributed to the computation of s via direct dataflow . In Figure 1 , agg _ by _ col depends on custom _ agg , while df _ x _ agg depends on df _ x and custom _ agg . We write Par ( s ) to denote the dependencies of s . Similarly , if t ∈ Par ( s ) , then s ∈ Chd ( t ) . A major contribution of nbsafety is to highlight cells with unsafe usages of stale symbols , which we define recursively as follows : Definition 4 [ Stale symbols ] . A symbol s is called stale if there exists some s (cid:48) ∈ Par ( s ) such that ts ( s (cid:48) ) > ts ( s ) , or s (cid:48) is itself stale ; that is , s has a parent that is either itself stale or more up - to - date than s . In Figure 1 , symbol agg _ by _ col is stale , because ts ( agg _ by _ col ) = 2 , but ts ( custom _ agg ) = 4 . Staleness gives us a rigorous concep - tual framework upon which to study the intuitive notion that , because custom _ agg wasupdated , weshouldalsoupdateitschild agg _ by _ col to prevent counterintuitive behavior . We now draw on these definitions as we describe how nbsafety maintains lineage metadata for symbols while tracing cell execution . 3 Stephen Macke , Hongpu Gong , Doris Jung - Lin Lee , Andrew Head , Doris Xin , and Aditya Parameswaran AST Node Example Rule Assign a = 𝑒 Par ( a ) = USE [ 𝑒 ] ( target in RHS ) a = a + 𝑒 Par ( a ) = Par ( a ) ∪ USE [ 𝑒 ] Assign with Call a = f ( 𝑒 ) Par ( a ) = USE [ 𝑒 ] ∪ RET [ f ] AugAssign a + = 𝑒 Par ( a ) = Par ( a ) ∪ USE [ 𝑒 ] For for a in 𝑒 : Par ( a ) = USE [ 𝑒 ] FunctionDef def f ( a = 𝑒 ) : Par ( f ) = USE [ 𝑒 ] ClassDef class c ( 𝑒 ) : Par ( c ) = USE [ 𝑒 ] Table 1 : Subset of lineage rules used by the nbsafety tracer . 3 . 2 Lineage Update Rules nbsafety attempts to be non - intrusive when maintaining lineage with respect to the Python objects that comprise the notebook’s state . To do so , we avoid modifying the Python objects created by the user , instead creating “shadow” references to each symbol . nbsafety then takes a hybrid dynamic / static approach to updating each symbol’s lineage . After each Python statement has finished executing , the tracer inspects the AST node for the executed statement and performs a lineage update according to the rules shown in Table 1 . Example . Suppose the statement gen = map ( lambda x : f ( x ) , foo + [ bar ] ) has just finished executing . Using rule 1 of Table 1 , the tracer will then statically analyze the right hand side in order to determine USE [ map ( lambda x : f ( x ) , foo + [ bar ] ) ] which is the set of used symbols that appear in the RHS . In this case , the aforementioned set is { f , foo , bar } — everything else is either a Python built - in ( map , lambda ) , or an unbound symbol ( i . e . in the case of the lambda argument x ) . The tracer will thus set Par ( gen ) = { f , foo , bar } and will also set ts ( gen ) to the current cell’s execution counter . Handling Function Calls and Returns . Recall that , in Python , a function may “capture” symbols defined in external scope by refer - encing them . In this case , the lineage update rule for a function call needs to be aware of the symbols referenced by the function’s return statement . As such , the nbsafety tracer saves these symbols when it encounters a return statement , and loads them upon encountering a return event , so that they are available for use with lineage update rules , e . g . , the third entry of Table 1 . Rationale for Tracing . Given that the tracer is already performing some static analysis as each Python statement executes , a natural ques - tion is : why should we trace cell execution at all , instead of performing static analysis on an entire cell in order to make lineage updates ? The answer is that , when a cell executes , a relatively small number of control flow paths may be taken , and a purely static approach must consider them all in order to be conservative . This may cause each Par ( s ) to be much larger than necessary , or to be unnecessarily over - writtenif , e . g . , s isassignedinsomeunexecutedcontrolflowpath . This can happen due to , e . g . , untaken branches , or if an exception is thrown mid - cell . Indeed , we attempted to infer lineage updates statically in an earlier version of nbsafety , but found this to be too coarse - grained in order to derive real benefits . Staleness Propagation . We already saw that the tracer annotates each symbol’s shadow reference with timestamp and lineage metadata . Additionally , it tracks whether each symbol is stale , as this cannot be inferredsolelyfromtimestampandlineagemetadata . Toseewhy , recall the definition of staleness : a symbol s is stale if it has a more up - to - date parent ( i . e . , an s (cid:48) ∈ Par ( s ) with ts ( s (cid:48) ) > ts ( s ) ) , or if it has a stale parent , precluding the ability to determine staleness locally . Thus , when s is updated , we perform a depth first search starting from each child c ∈ Chd ( s ) in order to propagate the “staleness” to all descendants . Fine - Grained Lineage for Attributes and Subscripts . Recall that the nbsafety tracer attempts to infer parent symbols statically when making lineage updates . While this is possible in many cases , there are limits to a purely static approach . For example , the statement “ s = a . b ( ) . c ” is valid Python code , but , in general , it is impossible to statically determine what a . b ( ) returns . As such , we must again rely on tracing to do so . Unfortunately , Python’s built - in tracing abilities operate at the granularity of code lines , so that a return event does not tell us the point within a line to which control returns . Thus , the tracer rewrites all Attribute nodes in the statement’s AST , so that the earlier example will actually run as follows : s = trace ( trace ( a , ’b’ ) . b ( ) , ’c’ ) . c The trace function will first determine that the symbol name b is ref - erenced within symbol a ’s namespace , setting the current RHS parent symbol to a . b . However , after the call event , the tracer will update this to the c symbol in the namespace of the return value of a . b ( ) , so that the true parent symbol is pinpointed . Subscripts are handled analogously to attributes . Handling External Libraries . nbsafety assumes that imported li - braries do not have access to notebook state . Thus , when the tracer observes a call into library code , it simply halts tracing , resuming once control returns to the notebook . Bounding Lineage Overhead . Consider the following cell : x = 0 for i in random . sample ( range ( 10 * * 7 ) , 10 * * 5 ) + [ 42 ] : x + = lst [ i ] In order to maintain lineage metadata for symbol x to 100 % correctness , we would need to somehow indicate that Par ( x ) contains lst [ i ] for all 10 5 random indices i ( as well as for lst [ 42 ] ) . It is impossible to maintain acceptable performance in general under these circumstances . Potential workarounds include conservative approximations , as well as lossy approximations . For example , as a conservative approximation , we could instead specify that x depends on lst , with the implication that it also depends on everything in lst ’s namespace . However , this will cause x to be incorrectly classified as stale whenever lst is mutated , e . g . , if a new entry is appended . Thus , nbsafety makes a compromise and sacrifices some correct - ness by only instrumenting each AST statement the first time it executes . In this case , after the cell executes , Par ( x ) will have a single entry : lst [ 0 ] . This helps to ensure that lineage metadata only grows in proportion to the amount of text in the user’s notebook . Note that this approach can lead to some false negatives when de - termining which symbols are stale . In the example above , if the user makes a point update to , e . g . , lst [ 42 ] , x should technically be con - sidered stale , but will fail to be updated as so since lst [ 42 ] ∉ Par ( x ) . We consider this tradeoff worthwhile , as we found that performance suffered greatly without it . Garbage Collection . Each symbol’s shadow metadata maintains a weak reference to the symbol . When a Python object is deleted , e . g . , because the user executed a del statement , or because it was garbage collected by Python’s built - in garbage collector , a callback associated with the weak reference executes . This callback tells the metadata to delete itself ( including from any Par ( · ) or Chd ( · ) sets ) , thereby ensuring that lineage metadata does not accumulate without bound over long notebook sessions . Handling Aliases . Since multiple symbols can reference the same objectinPython , weneedamechanismtopropagatemutationstosome object to all symbols that reference it . For example , if both x and y refer to the same list , and then this list is appended to , both x and y should be have their timestamps bumped . nbsafety accomplishes this by creating a registry that maps objects to all symbols referencing them . 4 . LIVENESS AND INITIALIZED ANALYSES In this section , we describe the program analysis component of nbsafety’s backend . The checker performs liveness analysis [ 2 ] , and 4 Fine - Grained Lineage for Safer Notebook Interactions Algorithm 1 : Liveness checker Input : Cell 𝑐 , CFG 𝐺 that stores successors succ [ 𝑠 ] for each stmt 𝑠 ∈ 𝑐 Output : LIVE ( 𝑐 ) 1 foreach stmt 𝑠 ∈ 𝑐 do 2 LIVE 𝑜𝑢𝑡 [ 𝑠 ] ←∅ ; 3 LIVE 𝑖𝑛 [ 𝑠 ] ←∅ ; 4 USE [ 𝑠 ] ← { referenced symbols in 𝑠 } ; 5 DEF [ 𝑠 ] ← { assigned symbols or defined functions in 𝑠 } ; 6 end 7 LIVE 𝑖𝑛 [ 𝐺 exit ] ←∅ ; 8 repeat 9 foreach stmt 𝑠 ∈ 𝑐 do 10 LIVE (cid:48) 𝑜𝑢𝑡 [ 𝑠 ] ← LIVE 𝑜𝑢𝑡 [ 𝑠 ] ; 11 LIVE (cid:48) 𝑖𝑛 [ 𝑠 ] ← LIVE 𝑖𝑛 [ 𝑠 ] ; 12 LIVE 𝑜𝑢𝑡 [ 𝑠 ] ← (cid:208) 𝑠 (cid:48)∈ succ [ 𝑠 ] LIVE 𝑖𝑛 [ 𝑠 (cid:48) ] ; 13 LIVE 𝑖𝑛 [ 𝑠 ] ← USE [ 𝑠 ] ∪ ( LIVE 𝑜𝑢𝑡 [ 𝑠 ] − DEF [ 𝑠 ] ) ; 14 end 15 until LIVE ∗ [ 𝑠 ] = LIVE (cid:48)∗ [ 𝑠 ] for both ∗∈ { 𝑖𝑛 , 𝑜𝑢𝑡 } , ∀ 𝑠 ∈ 𝑐 ; 16 return LIVE 𝑖𝑛 [ 𝐺 entry ] ; Algorithm 2 : Initialized variable checker Input : Cell 𝑐 , CFG 𝐺 that stores predecessors pred [ 𝑠 ] for each stmt 𝑠 ∈ 𝑐 Output : DEAD ( 𝑐 ) 1 foreach stmt 𝑠 ∈ 𝑐 do 2 DEAD 𝑖𝑛 [ 𝑠 ] ←∅ ; 3 DEAD 𝑜𝑢𝑡 [ 𝑠 ] ←U ; 4 USE [ 𝑠 ] ← { referenced symbols in 𝑠 } ; 5 DEF [ 𝑠 ] ← { assigned symbols or defined functions in 𝑠 } ; 6 end 7 DEAD 𝑜𝑢𝑡 [ 𝐺 entry ] ←∅ ; 8 repeat 9 foreach stmt 𝑠 ∈ 𝑐 do 10 DEAD (cid:48) 𝑖𝑛 [ 𝑠 ] ← DEAD 𝑖𝑛 [ 𝑠 ] ; 11 DEAD (cid:48) 𝑜𝑢𝑡 [ 𝑠 ] ← DEAD 𝑜𝑢𝑡 [ 𝑠 ] ; 12 DEAD 𝑖𝑛 [ 𝑠 ] ← (cid:209) 𝑠 (cid:48)∈ pred [ 𝑠 ] DEAD 𝑜𝑢𝑡 [ 𝑠 (cid:48) ] ; 13 DEAD 𝑜𝑢𝑡 [ 𝑠 ] ← ( DEF [ 𝑠 ] − USE [ 𝑠 ] ) ∪ DEAD 𝑖𝑛 [ 𝑠 ] ; 14 end 15 until DEAD ∗ [ 𝑠 ] = DEAD (cid:48)∗ [ 𝑠 ] for both ∗∈ { 𝑖𝑛 , 𝑜𝑢𝑡 } , ∀ 𝑠 ∈ 𝑐 ; 16 return DEAD 𝑜𝑢𝑡 [ 𝐺 exit ] ; if num % 3 = = 0 : foobar = True s = ' foobar ' elif num % 3 = = 1 : foo = True s = ' foo ' else : s = ' bar ' print ( s , foobar ) num foo foobar bar print % 3 = = 0 % 3 = = 1 % 3 = = 2 LIVE : num , foobar INITIALIZED : s Figure 4 : Example liveness and initialized variable analysis . a lesser - known program analysis technique called initialized variable analysis , or definite assignment analysis [ 32 ] . These techniques are crucial for efficiently identifying which cells are unsafe to execute due to stale references , as well as which cells help resolve staleness issues . We begin with background before discussing the connection between these techniques and staleness detection and resolution . 4 . 1 Background Liveness analysis [ 2 ] is a program analysis technique for determining whether the value of a variable at some point is used later in the program . Although traditionally used by compilers to , for example , determine how many registers need to be allocated at some point during program execution , we use it to determine whether a cell has references to stale symbols . We also show ( § 5 ) how initialized variable analysisanalysis [ 32 ] , atechniquetraditionallyusedbyIDEsandlinters to detect potentially uninitialized variables , can be used to efficiently determine which cells to run in order to resolve staleness issues . Example . In Figure 4 , symbols num and foobar are live at the top of the cell , since the value for each at the top of the cell can be used in some path of the control flow graph ( CFG ) . In the case of num , the ( unmodified ) value is used in the conditional . In the case of foobar , while one path of the CFG modifies it , the other two paths leave it unchangedbythetimeitisusedinthe print statement ; hence , itisalso live at the top of the cell . The symbol that is not live at cell start is foo , since it is only ever assigned and never used , and s , since every path in the CFG assigns to s . We call symbols such as s that are assigned in every path of the CFG dead once they reach the end of the cell . 4 . 2 Cell Oriented Analysis We now describe how we relate liveness , which is traditionally ap - plied in the context of a single program , to a notebook environment . In brief , we treat each cell as if it is an individual program when per - forming various program analyses . We formalize these notions below . Definition 5 [ Live symbols ] . Given a cell 𝑐 and some symbol s , we say that s is live in 𝑐 if there exists some execution path in 𝑐 in which the value of s at the start of 𝑐 ’s execution is used later in 𝑐 . Inotherwords , s islivein 𝑐 if , treating 𝑐 asastandaloneprogram , s is live in the traditional sense at the start of 𝑐 . We already saw in Figure 4 that the live symbols in the example cell are num , fiz , and buz . For a given cell 𝑐 , we use LIVE ( 𝑐 ) to denote the set of all live symbols in 𝑐 . We are also interested in dead symbols that are ( re ) defined in every branch by the time execution reaches the end of a given cell 𝑐 . Definition 6 [ Dead symbols ] . Given a cell 𝑐 and some symbol s , we say that s is dead in 𝑐 if , by the time control reaches the end of 𝑐 , every possible path of execution in 𝑐 overwrites s in a manner independent of the current value of s . Denoting such symbols as DEAD ( 𝑐 ) , we will see in Section 5 the role they play in assisting in the resolution of staleness issues . StalenessandFreshnessofLiveSymbolsinCells . Recallthatsym - bols are augmented with additional lineage and timestamp metadata computed by the tracer ( § 3 ) . We can thus additionally refer to the set STALE ( 𝑐 ) ⊆ LIVE ( 𝑐 ) , the set of stale symbols that are live in 𝑐 . When this set is nonempty , we say that cell 𝑐 itself is stale : Definition 7 [ Stale cells ] . A cell 𝑐 is called stale if there exists some s ∈ LIVE ( 𝑐 ) such that s is stale ; i . e . , 𝑐 has a live reference to some stale symbol . A major contribution of nbsafety is to identify cells that are stale and preemptively warn the user about them . Note that a symbol can be stale regardless of whether it is live in some cell . Given a particular cell 𝑐 , we can also categorize symbols according to their lineage and timestamp metadata as they relate to 𝑐 . For example , when a non - stale symbol s that is live in 𝑐 is more “up - to - date” than 𝑐 , then we say that it is fresh with respect to 𝑐 : Definition 8 [ Fresh symbols ] . Given a cell 𝑐 and some symbol s , we say that s is fresh w . r . t . 𝑐 if ( i ) s is not stale , and ( ii ) ts ( s ) > ts ( 𝑐 ) . We can extend the notion of fresh symbols to cells just as we did for stale symbols and stale cells : Definition 9 [ Fresh cells ] . A cell 𝑐 is called fresh if it ( i ) it is not stale , and ( ii ) it contains a live reference to one or more fresh symbols ; that is , ∃ s ∈ LIVE ( 𝑐 ) such that s is fresh with respect to 𝑐 . Example . Consider a notebook with three cells run in sequence , with code a = 4 , b = a , and c = a + b , respectively , and suppose the first cell is updated to be a = 5 and rerun . The third cell contains references to a and b , and although a is fresh , b is stale , so the third cell is not fresh , but stale . On the other hand , the second cell contains a live reference to a but no live references to b , and is thus fresh . As we see in our experiments ( § 6 ) , fresh cells are oftentimes cells that users wish to re - execute ; another major contribution of nbsafety is therefore to automatically identify such cells . In fact , in the above example , rerunning the second cell resolves the staleness issue present in the first cell . That said , running any other cell that assigns to b would also resolve the staleness issue , so staleness - resolving cells need 5 Stephen Macke , Hongpu Gong , Doris Jung - Lin Lee , Andrew Head , Doris Xin , and Aditya Parameswaran not necessarily be fresh . Instead , fresh cells can be thought of as re - solving staleness in cell output , as opposed to resolving staleness in some symbol . We study such staleness - resolving cells next . Cells that Resolve Staleness . We have already seen how liveness checking can help users to identify stale cells . Ideally , we should also identify cells whose execution would “freshen” the stale variables that are live in some cell 𝑐 , thereby allowing 𝑐 to be executed without po - tential errors due to staleness . We thus define refresher cells as follows : Definition 10 [ Refresher cells ] . A non - stale cell 𝑐 𝑟 is called refresher if there exists some other stale cell 𝑐 𝑠 such that STALE ( 𝑐 𝑠 ) − STALE ( 𝑐 𝑟 ⊕ 𝑐 𝑠 ) ≠ ∅ where 𝑐 𝑟 ⊕ 𝑐 𝑠 denotes the concatenation of cells 𝑐 𝑟 and 𝑐 𝑠 . That is , the result of merging 𝑐 𝑟 and 𝑐 𝑠 together has fewer live stale symbol references than does 𝑐 𝑠 alone . Intuitively , ifweweretosubmitarefreshercellforexecution , wewould reduce the number of stale symbols live in some other cell ( possibly to 0 ) . Note that a refresher cell may or may not be fresh . In addition to identifying stale and fresh cells , a final major contri - bution of nbsafety is the efficient identification of refresher cells . We will see in Section 5 that scalable computation of such cells requires initialized analysis to compute dead symbols , which we describe in detail next . 4 . 3 Initialized Variable Analysis Recall that we use liveness analysis to find “live” symbols whose values at the start of each cell contribute to the computation performed in the cell , and we use inverse liveness to find “dead” symbols whose values at the end of the each will have definitely been overwritten by the time control reaches the end of the cell . A working knowledge of traditional liveness analysis is a prerequisite for for understanding our inverse liveness technique ; we refer the reader to , e . g . , Aho et al . [ 2 ] for any review necessary . Dataflow Equations . Inverse liveness is a fixed - point method for solving the following set of dataflow equations : DEAD 𝑜𝑢𝑡 [ 𝑠 ] = (cid:0) DEF [ 𝑠 ] − USE [ 𝑠 ] (cid:1) ∪ DEAD 𝑖𝑛 [ 𝑠 ] DEAD 𝑖𝑛 [ 𝑠 ] = (cid:217) 𝑠 (cid:48) ∈ predecessors of 𝑠 DEAD 𝑜𝑢𝑡 [ 𝑠 (cid:48) ] That is , a symbol is dead in statement 𝑠 ( i ) if it is defined as a function , ( ii ) if it appears on the left hand side of an assignment ( but not the right hand side ) , or ( iii ) if it is dead in all predecessor statements in the control flow graph . Intuition . Traditional liveness analysis initializes each statement at the minimum point of a lattice ( i . e . , the empty set ) . Each statement’s set of used symbols ( USE [ 𝑠 ] ) are then iteratively propagated in the reverse direction of control until a fixed point is reached , thereby solving the following set of dataflow equations : LIVE 𝑖𝑛 [ 𝑠 ] = USE [ 𝑠 ] ∪ ( LIVE 𝑜𝑢𝑡 [ 𝑠 ] − DEF [ 𝑠 ] ) LIVE 𝑜𝑢𝑡 [ 𝑠 ] = (cid:216) 𝑠 (cid:48) ∈ successors of 𝑠 LIVE 𝑖𝑛 [ 𝑠 (cid:48) ] If the live variables propagated during liveness checking can be thought of as electrons , then the dead variables propagated during inverse liveness can be thought of as “holes” , using a metaphor from electronics . Nearly every decision made over the course of inverse liveness analysis is the “inverse” of decisions made during liveness analysis . For example , in inverse liveness , each statement’s set of dead symbols is initialized to everything ( i . e . , at lattice maximum ) , and in - verse liveness uses set intersection ( ∩ ) as the lattice meet operator instead of set union ( ∪ ) when propagating dead variables between statements , since symbols can be dead at cell bottom only if they are overwritten in every branch of control . Comparing Liveness and Inverse Liveness . A pseudocode descrip - tion of our inverse liveness checker is given in Algorithm 2 . We also give a description of a textbook liveness checker to the left in Algo - rithm 1 for contrast . In particular , we note that the two algorithms are nearly identical excepting a few key differences : • On line 3 , DEAD 𝑜𝑢𝑡 is initialized to every symbol , instead of ∅ ; • Online12ofAlgorithm2 , wetaketheintersectionofoutgoingdead symbols in predecessor nodes , instead of the union of incoming live symbols in successor nodes as in Algorithm 1 ; • On line 13 of Algorithm 2 , we compute outgoing dead symbols as theunionofsymbolskilledinthecurrentnodewithincomingdeadsymbols , whereas Algorithm 1 computes incoming live symbols as the union of symbols used in the current node with non - killed outgoing live symbols ; • The dataflows is from top to bottom in Algorithm 2 , while it is from bottom to top in Algorithm 1 . ThesedifferencesunderscoretheroleAlgorithm2playsasaninversionoflivenessanalysis . 4 . 4 Resolving Live Symbols In many cases , it is possible to determine the set of live symbols in a cell with high precision purely via static analysis . In some cases , however , it is difficult to do so without awareness of additional runtime data . To illustrate , consider the example below : x = 0 def f ( y ) : return x + y lst = [ f , lambda t : t + 1 ] [ 1 ] print ( lst [ 1 ] ( 2 ) ) [ 2 ] Whether or not symbol x should be considered live at the top of the second cell depends on whether the call to lst [ 1 ] ( 2 ) refers to the list entry containing the lambda , or the entry containing function f . In this case , a static analyzer might be able to infer that lst [ 1 ] does not reference f and that x should therefore not be considered live at the top of cell 2 ( since there is no call to function f , in whose body x is live ) , but doing so in general is challenging due to Rice’s theorem . Instead of doing so purely statically , nbsafety performs an extra resolution step , since it can actually examine the runtime value of lst [ 1 ] in memory . This allows nbsafety to be more precise about live symbols than a conservative approach would be , which would be forced to consider x as live even though f is not referenced by lst [ 1 ] . 5 . CELL HIGHLIGHTS In this section , we describe how to combine the lineage metadata fromSection3withtheoutputof nbsafety’sstaticcheckertohighlight cells of interest . 5 . 1 Highlight Abstraction We begin by defining the notion of cell highlights in the abstract before discussing concrete examples , how they are presented , and how they are computed . Definition 11 [ Cell highlights ] . Given a notebook 𝑁 abstractly defined as an ordered set of cells { 𝑐 𝑖 } , a set of cell highlights H is a subset of 𝑁 comprised of cells that are semantically related in some way at a particular point in time . More concretely , we will consider the following cell highlights : • H 𝑠 , the set of stale cells in a notebook ; • H 𝑓 , the set of fresh cells in a notebook ; and • H 𝑟 , the set of refresher cells in a notebook . Note that these sets of cell highlights are all implicitly indexed by their containing notebook’s execution counter . When not clear from con - text we write H ( 𝑡 ) 𝑠 , H ( 𝑡 ) 𝑓 , and H ( 𝑡 ) 𝑟 ( respectively ) to make the time 6 Fine - Grained Lineage for Safer Notebook Interactions Algorithm 3 : Computing refresher cells naïvely Input : Notebook 𝑁 , stale cells H 𝑠 ⊆ 𝑁 Output : Refresher cells H 𝑟 1 H 𝑟 ←∅ ; 2 foreach 𝑐 𝑠 ∈H 𝑠 do 3 STALE ( 𝑐 𝑠 ) ← live , stale symbols in 𝑐 𝑠 ; 4 foreach 𝑐 𝑟 ∈ 𝑁 −H 𝑠 do 5 STALE ( 𝑐 𝑟 ⊕ 𝑐 𝑠 ) ← live , stale symbols in 𝑐 𝑟 ⊕ 𝑐 𝑠 ; 6 if STALE ( 𝑐 𝑠 ) − STALE ( 𝑐 𝑟 ⊕ 𝑐 𝑠 ) ≠ ∅ then 7 H 𝑟 ←H 𝑟 ∪ { 𝑐 𝑟 } ; 8 end 9 end 10 end 11 return H 𝑟 ; Algorithm 4 : Computing refresher cells efficiently Input : Notebook 𝑁 , stale cells H 𝑠 ⊆ 𝑁 , stale and live symbols STALE ( 𝑐 𝑠 ) , ∀ 𝑐 𝑠 ∈H 𝑠 , dead symbols DEAD ( 𝑐 𝑟 ) , ∀ 𝑐 𝑟 ∈ 𝑁 −H 𝑠 Output : Refresher cells H 𝑟 ⊆ 𝑁 1 DEAD − 1 [ 𝑠 ] ←∅ , ∀ 𝑠 ∈ DEAD ( 𝑐 𝑟 ) , ∀ 𝑐 𝑟 ∈ 𝑁 −H 𝑠 ; 2 foreach 𝑐 𝑟 ∈ 𝑁 −H 𝑠 do 3 foreach s ∈ DEAD ( 𝑐 𝑟 ) do 4 DEAD − 1 [ 𝑠 ] ← DEAD − 1 [ 𝑠 ] ∪ { 𝑐 𝑟 } ; 5 end 6 end 7 H 𝑟 ←∅ ; 8 foreach 𝑐 𝑠 ∈H 𝑠 do 9 foreach 𝑠 ∈ STALE ( 𝑐 𝑠 ) do 10 H 𝑟 ←H 𝑟 ∪ DEAD − 1 [ 𝑠 ] ; 11 end 12 end 13 return H 𝑟 ; dependency explicit . Along these lines , we are also interested in the following “delta” cell highlights : • Δ H ( 𝑡 ) 𝑓 = H ( 𝑡 ) 𝑓 −H ( 𝑡 − 1 ) 𝑓 ( new fresh cells ) ; and • Δ H ( 𝑡 ) 𝑟 = H ( 𝑡 ) 𝑟 −H ( 𝑡 − 1 ) 𝑟 ( new refresher cells ) again omitting superscripts when clear from context . Interface . We have already seen from the example in Figure 3 that stale cells are given staleness warnings to the left of the cell , and refresher cells are given cleanup suggestions to the left of the cell . The current version of nbsafety as of this writing ( 0 . 0 . 49 ) also aug - ments fresh cells with cleanup suggestions of the same color as that used for refresher cells . Overall , the fresh and refresher highlights are intended to steer users toward cells that they may wish to re - execute , and the stale highlights are intended to steer users away from cells that they may wish to avoid , intuitions that we validate in our empirical study ( § 6 ) . Experimenting with presentation techniques for the various sets H ∗ is an interesting avenue that we leave to future work . Computation . Computing H 𝑠 and H 𝑓 is straightforward : for each cell 𝑐 , we simply run a liveness checker ( Algorithm 1 ) to determine LIVE ( 𝑐 ) , and then perform a metadata lookup for each symbol s ∈ LIVE ( 𝑐 ) to determine whether s is fresh w . r . t . 𝑐 or stale . The manner in which nbsafety computes refresher cells deserves a more thorough treatment that we consider next . 5 . 2 Computing Refresher Cells Efficiently Beforewediscusshownbsafetyusestheinitializedvariablechecker from Section 4 to efficiently compute refresher cells , consider how one might design an algorithm to compute refresher cells directly from Definition 10 . The straightforward way is to loop over all non - stale cells 𝑐 𝑟 ∈ 𝑁 −H 𝑠 and compare whether STALE ( 𝑐 𝑟 ⊕ 𝑐 𝑠 ) is smaller than STALE ( 𝑐 𝑠 ) . In the case that H 𝑠 and 𝑁 −H 𝑠 are similar in size , this requires performing O (cid:0) | 𝑁 | 2 (cid:1) liveness analyses , which would create unacceptable latency in the case of large notebooks . This inefficient approach is depicted in Algorithm 3 . By leveraging an initialized variable checker , it turns out that we can check whether STALE ( 𝑐 𝑠 ) and DEAD ( 𝑐 𝑟 ) have any overlap instead of performing liveness analysis over 𝑐 𝑟 ⊕ 𝑐 𝑠 and checking whether STALE ( 𝑐 𝑟 ⊕ 𝑐 𝑠 ) shrinks . We state this formally as follows : Theorem 1 . Let 𝑁 be a notebook , and let 𝑐 𝑠 ∈H 𝑠 ⊆ 𝑁 . For any other 𝑐 𝑟 ∈ 𝑁 −H 𝑠 , the following equality holds : STALE ( 𝑐 𝑠 ) − STALE ( 𝑐 𝑟 ⊕ 𝑐 𝑠 ) = DEAD ( 𝑐 𝑟 ) ∩ STALE ( 𝑐 𝑠 ) Proof . We show each side of the equality is a subset of the other side . First , suppose some stale symbol x is live in 𝑐 𝑠 but not in 𝑐 𝑟 ⊕ 𝑐 𝑠 . Then , at the point where control transfers from 𝑐 𝑟 to 𝑐 𝑠 in the outermost scope , every path of execution will definitely have redefined x . 2 Oth - erwise , there would exist a path in 𝑐 𝑟 wherein x is not redefined , and because x is live at the top of 𝑐 𝑠 , it would also be live at the top of 𝑐 𝑟 ⊕ 𝑐 𝑠 . As such , x ∈ DEAD ( 𝑐 𝑟 ) by definition . Furthermore , x ∈ STALE ( 𝑐 𝑠 ) by our initial assumption , so x ∈ DEAD ( 𝑐 𝑟 ) ∩ STALE ( 𝑐 𝑠 ) . Conversely , suppose some stale symbol x is live in 𝑐 𝑠 but dead in 𝑐 𝑟 . By definition , every path of execution in 𝑐 𝑟 redefines x . We would like to say that x is not live in 𝑐 𝑟 ⊕ 𝑐 𝑠 , but deadness in 𝑐 𝑟 does not preclude liveness in 𝑐 𝑟 ( if , e . g . , x is used in some path of 𝑐 𝑟 before it is redefined later ) . Thus , it is only true that x is not live if 𝑐 𝑟 ⊕ 𝑐 𝑠 if it is also not live in 𝑐 𝑟 . In fact , x is not live in 𝑐 𝑟 because 𝑐 𝑟 ∉ H 𝑠 ; i . e . , 𝑐 𝑟 has no live stale symbols by assumption , and x is stale ; thus x is both live in 𝑐 𝑠 and not live in 𝑐 𝑟 ⊕ 𝑐 𝑠 ; i . e . , x ∈ STALE ( 𝑐 𝑠 ) − STALE ( 𝑐 𝑟 ⊕ 𝑐 𝑠 ) , which is what we needed to show to complete the proof . Theorem 1 relies crucially on the fact that the CFG of the concatena - tion of two cells 𝑐 𝑟 and 𝑐 𝑠 into 𝑐 𝑟 ⊕ 𝑐 𝑠 will have a “choke point” at the position where control transfers from 𝑐 𝑟 into 𝑐 𝑠 , so that any symbols in DEAD ( 𝑐 𝑟 ) cannot be “revived” in 𝑐 𝑟 ⊕ 𝑐 𝑠 . Computing H 𝑟 Efficiently . Contrasted with taking O (cid:0) | 𝑁 | 2 (cid:1) pairs 𝑐 𝑠 ∈ H 𝑠 , 𝑐 𝑟 ∈ 𝑁 −H 𝑠 and checking liveness on each concatenation 𝑐 𝑟 ⊕ 𝑐 𝑠 , Theorem 1 instead allows us compute the set H 𝑟 as (cid:216) 𝑐 𝑠 ∈H 𝑠 (cid:216) s ∈ STALE ( 𝑐 𝑠 ) (cid:8) 𝑐 𝑟 ∈ 𝑁 −H 𝑠 : s ∈ DEAD ( 𝑐 𝑟 ) (cid:9) ( 1 ) Equation1canbecomputedefficientlyaccordingtoAlgorithm4 , which creates an inverted index that maps dead symbols to their contain - ing cells ( DEAD − 1 ) in order to efficiently compute the inner set union . Furthermore , Algorithm 4 only requires O ( | 𝑁 | ) liveness analyses and O ( | 𝑁 | ) initialized variable analyses as preprocessing , translating to significant latency reductions in our benchmarks ( § 6 . 4 ) . 6 . EMPIRICAL STUDY We now evaluate nbsafety’s ability to highlight unsafe cells , as well ascellsthatresolvesafetyissues ( refreshercells ) . Wedosobyreplaying 666 real notebook sessions and measuring how the cells highlighted by nbsafety correlate with real user actions . After describing data collec - tion ( § 6 . 1 ) andourevaluationmetrics ( § 6 . 2 ) , wepresentourquantitative results ( § 6 . 3 and § 6 . 4 ) , followed by a qualitative comparison with other systems informed by real examples from our data ( § 6 . 5 and § 6 . 6 ) . 6 . 1 Notebook Session Replay Data We now describe our data collection and session replay efforts . Data Scraping . The . ipynb json format contains a static snapshot of the code present in a computational notebook and lacks explicit inter - action data , such as how the code present in a cell evolves , which cells are re - executed , and the order in which cells were executed . 3 Fortu - nately , Jupyter’s IPython kernel implements a history mechanism that 2 Note that there is no way for control to transfer from 𝑐 𝑟 to 𝑐 𝑠 in the outermost scope except at the point where 𝑐 𝑟 and 𝑐 𝑠 meet lexically ( technically , 𝑐 𝑟 could call a function defined in 𝑐 𝑠 , but if this were to occur , control would not be at the outermost scope ) . 3 The cell counter in a . ipynb file only contains the latest executed cell version for each cell , and says nothing about how executions of earlier iterations of the cell are ordered w . r . t . others . 7 Stephen Macke , Hongpu Gong , Doris Jung - Lin Lee , Andrew Head , Doris Xin , and Aditya Parameswaran includes information about individual cell executions in each session , including the source code and execution counter for every cell exe - cution . We thus scraped history . sqlite files from 712 repositories files using GitHub’s API [ 15 ] , from which we successfully extracted 657 such files . In total , these history files contained execution logs for ≈ 51000 notebook sessions , out of which we were able to collect metrics for 666 after conducting the filter and repair steps described next . Notebook Session Repair . Many of the notebook sessions were im - possible to replay with perfect replication of the session’s original behavior ( due to , e . g . , missing files ) . To cope , we adapted ideas from Yan et al . [ 47 ] to repair sessions wherever possible . Specifically , we took the following measures : • Since nbsafety runs on Python 3 , we used the 2to3 tool [ 1 ] when - ever we encountered Python 2 code . • To deal with differing APIs used by different versions of the same library ( e . g . , scikit - learn ) , we first gathered all the import state - ments for each library and tried to execute them under different versions of the aforementioned library , using the version that min - imized import errors to finally replay the session . • We normalized all path - like strings to point to the same directory , to prevent invalid accesses to nonexistent directories . • We used the Kaggle API to search for and attempt to download any csv files referenced by each session . • We removed any lines or cells that attempted to run system com - mands through Jupyter’s line ( resp . cell ) magic functionality . • We executed the line magic % matplotlib inline before replay - ing a session to avoid rendering matplotlib charts with Qt . SessionFiltering . Despitetheseefforts , wewereunabletoreconstruct some sessions to their original fidelity due to various environment dis - crepancies . Furthermore , certain sessions had few cell executions and appeared to be random tinkering . We therefore filtered out sessions fitting any of the following criteria : • Sessions with fewer than 50 cell executions ; • Sessions that attempted to run shell commands ; • Sessions that solicited user input via readline or other means ; • Sessions that attempted to connect to external services ( e . g . AWS , Spark , Postgres , MySQL , etc . ) ; • Sessions that attempted to read nonexistent files ( or those that could not be found using the Kaggle API ) . After these steps , we were left with 2566 replayable sessions . However , we were unable to gather meaningful metrics on more than half of the sessions we replayed because of exceptions thrown upon many cell ex - ecutions . We filtered these in post - processing by removing data for any session with more than 50 % of cell executions resulting in exceptions . Afterthe repairand filtrationsteps , weextracted metricsfrom atotal of 666 sessions . Our repair , filtering , and replay scripts are available on GitHub [ 30 ] . Environment . All experiments were conducted on a 2019 MacBook Pro with 32 GiB RAM and a Core i9 processor running macOS 10 . 14 . 5 , Python 3 . 7 , and nbsafety 0 . 0 . 49 . We replayed notebook sessions in a container instance to ensure our local files would not be compromised in the event of intentionally or unintentionally malicious code present in the sessions we scraped . 6 . 2 Metrics Besidesconductingbenchmarkexperimentstomeasureoverheadas - sociated with nbsafety ( § 6 . 4 ) , the primary goal of our empirical study istoevaluateoursystemandinterfacedesignchoicesfromtheprevioussectionsbytestingtwohypotheses . Our first hypothesis ( i ) is that cells with staleness issues highlighted by nbsafety are likely to be avoided by real users , suggesting that these cells are indeed unsafe to execute . Our second hypothesis ( ii ) is that fresh and refresher cells highlighted by nbsafety are more likely to be selected for re - execution , indicating that these suggestions can help reduce cognitive overhead for users trying to choose which cells to re - execute . To test these hypotheses , we introduce the notion of predictive power for cell highlights . 0 20 40 60 80 Num safety errors 10 0 10 1 10 2 C O U N T ( ∗ ) Figure 5 : Histogram showing distribution of safety errors across sessions . Definition 12 [ Predictive Power ] . Given a notebook 𝑁 with a total of | 𝑁 | cells , the id of the next cell executed 𝑐 , and a non - empty set of cell highlights H ( chosen before 𝑐 is known ) , the predictive power of H is defined as P ( H ) = I { 𝑐 ∈H } · | 𝑁 | / | H | . Averaged over many measurements , predictive power assesses how many more times more likely a cell from some set of highlights H is to be picked for re - execution , compared to random cells . Intuition . To understand predictive power , consider a set of highlights H chosen uniformly randomly without replacement from the entire set of available cells . In this case , E [ I { 𝑐 ∈H } ] = P ( 𝑐 ∈H ) = | H | / | 𝑁 | so that the predictive power of H is ( | H | / | 𝑁 | ) · ( | 𝑁 | / | H | ) = 1 . This holds for any number of cells in the set of highlights H , even when | H | = | 𝑁 | . Increasing the size of H increases the chance for a nonzero predictive power , but it also decreases the “payout” when 𝑐 ∈H . For a fixed notebook 𝑁 , the maximum possible predictive power for H occurs when H = { 𝑐 } , in which case P ( H ) = | 𝑁 | . Rationale . Our goal in introducing predictive power is not to give a metric that we then attempt to optimize ; rather , we merely want to see how different sets of cell highlights correlate with real user behavior . In some sense , any P ( H ) ≠ 1 is interesting : P ( H ) < 1 indicates that users tend to avoid H , and P ( H ) > 1 indicates that users tend to prefer H . For the different sets of cell highlights { H ∗ } introduced in Section 5 , each P ( H ∗ ) helps us to make this determination . Gathering measurements . The session interaction data available in the scraped history files only contains the submitted cell contents for each cell execution , and unfortunately lacks cell identifiers . Therefore , we attempted to infer the cell identifier as follows : for each cell execu - tion , if the cell contents were ≥ 80 % similar to a previously submitted cell ( by Levenshtein similarity ) , we assigned the identifier of that cell ; otherwise , we assigned a new identifier . Whenever we inferred that an existing cell was potentially edited and re - executed , we measured predictive power for various highlights H ∗ when such highlights were non - empty . Across the various highlights , we computed the average of such predictive powers for each sessions , and the averaged the average predictive powers across all sessions , reporting the result as AVG ( P ( H ∗ ) ) for each H ∗ ( § 6 . 3 ) . Highlights of Interest . We gathered metrics for H 𝑠 , H 𝑓 , Δ H 𝑓 , H 𝑟 , and Δ H 𝑟 , which we described earlier in Section 5 . Additionally , we also gathered metrics for the following “baseline highlights” : • H 𝑛 , or the next cell highlight , which contains only the 𝑘 + 1 cell ( when applicable ) if cell 𝑘 was the previous cell executed ; and • H rnd , or the random cell highlight , which simply picks a random cell from the list of existing cells . We take measurements for H 𝑛 because picking the next cell in a note - book is a common choice , and it is interesting to see how its predictive power compares with cells highlighted by the nbsafety frontend such as H 𝑓 and H 𝑟 . We also take measurements for H rnd to validate via MonteCarlosimulationtheclaimthatrandomcells H rnd shouldsatisfy P ( H rnd ) = 1 in expectation . 6 . 3 Predictive Power Results In this section , we present the results of our empirical evaluation . Overall , nbsafety discovered that 117 sessions out of the 666 encountered 8 Fine - Grained Lineage for Safer Notebook Interactions H 𝑠 H rnd H 𝑛 H 𝑓 H 𝑟 Δ H 𝑟 Δ H 𝑓 Highlight set 0 . 0 2 . 5 5 . 0 7 . 5 10 . 0 M e a n P r e d i c t i v e P o w e r Numsafetyerrors 0 > 0 Figure 6 : Comparing AVG ( P ( H ∗ ) ) for sessions with / without safety issues . Quantity H 𝑛 H rnd H 𝑠 H 𝑓 H 𝑟 Δ H 𝑓 Δ H 𝑟 AVG ( P ( H ∗ ) ) 2 . 64 1 . 02 0 . 30 2 . 83 3 . 90 9 . 17 6 . 20 AVG ( | H ∗ | ) 1 . 00 1 . 00 2 . 71 3 . 73 2 . 31 1 . 73 1 . 81 Table 2 : Summary of measurements taken for various highlight sets . staleness issues at some point , underscoring the very real need for a tool to prevent such errors . Furthermore , we found that the “positive” highlights like H 𝑓 and H 𝑟 correlated strongly with user choices . Predictive Power for Various Highlights . We now discuss average P ( H ∗ ) for the various H ∗ we consider , summarized in Table 2 . Summary . Out of the highlights H ∗ with P ( H ∗ ) > 1 , new fresh cells , Δ H 𝑓 , had the highest predictive power , while H 𝑛 had the lowest ( excepting H rnd , which had P ( H rnd ) ≈ 1 as expected ) . H 𝑠 had the lowest predictive power coming in at P ( H 𝑠 ) ≈ 0 . 30 , suggesting that users do , in fact , avoid stale cells . We measured the average value of P ( H 𝑠 ) at roughly 0 . 30 , which is the lowest mean predictive power measured out of any highlights . One way to interpret this is that users were more then 3 × less likely to re - execute stale cells than they are to re - execute randomly selected highlights of the same size as H 𝑠 — strongly supporting the hypothesis that users tend to avoid stale cells . On the other hand , all of the highlights H 𝑛 , H 𝑓 , H 𝑟 , Δ H 𝑓 , and Δ H 𝑟 satisfied P ( H ∗ ) > 1 on average , with P ( Δ H 𝑓 ) larger than the others at 9 . 17 , suggesting that users are more than 9 × more likely to select newly fresh cells to re - execute than they are to re - execute randomly selected highlights of the same size as Δ H 𝑓 . In fact , H 𝑛 was the lowest non - random set of highlights with mean predictive power > 1 , strongly supporting our design decision of specifically guiding users to all the cells from H 𝑓 and H 𝑟 ( and therefore to Δ H 𝑓 and Δ H 𝑟 as well ) with our aforementioned visual cues . Furthermore , we found that no | H ∗ | was larger than 4 on average , suggesting that these cues are useful , and not overwhelming . Finally , given the larger predictive powers of Δ H 𝑓 and Δ H 𝑟 , we plan to study interfaces that present these highlights separately from H 𝑓 and H 𝑟 in future work . EffectofSafetyIssuesonPredictivePower . Ofthe666sessionswe replayed , we detected 1 or more safety issues ( due to the user executing a stale cell ) in 117 , while the majority ( 549 ) did not have safety issues . A histogram depicting the distribution of “ # safety issues” is given in Figure 5 . We reveal interesting behavior by computing AVG ( P ( H ∗ ) ) when restricted to ( a ) sessions without safety errors , and ( b ) sessions with 1 or more safety errors , depicted in Figure 6 . Summary . For sessions with safety errors , users were more likely to select the next cell ( H 𝑛 ) , and less likely to select fresh or refresher cells ( H 𝑓 and H 𝑟 , respectively ) . Figure 6 plots AVG ( P ( H ∗ ) ) for various highlight sets after faceting on sessions that did and did not have safety errors . By definition , AVG ( P ( H 𝑠 ) ) = 0 for sessions without safety errors ( otherwise , users would have attempted to execute one or more stale cells ) , but even for sessions with safety errors , we still found P ( H 𝑠 ) < 1 on average , though not enough to rule out random chance . Jupyter NBSafety NBSafety ( quadraticrefresher ) Kernel 0 2000 4000 6000 L a t e n c y ( s ) Component Analysis Execution Figure 7 : Comparing latencies of execution and ( if applicable ) analysis components for different kernels . 0 50 100 150 200 Number of Cells in Session 0 100 200 S e ss i o n A n a l y s i s T i m e ( s ) Analysis Latency vs # Cells in Session nbsafety ( quadraticrefresher ) nbsafety ( initializedanalysis ) Figure 8 : Measuring the impact of cell count on analysis latency for nbsafety with and without efficient refresher computation . Approach Jupyter nbsafety nbsafety ( quadratic refresher ) Total Time ( s ) 3150 5840 9920 Median Slowdown 1 × 1 . 44 × 1 . 58 × Table 3 : Summary of latency measurements . Median slowdown measured on sessions that took longer than 5 seconds to execute in vanilla Jupyter . Interestingly , we found that AVG ( P ( H 𝑛 ) ) was significantly higher for sessions with safety issues , suggesting that users were more likely to execute the next cell without much thought . Finally , we found that users were significantly less likely to choose cells from H 𝑓 , H 𝑟 , or Δ H 𝑟 for sessions with safety errors . In fact , users favored H 𝑛 over H 𝑟 or H 𝑓 in this case . Regardless of whether sessions had safety issues , however , Δ H 𝑓 and Δ H 𝑟 still had the highest mean predictive powers out of any of the highlights , with AVG ( P ( Δ H 𝑓 ) ) relatively unaffected by safety issues . 6 . 4 Benchmark Results Our benchmarks are designed to assess the additional overhead incurred by our tracer and checker by measuring the end - to - end ex - ecution latency for the aforementioned 666 sessions , with and without nbsafety . Furthermore , weassesstheimpactofourinitializedanalysis approach to computing refresher cells ( Algorithm 4 ) by comparing it with the naïve quadratic baseline ( Algorithm 3 ) . Overall Execution Time . We summarize the time needed for various methods to replay the 666 sessions in our execution logs in Table 3 , and furthermore faceted on the static analysis and tracing / execution com - ponentsinFigure7 . WemeasuredlatenciesforbothvanillaJupyterand nbsafety , as well as for an ablation that replaces the efficient refresher computation algorithm with the quadratic variant ( Algorithm 3 ) . Summary . The additional overhead introduced by nbsafety is within the same order - of - magnitude as vanilla Jupyter , taking less than 2 × longer to replay all 666 sessions , with typical slowdowns less than 1 . 5 × . Without initialized analysis for refresher computation , however , total reply time increased to more than 3 × the time taken by the vanilla Jupyter kernel . Furthermore , we see from Figure 7 that refresher computation begins to dominate with the quadratic variant , while it remains relatively minor for the linear variant based on initialized analysis . Although nbsafety’s tracer introduces some additional overhead compared to the vanilla Jupyter kernel , we note that this overhead is 9 Stephen Macke , Hongpu Gong , Doris Jung - Lin Lee , Andrew Head , Doris Xin , and Aditya Parameswaran System Datalore Nodebook Dataflow nbsafety Auto infers symbol lineage (cid:51) (cid:51) (cid:55) (cid:51) Composes with nbsafety (cid:55) (cid:55) (cid:51) N / A Auto resolves staleness (cid:51) (cid:51) (cid:51) ∗ optionally (cid:31) always does so correctly (cid:51) (cid:55) (cid:51) ∗ N / A ‡ Preserves Jupyter semantics (cid:55) (cid:55) (cid:51) † (cid:51) No crashing on valid Python (cid:55) (cid:55) (cid:51) (cid:51) No other performance penalty (cid:55) (cid:55) (cid:51) (cid:55) ( minor ) Table 4 : Summary of key distinguishing properties of notebook systems that help prevent stale executions . ∗ Only for manually specified dependencies . † Except for manually specified dependencies . ‡ nbsafety can display the run - plan and allow manual corrections if needed . relatively minor ( less than 1 . 5 × ) , and that a less - optimized tracing im - plementation would have performed far worse . For example , suppose lst contains one million elements , and we materialize the output of a map operation , e . g . lst = list ( lst . map ( f ) ) . Using Python’s trac - ing mechanism directly , this would produce at least one million call and return events , leading to overhead in excess of 10 × . nbsafety is smart enough to disable tracing if the same program statement is encountered twice during a given execution , so that this statement executes just as in vanilla Jupyter , while still detecting that symbol lst should be given f as a dependency . Impact of Number of Cells on Analysis Latency . To better illus - trate the benefit of using initialized analysis for efficient computation of refresher cells , we measured the latency of just nbsafety’s analysis component , and for each session , we plotted this time versus the total number of cells created in the session , in Figure 8 . Summary . Whilequadraticrefreshercomputationisacceptablefor sessions with relatively few cells , we observe unacceptable per - cell latencies for larger notebooks with more than 50 or so cells . The linear variant that leverages initialized analysis , however , scales gracefully even for the largest notebooks in our execution logs . The variance in Figure 8 for notebooks of the same size can be attributed to cells with different amounts of code , as well as different numbers of cell executions ( since the size of the notebook is merely a lower bound for the aforementioned according to our replay strategy ) . 6 . 5 Comparison with Other Systems We now give a qualitative comparison of nbsafety with other systems that attempt to resolve staleness issues , viewed through the lens of the data we collected in our empirical study . After surveying relevant literature and open source software repositories , we are aware of three such systems : Dataflow notebooks [ 28 ] , Nodebook [ 50 ] , and the Datalore kernel from JetBrains [ 10 ] . The most salient distinctions for each approach are summarized in Table 4 . We now provide a summary for each system . Dataflow Notebooks . While Dataflow notebooks have many desirable properties , they require the user to specify dependencies manually in order to leverage any staleness - resolving functionality . Dataflow notebooks can be used in conjunction with nbsafety if reactive cell execution via manually - specified dependencies is desired . Datalore and Nodebook . Both the Datalore kernel and Nodebook seem to take take a hybrid analysis / memoization approach toward au - tomatic staleness resolution : each cell serializes the variables that it assigns , and if a cell 𝑐 is rerun , a liveness checker determines what symbols need to be deserialized ( using versions computed by cells that appear in 𝑐 spatially ) and used as “inputs” to 𝑐 , possibly rerunning cells prior to 𝑐 if they were edited or if they depend on an edited cell . For example , in Figure 2 , the second cell would be automatically rerun if the user attempts to rerun the third cell after rerunning the first . These approaches allow notebooks to emulate script - like top - to - bottom behavior , but serialization can come at significant cost for objects like large dataframes , and furthermore , not all objects are se - rializable , thereby rendering these approaches viable only on a much smaller set of programs , as we will see . Finally , because liveness gives a conservative overestimation of symbols used , these approaches may perform more work than necessary to rerun prior edited cells , or to deserialize possibly - needed symbols . Ability to run valid Python . Perhaps the most serious shortcoming of memoization - based approaches stems from their failure to execute valid Python code . Consider the following example : y = ( i + 2 for i in range ( 10 ) ) [ 1 ] print ( list ( y ) ) [ 3 ] If the user edits the first cell and then attempts to run the second cell twice using either Nodebook or the Datalore kernel , they will observe an error when these approaches try ( and fail ) to load the non - serializable object y from storage . Ability to conduct multiverse analyses . To facilitate the below dis - cussion , we define the “rerun all cells” approach adopted by Nodebook , Datalore , and Dataflow notebooks ( for manual dependencies ) to be a “forcible cascade” approach , the selective rerun approach adopted by nbsafety to be a “supervised permissive cascade” approach , and that of Jupyter to be a “manual cascade” approach . In exploratory programming and data analysis , users do not usu - ally have a clear indication of which approach might work well up - front [ 24 ] . So , they typically try various alternative approaches to achieve their end - goal , while also recording snippets of what they had tried previously , for reuse , and for returning to old alternatives [ 23 ] . The forcible cascade approach in this case has the unintended effect of having all of their downstream alternatives being executed , when the user wanted to execute precisely one . These sorts of multiverse analyeses are hindered by the forcible cas - cade approaches . In fact , we found several instances in our execution logs wherein users explicitly saved off variables to be returned to later , and where forcible cascades would have overwritten these variables’ saved values . We now give a typical example , depicted below : df = pd . read _ csv ( ' universe1 . csv ' ) [ 1 ] df = df . dropna ( ) [ [ ' col1 ' , ' col2 ' , ' col3 ' , . . . ] ] [ 2 ] df = df . rename ( { . . . } ) [ 3 ] df = df . merge ( df . grouby ( . . . ) . sum ( ) . reset _ index ( ) , on = ' col ' , how = ' left ' ) [ 4 ] # more cells . . . [ . . . ] df _ saved = df . copy ( ) [ n ] After reading the file universe1 . csv into a dataframe and per - forming some transformations , the user would then save a copy of the transformed dataframe . The user would then repeat the same transformations by changing cell 1 to read in universe2 . csv and manuallyrunningthecellsbelow , butstoppingbeforecreatingthecopy . The user then would perform some comparison between the trans - formed universe1 . csv data and the transformed universe2 . csv data . Note that a forcible cascade would have overwritten the variable df _ saved , preventing this comparison . 6 . 6 Staleness Case Study We now discuss a particularly egregious example of unsafe behav - ior in one of the 666 replayed sessions that would have been caught by nbsafety . In this session , the user was attempting to visualize a Wiener process defined by the following function : 10 Fine - Grained Lineage for Safer Notebook Interactions def wiener ( tmax , n ) : # Return one realization of a Wiener process # with n steps and a max time of tmax . times = np . linspace ( 0 , tmax , n ) difference = np . diff ( times ) process = np . random . normal ( 0 , difference * * . 5 ) process = np . cumsum ( process ) return times , process [ 1 ] The user then initially called this function and saved the output in variables t and w : t , w = wiener ( 1 . 0 , 1000 ) [ 2 ] After inspecting a few values in the array w , the user then decided to rename it from lowercase w to uppercase W : t , W = wiener ( 1 . 0 , 1000 ) [ 3 ] Next , the user used the popular visualization library Altair [ 46 ] to plot the output of the wiener function , using the following code ( and producing output similar to the figure below the cell ) : data = pd . DataFrame ( { ' time ' : t , ' W ' : w } ) alt . Chart ( data ) . mark _ line ( ) . encode ( x = ' time ' , y = ' W : Q ' ) [ 4 ] 0 . 0 0 . 2 0 . 4 0 . 6 0 . 8 1 . 0 0 . 0 0 . 5 However , note that in cell 4 , the dataframe created by the user , data , refers to the old lowercase w , and not the new uppercase W most re - cently created . Thus , when the user reran cells 3 and 4 in succession , the exact same figure as that from the original cell 4 was generated . Confused , the user then reran cells 1 , 3 , and 4 in succession , each time generating a plot identical to that from the original cell 4 . This process repeated itself around 20 times , before the user finally noticed the problem and changed cell 4 to the following : data = pd . DataFrame ( { ' time ' : t , ' W ' : W } ) alt . Chart ( data ) . mark _ line ( ) . encode ( x = ' time ' , y = ' W : Q ' ) [ 4 ] This at last generated a different plot from the output of the original cell 4 , but the entire process resulted in a large amount of wasted effort that would have been saved had the user noticed the error earlier . How nbsafety Helps . To see how nbsafety would have helped , let us examine the highlights that nbsafety would have presented after the user reran 3 and 4 , got confused , and then reran cell 1 . The state of the notebook would have then appeared similar to the following : def wiener ( tmax , n ) : # Return one realization of a Wiener process # with n steps and a max time of tmax . times = np . linspace ( 0 , tmax , n ) difference = np . diff ( times ) process = np . random . normal ( 0 , difference * * . 5 ) process = np . cumsum ( process ) return ( times , np . insert ( process , 0 , 0 ) ) [ 7 ] t , W = wiener ( 1 . 0 , 1000 ) [ 5 ] data = pd . DataFrame ( { ' time ' : t , ' W ' : w } ) alt . Chart ( data ) . mark _ line ( ) . encode ( x = ' time ' , y = ' W : Q ' ) [ 6 ] That is , cell 3 would be given a fresh cleanup suggestion highlight , because the wiener symbol was recently updated when the user reran thefirstcell ( nowlabeledas7 ) . Likewise , cell6isgivena stale highlight because lowercase w depends on the old version of wiener . Next , when the user reruns the cell labeled as 5 in the above note - book , they would expect the unsafe highlight over cell 6 to be replaced with a fresh highlight , because they refreshed the symbol W . However , this does not occur , and the unsafe highlight remains . The user could have then query nbsafety’s API to determine why , and would have been presented with the following : t , W = wiener ( 1 . 0 , 1000 ) [ 7 ] data = pd . DataFrame ( { ' time ' : t , ' W ' : w } ) alt . Chart ( data ) . mark _ line ( ) . encode ( x = ' time ' , y = ' W : Q ' ) # WARNING : (cid:96) w (cid:96) ( latest update in cell 2 ) may depend # on old version of symbol ( s ) [ (cid:96) wiener (cid:96) ] . [ 6 ] At this point , the user likely would have noticed that cell 6 does not refer to symbol W , which was updated when the user ran cell 7 , but on symbol w , which lingers in notebook state from when the user originally ran cell 2 . 7 . RELATED WORK Our work has connections to notebook systems , fine - grained data versioning and provenance , and data - centric applications of program analysis . Our notion of staleness and cell execution orders is reminis - cent of the notion of serializability . We survey each area below . Notebook Systems . Error - prone interactions with global notebook state are well - documented in industry and academic communities [ 8 , 17 , 20 , 25 , 28 , 29 , 35 , 38 , 42 , 50 ] . The idea of treating a notebook as a dataflow computation graph with interdependent cells has been stud - ied previously [ 6 , 28 , 50 ] ; however , nbsafety is the first such system to our knowledge that preserves existing any - order execution seman - tics . We already surveyed Dataflow notebooks [ 28 ] , Nodebook [ 50 ] , and Datalore’s kernel in Sections 1 and 6 . 5 . nbgather [ 20 ] takes a purely static and non - dataflow approach to automatically organize notebooks using program slicing techniques , and thereby reducing non - reproducibility and errors due to messy notebooks . However , the functionality provided by nbgather is orthogonal to nbsafety and could be used in conjunction ; for example , it does not help prevent state - related errors made before nbgather - induced reorganization . VersioningandProvenance . Theworkondataversioningandprove - nance has enjoyed a long history in the database community . Prove - nancecapturecanbeeither coarse - grained , typicallyemployedbyscien - tific workflow systems , e . g . [ 3 , 5 , 7 , 11 , 12 ] , or fine - grained provenance as in database systems [ 9 , 16 , 21 ] , typically at the level of individual rows . Withinsystemstargetedtowardindividualscientists , Burrito [ 18 ] 11 Stephen Macke , Hongpu Gong , Doris Jung - Lin Lee , Andrew Head , Doris Xin , and Aditya Parameswaran tracks file and script - level coarse - grained provenance , whereas our work falls under the fine - grained umbrella . Within systems targeting scientific workflows , Burrito [ 18 ] tracks file and script - level coarse - grained provenance , and noWorkflow [ 33 , 37 ] additionally captures finer - grained control flow dependencies , libraries , and environment variables in scripts as well as in computational notebooks [ 36 ] . These systems target post - hoc analysis of fixed parameterized scripts to un - derstand , e . g . , how changing some parameter affects the result of some experiment , but do not directly enable safer notebook interactions . In contrast , the key observation of nbsafety is that , in a notebook envi - ronment , written code is not fixed up - front and often depends on the results of previously written code in a human - in - the - loop fashion ; we therefore leverage provenance to make it easier to reason about hidden notebook state in an online fashion , providing hints and warnings to users as they go about their exploratory workflows . Additional recent work has examined challenges related to version compaction [ 4 , 22 ] and fine - grained lineage for scalable interactive visualization [ 39 ] ; our focus is on enabling safer notebook interactions . Toward this same end , Vizier [ 6 ] attempts to combine cell version - ing and data provenance into a cohesive notebook system with an intuitive interface , while warning users of caveats ( i . e . , possibly brit - tle assumptions that the analyst made about the data ) . Like Vizier , we leverage lineage to propagate information about potential errors . However , data dependencies still need to be specified using Vizier’s dataset API , while nbsafety infers them automatically using its tracer . Furthermore , in our case , the semantics of the error stem directly from the ability to execute cells out - of - order , while in Vizier , they stem from their so - called caveats . That said , nbsafety could , in principle , also propagate caveats ; incorporating an API for specifying such caveats is an interesting avenue for future work . Data - centric Program Checking . The database community has tra - ditionally leveraged program analysis to optimize database - backed ap - plications [ 14 , 19 , 40 , 48 ] , while we focus on catching bugs in an in - teractive notebook environment . One exception is SQLCheck [ 13 ] , which employs a data - aware static analyzer to detect and fix so - called antipatterns that occur during schema and query design . Our goal with nbsafety is similar in spirit , though we focus on detecting and rectifying potential errors that occur over the course of interactive notebook sessions . Within the notebook space , Vizier [ 6 ] also uses static analysis to determine whether particular queries are affected by brittle assumptions / caveats . This use case is orthogonal to our goal , which is to preserve traditional notebook semantics while re - ducing error - proneness of such interactions ; we could incorporate caveat - checking into nbsafety’s static analysis in the future ( by , e . g . , detecting liveness of symbols with attached caveats in cells ) . Parallels with Transaction Processing . There are some parallels between the notion of transactional serializability and safety . For exam - ple , ifweviewacellasatransaction , conflictsbetweentwotransactions would correspond to dependencies between cells ( either in a R / W , W / R or W / W fashion ) . Moreover , our goal in identifying stale and refresher cells is akin to conservatively identifying whether the execution order corresponds to a safe / desirable schedule in terms of the read / writes ( e . g . , whether the schedule is view equivalent to a “run from top - to - bottom schedule” ) . Such conservative mechanisms of identifying schedules that adhere to various consistency have been proposed in prior work [ 41 , 49 ] . However , the similarities largely end there : 1 . If we view a cell as a transactional boundary , reads and writes within one cell cannot be interleaved with reads and writes within another cell . Thus , the notion of serializability is itself too weak in that it allows for interleavings between transactions . 2 . Say we abandon the notion of serializability , but instead consider the notion of view equivalence of two different cell execution schedules . Here , we note that there are often multiple ways to " refresh " a stale cell , typical in multiverse analyses—corresponding to different exe - cution paths in a DAG of cell dependencies ( or lineage ) . Any one of these would be permissible from our viewpoint . On the other hand , view equivalence is a strict linear definition , unlike our DAG - based permissive definition . 3 . Finally , even in the case that there is a single path in our DAG , view equivalence ends up being overly conservative , dismissing certain valid cell execution schedules as non - equivalent , when they are indeed equivalent from an end result standpoint . To illustrate this last point , consider the following three cells : x = 0 [ 1 ] y = 5 print ( x ) [ 2 ] print ( y ) [ 3 ] In the above example , 𝑐 1 writes 𝑥 , 𝑐 2 reads 𝑥 and writes 𝑦 , and cell 𝑐 3 reads 𝑦 . Suppose the user changes the assignment in 𝑐 1 to x = 42 . If enforcing view serializability , we would highlight cell 𝑐 3 as unsafe to execute , because 𝑐 2 would need to execute before it under view serializability : 𝑐 2 reads 𝑐 1 ’s write of 𝑥 , and 𝑐 3 in turn reads 𝑐 2 ’s write of 𝑦 . However , it is easy to see in the above example that the order of re - execution between 𝑐 2 and 𝑐 3 does not matter . If , on the other hand , 𝑐 2 hadset y = x + 1 , thenitisclearthat 𝑐 2 shouldbererunbefore 𝑐 3 can be safely rerun . It is for this reason that we adopted a lineage - centric framework , wherein cells are used primarily to associate timestamps with symbols and blocks of code via their execution counters . 8 . CONCLUSION We presented nbsafety , a kernel and frontend for Jupyter that attempts to detect and correct potentially unsafe interactions in note - books , all while preserving the flexibility of familiar any - order note - book semantics . We described the implementation of nbsafety’s tracer , checker , and frontend , and how they integrate into existing notebook workflows to efficiently reduce error - proneness in notebooks . We showed how cells that nbsafety would have warned as unsafe were actively avoided , and cells that would have been suggested for re - execution were prioritized by real users on a corpus of 666 real notebook sessions . While we focused on unsafe interactions due to staleness in this paper , extending our approach to other types of unsafe interactions is a promising direction for future research . REFERENCES [ 1 ] 2to3 : Automated Python 2 to 3 code translation . https : / / docs . python . org / 3 / library / 2to3 . html . Date accessed : 2020 - 07 - 29 . 2020 . [ 2 ] AlfredVAho , RaviSethi , andJeffreyDUllman . “Compilers , principles , techniques” . In : Addison wesley 7 . 8 ( 1986 ) , p . 9 . [ 3 ] Manish Kumar Anand et al . “Exploring scientific workflow provenance using hy - bridqueriesovernesteddataandlineagegraphs” . In : ScientificandStatisticalDatabase Management . Springer . 2009 , pp . 237 – 254 . [ 4 ] Souvik Bhattacherjee et al . “Principles of dataset versioning : Exploring the recre - ation / storagetradeoff” . In : ProceedingsoftheVLDBEndowment . InternationalCon - ference on Very Large Data Bases . Vol . 8 . 12 . NIH Public Access . 2015 , p . 1346 . [ 5 ] Shawn Bowers . “Scientific workflow , provenance , and data modeling challenges and approaches” . In : Journal on Data Semantics 1 . 1 ( 2012 ) , pp . 19 – 30 . [ 6 ] Mike Brachmann et al . “Your notebook is not crumby enough , REPLace it . ” In : CIDR . 2020 . [ 7 ] PeterBunemanetal . “Archivingscientificdata” . In : ACMTransactionsonDatabase Systems ( TODS ) 29 . 1 ( 2004 ) , pp . 2 – 42 . [ 8 ] Souti Chattopadhyay et al . “What’s Wrong with Computational Notebooks ? Pain Points , Needs , and Design Opportunities” . In : Proceedings of the 2020 CHI Confer - ence on Human Factors in Computing Systems . 2020 , pp . 1 – 12 . [ 9 ] James Cheney , Laura Chiticariu , and Wang - Chiew Tan . Provenance in databases : Why , how , and where . Now Publishers Inc , 2009 . [ 10 ] Datalore . https : / / datalore . jetbrains . com / . 2018 ( accessed December 1 , 2020 ) . [ 11 ] SusanBDavidson , SarahCohenBoulakia , etal . “ProvenanceinScientificWorkflow Systems . ” In : IEEE Data Eng . Bull . 30 . 4 ( 2007 ) , pp . 44 – 50 . [ 12 ] Susan B Davidson and Juliana Freire . “Provenance and scientific workflows : chal - lenges and opportunities” . In : Proceedings of the 2008 ACM SIGMOD international conference on Management of data . ACM . 2008 , pp . 1345 – 1350 . [ 13 ] Prashanth Dintyala , Arpit Narechania , and Joy Arulraj . “SQLCheck : Automated Detection and Diagnosis of SQL Anti - Patterns” . In : Proceedings of the 2020 ACM SIGMOD International Conference on Management of Data . 2020 , pp . 2331 – 2345 . 12 Fine - Grained Lineage for Safer Notebook Interactions [ 14 ] K Venkatesh Emani et al . “Dbridge : Translating imperative code to sql” . In : Pro - ceedings of the 2017 ACM International Conference on Management of Data . 2017 , pp . 1663 – 1666 . [ 15 ] GitHub Search API . https : / / developer . github . com / v3 / search / . Date accessed : 2020 - 07 - 29 . 2020 . [ 16 ] Todd J . Green , Grigoris Karvounarakis , and Val Tannen . “Provenance Semirings” . In : Proceedings of the Twenty - sixth ACM SIGMOD - SIGACT - SIGART Symposium on Principles of Database Systems . PODS ’07 . Beijing , China : ACM , 2007 , pp . 31 – 40 . isbn : 978 - 1 - 59593 - 685 - 1 . doi : 10 . 1145 / 1265530 . 1265535 . url : http : / / doi . acm . org / 10 . 1145 / 1265530 . 1265535 . [ 17 ] Joel Grus . I Don’t Like Notebooks ( JupyterCon 2018 Talk ) . https : / / t . ly / Wt3S . 2018 ( accessed June 26 , 2020 ) . [ 18 ] PhilipJGuoandMargoISeltzer . “Burrito : Wrappingyourlabnotebookincompu - tational infrastructure” . In : ( 2012 ) . [ 19 ] Surabhi Gupta , Sanket Purandare , and Karthik Ramachandra . “Aggify : Lifting the CurseofCursorLoopsusingCustomAggregates” . In : Proceedingsofthe2020ACM SIGMOD International Conference on Management of Data . 2020 , pp . 559 – 573 . [ 20 ] Andrew Head et al . “Managing messes in computational notebooks” . In : Proceed - ings of the 2019 CHI Conference on Human Factors in Computing Systems . 2019 , pp . 1 – 12 . [ 21 ] Melanie Herschel et al . “A survey on provenance : What for ? What form ? What from ? ” In : The VLDB Journal 26 . 6 ( 2017 ) , pp . 881 – 906 . [ 22 ] SiluHuangetal . “OrpheusDB : bolt - onversioningforrelationaldatabases ( extended version ) ” . In : The VLDB Journal 29 . 1 ( 2020 ) , pp . 509 – 538 . [ 23 ] Mary Beth Kery , Amber Horvath , and Brad A Myers . “Variolite : Supporting Ex - ploratory Programming by Data Scientists . ” In : CHI . Vol . 10 . 2017 , pp . 3025453 – 3025626 . [ 24 ] Mary Beth Kery and Brad A Myers . “Interactions for untangling messy history in a computational notebook” . In : 2018 IEEE Symposium on Visual Languages and Human - Centric Computing ( VL / HCC ) . IEEE . 2018 , pp . 147 – 155 . [ 25 ] Mary Beth Kery et al . “The story in the notebook : Exploratory data science using aliterateprogrammingtool” . In : Proceedingsofthe2018CHIConferenceonHuman Factors in Computing Systems . 2018 , pp . 1 – 11 . [ 26 ] Thomas Kluyver et al . “Jupyter Notebooks - a publishing format for reproducible computational workflows . ” In : ELPUB . 2016 , pp . 87 – 90 . [ 27 ] DonaldErvinKnuth . “Literateprogramming” . In : TheComputerJournal 27 . 2 ( 1984 ) , pp . 97 – 111 . [ 28 ] DavidKoopandJayPatel . “Dataflownotebooks : encodingandtrackingdependen - ciesofcells” . In : 9th { USENIX } WorkshopontheTheoryandPracticeofProvenance ( TaPP 2017 ) . 2017 . [ 29 ] SamLauetal . “TheDesignSpaceofComputationalNotebooks : AnAnalysisof60 Systems in Academia and Industry” . In : Proceedings of the IEEE Symposium on Vi - sual Languages and Human - Centric Computing ( VL / HCC ) . VL / HCC ’20 . Aug . 2020 . [ 30 ] Stephen Macke . NBSafety Experiments . https : / / github . com / nbsafety - project / nbsafety - experiments / . 2020 ( accessed July 29 , 2020 ) . [ 31 ] StephenMackeandHongpuGong . NBSafety . https : / / github . com / nbsafety - project / nbsafety / . 2020 ( accessed July 29 , 2020 ) . [ 32 ] Anders Møller and Michael I Schwartzbach . “Static program analysis” . In : Notes . Feb ( 2012 ) . [ 33 ] LeonardoMurtaetal . “noWorkflow : capturingandanalyzingprovenanceofscripts” . In : International Provenance and Annotation Workshop . Springer . 2014 , pp . 71 – 83 . [ 34 ] Jim Ormond . ACM Recognizes Innovators Who Have Shaped the Digital Revolution . https : / / awards . acm . org / binaries / content / assets / press - releases / 2018 / may / technical - awards - 2017 . pdf . 2018 ( accessed June 26 , 2020 ) . [ 35 ] JeffreyMPerkel . “WhyJupyterisdatascientists’computationalnotebookofchoice” . In : Nature 563 . 7732 ( 2018 ) , pp . 145 – 147 . [ 36 ] JoãoFelipeNicolaciPimenteletal . “Collectingandanalyzingprovenanceoninter - activenotebooks : whenIPythonmeetsnoWorkflow” . In : 7th { USENIX } Workshop on the Theory and Practice of Provenance ( TaPP 15 ) . 2015 . [ 37 ] Joao Felipe Pimentel et al . “noWorkflow : a tool for collecting , analyzing , and man - aging provenance from python scripts” . In : Proceedings of the VLDB Endowment 10 . 12 ( 2017 ) . [ 38 ] João Felipe Pimentel et al . “A large - scale study about quality and reproducibility of jupyter notebooks” . In : 2019 IEEE / ACM 16th International Conference on Mining Software Repositories ( MSR ) . IEEE . 2019 , pp . 507 – 517 . [ 39 ] FotisPsallidasandEugeneWu . “Smoke : Fine - grainedlineageatinteractivespeed” . In : arXiv preprint arXiv : 1801 . 07237 ( 2018 ) . [ 40 ] KarthikRamachandraetal . “Froid : Optimizationofimperativeprogramsinarela - tional database” . In : Proceedings of the VLDB Endowment 11 . 4 ( 2017 ) , pp . 432 – 444 . [ 41 ] Sudip Roy et al . “The homeostasis protocol : Avoiding transaction coordination throughprogramanalysis” . In : Proceedingsofthe2015ACMSIGMODInternational Conference on Management of Data . 2015 , pp . 1311 – 1326 . [ 42 ] Adam Rule , Aurélien Tabard , and James D Hollan . “Exploration and explanation incomputationalnotebooks” . In : Proceedingsofthe2018CHIConferenceonHuman Factors in Computing Systems . 2018 , pp . 1 – 12 . [ 43 ] Helen Shen . “Interactive notebooks : Sharing the code” . In : Nature 515 . 7525 ( 2014 ) , pp . 151 – 152 . [ 44 ] Sara Steegen et al . “Increasing transparency through a multiverse analysis” . In : Perspectives on Psychological Science 11 . 5 ( 2016 ) , pp . 702 – 712 . [ 45 ] sys : System - specific parameters and functions . https : / / docs . python . org / 2 / library / sys . html # sys . settrace . Date accessed : 2020 - 07 - 29 . 2020 . [ 46 ] Jacob VanderPlas et al . “Altair : Interactive statistical visualizations for python” . In : Journal of open source software 3 . 32 ( 2018 ) , p . 1057 . [ 47 ] CongYanandYeyeHe . “Auto - Suggest : Learning - to - RecommendDataPreparation Steps Using Data Science Notebooks” . In : Proceedings of the 2020 ACM SIGMOD International Conference on Management of Data . 2020 , pp . 1539 – 1554 . [ 48 ] Cong Yan et al . “Understanding database performance inefficiencies in real - world web applications” . In : Proceedings of the 2017 ACM on Conference on Information and Knowledge Management . 2017 , pp . 1299 – 1308 . [ 49 ] YangZhangetal . “Transactionchains : achievingserializabilitywithlowlatencyin geo - distributed storage systems” . In : Proceedings of the Twenty - Fourth ACM Sym - posium on Operating Systems Principles . 2013 , pp . 276 – 291 . [ 50 ] Kevin Zielnicki . Nodebook . https : / / multithreaded . stitchfix . com / blog / 2017 / 07 / 26 / nodebook / . 2017 ( accessed July 5 , 2020 ) . 13