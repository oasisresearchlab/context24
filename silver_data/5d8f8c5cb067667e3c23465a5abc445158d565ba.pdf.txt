A single - shot measurement of the energy of product states in a translation invariant spin chain can replace any quantum computation To cite this article : Dominik Janzing et al 2008 New J . Phys . 10 093004 View the article online for updates and enhancements . Related content Fundamentals of universality in one - way quantum computation M Van den Nest , W Dür , A Miyake et al . - Symmetry protection of measurement - based quantum computation in ground statesDominic V Else , Stephen D Bartlett and Andrew C Doherty - Quantum information processing with superconducting circuits : a review G Wendin - Recent citations Adiabatic quantum computation Tameem Albash and Daniel A . Lidar - This content was downloaded from IP address 54 . 70 . 40 . 11 on 05 / 02 / 2018 at 18 : 50 The open – access jour nal for physics New Jou rnal of Ph ys ics A single - shot measurement of the energy of product states in a translation invariant spin chain can replace any quantum computation Dominik Janzing 1 , 4 , Pawel Wocjan 2 and Shengyu Zhang 3 1 Max Planck Insitute for Biological Cybernetics , Spemannnstrasse 38 , 72076 Tübingen , Germany 2 School of Electrical Engineering and Computer Science , University of Central Florida , Orlando , FL 32816 , USA 3 Computer Science Department and Institute for Quantum Information , California Institute of Technology , Pasadena , CA 91125 , USA E - mail : dominik . janzing @ tuebingen . mpg . de , wocjan @ cs . ucf . edu and shengyu @ caltech . edu New Journal of Physics 10 ( 2008 ) 093004 ( 18pp ) Received 26 June 2008 Published 5 September 2008 Online at http : / / www . njp . org / doi : 10 . 1088 / 1367 - 2630 / 10 / 9 / 093004 Abstract . In measurement - based quantum computation , quantum algorithms are implemented via sequences of measurements . We describe a translationally invariant ﬁnite - range interaction on a one - dimensional qudit chain and prove that a single - shot measurement of the energy of an appropriate computational basis state with respect to this Hamiltonian provides the output of any quantum circuit . The required measurement accuracy scales inverse polynomially with the size of the simulated quantum circuit . This shows that the implementation of energy measurements on generic qudit chains is as hard as the realization of quantum computation . Here , a ‘measurement’ is any procedure that samples from the spectral measurement induced by the observable and the state under consideration . As opposed to measurement - based quantum computation , the post - measurement state is irrelevant . 4 Author to whom any correspondence should be addressed . New Journal of Physics 10 ( 2008 ) 093004 1367 - 2630 / 08 / 093004 + 18 $ 30 . 00 © IOP Publishing Ltd and Deutsche Physikalische Gesellschaft 2 Contents 1 . Introduction 2 2 . Deﬁning measurements and their accuracy 4 3 . Quantum computation as approximate energy measurement 5 4 . Spectral requirements on the Hamiltonian 7 5 . Construction of the Hamiltonian 12 5 . 1 . Description of our QCA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12 5 . 2 . Spectral properties . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 6 . Conclusions 16 Acknowledgments 17 References 17 1 . Introduction A characteristic feature of quantum systems is the abundance of mutually incompatible observables . According to the axioms of standard quantum mechanics [ 1 ] every self - adjoint operator on the system Hilbert space deﬁnes a physical variable that could in principle be measured ( the richness of observables even increases if one considers generalized observables , deﬁned by positive operator - valued measures [ 2 ] ) . In particular , for systems that are composed of many components it is by no means obvious how to measure an arbitrary observable given its description as a Hilbert space operator . In recent years , quantum information processing has shown how one could in principle design arbitrarily complex unitary transformations by concatenating elementary operations [ 3 ] . Given that a measurement procedure for one non - degenerate observable is available , such unitary transformations would allow us to measure every self - adjoint operator by transforming it into a function of the former . Moreover , it has been recognized that the so - called quantum phase - estimation procedure can be used to measure self - adjoint observables [ 4 ] – [ 6 ] . Insights of this kind raise the question of which types of observables are easy to measure and which ones require complex transformations to reduce them to observables for which measurement procedures are known . Even if we specify a set of elementary observables and a set of elementary unitary transformations , it is a difﬁcult task to ﬁnd lower bounds on the required control operations . The close relation to tasks of quantum information processing suggests addressing this question from a different point of view : instead of trying to ﬁnd such lower bounds ( which are also hard to get for computational problems ) one should rather try to place the question of the hardness of certain measurements in the context of complexity theory . This will be done in the present paper by showing that the implementation of certain measurements would already make it possible to solve classically hard computational problems . The computational power of quantum measurements has extensively been explored in recent years since models for quantum computations have been described that are solely based on measurements [ 7 , 8 ] . However , these models require either concatenations of measurements or the preparation of an entangled initial state [ 8 ] . In contrast , it has been shown that accurate measurements can even solve computational PSPACE - complete New Journal of Physics 10 ( 2008 ) 093004 ( http : / / www . njp . org / ) 3 problems 5 when applied to computational basis states [ 6 ] . This statement requires a high measurement accuracy allowing one to resolve the exponentially small spectral gaps that are typical for interactions in many - particle systems . Therefore , this result should be understood as exploring complexity - theoretic limitations on the measurement accuracy that can be achieved . It should not be interpreted that all ( i . e . even less accurate ) measurements of these observables are also difﬁcult . Based on the constructions in [ 6 ] , it was shown in the unpublished work [ 9 ] that one obtains the computational complexity class BQP instead of PSPACE if the required measurement accuracy is only inverse polynomial instead of exponential in the number of particles . More precisely , it was proved that a measurement instrument is a full BQP - oracle if it is able to measure the so - called k - local observables when the system is in an appropriate basis state 6 . Here and in the following , the term ‘basis state’ always refers to some element of a previously ﬁxed basis that consists of product states in the many - particle system . Here , we tighten the results of [ 9 ] in four different ways 7 . Firstly , we show that k - locality can be replaced with ﬁnite range interactions in one - dimensional chains . Secondly , we can restrict the attention to translationally invariant operators . Self - adjoint operators of this kind are closer to Hamiltonians of real physical systems . Consequently , both modiﬁcations increase the physical relevance of the result : measurements of the observable ‘energy’ , i . e . the Hamiltonian H of a system plays a central role in understanding its physics as the spectrum of the Hamiltonian determines the dynamical and thermodynamical behaviors . Thirdly , we do not need a measurement apparatus for general translationally invariant Hamiltonians . Instead , it sufﬁces in the present setting to measure just one speciﬁc observable that is universal . Fourthly , we need only a single - shot measurement instead of repeated measurements . The idea of the construction is as follows : ﬁrst of all we construct a Hamiltonian H that encodes a one - dimensional quantum cellular automaton ( QCA ) . In analogy to the constructions in [ 10 ] – [ 15 ] , the time - evolution exp ( − i Ht ) leads to superpositions between different time - steps and also between time - steps in a backward - time computation instead of implementing the computation step - by - step . Then we assume that we are given an arbitrary quantum circuit that computes the result ( YES , NO ) of a computational problem when applied to an appropriate basis state ( with respect to an a priori chosen product basis ) . Since the cellular automaton is universal for quantum computing , we can choose an initial basis state such that it simulates the quantum circuit . In other words , the program for the computation and the classical input data are encoded into the basis state . Due to our speciﬁc construction of H , the spectrum of its restriction to the smallest H - invariant subspace containing the initial state depends on the result of the simulated quantum circuit . Since we have ensured that the two spectra corresponding to the solutions YES and NO are disjoint , we obtain the answer by measuring only once . It should be emphasized that we obtain the result of the computation by applying measurements to the initial state , which is a basis state encoding program and data . The following argument describes in a metaphoric way why this is possible . We construct H in such 5 The basic idea is that every problem in PSPACE can be solved by an exponential number of applications of the same circuit ( which is polynomial both in space and time ) . After encoding the circuit into a Hamiltonian , a measurement reproduces the result of the computation . The allowed error is an appropriate inverse polynomial function of the total number of time - steps , i . e . layers of the circuit times the number of applications . 6 Note that the computational power of measurements of ‘sparse’ observables provided the underlying idea for the BQP - hardness proof of diagonal entry estimation problem in [ 16 ] . 7 We emphasize that [ 9 ] is included in this paper as a previous development , and is not to be submitted elsewhere . New Journal of Physics 10 ( 2008 ) 093004 ( http : / / www . njp . org / ) 4 a way that the computation process stops at the end of the computation whenever the output is negative . Otherwise it continues with performing a large number of idle operations . Whether or not the computation process stops is certainly relevant for the spectrum of the restriction of H to the smallest H - invariant subspace containing the initial state . We choose the number of idle steps in such a way that the spectra become mutually disjoint . Then we can check the result of the computation by a single - shot measurement of the energy applied to the initial state . 2 . Deﬁning measurements and their accuracy Our complexity theoretic results heavily rely on the deﬁnition of what it means to measure an observable with a certain accuracy . Following standard deﬁnitions in quantum mechanics [ 1 ] , we deﬁne a quantum operation to be a measurement of the observable A if its application to an arbitrary state ρ generates eigenvalues λ j of A as outcomes such that tr ( ρ Q j ) is the probability of obtaining λ j , where A = P j λ j Q j is the spectral decomposition of A . In other words , an A - measurement ( applied to the state ρ ) allows us to sample from the spectral measure induced by the operator A and the state ρ . Since the measurement accuracy is relevant for the implementation complexity ( compare [ 6 ] ) , we need a precise deﬁnition of the accuracy . Before formally introducing approximative measurements , we point out that a process generating outcomes whose expected value coincides with tr ( ρ A ) is not sufﬁcient for our purposes . To implement measurement of the latter type is certainly a much weaker assumption . Consider , for instance , a Hamiltonian H of the form H : = n X j = 1 H j , where each H j is an operator acting on k - adjacent particles only . Then we can reproduce the expected value tr ( ρ H ) = 1 n P j tr ( ρ ( n H j ) ) by choosing a value j randomly ( according to the uniform distribution ) and implementing a measurement for n H j ( requiring the ability to control only a small subsystem of the quantum system ) . Moreover , if we restrict the attention to basis states , the expected value can even be computed efﬁciently . We now deﬁne an approximative measurement : Deﬁnition 1 ( measurement accuracy ) . A measurement of the observable A is said to have maximal error δ and reliability 1 − (cid:15) if the following condition holds : the probability of obtaining an outcome λ in the interval [ a − δ , b + δ ] is at least tr ( ρ Q [ a , b ] ) ( 1 − (cid:15) ) for every interval [ a , b ] ⊆ R and every state ρ , where Q [ a , b ] denotes the spectral projection of A corresponding to the eigenvalues in [ a , b ] . We emphasize that our deﬁnition of approximate measurements focuses only on the measurement outcomes and not on the post - measurement states which are irrelevant . It is known that the time evolution exp ( − i At ) can efﬁciently be simulated for all k - local operators 8 A acting on n - qubits in the following sense : a unitary U t with k U t − exp ( − i Ht ) k 6 θ can be implemented with resources that are only polynomial in 1 / θ , n and t [ 17 ] – [ 19 ] . For k - local operators on n - qudits , one has to introduce elementary operations on such a system ( e . g . those involving only two qudits ) in order to deﬁne an appropriate notion of complexity . 8 Here a k - local operator is deﬁned as an operator that can be written as a sum of terms that act on k ( not necessarily adjacent ) qubits only . New Journal of Physics 10 ( 2008 ) 093004 ( http : / / www . njp . org / ) 5 It was shown how to realize approximate A - measurements using the quantum - phase estimation procedure using approximations V of U : = exp ( − i A / k A k ) for appropriate t [ 6 , 16 ] . A measurement with maximal error δ and reliability 1 − (cid:15) in our sense can be achieved using only resources polynomial in 1 / δ , 1 / (cid:15) and n . This follows by adapting the arguments of [ 6 , 16 , 20 , 21 ] to the above deﬁnition of reliability and accuracy . Roughly speaking , this result means that the realization of quantum computation is at least as hard as the implementation of approximate measurements of k - local observables . The results of [ 9 ] can be interpreted as the converse statement stating that the implementation of k - local measurements is at least as hard as the realization of quantum computation . To be more precise , [ 9 ] showed that repeated k - local measurements can solve all problems in the complexity class PromiseBQP ( i . e . the class of problems that can be solved by the quantum computer in polynomial time by a probabilistic algorithm ) and the required measurement accuracy is polynomial in the running time of the simulated circuit . The present work shows that approximate measurements of physically more relevant Hamiltonians ( translationally invariant ﬁnite - range interactions on qudit chain ) can also solve all problems in PromiseBQP . Before proving this , we give the formal deﬁnition of PromiseBQP . 3 . Quantum computation as approximate energy measurement The complexity class BQP is usually considered to represent the class of problems that can be solved efﬁciently on a quantum computer . However , it is often necessary to consider a generalization of this complexity class given by the promise version of BQP ( for an introduction into promise problems see [ 22 ] ) . For example , if we want to study complete problems ( i . e . problems that fully capture the power of quantum computing ) , then we have to work with PromiseBQP since BQP is not known to contain a complete problem ( just like its classical counterpart BPP and other semantic complexity classes such as MA ) . For these reasons , we work with PromiseBQP . BQP is the class of language - recognition problems that can be solved efﬁciently on a quantum computer [ 13 ] . A language - recognition problem is to decide whether a given string x is an element of a language L ⊆ { 0 , 1 } ∗ or not . The essential point is that a language deﬁnes a partition of the set of all strings into those that belong to L and those belonging to the complement of L and that the quantum computer must be able to decide whether x ∈ L and x 6∈ L for every x . The promise version of a complexity class can also contain decision problems that do not correspond to language - recognition problems . Given a set of allowed inputs 5 : = 5 YES ∪ 5 NO , the problem is to decide whether x ∈ 5 YES or x ∈ 5 NO given the promise that x ∈ 5 ( note that language - recognition problems are promise problems , where 5 is the set of all strings ) . We denote this problem by ( 5 YES , 5 NO ) . Observe that the problem of deciding if x is in 5 could be computationally much harder . The formal deﬁnition of PromiseBQP is : Deﬁnition 2 ( PromiseBQP ) . PromiseBQP is the class of promise problems that can be solved by an uniform 9 family of quantum circuits ( U ( n ) ) . More precisely , it is required that this family of quantum circuits U ( n ) decides if a string x of length n is a YES - instance or NO - instance in 9 By ‘uniform circuit’ we mean that there exists a polynomial time classical algorithm that generates a sequence of a polynomial number of quantum gates for every desired input length . New Journal of Physics 10 ( 2008 ) 093004 ( http : / / www . njp . org / ) 6 the following sense . The application of U ( n ) to the computational basis state | x , 0 i produces the state U ( n ) | x , 0 i = α x , 0 | 0 i ⊗ | ψ x , 0 i + α x , 1 | 1 i ⊗ | ψ x , 1 i ( 1 ) such that ( i ) p x , 1 : = | α x , 1 | 2 > 2 / 3 for all x ∈ 5 YES and ( ii ) p x , 0 : = | α x , 0 | 2 > 2 / 3 for all x ∈ 5 NO ( or equivalently , that p x , 1 6 1 / 3 ) . Equation ( 1 ) has to be read as follows : the input string x determines the ﬁrst n - qubits . The remaining a = poly ( n ) additional ancilla qubits are initialized to | 0 i . After U ( n ) has been applied we interpret the ﬁrst qubit as the relevant output ; the remaining n + a − 1 output values are irrelevant . The number of the gates of the circuit U ( n ) is r = poly ( n ) . Deﬁnition 2 clariﬁes the notion of an ‘efﬁcient quantum algorithm’ . The following theorem is the main result of the paper . It states that efﬁcient quantum algorithms can be simulated by energy measurements whose accuracy in the sense of deﬁnition 1 is inverse polynomial in the size of the simulated circuit , where the Hamiltonian is a ﬁnite - range translationally invariant Hamiltonian on a one - dimensional qudit chain and the initial state is a canonical basis state . The proof of the theorem follows from the construction of the Hamiltonian in section 5 using some general spectral analysis developed in the following section , phrased as lemmas 1 and 2 . Let us ﬁrst introduce the embedding of two - qubit interactions into a qudit chain . For any operator O on C d ⊗ C d deﬁne a family of embedding operators E ( m ) j : C d ⊗ C d → ( C d ) m by E ( m ) j ( O ) : = 1 ⊗ j ⊗ O ⊗ 1 m − 2 − j . Then we will show : Theorem 1 . There is an operator V acting on ( C 56 ) ⊗ 2 such that energy measurements with respect to the family of Hamiltonians H ( m ) : = m − 2 X j = 0 E ( m ) j ( V + V † ) ( 2 ) acting on ( C 56 ) ⊗ m can probabilistically solve PromiseBQP in the following sense . Assume we are given a device that is able to implement H ( m ) - measurements with maximal error δ = 1 / poly ( m ) and reliability 1 − (cid:15) . Let U ( n ) be a family of quantum circuits that solve a problem in PromiseBQP as in deﬁnition 2 . Then for all input strings x of length n , there is a partition R = Y m ˙ ∪ N m , and a computational basis state | ψ x i ∈ ( C 56 ) ⊗ m such that Pr ( λ ∈ Y m | x ∈ 5 YES ) > p x , 1 ( 1 − (cid:15) ) , ( 3 ) Pr ( λ ∈ N m | x ∈ 5 NO ) > p x , 0 ( 1 − (cid:15) ) , ( 4 ) where λ is the random variable deﬁned by the energy measurement of H ( m ) in the state | ψ x i and m = poly ( n ) . The quantities m , | ψ x i , Y m and N m can be efﬁciently computed from x and U ( n ) . Note that V is the same for all m . Later we will construct such an operator V with k V k 6 1 . New Journal of Physics 10 ( 2008 ) 093004 ( http : / / www . njp . org / ) 7 4 . Spectral requirements on the Hamiltonian We start with Hamiltonians that are not necessarily of the special form in equation ( 2 ) . This relaxation allows us to provide a simpler and more intuitive understanding of why accurate energy measurements can solve PromiseBQP - problems at all . We construct a suitable ﬁnite - range translationally invariant Hamiltonian on a qudit chain in section 5 . We now brieﬂy review the basic principles of the autonomous Hamiltonian computers proposed by Benioff , Feynman and Margolus [ 10 , 14 , 23 ] since our Hamiltonian can be viewed as a special type of an autonomous Hamiltonian quantum computer . Originally , the construction of computational models in terms of autonomous Hamiltonian dynamics of closed physical systems was motivated , among other things , by the study of thermodynamics of computation . Kitaev observed that these ideas are also useful in quantum complexity theory since they provide a connection between problems of determining spectral properties of Hamiltonians and those of ﬁnding solutions of hard computational problems . This link has mainly been used in the context of the proof of the QMA - completeness of the so - called local Hamiltonian problem ( estimating the ground state energy for a wide range of Hamiltonians [ 13 ] , [ 24 ] – [ 27 ] ) . Let U = U r U r − 1 · · · U 1 be a quantum circuit consisting of the elementary gates U t acting on the logical Hilbert space H for t = 1 , . . . , r . We adjoin a Hilbert space H clock that represents the clocking device of the autonomous computer and deﬁne on H ⊗ H clock the ‘forward time operator’ F : = X t ∈ Z U t ⊗ | t + 1 ih t | , ( 5 ) where we have used the convention U t = 1 for t 6∈ { 1 , . . . , r } . The states | t i label some states in H clock and represent the time steps of the quantum circuit U . They do not necessarily span the whole space H clock . We then deﬁne a Hamiltonian by H : = F + F † . Applying the time evolution exp ( − i Ht ) to the state | x , 0 i ⊗ | 0 i leads to superpositions of states of the form F t | ψ i =   t Y j = 1 U j | x , 0 i   ⊗ | t + 1 i with t > 0 and | x , 0 i ⊗ | t i with t 6 0 . The idea of Hamiltonian computers is then to initially prepare the clock in a superposition of states with negative t in such a way that the wave packet propagates mainly in forward direction and triggers the implementation of gates . The reason why such models of autonomous computation can only simulate quantum circuits in such a ‘broader sense’ ( i . e . one has always superpositions of different computational states ) is that the Hamiltonians should be k - local for some small constant k . It is not known how to directly implement unitary operations U by time - independent Hamiltonians H of this type where U = exp ( − i H ) represents some interesting computation . New Journal of Physics 10 ( 2008 ) 093004 ( http : / / www . njp . org / ) 8 An important feature of the forward - time operators in the abovementioned literature is that they act unitarily on the relevant subspace of ‘computational states’ spanned by F t ( | x , 0 i ⊗ | 1 i ) and ( F † ) t ( | x , 0 i ⊗ | 1 i ) with t ∈ N . This makes a spectral analysis feasible since F and F † commute on this subspace . For our construction , we do not want the Hamiltonian really to perform the computation in the above case . However , the above explanation still remains the leading intuition . To prove that approximate energy measurements can solve PromiseBQP - problems , we have to introduce a modiﬁcation of the above forward - time operator such that it is no longer unitary on the relevant subspace , and analyze its spectral properties . We need the read - out gate R : = | 1 ih 1 | and the annihilation gate A : = 0 ( where 0 is the zero matrix ) for this modiﬁcation . Let U = U r U r − 1 · · · U 1 be a quantum circuit as above and let s be greater than r . We construct a non - unitary quantum circuit ˆ U = ˆ U s + 1 ˆ U s ˆ U s − 1 · · · ˆ U r + 1 ˆ U r ˆ U r − 1 · · · ˆ U 1 ˆ U 0 , where its elementary gates are deﬁned as follows : ˆ U 0 : = A , ( 6 ) ˆ U t : = U t , for t = 1 , . . . , r , ( 7 ) ˆ U r + 1 : = R , ( 8 ) ˆ U t : = I , for t = r + 2 , . . . , s , ( 9 ) ˆ U s + 1 : = A . ( 10 ) The reader may be confused that ˆ U 0 and ˆ U s + 1 are trivial since our ‘annihilation gate’ A is just the zero operator . The reason why we deﬁne such an unusual ‘quantum circuit’ is that this deﬁnition allows us to interpret every operation performed by the forward - time operator , including state annihilation , as a ( not necessarily unitary ) quantum ‘gate’ . Then we construct a modiﬁed forward - time operator ( compare equation ( 5 ) ) by F : = s + 1 X t = 0 ˆ U t ⊗ | t + 1 ih t | . To intuitively understand why the spectral measure of the Hamiltonian H : = F + F † will then reﬂect the solution of the computational problem we observe the following . Assume we apply the time evolution exp ( − i Ht ) to the state | x , 0 i ⊗ | 1 i and the answer of the problem is ‘YES’ with probability 1 . In this case the orbit (cid:16) exp ( − i H τ ) ( | x , 0 i ⊗ | 1 i ) (cid:17) τ ∈ R + consists of superpositions of the states F t ( | x , 0 i ⊗ | 1 i ) for t = 0 , . . . , s . This is because F † and F annihilate the ﬁrst and the last state in this set , respectively , and on the remaining states ( i . e . t = 1 , . . . , s − 1 ) they commute since the non - unitary readout gate is irrelevant . The dynamics is then mathematically equivalent to a particle moving on a chain of length s + 1 ( with a dynamics induced by ‘hopping terms’ ) . If the answer is ‘NO’ with probability 1 the dynamics is restricted to the subspace spanned by F t ( | x , 0 i ⊗ | 1 i ) for t = 0 , . . . , r , i . e . a dynamics on a chain of length r + 1 . New Journal of Physics 10 ( 2008 ) 093004 ( http : / / www . njp . org / ) 9 In the generic case the answer is non - deterministic and we obtain a mixture of both cases such that the probability distribution of the results of a H - measurement depends directly on the outcome probabilities of the simulated circuit . For the mathematical analysis of this case we will use the decomposition | x , 0 i ⊗ | 1 i = p 1 − p 1 | ψ 0 i ⊕ √ p 1 | ψ 1 i , where | ψ 1 i is obtained by renormalizing ( F † ) r + 1 F r + 1 ( | x , 0 i ⊗ | 1 i ) and | ψ 0 i by renormalizing | x , 0 i ⊗ | 1 i − ( F † ) r + 1 F r + 1 ( | x , 0 i ⊗ | 1 i ) . These components correspond to new initial states for which the answer in the readout step is deterministic . The lemma below speciﬁes precisely the statement and the conditions on F that we require . Let us brieﬂy introduce some graph theoretic terminology ﬁrst . The adjacency matrix of the line graph on ‘ nodes is given by L ‘ : = S ‘ + S † ‘ , where S ‘ denotes the non - cyclic shift in ‘ dimensions with the canonical basis vectors | 0 i , | 1 i , . . . , | ‘ − 1 i , i . e . S ‘ = ‘ − 2 X v = 0 | v + 1 ih v | . Let λ v be the v th eigenvalue of L ‘ and Q ( ‘ ) v be the corresponding spectral projection . Let P ‘ be the probability distribution on the eigenvalues induced by the vector corresponding to the ﬁrst node , i . e . P ‘ ( λ v ) : = h 0 | Q ( ‘ ) v | 0 i . Then we have Lemma 1 . Let U = U r U r − 1 · · · U 1 be a quantum circuit that accepts the state | x , 0 i with probability p x , 1 in the sense of deﬁnition 2 . Let ˆ U = ˆ U s + 1 ˆ U s · · · ˆ U 0 be the corresponding non - unitary quantum circuit as deﬁned in equations ( 6 ) – ( 10 ) . Let F be an operator acting on H d ⊗ H clock where H d stands for ‘data space’ and H clock for ‘clock space’ , respectively . Let | 0 i , . . . , | s + 1 i denote some mutually orthogonal states of the clock register . Assume that F and F † act as F ( | φ i ⊗ | t i ) = ˆ U t | φ i ⊗ | t + 1 i , ( 11 ) F † ( | φ i ⊗ | t + 1 i ) = ˆ U † t | φ i ⊗ | t i , ( 12 ) for t = 0 , . . . , s on the smallest F and F † invariant subspace containing the initial state | ψ i : = | x , 0 i ⊗ | 1 i . Then the spectral measure induced by F + F † and the initial state | ψ i is given by the convex combination ( 1 − p x , 1 ) P r + 1 + p x , 1 P s + 1 . New Journal of Physics 10 ( 2008 ) 093004 ( http : / / www . njp . org / ) 10 Proof . Let | ψ 1 i be the vector obtained by renormalizing the vector ( F † ) r + 1 F r + 1 | ψ i = ( U †1 · · · U † r RU r · · · U 1 | x , 0 i ) ⊗ | 1 i and | ψ 0 i by renormalizing | ψ i − ( F † ) r + 1 F r + 1 | ψ i . Let V 0 be the span of { F t | ψ 0 i } t = 0 , . . . , r and V 1 the span of { F t | ψ 1 i } j = 0 , . . . , s . The statement V 0 ⊥ V 1 follows from the fact that F t | ψ 0 i ⊥ F t 0 | ψ 1 i ( 13 ) holds for all t 6 = t 0 , because the states then correspond to different basis vectors in the clock space . For t = t 0 = r the restrictions of the states F t | ψ 1 i and F t | ψ 0 i to the data register are given by renormalizing RU r · · · U 1 | ψ i and ( 1 − R ) U r · · · U 1 | ψ i , ( 14 ) respectively . For 0 6 t 6 r − 1 we have to apply the unitary operator U † t + 1 · · · U † r to both states in equation ( 14 ) , which obviously preserves the orthogonality relation . One can easily check that V 0 and V 1 are invariant under the action of F and F † . This implies that they are also invariant under F + F † . We ﬁrst determine the spectral measures induced by | ψ 0 i and | ψ 1 i . On V 0 the operator F is unitarily equivalent to the non - cyclic shift S r + 1 by identifying the orthonormal basis vectors F t | ψ 0 i with the basis vectors | t i ∈ C r + 1 for t = 0 , . . . , r . This unitary equivalence is readily veriﬁed by checking that F maps the t th basis vector to the ( t + 1 ) th for t < r and annihilates F r | ψ 0 i . Hence the spectral measure induced by F + F † on | ψ 0 i is the same as the spectral measure induced by L r = S r + 1 + S † r + 1 on | 0 i , i . e . it is equal to P r + 1 . Similarly , F + F † induces the spectral measure P s + 1 on | ψ 1 i . The spectral measure induced by | ψ i = p 1 − p x , 1 | ψ 0 i ⊕ √ p x , 1 | ψ 1 i is then just the convex sum of the measures induced by | ψ 0 i and | ψ 1 i , respectively . By elementary linear algebra , the corresponding weights are 1 − p x , 1 and p x , 1 . This completes the proof . ut The lemma shows how to construct a Hamiltonian H = F + F † such that the distribution of the results in an accurate measurement is given by the measure ( 1 − p x , 1 ) P r + 1 + p x , 1 P s + 1 as in lemma 1 . To analyze how to assign measurement outcomes with ‘YES’ and ‘NO’ we recall that the spectrum S ‘ of the line graph L ‘ contains the values λ v = 2 cos (cid:18) π ( v + 1 ) ‘ + 1 (cid:19) , for v = 0 , . . . , ‘ − 1 [ 28 ] . If r + 2 and s + 2 are relatively prime , then S s + 1 and S r + 1 are disjoint . This assumption is useful since it will allow us to replace the quantum computation with a single shot measurement instead of repeated sampling . To obtain a lower bound on the distance between these two sets , we apply the function x 7→ arccos ( x / 2 ) / π to the eigenvalues λ v and µ w and obtain the values a v : = v + 1 r + 2 and b w : = w + 1 s + 2 . The minimal distance between any of these values is at least 1 / ( r + 2 ) ( s + 2 ) . On the interval [ 0 , π ] the cosine function satisﬁes the inequality | cos ( x ) − cos ( y ) | > 14 ( x − y ) 2 , New Journal of Physics 10 ( 2008 ) 093004 ( http : / / www . njp . org / ) 11 for all x , y with | x − y | 6 1 . These facts imply that the minimal distance between the spectra S r + 1 and S s + 1 is at least 1 : = π 2 2 ( r + 2 ) 2 ( s + 2 ) 2 . ( 15 ) From an intuitive point of view , this already shows that the ability to implement measurements with inverse polynomial error makes it possible to assign a measurement outcome to either of the two spectra . The following lemma bases this statement on the formal deﬁnition of measurement accuracy and analyzes the probability of correctly classifying the input . It follows immediately from the arguments above . Lemma 2 . Let the distribution of measurement results in an accurate measurement be given by ( 1 − q ) P r + 1 + q P s + 1 with q ∈ [ 0 , 1 ] , where P ‘ for ‘ = r + 1 , s + 1 denotes the spectral measure of the line graphs of length ‘ as above . Assume we have an approximative measurement procedure with accuracy 1 as in equation ( 15 ) and reliability 1 − (cid:15) . For δ : = 1 / 3 deﬁne Y : = s [ w = 0 [ µ w − δ , µ w + δ ] and N : = R \ Y , where µ w denotes the w th eigenvalue of the line graph of length s + 1 . Let λ be the measurement outcome . Then we have the conditional probabilities Pr ( λ ∈ Y | x ∈ 5 YES ) > q ( 1 − (cid:15) ) , ( 16 ) Pr ( λ ∈ N | x ∈ 5 NO ) > ( 1 − q ) ( 1 − (cid:15) ) . ( 17 ) The lemma shows that the error of the measurement - based decision procedure then essentially reproduces the acceptance probabilities of the simulated circuit provided that the probability to have an error greater than 1 is small . The arguments in this section thus establish that energy measurements for local Hamiltonians can be used to solve PromiseBQP - problems . Here ‘local’ means that the interaction involves only a few , but not necessarily adjacent , qubits ( if we represent the clock also by a qubit register ) . Unfortunately , this does not sufﬁce to prove theorem 1 because we have not described how to construct a nearest - neighbor translationally invariant interaction H on a qudit chain having the desired properties . In the next section , we show how to construct such an interaction based on a QCA so that it still satisﬁes the spectral properties in lemma 1 . Large parts of our construction follow the idea of the ‘quantum computer on a line’ described in [ 27 ] . The main difference is that we need a translation invariant Hamiltonian and must therefore encode the gates into the initial state . Moreover , the way we include readout and annihilation gates is due to our speciﬁc requirement to obtain disjoint sets of potential measurement results . Our interaction is not supposed to be the simplest operator satisfying all the above requirements . However , we have chosen an encoding of quantum circuits that seems to be rather concise and quite natural . It is likely that more sophisticated encodings could signiﬁcantly reduce the size of the unit cell of the QCA . New Journal of Physics 10 ( 2008 ) 093004 ( http : / / www . njp . org / ) 12 5 . Construction of the Hamiltonian To construct the QCA , we restrict ourselves to the following universal set of quantum gates . Let S denote the swap gate and W the controlled gate deﬁned by W : =   1 0 0 0 0 1 0 0 0 0 1 √ 2 − 1 √ 2 0 0 1 √ 2 1 √ 2   . We require that both gates be only applied to adjacent qubits . Moreover , we require that W be applied only in one direction , i . e . the control - wire will always be the left qubit of the corresponding pair in the data register described later . This set of gates is universal because the W gate is universal if it can be applied to arbitrary qubit pairs [ 29 ] . We assume without loss of generality that the quantum circuits U in deﬁnition 2 are composed only of S and W acting on adjacent qubits . We also assume that gates acting on disjoint qubit pairs can be performed in parallel . In this way , the quantum circuits are split into layers . We refer to these layers as the time steps of the quantum circuit . 5 . 1 . Description of our QCA We now construct a QCA that can simulate any such quantum circuit so that the total number of time - steps required is polynomial in the number of gates and the number of qubits used in the simulated circuit . We encode the quantum circuit and its input in the initial state of the QCA . It acts on H : = H ⊗ m c , where H c : = C 56 denotes the Hilbert space of a single cell . Our Hamiltonian has the form H = F + F † = m − 2 X j = 0 E ( m ) j ( V + V † ) , ( 18 ) where V acts on two cells , i . e . on H c ⊗ H c . Each cell consists of a data and a program cell , i . e . we have H c : = H p ⊗ H d where H p and H d denote the Hilbert space of the program and data cell , respectively . We refer to the set of all program cells ( i . e . H ⊗ m p ) as the program band and to that of all data cells ( i . e . H ⊗ m d ) as the data band . The program band initially contains the description of the quantum circuit U to be simulated . We refer to this description as the program code . This code is divided into blocks where each block corresponds to one time - step of U . The data register is a subset of the data band that corresponds to the register on which U acts , i . e . it represents the logical qubits . The remaining part of the data band will only contain formatting symbols . The Hilbert spaces of the data and program cells are denoted by H d = C 4 and H p = C 14 , respectively . The basis vectors of H d are identiﬁed with the symbols in { 0 , 1 } ∪ { k , • } , New Journal of Physics 10 ( 2008 ) 093004 ( http : / / www . njp . org / ) 13 # # # # # # # # # # A W I I S I I R I I A I # x 0 Figure 1 . Initialization of the program and data bands . x W S 0 R A Figure 2 . Example of a simple quantum circuit that acts on two qubits and consists of ﬁve time - steps . The ﬁrst qubit that takes the input is x . The second qubit is an ancilla qubit . those of H p with the symbols in { I , S , W , R , A } ∪ { I , S , W , R , A } ∪ { (cid:3) , (cid:4) , ♦ , # , } . The program code is composed of the gate symbols I , S , W , R and A ( see ﬁgure 1 ) . These symbols correspond to the identity , S , W , R and A , respectively . The marked gate symbols I , S , W , R and A are used to control the propagation of the program code . The symbols (cid:3) , (cid:4) , ♦ and # are also used for this purpose . We refer to these symbols as the hole , execution , turn - around and blank symbols , respectively . The kets | 0 i and | 1 i correspond to the two orthogonal states of a qubit . The symbols k and • are used for formatting purposes ; the symbol k makes it possible to determine when the program has been moved by one block . They are contained only in those data cells that do not belong to the data register . During the dynamics the content of the program cells slides over the data cells and triggers the implementation of the gates on the data register . Since we want to construct a nearest - neighbor interaction the sliding of the program can only be realized by moving the content cell - by - cell . Therefore , we need a special control mechanism that ensures that the program is only executed after it has been moved by exactly one block , i . e . the block is again aligned with the corresponding data cells on which the gates are supposed to act ( in close analogy to the construction in [ 27 ] ) . The forward time operator F in equation ( 18 ) must implement the propagation and the execution of the gates whenever the program is aligned with the data band . The operator V in equation ( 18 ) is thus the product V = T X , where X applies gates on H d ⊗ H d conditioned on the state of H p ⊗ H p and T realizes transitions between the basis states of H p ⊗ H p . Before we deﬁne T and X explicitly , we look at a simple example to see how quantum circuits and inputs are encoded in the initial states . We also explain how the execution of the program code is controlled in a purely local procedure where no global clocking is available . 1 . Assume we want to simulate the circuit in ﬁgure 2 . Then we initialize the program and data bands as shown in ﬁgure 1 . The program code is A (cid:4) W IIS IIR IIA I , where the gaps are used to indicate the different time - steps of the quantum circuit U . All other program cells New Journal of Physics 10 ( 2008 ) 093004 ( http : / / www . njp . org / ) 14 contain the blank symbol # . Note that the two qubit gates W and S are encoded by symbol pairs IW and IS , respectively , and that the program contains an extra symbol I between the blocks ( i . e . the layers of the circuit ) and the ﬁrst command of the program reads A . In the initial state , the ﬁrst layer of the circuit is aligned with the data register that is initialized in the state | x , 0 i . The symbols k to the left and right of the data register enclose exactly two • symbols , corresponding to the number of qubits of U . 2 . It is important that the program code starts with the pair A (cid:4) . One may rather expect the initial conﬁguration (cid:4) A , but this would lead to an execution of A in the ﬁrst step . This is analogous to section 4 , where we have to start in the clock state | 1 i instead of | 0 i to prevent the execution of the ﬁrst annihilation gate ˆ U 0 : = A . The purpose of this choice of the initial state is to ensure that it is annihilated by the operator F † because it implements the program in the backward direction . The execution symbol (cid:4) is propagated cell - by - cell to the end of the program code until it arrives at the rightmost cell not containing the blank symbol # . In each step , (cid:4) and the gate symbol G on its right side swap their positions . More precisely , if (cid:4) is in the j th program cell and G in the ( j + 1 ) th cell , then G moves to the j th cell and (cid:4) to the ( j + 1 ) th cell . While swapping the symbols , the gate corresponding to G is executed . It is applied to data cells j and j + 1 if it is a two - qubit gate and to data cell j + 1 if it is a single qubit gate . This only happens if data cell j and data j + 1 are inside the data register in the case of a two - qubit gate . Similarly , it only happens if the data cell j + 1 is inside the data register in the case of a single qubit gate . 3 . Once the execution symbol (cid:4) has passed the end of the program code it is converted to the blank symbol # ( via the creation of the intermediate turn - around symbol ♦ ) , and a signal is sent to the beginning of the program code . This signal indicates that the execution of the ﬁrst time - step of the program code has been completed . To avoid the propagation of this signal leading to a backward propagation of the program code , the signal cannot occupy a program cell on its own . It propagates by converting each gate symbol G into a marked version G cell by cell . Once the marked gate symbol G is at the beginning of the program code , it is converted into the hole symbol (cid:3) via the creation of the turn - around symbol ♦ . 4 . The hole symbol (cid:3) propagates cell by cell to the end of the program where it is converted to the blank symbol # and triggers the left propagating marker G ( via the creation of the intermediate turn - around symbol ♦ ) . The arrival of this marker at the beginning of the program code triggers the conversion of the next copy of # into (cid:3) . This procedure is repeated until the program code begins and is again aligned with the next copy of the format symbol k in the data band . In this case , the marker G triggers the creation of (cid:4) instead of (cid:3) and the whole cycle starting in the second step is repeated ( again , this is done by the creation of the intermediate turn - around symbol ♦ ) . The above procedure is implemented by the following nearest - neighbor transition rules . These rules depend only on the contents of two adjacent cells of the QCA . We use ∗ to denote any of the symbols 0 , 1 and • . The symbol represented by ∗ is left unchanged by the corresponding transition rule . In the transition rules 2 and 6 , the left - lower and right - lower corners are left empty to indicate that the symbol at that place is not important for the transition rule and that it is left unchanged . New Journal of Physics 10 ( 2008 ) 093004 ( http : / / www . njp . org / ) 15 1 ( a ) (cid:3) G → G (cid:3) ( b ) (cid:4) G → G (cid:4) 2 ( a ) (cid:3) # ∗ → ♦ # ∗ ( b ) (cid:4) # k → ♦ # k 3 G ♦ → G # 4 F G → F G 5 # G → ♦ G 6 ( a ) # ♦ ∗ → # (cid:3) ∗ ( b ) # ♦ k → # (cid:4) k Transitions 1 ( a ) and ( b ) implement the rightward propagation of the symbols (cid:3) and (cid:4) , respectively . Transitions 2 ( a ) and ( b ) take place when (cid:3) and (cid:4) have passed the end of the program code , respectively . They create the symbol ♦ ( turn - around ) . Transition 3 creates a marked gate symbol that initiates the leftward moving signal . Transition 4 implements the propagation of this signal . Once this signal has arrived at the beginning of the program code , transition 5 and transitions 6 ( a ) and ( b ) create the symbols (cid:3) and (cid:4) via the creation of the intermediate turn - around symbol ♦ , respectively . The execution symbol (cid:4) is created only if the turn - around symbol ♦ is exactly above the formatting symbol k , which happens only if the blocks of the program code are aligned with the data register . Otherwise , the hole symbol (cid:3) is created . Now we are ready to deﬁne the transition operator T . It is the annihilation - creation operator on H c ⊗ H c deﬁned by all the above transition rules . It annihilates all conﬁgurations that do not appear on the left - hand side of any of the above transitions . We denote by X the operator that realizes the controlled execution of the gates . It is deﬁned by X : = | (cid:4) S ih (cid:4) S | ⊗ S d + | (cid:4) W ih (cid:4) W | ⊗ W d + | (cid:4) R ih (cid:4) R | ⊗ ( I d ⊗ R d ) + | (cid:4) A ih (cid:4) A | ⊗ ( I d ⊗ A d ) + Q ⊗ ( I d ⊗ I d ) , where Q : = I p ⊗ I p − X G ∈ { S , W , R , A } | (cid:4) G ih (cid:4) G | . The projectors | (cid:4) G ih (cid:4) G | for G ∈ { S , W , R , A } act on H p ⊗ H p . I p and I d act as identity on H p and H d , respectively . S d and W d act as S and W , respectively , on the subspace of H d ⊗ H d spanned by { | 00 i , | 01 i , | 10 i , | 11 i } and as identity on the orthogonal complement ( spanned by pairs of format symbols k , • ) . Similarly , R d and A d act as R and A , respectively , on the subspace of H d spanned by { | 0 i , | 1 i } and as the identity on the complement . New Journal of Physics 10 ( 2008 ) 093004 ( http : / / www . njp . org / ) 16 5 . 2 . Spectral properties We denote the initial state of the QCA by | x , 0 i ⊗ | 1 i , where | x , 0 i is the initial state of the quantum circuit to be simulated and | 1 i represents the state of the program band and the state of all data cells outside the data register that corresponds to an appropriately chosen initial conﬁguration . The application of F changes the conﬁguration in the program cells into a new basis state and applies , at the same time , gates to the relevant section in the data cells . This is because the transition rules are designed such that only one transition is possible in each step provided that the initial conﬁguration has been chosen as described in the preceding section . We can thus denote the conﬁgurations as the clock states | 1 i , | 2 i , . . . . Since our simulation of the original circuit contains not only execution steps but also operations where only signals are propagated the circuit is thus extended by polynomial overhead of identity gates on the data cells . Thus we have ˜ s + 1 steps instead of s + 1 until the state is completely annihilated . Likewise , the readout gate causes a conditional annihilation in the step ˜ r + 1 instead of r + 1 . To make sure that F and the initial state | x , 0 i ⊗ | 1 i satisfy the conditions of lemma 1 , we have to check that the application of F † to one of the states in the orbit F t ( | x , 0 i ⊗ | 1 i ) with t = 1 , . . . , ˜ s indeed leads to the preceding clock state and to an annihilation for t = 0 . The annihilation property is satisﬁed since we have started the system in a state where the running of the program in the backward direction would immediately execute the A gate . To see that F † leads in the general case to the preceding states , we have to check our list of transitions in the backward direction . Every conﬁguration that arises from the repeated application of the forward - time operator F always contains exactly one element in the set { (cid:3) , (cid:4) , ♦ , I , S , W } . If the conﬁguration contains one of the symbols (cid:3) and (cid:4) but they are neither preceded nor followed by the blank symbol # ( i . e . they are not located at the boundaries of the program code ) , then only rule 1 ( a ) or ( b ) can be active in the backward direction . The pattern in rule 2 only occurs when the symbols (cid:3) or (cid:4) are located at the right boundary of the program code . In this case , no other rules are active in the backward direction . Similarly , the pattern in rule 6 only occurs when the symbols (cid:3) or (cid:4) are located at the left boundary of the program ( i . e . only when they are preceded by # ) . In this case , no other rule is active in the backward direction . The symbol ♦ only appears in rules 2 and 5 on the right - hand side of the transitions . But there is no conﬁguration where both rules can be applied backwards at the same time . Likewise , the marked gate symbols only occur in rules 3 and 4 . Again , there is no conﬁguration where both rules can be applied backwards at the same time . Hence , we have shown that F meets the requirements of lemma 1 and that the spectral measure induced by F + F † on the initial state | x , 0 i ⊗ | 1 i depends on the acceptance probability p x , 1 . To design a program code such that the supports of the two corresponding spectral measures to be distinguished are disjoint , we may choose the position of the annihilation gate appropriately . In this way , we can always achieve that ˜ r + 2 and ˜ s + 2 are relatively prime , ensuring that the minimal distance between the supports of the spectra satisﬁes equation ( 15 ) . 6 . Conclusions In contrast to usual measurement - based approaches to quantum computing , we have constructed an observable whose measurements have full quantum computation power when applied to a basis state only once . The observable is a translation invariant nearest - neighbor interaction New Journal of Physics 10 ( 2008 ) 093004 ( http : / / www . njp . org / ) 17 Hamiltonian on a spin chain with a single cell dimension 56 . Given an arbitrary quantum circuit of U , an energy measurement applied to the same type of spin chain ( but with sufﬁcient length depending on the length of U ) indicates the result ‘YES’ or ‘NO’ of U since they correspond to mutually disjoint sets of potential measurement results . The gaps between these sets scale inverse polynomially with the number of gates of the simulated quantum circuit . If the measurement device is able to reliably distinguish between these energy values , one can reproduce the outcome probabilities of the circuit exactly . In this sense , one measurement procedure replaces one run of a quantum circuit . Even though our speciﬁc construction is unlikely to be found in real physical systems , our result strongly suggests that energy measurement for real physical systems is a task whose realization is as challenging as the realization of quantum computing . This shows , once more , that quantum information processing in a broader sense is not only required to solve computational problems . Instead , it is a task that occurs already in the context of usual quantum control . Since we have shown in a previous paper that more accurate measurements of observables of a similar type solve all problems in the complexity class PSPACE , our result can also be interpreted as showing how the complexity of quantum control procedures depends on the demanded accuracy . Acknowledgments PW acknowledges the support by NSF grant CCF - 0726771 . SZ was supported by NSF grant PHY - 0456720 and ARO grant W911NF - 05 - 1 - 0294 . We thank Daniel Nagaj for his helpful discussions about the transition rules of the quantum cellular automaton . References [ 1 ] Jauch J 1968 Foundations of Quantum Mechanics ( Reading , MA : Addison - Wesley ) [ 2 ] Davies E 1976 Quantum Theory of Open Systems ( London : Academic ) [ 3 ] DiVincenzo D 1995 Two - qubit gates are universal for quantum computation Phys . Rev . A 51 1015 – 22 [ 4 ] Janzing D 2006 Computer Science Approach to Quantum Control ( Karlsruhe : Uni - Verlag ) [ 5 ] Travaglione B and Milburn G 2001 Generation of eigenstates using the phase - estimation algorithm Phys . Rev . A 63 032301 [ 6 ] Wocjan P , Janzing D and Decker T 2008 Measuring 4 - local n - qubit observables could probabilistically solve PSPACE Quantum Inf . Comput . 8 741 – 55 [ 7 ] Childs A , Leung D and Nielsen M 2005 Uniﬁed derivations of measurement - based schemes for quantum computation Phys . Rev . A 71 032318 [ 8 ] Raussendorf R and Briegel H J 2000 Quantum computing via measurements only Phys . Rev . Lett . 86 5188 [ 9 ] Wocjan P and Zhang S 2006 Several natural BQP - complete problems arXiv : quant - ph / 0606179 [ 10 ] Feynman R 1985 Quantum mechanical computers Opt . News 11 11 – 46 [ 11 ] Janzing D 2007 Spin - 1 / 2 particles moving on a 2D lattice with nearest - neighbor interactions can realize an autonomous quantum computer Phys . Rev . A 75 012307 [ 12 ] Janzing D and Wocjan P 2005 Ergodic quantum computing Quantum Inf . Process . 4 129 – 58 [ 13 ] Kitaev A , Shen A and Vyalyi M 2002 Classical and Quantum Computation vol 47 ( Providence , RI : American Mathematical Society ) [ 14 ] Margolus N 1990 Parallel quantum computation ed W Zurek Complexity , Entropy , and the Physics of Information ( Reading , MA : Addison - Wesley ) New Journal of Physics 10 ( 2008 ) 093004 ( http : / / www . njp . org / ) 18 [ 15 ] Vollbrecht K and Cirac I 2008 Quantum simulators , continuous - time automata , and translationally invariant systems Phys . Rev . Lett . 100 010501 [ 16 ] Janzing D and Wocjan P 2007 A simple PromiseBQP matrix problem Theory Comput . 3 61 – 79 [ 17 ] Aharonov D and Ta - Shma A 2003 Adiabatic quantum state generation and statistical zero knowledge Proc . 35th Annu . ACM Symp . on Theory of Computing pp 20 – 9 [ 18 ] Berry D , Ahokas G , Cleve R and Sanders B 2007 Efﬁcient quantum algorithms for simulating sparse Hamiltonians Commun . Math . Phys . 270 359 – 71 [ 19 ] Childs A 2004 Quantum information processing in continuous time PhD Thesis Massachusetts Institute of Technology [ 20 ] Janzing D and Wocjan P 2006 BQP - complete problems concerning mixing properties of classical random walks on sparse graphs arXiv : quant - ph / 0610235 [ 21 ] Janzing D and Wocjan P 2007 A PromiseBQP - complete string rewriting problem arXiv : 0705 . 1180 [ 22 ] Goldreich O 2006 On promise problems Essays in Memory of Shimo Even pp 254 – 900 . Online at http : / / dx . doi . org / 10 . 1007 / 11685654 12 [ 23 ] Benioff P 1980 The computer as a physical system : a microscopic quantum mechanical model of computers as represented by Turing machines J . Stat . Phys . 22 562 – 91 [ 24 ] Kempe J and Regev O 2003 3 - local Hamiltonian is QMA - complete Quantum Inf . Comput . 3 258 – 64 [ 25 ] Kempe J , Kitaev A and Regev O 2004 The complexity of the local Hamiltonian problem SIAM J . Comput . 35 1070 – 97 [ 26 ] Oliveira R and Terhal B 2008 The complexity of quantum spin systems on a two - dimensional square lattice Quantum Inf . Comput . at press ( arXiv : quant - ph / 0504050 ) [ 27 ] Aharonov D , Gottesman D and Kempe J 2007 The power of quantum systems on a line Proc . 48th Annu . IEEE Symp . on Foundations of Computer Science pp 373 – 83 [ 28 ] Cvetkovic D 1997 Eigenspaces of Graphs ( Cambridge : Cambridge University Press ) [ 29 ] Shepherd D , Franz T and Werner R 2006 A universally programmable quantum cellular automaton Phys . Rev . Lett . 97 020502 New Journal of Physics 10 ( 2008 ) 093004 ( http : / / www . njp . org / )