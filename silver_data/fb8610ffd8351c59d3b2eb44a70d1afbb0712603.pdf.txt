19 Teaching Computational Thinking Using Agile Software Engineering Methods : A Framework for Middle Schools ILENIA FRONZA , NABIL EL IOINI , and LUIS CORRAL , Free University of Bozen - Bolzano , Italy Computational Thinking ( CT ) has been recognized as one of the fundamental skills that all graduates should acquire . For this reason , motivational concerns need to be addressed at an early age of a child , and reaching students who do not consider themselves candidates for science , technology , engineering , and mathematics disciplines is important as well if the broadest audience possible is to be engaged . This article describes a framework for teaching and assessing CT in the context of K - 12 education . The framework is based on Agile software engineering methods , which rely on a set of principles and practices that can be mapped to the activities of CT . The article presents as well the results of an experiment applying this framework in two sixth - grade classes , with 42 participants in total . The results show that Agile software engineering methods are effective at teaching CT in middle schools , after the addition of some tasks to allow students to explore , project , and experience the potential product before using the software tools at hand . Moreover , according to the teachers’ feedback , the students reached all the educational objectives of the topics involved in the multidisciplinary activities . This result can be taken as an indicator that it is possible to use computing as a medium for teaching other subjects , besides computer science . CCS Concepts : • Applied computing → Education ; • Software and its engineering → Agile software development ; Additional Key Words and Phrases : Computational thinking , software engineering , agile methods , K - 12 , framework ACM Reference format : Ilenia Fronza , Nabil El Ioini , and Luis Corral . 2017 . Teaching Computational Thinking Using Agile Software Engineering Methods : A Framework for Middle Schools . ACM Trans . Comput . Educ . 17 , 4 , Article 19 ( August 2017 ) , 28 pages . https : / / doi . org / 10 . 1145 / 3055258 1 INTRODUCTION The ACM model curriculum for K - 12 computer science ( Tucker et al . 2003 ) defines computer sci - ence ( CS ) as “the study of computers and algorithmic processes , including their principles , their hardware and software designs , their applications , and their impact on society . ” In this view , CS is neither programming nor computer literacy ( Barr and Stephenson 2011 ) . CS can , instead , teach Authors’ addresses : I . Fronza and N . El Ioini , Faculty of Computer Science , Free University of Bozen - Bolzano , Piazza Domenicani 3 , 39100 , Bolzano , Italy ; emails : { ilenia . fronza , nabil . elioini } @ unibz . it ; L . Corral , ITESM Campus Queretaro , E . Gonzalez 500 , 76130 Queretaro , Mexico ; email : lrcorralv @ itesm . mx . Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies show this notice on the first page or initial screen of a display along with the full citation . Copyrights for components of this work owned by others than ACM must be honored . Abstracting with credit is permitted . To copy otherwise , to republish , to post on servers , to redistribute to lists , or to use any component of this work in other works requires prior specific permission and / or a fee . Permissions may be requested from Publications Dept . , ACM , Inc . , 2 Penn Plaza , Suite 701 , New York , NY 10121 - 0701 USA , fax + 1 ( 212 ) 869 - 0481 , or permissions @ acm . org . © 2017 ACM 1946 - 6226 / 2017 / 08 - ART19 $ 15 . 00 https : / / doi . org / 10 . 1145 / 3055258 ACM Transactions on Computing Education , Vol . 17 , No . 4 , Article 19 . Publication date : August 2017 . 19 : 2 I . Fronza et al . how to apply computational processes to problems that occur during everyday life and involve many disciplines . To this end , a person needs to acquire the following skills ( Perković et al . 2010 ) : ( 1 ) computer literacy , which is the ability to use basic computer applications ( e . g . , editor , web browser ) to perform a task ; ( 2 ) computer fluency , which consists in a high - level understanding of how a computer system works ; ( 3 ) computational thinking , which is needed to apply computational techniques in every field . This skill received its name in 2006 in an article by Jeannette Wing ( 2006 ) . This means that developing only computer literacy skills does not correspond to learning CS , even though in the past few decades CS curricula have often aimed at teaching only computer literacy . This choice resulted almost inevitably in the identification of CS with the concept of “ability to use technology” ( Fronza et al . 2014 ) . What is needed , instead , is to teach conceptual skills besides computer literacy , as software and operating systems evolve very quickly . Indeed , Computational Thinking ( CT ) has been proposed to address this issue ( Wing 2006 ) . Since its introduction , the definition of CT has been modified and refined ( Denning and Freeman 2009 ; Council 2010 ; Aho 2012 ) . A recent definition describes CT as “the thought processes involved in formulating a problem and expressing its solution ( s ) in such a way that a computer—human or machine—can effectively carry out” ( Wing 2014 ) . This definition includes the main characteristics of CT : ( 1 ) The solution can be computed by a human or machine , ( 2 ) CT can be learned without a machine , and ( 3 ) CT concerns not only problem - solving but also problem formulation . In 2013 , ACM recognized CT as “one of the fundamental skills desired of all graduates” ( Joint Task Force on Computing Curricula and Society 2013 ) . Thus , focusing on high schools is a good start , but this may not be the ultimate goal . Instead , motivational concerns need to be addressed at an early age of a child , particularly for girls and underrepresented minorities ( Fisher and Margolis 2002 ; Cooper and Cunningham 2010 ) . Reaching students who do not consider themselves candi - dates for science , technology , engineering , and mathematics is also important to engage the broad - est audience possible ( Settle et al . 2012 ) and to help filling gender and race gaps in CS ( Prey and Weaver 2013 ; Margolis 2008 ) . Research in this field has recently focused on defining curricula for teaching CT to solve these issues ( Grover and Pea 2013 ; Repenning et al . 2010 ; Fronza et al . 2015 ) . Despite all the mentioned effort , there are still gaps that call out for empirical inquiries , since the majority of research studies are performed in the context of undergraduate classrooms ( Grover and Pea 2013 ) ; thus , empirical research should be carried out in the K - 12 education context . Also , examples in non - computer - science disciplines are of paramount importance for the progress in this area ( Barr and Stephenson 2011 ) . This article tackles the need of teaching CT not only at the university level ( Grover and Pea 2013 ) by introducing a framework for teaching and assessing CT in the context of K - 12 education . The framework has been developed also to accommodate the needs of the middle school system in Italy , known as “Buona Scuola” ( Italian Ministry of Education 2014 ) . The main idea is to teach CT using Agile software engineering methods , replacing the typical software development tools with elements that are more appropriate for the K - 12 environment . The framework introduced in this article allows us to teach CT as part of a larger scope project , where part of the time is also invested in activities away from computer terminals . With this approach , we exercise CT abilities to favor the acquisition of additional knowledge , offered by other courses and instructors , and we use the creation of a software system as a tool to reflect , reinforce , and confirm the concepts acquired in other subjects . Additionally , the article presents the results of an experiment applying this framework in two 6th - grade classes , with 42 participants in total . ACM Transactions on Computing Education , Vol . 17 , No . 4 , Article 19 . Publication date : August 2017 . Teaching Computational Thinking using Agile Software Engineering Methods 19 : 3 Table 1 . The Three Dimensions of CT ( Brennan and Resnick 2012 ) Dimension Definition Computational The concepts designers employ as they program : concepts • Sequences ( S ) • Loops ( L ) • Events ( E ) • Parallelism ( P ) • Conditionals ( C ) • Operators ( O ) • Data ( D ) Computational The practices designers develop as they program : practices • Being incremental and iterative ( I ) • Testing and debugging ( T ) • Reusing and remixing ( R ) • Abstracting and modularizing ( A ) Computationalperspectives The perspectives designers form about the world around them and about themselves : • Expressing ( Exp ) • Connecting ( Con ) • Questioning ( Que ) 2 BACKGROUND CT “involves solving problems , designing systems , and understanding human behavior , by draw - ing on concepts fundamental to CS” ( Wing 2006 ) . This ability , according to Jeannette Wing , should be made available “not just to CS majors” ( Wing 2006 ) . In the past few years , CT has caught the attention of a large part of the academic community , and many studies have tried to capture the essence of CT and to create an agreed definition , as CT was rather a broad term ( Denning and Freeman 2009 ; Council 2010 ; Aho 2012 ; Wing 2014 ) . In 2011 , the CS Teachers Association ( CSTA ) and the International Society for Technology in Education ( ISTE ) suggested an operational defi - nition of CT that provides a framework and a vocabulary dedicated to K - 12 educators ( ISTE and CSTA 2011 ) . In 2012 , Brennan and Resnick developed an operational definition ( Table 1 ) that in - volves three key dimensions ( Brennan and Resnick 2012 ) . Recent work on CT has focused on tools that foster it ( Grover and Pea 2013 ; Repenning et al . 2010 ) . Graphical programming environments are probably the most commonly used solution , since they allow us , starting from learners’ early experiences , to focus on design and construction while avoiding syntax problems ( Adams and Webster 2012 ; Charlton 2013 ) . Most of the recent research has addressed the issue of CT assessment to evaluate the effectiveness of any curriculum by mea - suring what students have effectively learned ( Brennan and Resnick 2012 ; Werner et al . 2012 ; Koh et al . 2010 ) . Large gaps , however , still require additional empirical inquiries ( Grover and Pea 2013 ) . Grade and age - appropriate curricula for CT still need to be designed or improved ( Fronza et al . 2015 ) , and the possibility to use computing as a medium for teaching other subjects should be explored ( Grover and Pea 2013 ) . Nevertheless , because of a strong emphasis being led by the media , new proposed curricula focused on coding ( Crow 2014 ) . This misleading perception resulted in teach - ers focusing on a small aspect of CT , thereby neglecting its broader aims . Moreover , most of the studies have been conducted in an undergraduate context . Thus , empirical studies in K - 12 context ACM Transactions on Computing Education , Vol . 17 , No . 4 , Article 19 . Publication date : August 2017 . 19 : 4 I . Fronza et al . are needed to understand the problems faced during the first programming experiences that go beyond syntactical issues . Additionally , research should explore students’ attitudes toward com - puting ( Grover and Pea 2013 ) . 2 . 1 Teaching Computational Thinking The goal of teaching CT is to improve students’ ability to conceptualize , understand , and use computer - based technologies so that they are better prepared for today’s society ( Wing 2014 ) . Ad - ditionally , teaching CT may also help to change the perception of careers in computing ; this goal can be reached by showing that programmers , beside programming skills , need to interact with others to look for ideas to solve problems with a computational strategy ( Vinayakumar 2014 ; Ham - brusch et al . 2009 ) . In the following , we describe existing strategies and tools to teach and assess CT . 2 . 1 . 1 Strategies . To facilitate the learning process , teachers and students should use appropri - ate vocabulary to describe problems and solutions ( Barr and Stephenson 2011 ) . Moreover , students should learn to accept wrong solutions as part of a path for a positive result and should be en - couraged to work as a team and to use decomposition techniques , abstraction , negotiations , and consensus building . It is also important to stimulate interest in computing ( Wing 2006 ) and to introduce the basics of CT long before students learn to program . Students , in particular , should become familiar with the control flow of an algorithm and be able to abstract and represent infor - mation . For these purposes , different approaches can be used , such as that of Lodi ( 2014 ) : —underline the applicability of CT in other disciplines ; —involve students in multidisciplinary activities ; —structure group - work to learn how to overcome problems related to communication . To introduce programming , exercises that require a “mental model” execution of their solution should be proposed , and natural constructs should be preferred ( Fronza and Zanon 2015 ; Lodi 2014 ) . 2 . 1 . 2 Tools . The most commonly used tools to teach CT are visualization - based tools . Among them , visual programming languages allow us to create programs by manipulating graphical ele - ments ; the notation is usually constituted by diagrams or blocks , thus eliminating syntax difficul - ties ( Charlton 2013 ) . Animation programs , instead , explicitly show some aspects of the execution of a program ( e . g . , the call stack ) . Moreover , visual simulations of programs allow students to learn how to read a piece of code , understand the flow , and trace it . 2 . 1 . 3 Assessment . Despite the many efforts aimed specifically at tackling the issue of CT as - sessment , assessing the learning of CT remains a challenge ( Meerbaum - Salant et al . 2010 ; Werner et al . 2012 ; Brennan and Resnick 2012 ; Moreno - León et al . 2015 ; Boe et al . 2013 ) . This gap makes the introduction of CT in schools curricula difficult ( Grover 2015 ) , as an assessment methodol - ogy enables the evaluation of the success or failure of a CT strategy in an educational context . Currently , programming environments are most often used as the basis for assessment ( Werner et al . 2012 ) ; moreover , few if any tools exist that enable real - time formative assessment of CT ( Koh et al . 2014 ) . Grover ( 2015 ) provides an overview of CT assessment techniques and highlights the need for multiple measures that are complementary , encourage and reflect deeper learning , and contribute to a comprehensive picture of student learning . Grover et al . describe various forms of assessment used in a 6 - week middle school curriculum with the goal of capturing a holistic view of students’ learning ( Grover et al . 2014 ) . Werner et al . propose a CT performance assessment for middle school students , in which assessment tasks measure algorithmic thinking , abstraction , and modeling ( Werner et al . 2012 ) . ACM Transactions on Computing Education , Vol . 17 , No . 4 , Article 19 . Publication date : August 2017 . Teaching Computational Thinking using Agile Software Engineering Methods 19 : 5 Brennan and Resnick describe three approaches for assessing the development of CT con - cepts , practices , and perspectives ( Brennan and Resnick 2012 ) . For each approach , authors dis - cuss strengths and limitations . The same article provides the following general suggestions for assessing the learning that takes place when young people engage in programming : ( 1 ) supporting further learning ; ( 2 ) incorporating artifacts ; ( 3 ) illuminating processes ; ( 4 ) checking in at multiple points across the learning experience ; ( 5 ) valuing multiple ways of knowing ; ( 6 ) including multiple viewpoints . Meerbaum - Salant et al . underline the importance of assessing the vocabulary of computing ( Meerbaum - Salant et al . 2010 ) ; according to the authors , in fact , a language of the domain can aid thinking about and communicating computational ideas more effectively . 3 BASIC CONCEPTS This section introduces preliminary information about the tools adopted in our framework . We have chosen tools and strategies following the existing guidelines reported in Section 2 . 1 . Where no indications were available , preference was given to those tools already adopted in schools ( for example , in the case of mind map ) . 3 . 1 Scratch Scratch is a visual programming language that allows users of all ages and backgrounds to easily create their interactive stories , animations , games , and more , simply by snapping together puzzle - shaped blocks ( Resnick et al . 2009 ; Vinayakumar 2014 ) . Still , to construct a program , users need to have an idea of what they want to build , what objects they may use , and how to get those objects to move and act ( Charlton 2013 ) . To accomplish this goal , it is necessary to have the resources and tools that ease the integration of different components , and the structuring of a congruent solution . Also , it is important to take the maximum advantage of a user’s creativity and problem - solving skills and to minimize the pre - requisite of being trained in programming tools ( Charlton 2013 ; Resnick et al . 2009 ) . Scratch fosters the three dimensions of CT ( Brennan and Resnick 2012 ) . The implementation of sequences happens by integrating compatible blocks that can be translated into commands to be executed sequentially by the characters . The control blocks also offer the possibility to repeat ac - tions many times , introducing the concept of loops into a design strategy . Parallelism is illustrated with the presence of two or more characters that can execute an action at the same time . Events are represented by the listeners ( “sensors” ) of actions that characters may be carrying out . These events can be eventually evaluated by conditions . Conditional blocks can be added to evaluate a fact , after which a decision can be made . Data are present thanks to the possibility of integrating variables that can be managed by using logic and mathematic operators . Both data and operators provide inputs for conditional blocks as well ( Brennan and Resnick 2012 ) . 3 . 2 Mind Map Mind maps serve to structure the ideas within a project , and to identify their relevance , strength , and impact , as well as to describe the relationships between ideas . The approach to create a mind map is conducting a brainstorming session to identify ideas that are relevant to the project . Groups of congruent ideas are created , drawing connections among them , or assigning a different shape or size , depending on the relevance or affiliation of each idea ( Biktimirov and Nilson 2006 ; Buzan ACM Transactions on Computing Education , Vol . 17 , No . 4 , Article 19 . Publication date : August 2017 . 19 : 6 I . Fronza et al . and Buzan 2000 ; Davies 2011 ) . In our framework , the value delivered by this activity is the precise identification of the elements , their importance , and interactions , and the creation of an initial list of actors , roles , and situations as an input to a storyboard . Creating a mind map requires spontaneous thinking ; therefore , mind mapping promotes cre - ative thinking ( Gunstone 1992 ) and encourages brainstorming ( Paykoç et al . 2004 ) . Nevertheless , creative thinking should follow techniques and recommendations to create useful mind maps . For example , images , symbols , codes , and dimensions should be used throughout a mind map ; more - over , colors should be chosen according to the author’s code . Emphasis should be used , and asso - ciation should be clearly shown . Despite all the possible guidelines , each person should develop a personal style for mind mapping ( Buzan and Buzan 2000 ) . 3 . 3 Storyboard Storyboards are a series of images that depict the sequence or execution flow of the scenes repre - sented in a system , including the interaction of the elements that are represented in mind maps . One can consider a storyboard as the display of the blocks of a comic strip , in which there is a vi - sual representation of the sequence of activities that include situations , actors , roles , and actions . Also , a storyboard includes comments and annotations that help to have a better notion of the ac - tion represented . Creating a storyboard requires visual thinking and planning , and this promotes brainstorming in a team and generates more ideas and consensus inside the group ( Kapp 2013 ) . The main benefit of storyboarding is that it helps to understand exactly how a piece of software will work , much better than an abstract description ( Cardinal 2013 ; Van der Aa 2014 ) . Storyboards typically take the form of a series of panels ; each panel features the main elements needed for each scene . In this framework , a simple template is adopted , which includes the following infor - mation : scene number , type of background , characters in the scene and their actions , and a short description . The added value of this activity is the generation of a work product that permits to experience visually and notionally the product to be developed and assists the structuring and implementation of a logic flow in a way in which it will be clearer to be translated in computer notation ( Cardinal 2013 ) . 3 . 4 Feasibility Table Effort estimation is an integral part of software engineering , and each type of development process ( e . g . , Waterfall and Agile ) has a different perspective on this task ( Jorgensen and Shepperd 2007 ; Abrahamsson et al . 2011 ) . For example , in Agile software development , a system is developed in - crementally in small iterations ; this implies that estimation needs to be performed progressively . In this framework , we adopted a widespread technique for estimation in Agile software develop - ment , called disaggregation ( Cohn 2005 ) , which consists in breaking a big task ( called story ) into smaller ones ; the effort of each task is then estimated , and the story’s total estimate is calculated as the sum of the effort estimates of each task . Before each iteration , a table is created , which con - tains the estimations for the upcoming tasks ; then , the team adds the estimates up and makes a realistic assessment about whether those tasks can all be completed ( i . e . , they are feasible ) during the iteration ( Cohn 2004 ) . 4 THE FRAMEWORK As detailed in Section 2 , much of the recent work on CT has focused on definitional issues and tools to foster CT development . Some strides have been made in defining curricula ; however , large gaps still exist that call out for empirical inquiries , in particular for K - 12 education ( Grover and Pea 2013 ) . To address this issue , this article proposes a framework that uses animations as a tool to engage children in developing CT ( Kelleher and Pausch 2007 ) . Students are required to work on ACM Transactions on Computing Education , Vol . 17 , No . 4 , Article 19 . Publication date : August 2017 . Teaching Computational Thinking using Agile Software Engineering Methods 19 : 7 Fig . 1 . Mapping Agile development process to Computational Thinking development process . multidisciplinary activities to show them that CT can be applied in other disciplines other than CS . Moreover , this choice allows us to explore the possibility to use computing as a medium for teaching other subjects , as suggested in Grover and Pea ( 2013 ) . The framework is based on the central concepts of the software development process , which are linked and adapted to the peculiarity of the educational context . The framework covers 60 hours , which include an introductory part ( Section 4 . 2 ) and a project part ( Section 4 . 3 ) . As for the sched - uling of the activities , the 60 hours are distributed over a long time span ( e . g . , 4 hours per week ) . We motivate this choice by reaching three goals : ( 1 ) Give more time to middle school students to elaborate the information ; ( 2 ) let students perceive the course as part of the curriculum , not as an isolated event ; and ( 3 ) establish a strong relationship with the students , in case the teacher is not part of the school teaching body ( e . g . , a researcher in our case ) . 4 . 1 Rationale Traditionally , the course of software development process is used to teach CS students the differ - ent aspects and foundations needed to develop software systems . The steps to develop a software system include collecting requirements , requirements analysis , software design , software imple - mentation , and software testing ( Layman et al . 2008 ) . The success of this approach in software development has encouraged researchers to find ways to transfer this knowledge into other fields and take advantage of the systematic way for problem solving offered by the software development process to solve problems in other areas ( Rahman and Juell 2006 ) . A strict , sequential software development process is not an option when the goal is to promote creativity , experimentation , and practical work on developers ( Dybå 2000 ) . Traditional and for - mal processes rely on predictability and rationality to dominate systems ; Agile processes instead depend on the creative talent of people to find solutions for complex software development prob - lems ( Dybå 2000 ) . For this reason , as shown in Figure 1 , our framework adopts an Agile - inspired software development process to promote creativity , experimentation , and practical work on stu - dents . Furthermore , at the teaching level , when considering students who have no background ACM Transactions on Computing Education , Vol . 17 , No . 4 , Article 19 . Publication date : August 2017 . 19 : 8 I . Fronza et al . on software development , additional tasks are needed to allow them to explore and experience a potential product before using the software tools at hand ( Cardinal 2013 ) . The referenced activi - ties should generate intermediate working products that are pivotal inputs for the following steps , from the generation of graphic materials to the actual implementation of a software product . In our framework , the proposed activities are —the creation of a mind map , which is a visual representation of the ideas that integrates the concept of the project ( Section 3 . 2 ) ; —the design of a storyboard , which is a depiction of the sequence of system execution ( Section 3 . 3 ) . The main scope of creating these two working products is to have a structured view of the rele - vant elements , in a way that participants can experience visually the product since the inception of the idea ( Cardinal 2013 ) . Indeed , on the one hand , these instruments give a structured arrangement of inter - connected ideas ; on the other hand , they provide a limited series of images that represent how the execution of the program would flow . Moreover , the creation of these working - products facilitates the interchange of ideas among the members of a team and assists in orchestrating an all - hands , brainstorming working strategy that ensures that all participants speak and listen and all the viewpoints are taken into account ( Walny et al . 2011 ) . From the educational point of view , our goal is to make sure that each team has a working product even with a minimum set of functionality at any point in time during the development . To achieve this goal , throughout the development of the product , different Agile practices are employed , as follows ( Martin 2003 ) : —Iterations : dividing the workload into short iterations allows the team to focus on having a working product at the end of each iteration . —Teams : working in teams brings more value regarding creativity and product quality , since it allows team members to discuss and collaborate to produce a working product . —Tests : at the end of each iteration the product is tested . This has the advantage of discovering and fixing errors sooner . —Continuous integration : once the iteration is finished successfully , the new features are integrated into the final product . Moreover , disaggregation is used as a technique for effort estimation ( Cohn 2005 ) to make stu - dents discuss the possibility of reducing their goals or accelerating some tasks . Before each itera - tion , participants are asked to fill in a feasibility table with all the elements ( e . g . , actors , costumes , background ) of the scene of the animations to be created in the upcoming iteration . For each el - ement , they provide an estimation of the number of hours needed to complete it ; the sum of all these values represents the effort estimation for the scene . 4 . 2 Introductory Part Before undertaking the activities shown in Figure 1 to work on the project part , an introductory part of 20 hours takes place to introduce all the computational concepts through a targeted set of exercises , which are described in Table 2 . Initially , the first four exercises are proposed as non - software , unplugged , situations . For exam - ple , in Exercise 2a , a student stands up and plays the role of a cat that needs to move to the point in the classroom where a key is located and then say , “I found my key . ” The class brainstorms on how to provide instructions to do that and on how to let the key disappear in the correct mo - ment . Students have to identify the problem , explain a high - level solution , and then model and structure an algorithm down to the smallest details . After this phase , each exercise evolves to a ACM Transactions on Computing Education , Vol . 17 , No . 4 , Article 19 . Publication date : August 2017 . Teaching Computational Thinking using Agile Software Engineering Methods 19 : 9 Table 2 . Computational Concepts Covered in the Exercises of the Introductory Part Relevant computational Ex . Description concepts a 1 A cat moves from one point of the stage to another point ; then , it goes back to the starting point . S ( first stacks of blocks ) E ( green flag ) 2a A cat moves to the point where a key is located , then it says “I found my key . ” Then , the key disappears . In this version of the solution , the key also starts when pressing the green flag ( i . e . , in parallel with the cat ) , then it “waits” the amount of seconds that are necessary for the cat to complete its actions . P ( coordinate key and cat ) 2b An alternative solution to the previous exercise . The cat starts with the green flag . When the cat completes its actions , broadcasting is used to start the key . E ( broadcasting ) 3 The same of Ex . 2b , but without knowing the coordinates of the key . The cat keeps doing one step in the direction of the key and stops when it touches the key . E ( touching ) L ( repeat until ) 4 The cat continuously draws a star on the stage . L ( forever ) 5 A fish is moving in a fish tank from the left to the right until it touches the edge , then it goes back , and so on . C ( if ) L ( forever ) 6 Ex . 5 is extended . Each time the fish touches an edge , it bounces and changes its direction randomly . O ( pick random number ) 7 Ex . 6 is extended to create a trivial game : when the user clicks on the fish , she / he increases her / his score by one . D ( variable ) a Abbreviations are defined in Table 1 . programming - specific problem : The designed solution is implemented using Scratch ( Section 3 . 1 ) and new computational concepts are introduced meanwhile . The solution of each exercise is built on the solutions of the previous ones . Afterwards , Exercises 5 – 7 have been designed to review all the previously introduced computa - tional concepts . For this reason , two or three students work together to find the solutions without additional explanations of the teacher to show their understanding of the computational concepts . Teachers provide few explanations during these exercises , as learners have now sufficiently high prior knowledge ( Kirschner et al . 2006 ) , and solutions are checked at the end . In general , students have two opposite attitudes ; some are eager to learn and would like to pro - gram from the very first minute , and others are somehow “afraid” of programming as they view computer programming as a narrow , technical activity , appropriate for only a small segment of the population ( Resnick et al . 2009 ) . To address this issue , the introductory part was designed so that programming is introduced through exercises with an increasing degree of difficulty , allowing wary students to appreciate the “fun” part of programming and eager ones to program immedi - ately . Therefore , to introduce the theoretical basis , for Exercises 3 and 7 a sort of reverse engineering process is applied , which starts from the solutions and ends with their storyboards , mind maps , and brainstorming documents . Besides computational concepts , the introductory part has been designed to start fostering com - putational practices ( Table 1 ) . For example , the solution of Exercise 3 is approached in small steps ( i . e . , practice “I” ) and , in general , students are encouraged to reuse and remix the code they created ACM Transactions on Computing Education , Vol . 17 , No . 4 , Article 19 . Publication date : August 2017 . 19 : 10 I . Fronza et al . for the previous exercises ( i . e . , practice “R” ) . First examples of “bugs” are solved together , and the idea of testing and debugging is explained ( i . e . , practice “T” ) . Finally , the introductory exercises represent a first example of the practice of conceptualizing the problem and translating the concept to sprites and stacks of code ( i . e . , practice “A” ) . Section 4 . 4 . 1 details the interview protocol for the introductory part , which checks the under - standing of the computational concepts introduced in the seven exercises . 4 . 3 Project Part Students work on the project part for 40 hours , covering the steps shown in Figure 1 to create an animation . The goal of the animation is to display information unidirectionally , with a minimal interaction with the user ( usually just to start the animation ) . Internally , the animation can be relatively complex from the logic point of view . Students are required to structure their solutions , to orchestrate the actions of all the characters and backgrounds , and to set the control blocks to guarantee the correct flow of execution of the application ( for instance , conditions and loops ) . Therefore , according to the instructors’ plans , students are expected to show that they master all the computational concepts except operators and variables ( Adams and Webster 2012 ) . As shown in Figure 1 , during the first part of the project each team is asked to brainstorm about the assigned topic . Afterwards , mind maps and storyboards are created . In the second part , during each development iteration , each team is asked to create the storyboard for the iteration and to perform the feasibility analysis . To start an iteration , a team needs to show the achievement of the goal of the previous iteration during an assessment interview with the instructors ( Section 4 . 4 . 2 ) . Moreover , at the end of each iteration , the team needs to check the conformance with the require - ments and connect the new part with the existing materials . During development , working in teams is an important task to master . Agile teaches us that good products come from good teams and working in teams allows team members to exchange experiences and brings powerful opportunities for personal development ( Martin 2003 ) . To imple - ment a project successfully , team members need to have a shared vision of the project as well as have a good understanding of its details . Depending on the project size , team members can decide to have specialized roles in that each member focuses on a specific task , or in case of small projects such as ours , all team members need to be able to perform all the tasks , meaning that there cannot be students dedicated only to drawing or programming , since our goal is to learn how to perform all these tasks . Working in teams also exercises the “parallelization” skill ( ISTE and CSTA 2011 ) , as students need to organise their activities to simultaneously carry out their tasks and reach a common goal . Moreover , previous studies have shown pair programming to be positively correlated with CT assessment scores ( Werner et al . 2012 ) . Teams need to be decided by school teachers , as they know students characteristics . During the entire development process , particular attention is paid to fostering all the computa - tional practices ( Table 1 ) through , for instance , iterations , frequent testing , and reuse of previously created code . 4 . 4 Assessment We developed a framework to assess the development of computational practices and con - cepts . The framework includes both project analysis ( during and after the development process ) and artifact - based interviews . Indeed , the presence of blocks indicates conceptual encounters ( Brennan and Resnick 2012 ) but does not provide information about the learning of CT . However , looking at student - created code alone could provide an inaccurate sense of students’ computational ACM Transactions on Computing Education , Vol . 17 , No . 4 , Article 19 . Publication date : August 2017 . Teaching Computational Thinking using Agile Software Engineering Methods 19 : 11 competencies ( Brennan and Resnick 2012 ) ; therefore , despite being time consuming , artifact - based interviews can reveal the learning of computational concepts and practices and also help providing a more accurate picture of students’ understanding ( Barron et al . 2002 ) . Following the guidelines of Brennan and Resnick ( Brennan and Resnick 2012 ) , our assessment of students’ learning checks in at multiple points across the learning experience : during the intro - ductory part ( Section 4 . 4 . 1 ) , during the project part ( Section 4 . 4 . 2 ) , and at the end of the activities ( Section 4 . 4 . 3 ) . Moreover , following the indications of Bell and Cowie ( Bell and Cowie 2001 ) , our formative assessment is used to assist students’ learning and one of its main characteristics is responsiveness , that is , it is progressive , it can be unplanned as well as planned , and it involves responding with individuals and with the entire class . 4 . 4 . 1 During the Introductory Part . At the end of the first four exercises ( Table 2 ) , all the stu - dents are asked ( one by one ) to explain the solutions of Exercise 3 , which includes the solutions of the previous exercises , and of Exercise 4 . During this interview , we focus on the students’ under - standing of the computational concepts by asking the following questions : ( 1 ) How does the key understand that it is time to disappear ? Depending on the student’s answer ( i . e . , “wait” or “broadcasting” ) , we check if she / he can remember the alternative solution . This question checks the understanding of parallelism ( P ) and events ( E ) ; ( 2 ) How do you tell the cat to continue taking steps ? Here we check if the student can show the “repeat” command in the solution of Exercise 3 . This question checks the understanding of loops ( L ) ; ( 3 ) How does the cat know that it has found the key ? Here we check if the student can show , in the solution of Exercise 3 , that the cat stops walking ( i . e . , the “repeat” command stops ) when touching the key . This question checks the understanding of events ( E ) ; ( 4 ) The cat will never stop drawing stars . Why ? Here we check if the student can show the “forever” command in the solution of Exercise 4 . This question checks the understanding of loops ( L ) . This interview has been designed to be completed in about 10 minutes . Depending on the num - ber of students , the presence of two interviewers would be recommended to complete this process in about 2 hours . We consider the result of this interview to be sufficient when the student can explain ( 1 ) the “wait” command in Exercise 1 , ( 2 ) the role of the green flag in starting both cat’s and key’s ac - tions , and ( 3 ) that the cat will never stop drawing stars because of the “forever” command . Indeed , these answers show an understanding of the concepts of events , parallelism , and loops . Such an understanding can be considered sufficient as the concepts loops and events are repeated in the following set of exercises ; for example , “wait” is an intuitive solution for events , which is refined ( using “broadcasting” ) later during the other activities . Additional explanations are provided when needed directly to one student or involving the entire class , in case the explanation appears to be relevant for more students . At the end of Exercise 7 , those students that did not obtain a sufficient evaluation at the end of Exercise 4 are interviewed to check if gaps have been filled . The introductory part ends only when all the students show a sufficient understanding of the computational concepts , as defined above . Considering the type of projects ( i . e . , an animation ) , sufficient knowledge of data and operators is not considered necessary to proceed to the project part ( Adams and Webster 2012 ) . 4 . 4 . 2 During the Project Part . At the end of each iteration , each team is interviewed ; this means that , as each team works at its own pace on an iteration , these interviews are usually not synchro - nized . First , we check that they have achieved the goal of the previous iteration . Then , we check the ACM Transactions on Computing Education , Vol . 17 , No . 4 , Article 19 . Publication date : August 2017 . 19 : 12 I . Fronza et al . Table 3 . Mapping of Computational Concepts to Blocks Concepts Blocks Sequences Stacks of blocks Loops Forever , repeat , forever if , repeat until Events When flag / key / sprite is clicked , when I receive , wait until , broadcasting Parallelism When flag / key is clicked Conditionals Forever if , if , if else Operators Green blocks ( math operators ) Data Variables , lists learning of the computational concepts using the following questions ( the corresponding concept is indicated in parentheses ) : ( S ) Can you explain the meaning of this stack of blocks ? ( L ) Did you need to write some code to repeat the same action multiple times ? Where ? ( P ) Do you make things happen at the same time ? Where ? ( E ) Does it happen that one thing causes another thing to happen ? Where ? ( C ) Do you make decisions based on conditions ? Where ? ( O ) Do you use some mathematical operators ? Where ? ( D ) Do you have to store values , as we did in the “fish tank” exercise ? Where ? At the same time , we perform code inspections : The presence of specific blocks ( Table 3 ) is checked to confirm that the students are using the corresponding computational concept ( Brennan and Resnick 2012 ) . Figure 2 shows how answers and code inspections are used to take action , as an integral part of the formative assessment ( Bell and Cowie 2001 ) . Three possibile actions are : —mark the interview as passed ; —refresh , in case a concept has not been used , even if it was needed ; —refactor , if the concept has been used where needed , but it needs some fixes . Another set of questions is used to assess computational practices ( Table 4 ) and students’ learn - ing is assessed as “low , ” “medium , ” or “high . ” Those students that achieve a medium / high mark are not asked the corresponding questions anymore ; those students with a “low” mark are instead interviewed and assisted more frequently . As the main goal of this assessment is to provide feedback with the intention of supporting students’ learning ( Bell and Cowie 2001 ) , at the end of these interviews we provide suggestions for improvement , to a team or to the entire class when a suggestion can be helpful for more students . During the next interview , we check whether the team has used our suggestion to achieve the goal . During these interviews we involve all the team members to check that all of them have a balanced level of knowledge ; this means that , as much as possible , and even if this can result in having a final product with lower quality , we want to avoid having a team where one of the members is excluded because of her / his weakness and the other members work with their faster pace . In case one of the team members shows difficulties in understanding some concepts , we focus on her / him to fill the gaps , and we take notes about this situation . Unplanned interactions with the team are also possible , besides those planned at the end of each iteration ( Bell and Cowie 2001 ) . While working on a scene , a team can be stuck on a task and ACM Transactions on Computing Education , Vol . 17 , No . 4 , Article 19 . Publication date : August 2017 . Teaching Computational Thinking using Agile Software Engineering Methods 19 : 13 Fig . 2 . Concept loops : actions taken based on interview and code inspection . require clarifications or help to move on ; in this case , we assist the team or involve the class in a short discussion about the problem if this could be useful for everybody . 4 . 4 . 3 At the End of the Activities . The analysis of a project’s blocks can provide a record of computational concepts that are being encountered by a student ( Brennan and Resnick 2012 ) . For this reason , we perform an automated analysis of the final version of each project . Brennan and Resnick ( 2012 ) suggest the analysis of a collection of works over time to emphasize the evolving and developing nature of a project . Our solution is to perform a summative examination of a single final project and to follow the evolution by interviewing over time during the implementation , as detailed in Section 4 . 4 . 2 . ACM Transactions on Computing Education , Vol . 17 , No . 4 , Article 19 . Publication date : August 2017 . 19 : 14 I . Fronza et al . Table 4 . Assessing Development of CT Practices Question Low Medium High Experimenting and iterating Describe how you built this scene She can provide a basic description She can provide some details She provides details about the different components of the scene and how they were developed Describe different things you tried out while work - ing on the scene She cannot provide ex - amples She can provide gen - eral examples She can provide specific ex - amples of things they tried in the scene Describe a time when you tried to do something new in this scene She cannot provide ex - amples She can provide gen - eral examples She can describe specific new things they tried in the scene Testing and debugging What is going on ? She does not explain the problem She can identify vaguely the problem She can describe the prob - lem precisely How would you fix this ? She waits passively for a solution She has some ideas She is able to debug Describe other ways to solve the problem She cannot describe other solutions She can provide a gen - eral idea of another so - lution She provides specific exam - ples of other solutions to the problem Describe how you fixed the problem She cannot explain it She shows vaguely the change that solved the problem She shows precisely the change that solved the prob - lem and how they tested it What do you think is go - ingonafteryourchanges ? She cannot explain the consequences She has some vague ideas She is able to explain the consequencesofherchanges Reusing and remixing Describe a time you used a part of another scene / exercise as part of this scene She does not describe how scripts / ideas / re - sources were adapted She describes in gen - eral how scripts / ideas / resources were adapted She explains precisely how scripts / ideas / resources were adapted Do you remember an ex - ercise or another scene were you had a similar problem ? Can you use that code here ? She cannot associate the current problem to a similar situation and can not adapt scripts / ideas / resources to solve the current prob - lem She associates the cur - rent problem to a sim - ilar situation and has some ideas on how to adapt scripts / ideas / resources to solve the current problem She remembers a similar sit - uations and knows how to adapt scripts / ideas / re - sources to solve the current problem Abstracting and modularizing Describe how you decided what sprites were needed for the scene , and where they should go She provides no de - scription of how they selected sprites She provides a gen - eral description of de - ciding to choose cer - tain sprites She provides a specific de - scription of how they made decisionsaboutspritesbased on goals for the scene Describe how you decided what scripts were needed for the scene , and what they should do She provides no de - scription of how they created scripts She provides a gen - eral description of de - ciding to create certain scripts She provides a specific de - scription of how they made decisions aboutscripts based on goals for the scene Describe how you orga - nized the scripts She cannot describe how scripts are orga - nized She provides a gen - eral description of how scripts are organized She provides specific exam - ples of how scripts are orga - nized and why ACM Transactions on Computing Education , Vol . 17 , No . 4 , Article 19 . Publication date : August 2017 . Teaching Computational Thinking using Agile Software Engineering Methods 19 : 15 During the analysis of the final versions of the projects , we make sure that they do not show errors and that the execution follows a logical flow . Furthermore , we compare the software systems against the storyboards . Moreover , descriptive statistics are extracted about the number of scenes , blocks , sprites , costumes , backgrounds , and blocks per stacks . Moreover , the presence of specific blocks in the final version of each project is checked to con - firm the usage of the corresponding computational concept ( Table 3 ) . Manual inspection is per - formed when no block associated to a computational concept is found by the tool . For example , if no “loops” blocks are found , the manual inspection serves to find out if there was a need of a loop in the project and the students did not use the appropriate block but , for example , just repeated the same command many times . In this case , the computational concept “loops” cannot be assessed positively . Furthermore , cyclomatic complexity ( CC ) is calculated for each project , following the guidelines in Moreno - León et al . ( 2016 ) . This metric is based on the number of linear independent paths in a program ( McCabe 1976 ) and has been widely used in software engineering ( Fenton and Ohlsson 2000 ) . In our case , CC allows us to understand the different levels of complexity that students can reach by combining blocks in their projects . 5 EXPERIMENT To answer the call for empirical inquiries ( Section 2 ) , we experimented the proposed framework in middle schools . Given the open problems in CT research ( Grover and Pea 2013 ) , we stated the research question as follows : RQ . To what degree is the proposed framework effective at teaching computational thinking in middle schools ? To answer this question , we applied the framework presented in this article during an experi - ment that involved 42 sixth graders . This section details the methodology of the experiment . 5 . 1 Participants In total , 42 students participated in the experiment , all 12 years old , of which there were 20 females . The participants were divided into two classes ( 20 and 22 students ) . The students of the two classes had the same background , and the application of the framework happened with the same methods : the same amount of hours , the same instructors , the same interviewers , and the same type of final product . Nevertheless , this is a quasi - experiment ( Wohlin et al . 2012 ) , because the two classes were already existing and non - modifiable , and , therefore , several factors could not be controlled . For example , there is no possibility to check if any differences of the results are due to the different composition of classes or the characteristics of the subjects . For these reasons , from now on in this article , we will ignore the division in two groups . To collect information for replication purposes ( Wohlin et al . 2012 ) , during the first meeting , a survey was conducted to answer the following questions : —What is CS ? —What would you like to learn in a CS course ? Section 6 . 1 reports the results of this survey . 5 . 2 Teaching Staff The teaching staff was composed as follows : one teacher ( alternately of technology , art , and his - tory ) and one researcher ( i . e . , one of the authors of this article ) . Before starting the activities with the students , the researchers trained the teachers about the framework . During the activities , brief - ings were organized when needed ( usually at the end of teaching hours ) to solve doubts and issues ACM Transactions on Computing Education , Vol . 17 , No . 4 , Article 19 . Publication date : August 2017 . 19 : 16 I . Fronza et al . and to check the participants’ progress . During the introductory part , the teachers’ presence was not necessary , as there was no direct link to their topics ; however , they voluntarily took part al - ternately to the introductory phase to refresh their knowledge of Scratch and to review the frame - work . Meanwhile , they could help keep the discipline in the class . An additional researcher joined the class to conduct the interviews during the introductory part . During the project part , the role of each teacher consisted mainly of answering questions re - lated to her topic , such us how to draw backgrounds or how clay tablets were created . Moreover , the teachers could also answer to questions about storyboards and mind maps , and also about programming issues , even if the most technical matters were forwarded to the researcher . The presence of teachers of different topics was also chosen to let students perceive CT as useful for the teacher’s topic , not only for the CS lab . During the project phase , the researcher was conducting all the interviews at the end of a team’s iterations ( which means that they were not synchronized ) . Meanwhile , the teacher could continue helping the activities of the other teams . Towards the end of the activities , the researcher happened to be alone with the students in the class ; nevertheless , this did not represent an issue , as at that point most of the teams were almost autonomous and interviews could be faster . 5 . 3 Project Focus : The Evolution of Writing Techniques The topic of the animation was decided together with the school teachers , who wanted to dedicate many hours to this activity , but at the same time needed to cover the mandatory topics of their syllabus . The teacher of technology used to create with students a poster to visualize the evolution of writing techniques ; following our suggestion , she volunteered to change her methodology and to create an animation instead . The evolution of writing techniques was considered a good topic , as it is multidisciplinary ; indeed , it involves history , technology , and art to draw backgrounds and actors . Therefore , this choice shows to the students how CT is applied to other disciplines . The following writing techniques were identified and assigned to one ( or more ) team : clay tablet , papyrus , wax tablet , vellum paper , paper , and digital writing . As detailed in Section 4 . 3 , each team was asked to brainstorm and to create a mind map using a document that was created together with the history teacher , which contained the relevant in - formation about each technique , such as the method of production , primary characteristics , era , population , and writing style . During each development iteration , each team was asked to create the storyboard for the scene and perform the feasibility analysis . Afterwards , the students needed to draw backgrounds and characters manually , following the instructions of the teacher of art ( Figure 3 ) . Then , they could scan their drawings and improve them using Gimp ( www . gimp . org ) . At the end of each iteration ( which means when a scene was complete ) , the team needed to check the conformance with the requirements and connect the new scene with the existing ones . Each team was interviewed at the end of each iteration , as detailed in Section 4 . 4 . 2 . During the entire devel - opment process , particular attention was paid to fostering all the computational practices through , for example , iterations , frequent testing , and reuse of previously created code ( Section 4 . 1 ) . 6 RESULTS First , this section describes the results of the initial survey ( Section 6 . 1 ) . Then , the results of the students’ performance are reported ( Section 6 . 2 ) . At the end of the section , an assessment of tools and strategies adopted in this framework is presented ( Section 6 . 3 ) . 6 . 1 Initial Survey This section reports the results of the initial survey . ACM Transactions on Computing Education , Vol . 17 , No . 4 , Article 19 . Publication date : August 2017 . Teaching Computational Thinking using Agile Software Engineering Methods 19 : 17 Fig . 3 . Students were asked to draw backgrounds and characters manually . Fig . 4 . What is computer science ? What is CS ? Each student was asked to write a definition of CS using her / his words . In Figure 4 , the size of each word depends on the number of times it appears in the responses ; we con - sider this figure an indicator that the participants associate CS to the usage of technology ( Fronza et al . 2014 ) . What would you like to learn in a CS course ? Fifty percent of the participants wanted to learn how to use better their devices . To explain their answers , they provided examples , including writing text faster , drawing , browsing , saving files , copying documents , creating folders , and social networks . Some students also would like to understand how a computer works , learn how to program , and find out how to build a website . We consider these answers as indicators that the participants are average middle school students who consider computers as commodities ( Fronza et al . 2014 ) and most of the time are not aware of the potential usage of computers ( e . g . , programming ) beyond the everyday one ( e . g . , browsing ) . This information could be particularly relevant for replication purposes , in case other researchers would like to repeat the investigation under similar conditions while varying the subject popu - lation ( Wohlin et al . 2012 ) . Furthermore , this information could help teachers in understanding whether they could obtain results similar to ours by applying the framework in their classes . 6 . 2 Assessment of Students’ Performance Table 5 shows the results of the two parts of the assessment that took place during the introductory part , namely after Exercise 4 and after Exercise 7 . At the end of Exercise 4 , 78 . 6 % of the participants obtained a positive evaluation ( as defined in Section 4 . 4 . 1 ) of the following concepts : sequences , events , parallelism , and loops . Within this group , 14 . 3 % of the students obtained a good evaluation , as they understood “broadcasting , ” besides ACM Transactions on Computing Education , Vol . 17 , No . 4 , Article 19 . Publication date : August 2017 . 19 : 18 I . Fronza et al . Table 5 . Introductory Part : Results of the Two Assessments After Exercise 4 ( % ) After Exercise 7 ( % ) Negative 21 . 4 0 . 0 Sufficient 64 . 3 73 . 8 Good 14 . 3 26 . 2 Total 100 100 Fig . 5 . Deliverables of the first phase : Mind map and storyboard . “wait , ” as a solution to handle events ; moreover , they could explain the difference between “for - ever” and “repeat until . ” At the end of Exercise 7 , each student reached a positive evaluation of CT concepts . Furthermore , 26 . 1 % of the students obtained a good evaluation ; 48 % of this group also showed a basic understanding of the concepts operators and data . At the end of the project part , all students delivered simple software systems that represented effectively the assigned part of history and technology . The 18 developed software systems rep - resent sequential animations with a minimum level of interaction ( e . g . , users are asked to push a key to continue ) . All the delivered systems do not show errors , and , for each one , the execution follows a logical flow . Furthermore , each final product has a good level of accuracy on its initial conception , considering a comparison of the final product against its corresponding storyboard . Figure 5 shows two examples of the mind maps and storyboards created during the project part . A website ( http : / / www . inf . unibz . it / ~ ilefronza / ct4all / ) has been created to display more examples of intermediate and final products developed following the course’s methodology . The analysis of the final versions of the developed software systems , which is reported in Table 6 , shows that the 18 solutions to a similar problem are rather different regarding the con - sidered metrics . The analysis of blocks distribution indicates that control and looks were the most used ones ( 41 . 5 % and 40 . 9 % , respectively ) , followed by motion ( 9 . 6 % ) and sound ( 7 . 9 % ) blocks . As expected , the type of project did not require to use data and operators blocks ( Adams and Webster 2012 ) . The values of Computational Complexity ( CC ) reported in Table 6 are consistent with the ex - isting literature , where this kind of systems ( i . e . , animations for storytelling ) are reported to have lower CC with respect to other types of systems ( e . g . , games ) . Indeed , they usually have more linear structures with fewer branches and decision points ( Adams and Webster 2012 ) . However , as noted by Raymond ( Raymond 2004 ) , a level of unnecessary complexity might be introduced if ACM Transactions on Computing Education , Vol . 17 , No . 4 , Article 19 . Publication date : August 2017 . Teaching Computational Thinking using Agile Software Engineering Methods 19 : 19 Table 6 . Animations : Descriptive Statistics min 1 st qu median mean 3 rd qu max Number of blocks 69 118 . 2 234 293 . 5 330 . 8 1258 Number of sprites 3 7 . 3 13 . 5 15 . 6 21 . 5 36 Number of costumes 5 10 . 3 18 . 5 24 . 6 31 . 5 79 Number of scenes 3 4 . 3 6 . 5 7 7 17 Number of backgrounds 1 4 . 0 4 . 5 5 . 8 6 . 8 22 Avg . Number of blocks per stacks 3 . 2 4 4 . 7 5 . 7 6 . 2 10 . 9 Cyclomatic complexity 7 . 0 20 . 3 57 . 5 58 . 4 86 . 3 159 . 0 Fig . 6 . Linear relationship between CC and number of sprites , costumes , and scenes . programmers do not pay attention to good design and programming rules and practices . Conse - quently , in our 18 solutions , complexity could be uselessly high , instead of representing a system with many scenes and characters , which requires a more difficult logic to control switches and interactions . For this reason , we performed an analysis which reveals the existence of a linear relationship between CC and number of sprites , costumes , and scenes ( Figure 6 ) . The three lin - ear relationships are significant ( p - values < 0 . 5 ) and , respectively , 66 % , 72 % , 70 % of the data are well predicted ( with 95 % of significance ) by these models . These results allow us to use CC as an indicator of the different levels of mastering of the CT concepts and the tool set . Also , no significant linear relationship emerges between CC and the number of backgrounds ; indeed , during the development process we noticed that teams often used several backgrounds to limit the changes of costumes and the number of actions ( thus reducing the coordination logic ) , by drawing some actors in the backgrounds , in different positions or costumes . Five teams achieved top CC scores ( ≥ 90 ) ; two of these teams were each formed by two girls , while the other three teams were formed by two boys . The top three projects are available on - line : http : / / www . inf . unibz . it / ~ ilefronza / ct4all / . For the entire duration of the activities , these teams stood out for their creativity and willingness to outperform . Moreover , they managed team dynam - ics constructively and learned concepts and tool set very quickly : They were always scoring high in the interviews and required faster interviews at the end of each iteration . The lowest CC score ( i . e . , 7 ) was achieved by one team . In this case , the two team members needed a longer adjustment period in the transition to collaborative programming . In principle , this could not have been an issue : This period is well known also in industry , as the period in which developers are said to “jell” ( Katzenbach and Smith 1993 ; Fronza and Succi 2009 ; Di Bella et al . 2013 ) . Nevertheless , in the case of this team , the frequent absences of one of the students worsened the situation and lowered the motivation of both the students . However , this case emphasizes the effectiveness of our iterative ACM Transactions on Computing Education , Vol . 17 , No . 4 , Article 19 . Publication date : August 2017 . 19 : 20 I . Fronza et al . approach , as it ensured that even this team could end the activities with a working , although very simple , system . The assessment framework detailed in Section 4 . 4 foresees interviewing each team at the end of each iteration ( i . e . , when a new scene is complete ) . The main goal of the interviews at the end of each iteration is to provide information for formative assessment and not to obtain quantitative data . In this view , the students’ answers were used to help the instructors identifying learners’ areas of strength and weakness , to plan instruction to build on the one and remediate the other . For this reason , we report here an examination of how these interviews supported the students in their learning process . As shown in Table 6 the number of scenes variates largely from team to team . As this number corresponds to the number of planned interviews that was performed , unplanned assessment and feedback ( Bell and Cowie 2001 ) were required for those teams that performed a limited number of iterations , which are the teams that experienced more problems during the development and therefore proceeded at a slower pace . Indeed , these teams were often stuck on a task while working on a scene and required help to move on ; in this case , we assisted the team , or involved the class in a short discussion about the problem if this was considered to be useful for everybody . In opposition , some skilled teams demonstrated to have good progress working independently , and they got positive assessment faster . It should be taken into account that these teams included one or more students that obtained a “good” evaluation at the end of the introductory part . Among these teams are the five teams that produced the projects with the highest number of scenes ( 5 to 17 ) and with higher CC ( higher than 90 ) . In these cases , the entire interview was required only once and the second round of interviews focused on some critical points outlined in the previous interviews ( e . g . , debugging ) . Starting from the third iteration , we could just ask some of the questions and dedicate more time to solving curiosities , checking the conformance with the requirements , and planning how to evolve the project , as the teams completed their planned activities faster . For these teams , fewer unplanned feedback sessions were required . In the case of the other four teams , interviews were repeated 2 or 3 times with most of the questions . At the end of these interviews , we provided suggestions to a team or the entire class when it could be helpful for more students . The most common suggestions are as follows : ( 1 ) check an exercise of the introductory part where a concept was used and try to reuse that solution in this case , ( 2 ) continue working on the same scene during the next iteration and try fixing the problems we found , ( 3 ) try the alternative solution we have suggested during the interview , ( 4 ) review the scene to respect your requirements , and ( 5 ) ask another team that solved the same problem successfully . During the next iteration and the next interview , we checked whether our suggestions were followed . One of the suggestions that encountered some objection was to keep working on the same scene , especially when that meant reducing the initial requirements of the team . In these cases , the role of the instructors was to convince the students that it was not a defeat and that having a simple , but working , animation would have been better . Moreover , the instructors tried to isolate the causes of the team’s slowness and in a couple of cases that meant trying to solve team issues ( e . g . , different ideas on the prosecution ) . What we could observe is that , in general , after the first iterations , the participants did not perceive the conversations as an assessment ; instead , they took advantage of interviews to get feedback and , to this end , they were happy to explain their work . During these interviews we involved all the team members to check that all of them had a balanced level of knowledge ; this means that , as much as possible , and even if this could result in having a final product with lower quality , we wanted to avoid having a team where one of the members was excluded because of her / his weakness and the other members worked with their faster pace . In case one of the team members was showing difficulties in understanding some ACM Transactions on Computing Education , Vol . 17 , No . 4 , Article 19 . Publication date : August 2017 . Teaching Computational Thinking using Agile Software Engineering Methods 19 : 21 concepts , we focused on her / him to fill the gaps , and we explained to the rest of the team that helping her / him would have resulted in a better result for the entire team . As for computational practices , the main criticalities were found for testing and debugging and for abstracting and modularizing . Indeed , half of the students were able to debug autonomously at the end of the project , while the other half was able to debug after getting some hints from the teachers . Moreover , the students were usually so proud of their solutions that they did not try to provide alternative solutions . For abstracting and modularizing , when asked about the organization of the scripts , those three teams that were ordering stacks of blocks per actor typically answered : “scripts of actor 1 are here , and scripts of actor 2 are there , ” but they could not explain why . Regarding computational concepts , the analysis of blocks to assess the learning of computational concepts and the inspections performed during the interviews reveal that all the participants could create sequences of commands , as they could complete the project . Moreover , they could coordinate parallel actions , as in all the projects the green flag starts multiple sprites’ actions . For events , in 16 projects broadcasting is used . The manual inspection of the two animations that do not use broadcasting shows that the authors just used “wait” instead of “broadcasting . ” For example , in one project the object “stilo” needs to appear at the end of the stack shown in Figure 7 ( a ) ; to do that , the authors decided to start stilo’s actions with the green flag and then let the “stilo” wait for the stack in Figure 7 ( b ) to be completed . Mastering of events would have been demonstrated by the solution in Figure 7 ( c ) and ( d ) , where stilo appears as soon as a message is broadcasted by the other actor . This suggestion was given to the authors of this project during the interviews during the development process ; the students were able to explain how broadcasting worked but did not feel confident enough with this concept to chance their “working” solutions . The main difficulties were found in the application of conditionals . In this type of project , condi - tionals could be useful , for example , to let one sprite do something when touching another sprite ; for instance , Sprite 1 might need to disappear when Sprite 2 touches it . Figure 8 ( a ) shows the most , very basic , adopted solution : Sprite 1 waits until Sprite 2 arrives at its location ( the team was count - ing the seconds needed ) and then Sprite 1 disappears . During the interviews , we explained how this solution could be improved as follows ( Figure 8 ( b ) ) : Sprite 2 is walking , and when it touches Sprite 1 , Sprite 1 disappears . Despite the examples in the introductory phase , and the additional explanations provided , only one team started to use conditionals autonomously , which means they started using conditionals after the additional explanations provided during an interview . By definition , computational perspectives cannot be captured by frameworks that assess concepts and practices ( Brennan and Resnick 2012 ) . This means that neither code analysis nor interviews can help assessing them directly . For this reason , together with school teachers , we looked for indicators of the development of computational perspectives . During the activities , for example , the students abandoned the idea of CS as “use of technology” towards the awareness of the pos - sibility to use computation for self - expression ( i . e . , “expressing” perspective ) . Moreover , we could observe the increase of intra - and inter - team interactions , for example , to exchange ideas or reuse others’ solutions ( i . e . , “connecting” ) . Also , students were less and less passive over time and , in the end , some of them were also proposing alternative solutions or even creating new problems to be solved ( i . e . , “questioning” ) . Table 7 summarizes what students learned regarding computational concepts and practices . 6 . 3 Assessment of Tools and Strategies The introductory part guaranteed that all the participants had sufficient knowledge of all the CT concepts . Nevertheless , during the project part , in many cases , we noted that the students expe - rienced problems , especially in using the CT concepts autonomously in a new context . During the projects , indeed , they were required to identify problem themselves ; select the most effective ACM Transactions on Computing Education , Vol . 17 , No . 4 , Article 19 . Publication date : August 2017 . 19 : 22 I . Fronza et al . Fig . 7 . Manual inspection of code to assess the learning of events . solution , using the introductory part as a basis and for inspiration ; and , finally , create their solu - tions . Therefore , the introductory part and the project part complement each other to cover all the cognitive processes using Bloom’s taxonomy ( Anderson et al . 2001 ; Bloom and Krathwohl 1956 ) . The introductory part covers the lower part of Bloom’s pyramid ( i . e . , remembering , understanding , and applying ) , while the project part allows covering the higher part ( i . e . , analyzing , evaluating , and creating ) . The results of this experiment , therefore , confirm the importance of proposing a project part to make sure that students move from the first level of “knowing” concepts to being able to use and apply those concepts ( Adams and Webster 2012 ) . Even if it requires further evaluation , the assessment framework seems promising , as it creates a valuable setting for developing CT skills ( Brennan and Resnick 2012 ) . Indeed , it is repeated at several points of time . Moreover , it involves projects evaluation , and it requires students to be able to define a concept and to put it to use . Furthermore , despite seeming to be “time consuming” at ACM Transactions on Computing Education , Vol . 17 , No . 4 , Article 19 . Publication date : August 2017 . Teaching Computational Thinking using Agile Software Engineering Methods 19 : 23 Fig . 8 . Manual inspection of code to assess the learning of conditionals . Table 7 . Computational Concepts and Practices : The Participants’ Learning Outcome Concepts Sequences All the participants could create sequences of commands correctly Events Thirty - eight of 42 participants could use broadcasting correctly . Four participants could use “wait” instead of “broadcasting” ; even if they were suggested to use broadcasting many times , they did not feel confident enough with this concept to chance their “working” solutions Parallelism All the participants could coordinate parallel actions . For example in all the projects the green flag starts multiple sprites’ actions Conditionals Three participants could use conditionals autonomously , after the additional explanations provided during an interview . The rest of the students could explain the “Conditionals” concept but did not feel confident enough to apply it PracticesBeingincremental and iterative All the students learned the main elements of an incremental and iterative process , such as reviewing intermediate work products , assessing the current functional products , and setting new plans Testing and debugging Twenty - one of 42 participants were able to debug autonomously at the end of the projects ; the other 21 participants were able to debug after getting some hints from the teachers . Reusing and remixing All the participants could identify , adapt , and reuse previous code to the current situation Abstracting and modularizing Six of 42 participants could order stacks of blocks per actor first sight , it is intended to be a formative assessment . This means that students ( and teachers ) can take advantage of interviews to guide the following steps of the project . Moreover , interviews can be faster from time to time , as teachers can just focus on the critical points outlined in the previous interviews . The application of the framework during the experiment revealed that , for the “weaker” students , one interview at the end of each iteration is not enough , as they tend to have longer iterations and need further assistance . Considering an Agile approach where students acted as developers , and instructors as product owners , we exercised the following practices : ( 1 ) Organizational controls on iterations : guided interviews to identify what is working and what is not and determine the individual contribution of all team members . ( 2 ) Technical controls on iterations : review intermediate work products ; assessment of the current functional products ; informal review of the backlogs ; set new plans ; and so on . ACM Transactions on Computing Education , Vol . 17 , No . 4 , Article 19 . Publication date : August 2017 . 19 : 24 I . Fronza et al . This structure helped teams to guarantee that , using iterations , they could accomplish a working product , even though in some occasions it had very limited functionality . We introduced the following non - computer support tools to aid students setting down their ideas and structuring them in a way in which eventually they can integrate them into their software systems : ( 1 ) mind maps ; ( 2 ) storyboards ; ( 3 ) feasibility table . For these three tools , it is important to note that usually students were eager to use computa - tional tools to set up a software system . It was the task of the instructors to discuss and convince them about the added value of using pencil and paper to structure an idea that eventually can be integrated ( scanned , translated ) to the software system . With respect to the feasibility table , it was a challenge to deliver the idea that several aspects of the system can be done in a limited time span and some others should be left out . Students often believed that anything was possible , even in a limited time frame , and , as a consequence , in the last lessons , they struggled to finish incomplete sections . 6 . 4 Answer to Research Question Considering the results of our experiment , the research question addressed in this article can be answered as follows . The proposed framework is effective at teaching CT in middle schools , as shown by the positive evaluations that all the participants reached at the end of our experiment . Thus , Agile software engineering methods can be suggested to organize the development process in class ; indeed , our experiment shows that most of the advantages that are obtained using Agile in a professional environment can also be attained in middle schools . Nevertheless , with respect to a professional environment , the specificity of the target ( i . e . , 12 - year - old students ) requires the introduction of additional tasks to allow students to explore , project , and experience a potential product before using the software tools at hand . To do that , in this article we suggested additional tools and strategies ( e . g . , mind map ) with respect to traditional software development . Furthermore , according to the teachers’ feedback , the students reached all the educational objec - tives of the topics involved in the multidisciplinary activities . This can be taken as a first indicator that it can be possible to use computing as a medium for teaching other subjects , offered by other courses besides computer science ; the multidisciplinary project , indeed , included history , technol - ogy , and art . Moreover , it is relevant to mention that involving other subjects ( like art and history ) in the CT course shows the software development aspects as a piece of a project of a larger scope , where the time is to be invested also away from a computer terminal . With this approach , the CT abilities are exercised to favor the acquisition of additional knowledge , offered by other courses and instructors , and the software system is used as a tool to reflect , reinforce , and confirm the concepts acquired in other subjects . Also , those students who are discouraged in learning scien - tific topics might get close to CS through a different path , being less influenced by their previous opinions . 7 DISCUSSION AND FUTURE WORK We foresee tremendous value to this research work by repeating the experiment described in this article , with the purpose of ensuring repeatability and reproducibility . Replication would confirm the validity of the observations reported in this article and would allow us to single out eventual differences intrinsic to the grade , type of class , and so on . Furthermore , one of the issues that needs further exploration is the framework that was developed to assess the development of CT . To this ACM Transactions on Computing Education , Vol . 17 , No . 4 , Article 19 . Publication date : August 2017 . Teaching Computational Thinking using Agile Software Engineering Methods 19 : 25 end , more experiments would help in validating and refining the framework . In this experiment , despite being time consuming , the assessment framework helped in revealing conceptual gaps . Moreover , the participants did not perceive the conversations as an assessment ; instead , they took advantage of those moments to get help or solve issues and , to this end , they were happy to explain their work . Even if it requires further evaluation , the assessment framework seems promising , as it creates a valuable setting for developing capacities for CT ( Brennan and Resnick 2012 ) , because ( 1 ) it is repeated at several points of time , and it is useful to address possible issues ; ( 2 ) projects are examined ; ( 3 ) students are encouraged to think about their processes ; and ( 4 ) students need to be able to define a concept and to put it to use . Evaluations would also be of high relevance to understanding the types of problems beginners face in their early programming experiences that go beyond syntactical issues . In a different track , this evaluation would supply relevant information to determine the areas that require further development both conceptually and practically . 8 CONCLUSION This article describes the design and implementation of an educational framework to teach CT skills based on Agile software development practices . The implementation of this framework in an Italian middle school allowed us to collect evidence on the assimilation and exercising of CT skills by observing how the sixth - grade students with little or no background in software development were able to design and implement a working software application . Students and teachers engaged in a collaborative effort that binds not only CS but other subjects like history and art . CT skills deliver necessary resources to help students to analyze and decompose a problem using mind maps , understand its complexity and feasibility , design a solution implementing storyboards , and develop a working software application successfully . As CT is a valuable resource for students , regardless of the future career they pursue , putting timely effort into developing CT is important , which should be cultivated in the K - 12 environment . Having a design and implementation methodology contributes to cultivating and profiting from these CT skills and to put them into the service of the subjects of different study courses . This helps as well to accomplish a seamless integration of CT with the current K - 12 curriculum . REFERENCES Pekka Abrahamsson , Ilenia Fronza , Raimund Moser , Jelena Vlasenko , and Witold Pedrycz . 2011 . Predicting development effort from user stories . In Proceedings of the 2011 International Symposium on Empirical Software Engineering and Mea - surement ( ESEM’11 ) . 400 – 403 . Joel C . Adams and Andrew R . Webster . 2012 . What do students learn about programming from game , music video , and storytelling projects ? In Proceedings of the 43rd ACM Technical Symposium on Computer Science Education ( SIGCSE’12 ) . ACM , New York , NY , 643 – 648 . Alfred V . Aho . 2012 . Computation and computational thinking . Comput . J . 55 , 7 ( July 2012 ) , 832 – 835 . DOI : http : / / dx . doi . org / 10 . 1093 / comjnl / bxs074 Lorin W . Anderson , David R . Krathwohl , Peter W . Airasian , Kathleen A . Cruikshank , Richard E . Mayer , Paul R . Pintrich , James Raths , and Merlin C . Wittrock . 2001 . A Taxonomy for Learning , Teaching , and Assessing : A Revision of Bloom’s Taxonomy of Educational Objectives . Allyn & Bacon ( Pearson Education Group ) , Boston , MA . Valerie Barr and Chris Stephenson . 2011 . Bringing computational thinking to K - 12 : What is involved and what is the role of the computer science education community ? ACM Inroads 2 , 1 ( Feb . 2011 ) , 48 – 54 . Brigid Barron , Caitlin Martin , Eric Roberts , Alex Osipovich , and Michael Ross . 2002 . Assisting and assessing the develop - ment of technological fluencies : Insights from a project - based approach to teaching computer science . In Proceedings of the Conference on Computer Support for Collaborative Learning : Foundations for a CSCL community , 2002 . International Society of the Learning Sciences , 668 – 669 . Beverley Bell and Bronwen Cowie . 2001 . The characteristics of formative assessment in science education . Sci . Educ . 85 , 5 ( 2001 ) , 536 – 553 . DOI : http : / / dx . doi . org / 10 . 1002 / sce . 1022 ACM Transactions on Computing Education , Vol . 17 , No . 4 , Article 19 . Publication date : August 2017 . 19 : 26 I . Fronza et al . Ernest N . Biktimirov and Linda B . Nilson . 2006 . Show them the money : Using mind mapping in the introductory finance course . J . Financ . Educ . 32 , 3 ( 2006 ) , 72 – 86 . Benjamin S . Bloom and David R . Krathwohl . 1956 . Taxonomy of Educational Objectives : The Classification of Educational Goals , by a Committee of College and University Examiners . Handbook I : Cognitive Domain . Longmans , Green , New York , NY . Bryce Boe , Charlotte Hill , Michelle Len , Greg Dreschler , Phillip Conrad , and Diana Franklin . 2013 . Hairball : Lint - inspired static analysis of scratch projects . In Proceeding of the 44th ACM Technical Symposium on Computer Science Education ( SIGCSE’13 ) . ACM , New York , NY , 215 – 220 . Karen Brennan and Mitchel Resnick . 2012 . New frameworks for studying and assessing the development of computational thinking . In Proceedings of the 2012 Annual Meeting of the American Educational Research Association ( AERA’12 ) . 1 – 25 . Tony Buzan and Barry Buzan . 2000 . The Mind Map Book . BBC Books , London . Mario Cardinal . 2013 . Executable Specifications with Scrum : A Practical Guide to Agile Requirements Discovery ( 1st ed . ) . Addison - Wesley Professional . Patricia Charlton . 2013 . Computational Thinking and Computer Science in Schools . Retrieved Januay 2 , 2015 from http : / / www . lkl . ac . uk / cms / files / jce / articles / time _ to _ re - loadwhattheresearchsaysbriefing27april2012 . pdf . Mike Cohn . 2004 . User Stories Applied : For Agile Software Development . Addison - Wesley Professional . Mike Cohn . 2005 . Agile Estimating and Planning . Pearson Education . Steve Cooper and Steve Cunningham . 2010 . Teaching computer science in context . ACM Inroads 1 , 1 ( March 2010 ) , 5 – 8 . National Research Council . 2010 . Committee for the Workshops on Computational Thinking : Report of a Workshop on the Scope and Nature of Computational Thinking . Technical Report . National Research Council . Dan Crow . 2014 . Why Every Child Should Learn to Code . ( feb 2014 ) . Retrieved November 3 , 2015 from http : / / www . theguardian . com / technology / 2014 / feb / 07 / year - of - code - dan - crow - songkick . Martin Davies . 2011 . Concept mapping , mind mapping and argument mapping : What are the differences and do they matter ? Int . J . High . Educ . Educati . Plan . 62 , 3 ( September 2011 ) , 279 – 301 . Peter J . Denning and Peter A . Freeman . 2009 . The profession of IT : Computing’s paradigm . Commun . ACM 52 , 12 ( Dec . 2009 ) , 28 – 30 . Enrico Di Bella , Ilenia Fronza , Nattakarn Phaphoom , Alberto Sillitti , Giancarlo Succi , and Jelena Vlasenko . 2013 . Pair pro - gramming and software defects—A large , industrial case study . IEEE Trans . Softw . Eng . 39 , 7 ( 2013 ) , 930 – 953 . Tore Dybå . 2000 . Improvisation in small software organizations . IEEE Softw . 17 , 5 ( Sept . 2000 ) , 82 – 87 . Norman E . Fenton and Niclas Ohlsson . 2000 . Quantitative analysis of faults and failures in a complex software system . IEEE Trans . Softw . Eng . 26 , 8 ( Aug . 2000 ) , 797 – 814 . Allan Fisher and Jane Margolis . 2002 . Unlocking the Clubhouse : The Carnegie Mellon Experience . MIT Press , Cambridge , MA . Ilenia Fronza , Nabil El Ioini , and Luis Corral . 2015 . Students want to create apps : Leveraging computational thinking to teach mobile software development . In Proceedings of the 16th Annual Conference on Information Technology Education ( SIGITE’15 ) . ACM , New York , NY , 21 – 26 . Ilenia Fronza , Nabil El Ioini , Andrea Janes , Alberto Sillitti , Giancarlo Succi , and Luis Corral . 2014 . If I had to vote on this laboratory , I would give nine : Introduction on computational thinking in the lower secondary school : Results of the experience . Mond . Digit . 13 , 51 ( 2014 ) , 757 – 765 . Ilenia Fronza and Giancarlo Succi . 2009 . Modeling spontaneous pair programming when new developers join a team . In Proceedings of the 10th International Conference on Agile Processes and eXtreme Programming in Software Engineering ( XP’09 ) . Ilenia Fronza and Patrick Zanon . 2015 . Introduction of computational thinking in a hotel management school [ Introduzione del computational thinking in un istituto alberghiero ] . Mond . Digit . 14 , 58 ( 2015 ) , 28 – 34 . Shuchi Grover . 2015 . “Systems of assessments” for deeper learning of computational thinking in K - 12 . In Proceedings of the Annual Meeting of the American Educational Research Association . 1 – 9 . Shuchi Grover , Stephen Cooper , and Roy Pea . 2014 . Assessing computational learning in k - 12 . In Proceedings of the 2014 Conference on Innovation and Technology in Computer Science Education ( ITiCSE’14 ) . ACM , New York , NY , 57 – 62 . Shuchi Grover and Roy Pea . 2013 . Computational thinking in k – 12 : A review of the state of the field . Educ . Res . 42 , 1 ( Jan . / Feb . 2013 ) , 38 – 43 . Richard F . Gunstone . 1992 . Probing Understanding . Falmer . Susanne Hambrusch , Christoph Hoffmann , John T . Korb , Mark Haugan , and Antony L . Hosking . 2009 . A multidisciplinary approach towards computational thinking for science majors . SIGCSE Bull . 41 , 1 ( March 2009 ) , 183 – 187 . ISTE and CSTA . 2011 . Computational Thinking : Teacher Resources ( 2nd ed ) . Retrieved December 2014 from http : / / csta . acm . org / Curriculum / sub / CompThinking . html . ( 2011 ) . Italian Ministry of Education . 2014 . Retrieved May 20 , 2015 from La buona scuola in 12 punti . https : / / labuonascuola . gov . it / documenti / I _ 12 _ punti . pdf ? v = b4d78c0 . ACM Transactions on Computing Education , Vol . 17 , No . 4 , Article 19 . Publication date : August 2017 . Teaching Computational Thinking using Agile Software Engineering Methods 19 : 27 Association for Computing Machinery ( ACM ) Joint Task Force on Computing Curricula and IEEE Computer Society . 2013 . Computer Science Curricula 2013 : Curriculum Guidelines for Undergraduate Degree Programs in Computer Science . ACM , New York , NY . Magne Jorgensen and Martin Shepperd . 2007 . A systematic review of software development cost estimation studies . IEEE Trans . Softw . Eng . 33 , 1 ( 2007 ) , 33 – 53 . Karl M . Kapp . 2013 . The Gamification of Learning and Instruction Fieldbook : Ideas into Practice ( 1st ed . ) . Pfeiffer & Company . Jon R . Katzenbach and Douglas K . Smith . 1993 . The Wisdom of Teams : Creating the High - performance Organization . Harvard Business Press . Caitlin Kelleher and Randy Pausch . 2007 . Using storytelling to motivate programming . Commun . ACM 50 , 7 ( July 2007 ) , 58 – 64 . Paul A . Kirschner , John Sweller , and Richard E . Clark . 2006 . Why minimal guidance during instruction does not work : An analysis of the failure of constructivist , discovery , problem - based , experiential , and inquiry - based teaching . Educ . Psychol . 41 , 2 ( 2006 ) , 75 – 86 . Kyu Han Koh , Ashok Basawapatna , Vicki Bennett , and Alexander Repenning . 2010 . Towards the automatic recognition of computational thinking for adaptive visual language learning . In Proceedings of the 2010 IEEE Symposium on Visual Languages and Human - Centric Computing ( VLHCC’10 ) . IEEE Computer Society , Washington , DC , 59 – 66 . Kyu Han Koh , Ashok Basawapatna , Hilarie Nickerson , and Alexander Repenning . 2014 . Real time assessment of com - putational thinking . In Proceedings of the 2014 IEEE Symposium on Visual Languages and Human - Centric Computing ( VL / HCC’14 ) . 49 – 52 . Lucas Layman , Laurie Williams , Kelli Slaten , Sarah Berenson , and Mladen Vouk . 2008 . Addressing diverse needs through a balance of agile and plan - driven software development methodologies in the core software engineering course . Int . J . Eng . Educ . 24 ( 2008 ) , 659 – 670 . Michael Lodi . 2014 . Imparare il pensiero computazionale , imparare a programmare . Mond . Digit . 13 , 51 ( 2014 ) . Jane Margolis . 2008 . Stuck in the Shallow End : Education , Race , and Computing . The MIT Press . Robert Cecil Martin . 2003 . Agile Software Development : Principles , Patterns , and Practices . Prentice Hall PTR , Upper Saddle River , NJ . Thomas J . McCabe . 1976 . A complexity measure . IEEE Transactions on Software Engineering SE - 2 , 4 ( Dec 1976 ) , 308 – 320 . Orni Meerbaum - Salant , Michal Armoni , and Mordechai ( Moti ) Ben - Ari . 2010 . Learning computer science concepts with scratch . In Proceedings of the 6th International Workshop on Computing Education Research ( ICER’10 ) . ACM , New York , NY , 69 – 76 . Jesús Moreno - León , Gregorio Robles , and Marcos Román - González . 2015 . Dr . Scratch : Automatic analysis of scratch projects to assess and foster computational thinking . Revi . Educ . Dist . 46 ( September 2015 ) , 1 – 23 . Jesús Moreno - León , Gregorio Robles , and Marcos Román - González . 2016 . Comparing computationalthinking development assessment scores with software complexity metrics . In Global Engineering Education Conference ( EDUCON’16 ) . IEEE , 1040 – 1045 . Fersun Paykoç , Bünyamin Mengi , Pınar Olgun Kamay , Pınar Önkol , Birikim Özgür , Olga Pilli , and Hamide Yıldırım . 2004 . What are the major curriculum issues ? The use of mindmapping as a brainstorming exercise . In Proceedings of the 1st International Conference on Concept Mapping , Vol . 2 . 457 – 467 . Ljubomir Perković , Amber Settle , Sungsoon Hwang , and Joshua Jones . 2010 . A framework for computational thinking across the curriculum . In Proceedings of the 15th Annual Conference on Innovation and Technology in Computer Science Education ( ITiCSE’10 ) . ACM , New York , NY , 123 – 127 . Jane Chu Prey and Alfred C . ( Alf ) Weaver . 2013 . Fostering gender diversity in computing . Computer 46 , 3 ( March 2013 ) , 22 – 23 . Syed M . Rahman and Paul L . Juell . 2006 . Applying software development lifecycles in teaching introductory programming courses . In Proceedings of the 19th Conference on Software Engineering Education Training ( CSEET’06 ) . 17 – 24 . Eric Steven Raymond . 2004 . The Art of Unix Programming . Addison - Wesley . Alexander Repenning , David Webb , and Andri Ioannidou . 2010 . Scalable game design and the development of a checklist forgettingcomputationalthinkingintopublicschools . In Proceedings ofthe41stACMTechnical SymposiumonComputer Science Education ( SIGCSE’10 ) . ACM , New York , NY , 265 – 269 . Mitchel Resnick , John Maloney , Andrés Monroy - Hernández , Natalie Rusk , Evelyn Eastmond , Karen Brennan , Amon Mill - ner , Eric Rosenbaum , Jay Silver , Brian Silverman , and Yasmin Kafai . 2009 . Scratch : Programming for all . Commun . ACM 52 , 11 ( Nov . 2009 ) , 60 – 67 . Amber Settle , Baker Franke , Ruth Hansen , Frances Spaltro , Cynthia Jurisson , Colin Rennert - May , and Brian Wildeman . 2012 . Infusing computational thinking into the middle - and high - school curriculum . In Proceedings of the 17th ACM Annual Conference on Innovation and Technology in Computer Science Education ( ITiCSE’12 ) . ACM , New York , UNY , 22 – 27 . ACM Transactions on Computing Education , Vol . 17 , No . 4 , Article 19 . Publication date : August 2017 . 19 : 28 I . Fronza et al . Allen Tucker , Dennis McCowan , Fadi Deek , Chris Stephenson , Jill Jones , and Anita Verno . 2003 . A Model Curriculum for K - 12 Computer Science : Report of the ACM K - 12 Task Force Computer Science Curriculum Committee . ACM , New York , NY . Anna Van der Aa . 2014 . Should our software development process begin with storyboarding ? Retrieved from http : / / www . ensci . com / uploads / media / memoire _ Anna _ VanderAa . pdf . R . Vinayakumar . 2014 . Learning computational thinking with scratch programming . Retrieved from http : / / scratched . gse . harvard . edu / sites / default / files / . Jagoda Walny , Sheelagh Carpendale , Nathalie Henry Riche , Gina Venolia , and Philip Fawcett . 2011 . Visual thinking in action : Visualizations as used on whiteboards . IEEE Trans . Vis . Comput . Graph . 17 , 12 ( Dec 2011 ) , 2508 – 2517 . Linda Werner , Jill Denner , Shannon Campe , and Damon Chizuru Kawamoto . 2012 . The fairy performance assessment : Measuring computational thinking in middle school . In Proceedings of the 43rd ACM Technical Symposium on Computer Science Education ( SIGCSE’12 ) . ACM , New York , NY , 215 – 220 . DOI : http : / / dx . doi . org / 10 . 1145 / 2157136 . 2157200 Jeannette M . Wing . 2006 . Computational thinking . Commun . ACM 49 , 3 ( 2006 ) . Jeannette M . Wing . 2014 . Computational thinking benefits society . Retrieved September 17 , 2015 from http : / / socialissues . cs . toronto . edu . Claes Wohlin , Per Runeson , Martin Höst , Magnus C . Ohlsson , Björn Regnell , and Anders Wesslén . 2012 . Experimentation in Software Engineering . Springer Science & Business Media . Received January 2016 ; revised February 2017 ; accepted February 2017 ACM Transactions on Computing Education , Vol . 17 , No . 4 , Article 19 . Publication date : August 2017 .