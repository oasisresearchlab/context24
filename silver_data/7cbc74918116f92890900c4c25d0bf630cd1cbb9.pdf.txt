Programming at Runtime : Requirements & Paradigms for Nonprogrammer Web Application Development Jochen Rode Virginia Polytechnic Institute and State University 3 160 Torgersen Hall Blacksburg , VA 24061 , USA jrode @ vt . edu Abstract + I - 540 - 23 1 - 6140 We investigate the femibiliy of nonprogramnier web application development andpropose the creation of end - userprogramming tools that address the issire at a high level of abstraction . The results of three related empirical studies and one proto @ ping effart are reported . We surveyed nonprogrammers ’ needs for web applications and studied how nonprogrammers would naturally approach web developnient To express whar a tool should provide we suniniarize high - level components and concepts employed by web applications . To express how a tool may provide its functionalify , we propose “Programming - at - Runtime I’ - a programming paradigm that is in its core similar to the automatic recalculation in spreadsheets . Finally , we introduce “FlashLight” - a protoype web development tool for nonprogranimers . 1 . Introduction Today , thanks to the availability of WYSIWYG web editors , even nonprogrammen can mate websites . No longer is knowledge of HTML the sine qua non . As a result , the web has become more accessible as a publishing medium . For the most part , however , progress in end - user development environments has been limited to tools for the creation of static websites . Even now , years after the rise of CGI scripting , and other server - side technologies , a high level of technological expertise is required to create interactive web applications . Research in web engineering has addressed issues in web development from the perspective of professional programmers . Small - scale development by end - users has not yet been a focus in research or industry . We argue that it is time to focus more on empowering nonprogrammers as developers . By making web development possible for a wider audience , we may see a greater variety of useful applications , including applications not yet envisioned . Indeed , the WWW in general is an excellent example of what can happen when technology becomes accessible . Desbpande and Hansen [ IZ ] , the co - founders of the web engineering discipline , argue that we need to “devise methods and processes to assist end users” which would help to increase the reliability of applications and ‘Mease the creative power of people . ” Enabling end - users to serve their own ‘programming” needs may also have economical benefits . Often , hiring a Mary Beth Rosson Virginia Polytechnic Institute and State University 504 McBryde Hall Blacksburg , VA 24061 , USA rosson @ cs . vt . edu programmer is not cost - effective . Furthermore , if the user and the developer are one and the same person , it seems likely that system requirements will be better understood . Of course , it is unlikely that end - users will ever develop complex web applications without the help of an experienced programmer . But we predict that end - users have many needs for applications that are quite simple , and that the many such needs are similar in nature . If w are right , we may he able to provide end - user programming ( EUP ) tools that addresses a significant proportion of these web programming needs . In considering the web programming needs of end - users , we suggest that a good starting point is to analyze and develop tools for sophisticated end - users , individuals who have considerable experience in web design but not in the use of web programming technologies - these end - users are likely to have a good understanding of the potential of interactive web applications hut not the skills or knowledge to realii this potential . Thus , our initial target audience is comprised of people who a ~ experienced in web - design but have not yet turned towards programming , For the remainder of this paper we simply refer to this group as “nonprogrammers” . In the balance of the paper , we first report a survey of requirements for web applications . We then describe a study of the mental models that nonprogrammers have of web programming . , We follow this with a brief survey of the components , concepts and functionality that basic web applications typically employ . This knowledge builds a foundation for what functionality should be included in an end - user web programming tool . In the second half of the paper , we shift our attention to how nonprogrammers might be supported in web programming - we motivate and describe an EUP approach called “programming - at - runtime” . We illustrate the approach with a prototype tool - Flashlight - that implements a subset of the requirements collected from our target audience and application survey . We conclude with discussion of open issues and future work . 2 . Nonprogrammer web application development : The status quo + 1 - 540 - 23 1 - 6470 The research most related to our work is in end - user programming , Even before the rise of the web , end - user programming of basic data management applications has been a topic in research and industry , with Apple’s Hypercard a well - known and successful EUP tool . With respect to web applications , an E W example is WebFormulate [ 2 ] , a tool for building web applications that is itself web - based and thereby platform - independent . FlashLigb - the tool that we introduce later - adopts a similar approach to ensure that it is platfonn - independent . FAR [ 7 ] combines ideas from spreadsheets and debased programming with drag - and - drop web page layout to help end - usm develop online services . An important concept that we draw from this work is that of immediate feedback : Tanimoto coined the term liveness to describe how a software development tool gives semantic feedback [ 29 ] . He defmes different levels of this concept ranging from no feedback ( level 1 ) to immediate incremental feedback for each program modification ( level 3 , 4 ) . With its automatic recalculation feature , the spreadsheet paradigm is a familiar example of level 3 liveness . With ‘‘Glue’’ Fry [ I41 proposes to simplify web development through a textual programming language that unifies the functionality and power of traditional languages and standards ( HTML , XML , JavaScript , Java etc . ) . The < bigwig > project [ 5 ] approaches the problem by suggesting different sub - languages that are specialized for a particular problem domain . Although this method solves some typical problems like form - field validation in an efficient manner , it introduces new complexity with different syntaxes for the sub - languages . As a more powerful substitute for the combination of HTML , CSS , and JavaScript , Hostetter et al . [ I61 propose Curl , which they describe as “a gentle slope language for the web” in reference to the user’s learning curve . A review of commercial tools suggests that industry has embraced EUF’ in web development perhaps even more than the research community . Several EUP - like web development environments are commercially available . Instantis’ online development tool “Sitewand” [ 17 ] and Ampersand‘s codegenerator “Zerocode” [ 3 ] are just two examples . While not specifically targeted for the web Microsoft’s yet - to - be - released product InfoPatb [ 21 ] appears to be a powerful E W tool for creating data gathering and management applications . The “Laszlo Presentation Server’’ [ IS ] addresses most of the problems that currently complicate web application development but does not yet offer visual EUP tools . Our informal review of projects on sourceforge . net and fresbmeat . net suggests that the open - source community has not yet adequately addressed the topic of end - user web application development . Although the idea of web EUP is implemented by some projects ( e . g . [ 20 ] , [ Ill ) we are unaware of any open - source tools that would satisfy more than basic end - user programming needs . 3 . End - users’ needs for web applications Our fKst step toward understanding the scope needed by wehEUP was to characterize the kinds of web applications our target population would like to build . In May 2002 we conducted an online survey of webmasters at our university [ 24 ] . Out of the 1357 individuals who were contacted , 67 ( 5 % ) responded to the survey . One survey question asked the participants to indicate “opportunities for interactive websites [ a . k . a . web applications ] in [ their ] environment” . We found that about one third of the web applications described by these users might be implemented by nonprogrammers who had a high - level development tool that offered basic data storage and retrieval functionality . Another 40 % of the requests could be satisfied by a set of five customizable generic web applications ( resource reservation , shopping cart and payment , message board , content management , calendar ) . Research on tailorabilify ( e . g . [ 19 ] ) bas shown that software can be designed for easy customization by end - users . Diverse requests for more advanced applications comprised the remaining 25 % . Of particular interest to us were the 34 % of the requests that would have been satisfied by basic data collection and management , because such functionality seems quite reasonable to provide via a web - EW tool . 4 . How nonprogrammers naturally approach web development To empower nonprogrammers , we need better tools ; but to provide better tools we must understand the expectations of prospective tool users - their mental models of how applications work . In the following me describe a study of how nonprogrammers think about the behavior of web applications . This study adapts the methods of Pane , Ratanamahatana and Myers [ 22 ] , who designed a “natural” programming language for children by first studying how children and adults use natural language to solve programming problems . 4 . 1 . Participants We recruited participants for a two - part paper and pencil study : labeling screen elements ; specification of application behavior . We created a simple web application ( member registration and management ) for the study . Ten participants were sampled randomly kom organizational webmasters who had reported in a previous survey that they had significant experience in web authoring but none or little in programming . Five wex female , and five male . Pre - and post - study interviews revealed that one person had more programming experience than initially reported ( use of Macromedia ColdFusion for a simple web application ) . 4 . 2 . Test procedure Participants were given a general introduction to the goals of the study , then asked to view and label three screenshots from the application ( login , member list , add member ) . The labeling instructions included a sample labeled image ( a room with objects ) , including nested items . Next , participants explored the sample application until they were comfortable with bow it worked . After the familiarization phase , participants were given seven user tasks ( login , paging , user - specific listing , add member , sort , search , delete ) and asked to “teach” these 24 Screen element Web page Text mnut field Labels provided by the Participants page 141 , page and screen interchangeably [ 4 ] field 131 mnut field 131 box or text box 121 These results confirmed our expectation that experience web authors possess a “technical” understanding of a web application’s visible elements . This understanding should provide a foundation for more advanced skills . when describing the application‘s behavior , participants tended to combine procedural steps and declarative statements . They used declarative statements to specify constraints on behavior ( e . g . “certain fields are required” ) . Procedural statements often conveyed a test and result ( e . g . . “If the password is incorrect , that field is cleared” ) or a page transaction ( e . g . , “Type the colTect password into the field and Enter ; this action opens the Members page” ) . Except for the user with ColdFusion experience , no one mentioned constructs such as variables and loops in the behavior specifications . Where looping constructs are required ( e . g . authenticating a user ) , the participants specified one iteration , seeming to expect that it would apply ( i . e . . be repeated ) as necessary . We were particularly interested in how these usem described webspecific data processing - e . g . , client - server interaction , HTML generation , the web‘s stateless nature , and so on . Only three users included any description of what happens “behind the scenes” in a web application ( e . g . , mentioning interactions with a server ) . Even these participants made no effort to describe page transactions in detail ( e . g . , no one discussed how information is fwarded between pages ) . Most participants ( 7 of 10 ) refend to application data as a database ; another talked Member list about a file . This is consistent with their general use of a “technical” vocabu1 ; uy . However , only one included communication between the application and database ( “sends command to the database on the server telling it to query” ) . Though comfortable with the concept of a database , the others seem to see it as a placeholder for a background resource . In a similar fashion , users often referred to a “member list” or a “member” as if these abstractions are simply available for use as needed no one womed about how an application obtains or manages data . We thought that the search and sort tasks might evoke informal descriptions of algorithms , but most participants focused on a result ( e . g . , what the user sees next in a table ) rather than on how a data listing was obtained . Six users seemed to assume that the “magical machine” manages user authentication ; four offered as a detail that user data must be checked against a list or table of valid IDS . 4 . 4 . Implications for Web - EUP As expected , end - users familiar with web authoring are comfortable with terms commonly used to describe user interface elements , and with general abstractions like database and file . Their descriptions of how applications retrieve and process information contain a mixture of declarative constraints and simple event - processing procedures . For most , the programming logic needed to retrieve and organize the application data , format it , etc . , was simply assumed . Tools like Macromedia Dreamweaver enable end - users to create and format sophisticated web pages , but do not provide adequate support for building non - hivial web applications . The nonprogrammers in our study seemed to know the role of screen elements , but were not interested ( or able ) to specify bow these roles would be implemented . lhese fmdmgs are not particularly surprising and suggest that an end - user web development tool should work at a high level of abstraction , to better match the mental models of nonprogrammers . The focus should be on providing and interconnecting already - hctional components , rather than laying out visual elements and then connecting them to code that “makes them work” . 5 . The elements of basic web applications A second step we took in assessing the requirements for web - EUP was to determine the components , concepts , and functionality needed to implement simple data collection and management web applications . This assessment is important in determining the features needed to make a web - EUP tool sufficiently powerful . Rather than limiting ourselves to applications repotted by survey respondents , we analyzed existing web applications . We recognize that neither this analysis of existing applications nor survey and interviews data will provide a full picture of the applications nonprogrammers might want to develop in the future . However , we believe we can obtain a reasonable approximation by looking at what has been done in the past . table IS ] , dynamic table [ I ] , data table [ l ] 25 Member add , etc . lid 141 , action [ 3 ] , option [ 31 , function [ 3l It is impossible to review all web applications that on disregarded simple dynamic websites ( scripting only used the public web or private Intranets ; we restricted our for navigation , header & footers , no database ) and focused analysis to a sample of web applications available at our on those applications that were close to the needs university . We used Google and its filtering capabilities expressed by the survey respondents , ending up with a set ( e . g “filetype : asp site : mysite . edu” ) to fmd applications in of 61 example applications . Wese included databases for use at our institution . Using file extensions that indicate people , news items , publications , job offers , policies , dynamic content ( . asp , . aspx , . php , . php3 . . cfm , . jsp , . pl , conference sessions , plants , service providers and so on . . cgi ) we were able to fmd a large number of cases . We Radiobutton , Combohox , Listbox , Textfield , Link qVnaniic Outmtt Image Button Name I Description Static text , Checkbox , I Basic input , output and action components Output of variable content ; text or image ( e . g . input value of a textfield ) Picture that may occur in a decorative role or as data to be managed by the application Invokes an action ; related to concept of screen navigation , database etc . Menu Scrollable content I Offers a flat or hierarchical set ofchoiccs and invoke5 an action I Displays data through a scrollable \ rindow if it is too large to be show 35 a whole I Altributes that det - me look 8 : feel of components ( e . g . text si7u , font . color ) : these ma } I File upload Table 2 : High - level components , concepts & functionality of typical basic web applications I Upload of images , PDF documents and other file - based resources I ( Concepts marXed in italics are those that are currently implemented by our prototype tool ) 26 We reviewed the applications that were publicly accessible and constructed a list of concepts and components found within these basic web applications ( see Table 2 ) . The components , concepts and functions that we derived can be viewed as high - level equivalents to low - level language constructs , predefmed functions , objects and methods in classical text - based programming languages ( e . g . for - loop , while - loop , if , print ) . Of course . commercial Web development tools already offer much of the high - level functionality listed in Table 2 , but these tools are not aimed at nonprogrammers . We expect the list of elements to change and grow along with our knowledge about web applications and the progress of technology . We see this list as simply a start towards a functional requirements list for web - EUP tools . 6 . Programming - at - runtime Studies of programming have analyzed several key subtasks - analysis , design , coding , and testing [ 23 ] . Withim each of these subtasks , a picture of active programming bas emerged , similar to the strategies of active use described for end - users working with word processors or other desktop applications [ 8 ] [ 9 ] . That is , programmers are goal - directed and use available resources to produce concrete results as rapidly as possible . This strategy may work against traditional structured and top - down methods of analysis and design [ I31 in that it tends to promote opportunistic and interleaved attention to the different subtasks . For example , an experienced designer may identify a low - level implementation question very early on and proceed in a depth - fmt fashion to explore the issue before jumping back to a more abstract level of analysis [ 10 ] [ 1 ] [ 15 ] . Similarly , programmers who ax evaluating code resist comprehending it line by line , instead searching for “beacons” that signal key elements for attention [ 6 ] . When programming tools are available , programmers recruit them in support of an iterative and heterarchical design and development process . For instance , the Smalltalk environment provides a sophisticated debugger that enables programmers to identify and expand references to objects at runtime . This promotes a strategy of “debugging into existence , ” wherein expert Smalltalk programmers do the minimum amount of analysis and programming needed to construct a running application ; they successively refme it by finding where it “breaks , ” correcting the source of the problem , locating the next problem , and so on [ 26 ] [ 27 ] . These studies of active programming strategies provide a scientific grounding for our work on nonprogrammer tools - indeed we expect end - users to be even more active and result - oriented than experienced sothvare developers . For example , a nonprogrammer is less likely than a programmer to worry about designing an elegant system arcbitecture . Many studies of computer use have demonstrated that for the most part end - users do not want to “learn” but rather to “produce” , and will use whatever information or resources available to help them make sense of a task just enough to make progress [ 8 ] . Given this view of programmers as active users , we propose an altemative to the programming paradigm of typical visual web development tools ( e . g . , Macromedia Dreamweaver MX or Visual Studio . Net ) which we believe will make web application development more accessible to nonprogrammers . We call the paradigm “Programming - at - Runtime” . The programming - at - runtime concept builds from the ideas of direct manipulation [ 28 ] and the “debugging into existence” behavior [ 27 ] studied in professional programmers . In its core it is similar to the automatic recalculation aspect in spreadsheet programs . A critical piece of the concept is that the user is able to both develop and use the application without switching back and forth between programming and runtime modes . That is , the application is always usable to the fullest extent that it has been programmed . The end - user programmer alternates between constructing and “us @ g” the application until he or she tries to use an object with a not - yet - defined behavior . At this point the user is guided through a dialog to define”the missing behavior . This interleaving of development and use continues until the whole application has been defmed and tested . The applicability of programming - at - runtime reacbes beyond just web development - the paradigm could be used by prognmmers and nonprogrammers alike , in any domain . However , our focus is on web - EUP and our discussion addresses this particular application of the general concept . Of course , the usefulness of working with live data instead of placeholders at design - time has been realized before . In Macromedia Dreamweaver MX , developers can switch to the so - called ‘2ive Data View” . In this mode live web pages are shown and some adjustments can be made . However , Dreamweaver does not allow developers to actually use their developing applications - for example , hyperlinks do not work in this mode . Therefore , the developer still must repeatedly switch between different interaction modes . 6 . 1 . Pros & Cons Although we have not yet conducted any experiments to compare programming - at - runtime against classical mode - based programming we believe that it has a number of advantages . The paradigm embraces the naturally occuning tendency for “debugging into existence” . The programming environment gives immediate feedback to any actions and changes by the developer . Programming - at - runtime delivers true What - You - See - Is - What - You - Get ( WYSIWIG ) , because the developer always works with live data . Finally , the application under development is implicitly subject to continuous testing . This may help to improve the reliability of the resulting application . However , there are still many unresolved issues regarding the realization of the programming - at - runtime paradigm . For example , developers need a means to distinguish whether they want to execute or edit an already - defmed button action - therefore , at least a minimal notion of a runtime mode vs . design mode is still needed . Another example for the challenges of programming - at - 27 runtime is a component that outputs a value which momentarily is empty . It may be tedious for the developer to determine the role of the output component or even worse , he or she may not even notice the component at all - some concept of roleexpressive placeholders for empty values may still be needed . 7 . FlashLight - A web development tool for nonprogrammers As a proof - of - concept for a web development tool that employs the programming - at - runtime paradigm and that may be suitable for nonprogrammers we created a system called “FlashLight” ( see Figure I ) . It is a prototype tool ( http : / / purl . vt . edu / flashlight ) using a combination of Flash MX and other web programming technologies . This early prototype implements a subset of the concepts and components that may appear in a typical web application . The tool works at a high level of abstraction in order to hide the complexities of web application development . It currently allows users to create multi - screen web applications for data collection . 7 . 1 . Programming in FlasbLight In FlashLight , developers design a series of screens by dragging components like checkboxes , radio - buttons , or text input fields onto the workspace . Screens can be selected via tabs ( see Figure I ) . Developers can edit the component properties at any time by clicking on a small yellow dot that visualizes a “handle” for the component . The components are fully functional as soon as they are dragged onto the workspace - text input fields allow user input , buttons can be clicked and so - called “output text components” display live data . Application - specific functionality is programmed by dragging buttons onto a screen and clicking them . If a button already has an action ( e . g . go to screen xyz , save data record ) associated with it , the action is immediately performed ; otherwise a dialog with the user is initiated to specify an action . The dynamic behavior of the application is controlled by defming “action rules’’ which are pairs of conditions and associated actions . Figure 1 shows a screenshot of FlashLight that depicts the process of defming an action rule . The screenshot shows that three rules have already been associated with the button to define what it should do depending on the user’s inputs . In a similar manner the user can defme the behavior of the “output text” component . So - called output rules determine what kmd of output is shown under certain conditions . Flashlight also simplifies application deployment . Once a developer saves an application ( FileBave ) , the , properties inspector of each screen displays a webaddress that can be pasted into a browser to access the working application . Every screen is given a unique web address . Thus an application may offer different functionalities to different users ( e . g . data input for general public , data browsing for authorized users only ) . Authentication and authorization are not yet implemented in FlashLight but are simply work waiting to be done . 7 . 2 . Database Model FlasbLight’s underlying database model is simple as the development of a powerful and scalable database layer has not been a priority for this prototype . The database model is represented by a set of data records , each of which contain the values that correspond to the user inputs from checkboxes , radio - buttons , and input text components during one user session . The data entered by the user is automatically kept persistent throughout the application allowing the user to jump back and forth between different screens . On one hand , our implementation of the database model simplifies development by biding the database layer from the developer ( as our requirements study suggested ) . On the other hand , it has severe limitations . In FlashLight , there is always a one - to - one mapping between an input component and a database field . It is currently not possible to have two input components correspond to the same value in the database . This would be needed to implement “add record” together with “edit record” functionality in a web application - in fact a rather basic requirement . A fully functional EUP tool would need to address the problem by decouplmg input components from database fields . Also , FlashLight only handles databases with exactly one type of record ( or table ) , and . web applications ofme contain more than one type ( e . g . a library application would contain a data table for books , one for patrons etc . ) . Finding a good way to represent the entity - relationship - model ( multiple database tables and relationships via keys ) to a nonprogrammer is a challenge for further research . Following a commonly - used approach [ 18 ] [ 30 ] [ 31 ] , FlashLight stores metadata describing the application in a custom XML format . User data is stored on the server in a similar fashion . 7 . 3 . Platform We developed FlashLight using Flash MX and the integrated programming language ActionScript . FlashLight implements a small subset of what is possible with Flash - hence its name . Flashlight components running on a server use PHP to save application metadata and data into XML files for persistent storage . We chose Flash mainly because of its flexibility , rapid prototyping support , and web delivery capability . Nevertheless , we do not endorse Flash as an ideal platform for comprehensive web development tools . Potential alternatives are a desktop application ( written in C + t , Java , Visual Basic , C # etc . ) , or a classical ( D ) m - b a s e d web application h t t e n in ASP , PWP , ColdFusion or Java . Indeed , our experiences with Flash have been mixed . A frequent complaint - that Flash’s movie metaphor gets in the way of application programming - turned out to have a simple solution . We ignored the movie metaphor and placed all ActionScript code within one movie frame . 28 when Flash applications are published on the web , another advantage becomes apparent : Flash’s file format is compact . The FlashLight tool itself is only slightly larger than lOOKB , making it suitable for download - on - demand . Last but not least , Flash communicates readily with server - side scripts . The information exchange between client and server can be accomplished in three ways : via Hl - Il’ - parameter - value pairs , raw XML or the proprietary hut more powerful “Flash remoting . ” FlashLight communicates using XML . We found “Flash remoting” to he an attractive alternative if the client needs to frequently exchange small data packages with the server . On the downside , although ActionScript is object - oriented , it seems limited in terms of scalability . We externalized all of the ActionScript code using Flash’s “ # include” directive ; nonetheless , we found it difficult to enforce a maintainable code simcture and avoid unwanted side - effects . If we continue to develop web - EUP tools in Flash , we will need to develop a sound and extensible software engineering framework to manage the code base . S . Summary and Discussion We conducted a survey to determine the needs of OUT audience . We cannot easily generalize the survey findings because the selection process was limited to associates of our educational institution and self - selection may have biased the outcome . However , for our particular sample we conclude that ahout one third of all requests for web applications represented basic hut custom information gathering and management applications like online job application , member management or service request forms . These requests seem to be a good target for EW . The results of OUT mental - models study may gendize to other nonprogrammer webmasters . The results confirm that such users understand web programming at a high level of abstraction . Concepts like session management and database are just assumed to work “out - of - the - box” . The review of existing web applications withim our institution helped us to compile a list of elements that most basic web applications employ . An EUP tool would need to implement these components and address the concepts in order to be sufficiently powerful . There are many possible ways in which a development tool might interact with its users . We have proposed the 29 " programming - at - runtime " paradigm as a user - friendly option . The paradigm embraces the naturally occurring tendency for " debugging into existence " , gives immediate feedback to any actions and changes by the developer , provides almost true WYSIWIG , and implicitly subjects the application to continuous testing . FlashLight , our prototype EUP tool , demonstrates how programmjng - at - runtime may be implemented and how web application development can be made accessible to nonprogrammers . 9 . Future Work We have taken several small but important steps towards our vision of web - Em . More work needs to be done to establish requirements for EUP tools . Because the desired functionality for a tool will always be a moving target , we should continue to query end - users about their application needs . Replications of user surveys similar to ours are needed to validate and generalize our fmdings for different settings . The programming - at - runtime paradigm - for example , as illustrated by OUT FlashLight prototype - must be evaluated empirically to determine how well it meets nonprogrammers ' needs , and how it might be improved to meet these needs more effectively . If the approach is found to be sound , the programming - at - runtime tool must be refmed and made available to end - users in their normal work environment , so that they cm apply it to their longstandmg or ad hoc application needs . The potential for nonprogrammer web application development is there . It just needs to be realized . 10 . Acknowledgements We thank B . Collier Jones for inspiring the idea of programming - at - runtime in a web development context . and for his valuable feedback throughout our research . 11 . References [ I ] Adelson . B . andE . Soloway ( 1985 ) . " The role of domain experience in software design . " EE Transactions on Soffware Engineering SE - 11 : 233 - 242 . [ 2 ] Ambler , A and J . Leopold ( 1998 ) . Public Programming in a Web World . Visual Languages . Nova Scotia , Canada . 131 Ampersand ( 2003 ) . zerocode . March 13 , 2003 . http : l / www . zerocode . com / [ 4 ] Apple Computer Inc . ( 1987 ) . Hypercard User ' s Guide . [ 5 ] Brabrand , C . , A Moeller , et al . ( 2002 ) . " lbe < bigwig > project . " ACM Trans on Intemet Technology 2 ( ? ) : 79 - 114 . 161 Brooks , R ( 1983 ) . " Towards a theory of the comprehension of computer programs . " Intemational Journal of Man - Machine Studies 18 : 543 - 554 . 171 Bumett , M . S . K Chekka , et al . ( 2001 ) . FAR : An End - User Language to Support Cottage E - Services . HCC - 2001 IEEE Symposia on Human - Centric Computing Languages and Environments ; Stresa , Italy . [ SI Carroll , J . M . ( 1990 ) . The Numberg Funnel : Minimalist Instruction for Computer Skill . Cambridge , MA , MIT Press . [ 9 ] Carroll , 1 . M ( 2000 ) . Making use : Scenario - based design of human - computer interactions . Cambridge , MA , hlrr press . [ IO ] Camoll , 1 . M , J . C . Thomas , et al . ( 1979 ) . " Clinical - experimental analysis of design problem solving . " Design Studies 1 : 84 - 92 . [ Ill CUOnline ( 2003 ) . Form Generator Pro . http : / / www . c - u - online . net / generators / fo ~ generatorpro - v31 1121 Deshpande , Y . , S . Hansen ( 2001 ) . " Web Engineering : Creating a Discipline among Disciplines . " IEEE MultiMedia 8 ( 2 ) : 82 - 87 . [ 13 ] Dijkstra , E ( 1968 ) . " GOT0 considered harmful . " Communications of the ACM ll ( 3 ) : 147 - 148 . [ I41 Fry . C . ( 2001 ) . The World Wide Train Wreck Is there light at the end of the tunnel ? HCC ~ 2001 IEEE Symposia on Human - Centic Computing Languages and Environments ; Symposium on End - User Programming , Stresa , Italy . [ 15 ] Guindon , R ( 1990 ) . " Designing the design process : Exploiting opportunistic thoughts . " Human - Computer Interaction 5 : 305 - 344 . [ 16 ] Hostetter , U , D . Kranz , et al . ( 1997 ) . " Curl : A Gentle Slope Language for the Web . " WWW Joumal Il ( 2 ) . [ I71 Instantis ( 2003 ) . Sitewand March 13 , 2003 . http : / / www . instantis . com / 1181 Laszlo Systems ( 2003 ) . Laszlo Presentation Server . March 20 , 2003 . http : / / www . laszlosystems . coml [ I91 MacLean , A , Carter , K , Levstrand , L . Moran , T . ( 1990 ) . User - Tailorable Systems : Pressing Issues with Buttons . ACM . Proceedings of CHI 1990 175 - 182 . 1201 McDermott , Peter ( 2001 ) . Bricks Site Builder . http : Nbricks . sourceforge . net / [ ZIlMicrosoft ( 2003 ) . Infopath . March 20 , 2003 . http : l / www . microsoft . comloftice / preview / infopatW [ 22 ] Pane , J . F . , C . A Ratanamahatana , et al . ( 2001 ) . " Studying the language and structure in non - programmers ' solutions to programming problems . " International Joumal of Human - Computer Studies 5 4 237 - 264 . [ 23 ] Pemington . N . and B . Grabowski ( 1990 ) . The tasks of programming . In Psychology of Programming . T . R G G . J . - U Hoc . R Samurpay , and D . J . Ghore . London , Academic Press : 45 - 62 . 1241 Rode , J . and M B . Rosson ( 2003 ) . End - User Web Aoolication Develooment : A Swev of Needs and Ch ; llenges . Submittid . 1251Rosson , M B . ( 1996 ) . The human factor in software & v & opment . In Handbook of Computer Science and Engineering . Boca Ratou . FL , CRC Press : 1596 - 1617 . [ 26 ] Rosson , M B . and J . U Carroll ( 1993 ) . Active programming strategies for reuse . Proceedings of ECOOP ' 93 : Object - Oriented Programming . 7th European Conference , Kaiserslautem , Germany , 26 - 30 July , Springer - Verlag . 1271 Rosson , U B . and J . M Carroll ( 1996 ) . " The reuse of uses in Smalltalk programming . " ACM Transactions on Computer - Human Interaction 3 ( 3 ) : 219 - 253 . [ 28 ] Shoeidemuan , B . ( 1983 ) . Direct Manipulation : A Step Beyond Programming Languages . IEEE Computer . 16 57 - 69 . [ 29 ] Tanimoto , S . ( 1990 ) . VIVA A Visual Language for Image Processing . Jonmal of Visual Languages and Computing l ( 2 ) : 127 - 139 . 1301 Turau . V . ( 2002 ) . A framework for automatic generation of webbased data entry applications based on XML . 17th Symposium on Applied Computing , Madrid , Spain , ACM [ 3 I ] Zdun , U . ( 2002 ) . Dynamically Generating Web Application Fragments from Page Templates . 17th Symposium on Applied Computing . Madrid , Spain , ACM 30