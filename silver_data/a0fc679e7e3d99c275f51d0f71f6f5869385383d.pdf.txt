Reimplementation and Reinterpretation of the Copycat Project Hongyi Huang ∗ Northeastern University 440 Huntington Ave Boston , MA 02115 h . hongyi @ northeastern . edu Abstract We present the reinterpreted and reimplemented Copycat project , an architecture solving letter analogy domain problems . To support a ﬂexible implementation change and rigor testing process , we propose a implementation method in DrRacket by using functional abstraction , naming system , initialization , and structural ref - erence . Finally , beneﬁts and limitations are analyzed for cognitive architectures along the lines of Copycat . 1 Introduction Copycat intends to model and prove that analogies are the source of human behavioral ﬂuidity and creativity [ 12 ] . These letter analogy problems are given for the program to solve . For example , the problem abc : abd : : ijk : ? could have answers ijl , ijd , or even abd — L being the successor of K , D being the literal letter substitution , and abd being the complete direct substitution . However , humans give the answer ijl more often than other answers statistically . Other answers are the result of different mental pressures producing different plausible answers . With this in mind , the model should produce answers in similar frequency . Formally , the letter analogy problem is denoted as initial : modiﬁed : : target : answer . The interpretation for Copycat is written in 1980s , before the bloom of reinforcement learning and machine learning . On one hand , these two ﬁeld could potentially formalize the analogy problem . On the other hand , traditional reinforcement learning models has yet to address the viability to act and learn broadly and ﬂuidly . This paper tries to connect each method by analyzing their respective beneﬁts and limitations . Figure 1 : The initial conﬁguration of Copycat’s Workspace with descriptions attached . ∗ Currently in Viewpoint School ; 23620 Mulholland Hwy , Calabasas , CA 91302 . Alternative email address : f . huang19 @ viewpoint . org . Preprint . Work in progress . a r X i v : 1811 . 04747v1 [ c s . A I ] 26 O c t 2018 2 Background 2 . 1 Research Approach Cognitive architectures are aspects of cognition that remain constant in an agent [ 13 ] . Copycat is an example of so that consists of three main constant components to solve letter - domain analogy problems — Workspace , Coderack , and Slipnet [ 12 , 6 ] . The architecture is a step towards Newell and Minsky’s urge to both bridge the symbolism - connectionism gap and to address all different layers of abstraction in human actions [ 11 , 13 ] . Research in cognitive architectures involves dealing with unknown components of cognition , thus traditional Popperian data - hypothesis falsiﬁcation process does not apply [ 13 , 1 ] . In the experimental process of these types of studies , some long - held assumptions are assumed to be true in order to test another central hypothesis . Copycat’s hypothesis is that analogies are the source of human behavioral ﬂuidity and creativity . To evaluate progress scientiﬁcally , Lakatos proposed that these research programs are composed of assumptions in a core and hypothesis in a protective belt , in which the assumptions within the belt is adjusted when empirical evidence refutes the hypothesis [ 8 ] . This standard has been commonly used to assess how much progress has been made for research in other modern cognitive architectures [ 14 ] . To make scientiﬁc progress , later research projects must change and manipulate parts of the earlier architectures , such as the Marshall’s Metacat that builds upon Copycat’s architecture [ 9 ] . If such architectures are easy to implement , test and understand , this would not be much of a problem at practice . However , these architectures are often complex and include handcrafted knowledge to hold the core assumption of cognition constant . Later researchers could spend a signiﬁcant amount of time to investigate software not maintained or documented properly . In this case , Marshall had to rewrite the code in Chez Scheme for the Metacat project instead of reusing Common - Lisp code from a few years ago . Maintaining a consistent and efﬁcient practice would contribute to reusable code . Figure 2 : Lakatosian’s core assumptions and falsi - ﬁable protective belts when facing inconsistency . Figure 3 : Part of Slipnet with examples of node length attached to a node , length shrinks if the corresponding node activates . 2 . 2 Copycat Three important components that enable ﬂuidity and creativity are Workspace , Coderack , and Slipnet . The method is described in [ 12 ] , but is included for completeness of this paper . In summary , Slipnet enables ﬂuidity through conceptual slippages , Workspace creates a mental blackboard for storing perceived relationships between letters , and Coderack runs Codelets to explore possible outcomes Workspace . Practical implementation methods are discussed in section 3 , and a reinterpretation using modern methedologies of reinforcement learning is described in section 4 . 1 . Workspace consists of a set of permanent structures for the problem description and a set of temporary structures for working towards a sensible answer . It corresponds to a mental representation of the real world . The structures of Workspace consists of are as follows : letter , group , description , bond , correspondence , rule , and replacement . The Workspace stores each of them in an array or vector . • Letters and Groups make up object . • Letter consists of a single letter . • Group consists of multiple consecutive letters . • Descriptions , bonds , correspondences , rules , and replacements make up objects . • Descriptions are attached to a particular object . 2 • Bonds are object relationships within initial , modiﬁed , target , or answer . • Correspondences are object relationships between initial , modiﬁed , target , or answer . • Rule is a hypothesis regarding how the initial is transformed to the modiﬁed string . • Replacement is a rule that applies on the target to the answer string . Slipnet contains platonic concepts that are linked together ( see ﬁgure 3 ) . Nodes that represents concepts are activated when perceived from Workspace . These slippages are giving context of what is relevant to inform Codelet’s non - determistic search trajectory . Activated nodes and spread their activations to neighbor nodes who are close . A node is discontinuously fully active when it is activated more than 50 % . Node activation also decays of the activation of a node is directly proportional to conceptual depth — measuring how deep a pattern is hidden from a perceivable surface symbol . Coderack consists of an array of codelets instances . A codelet type can be activated by other codelets or activations from the Slipnet . It incorporates ideas from Slipnet that are activated to test plausibility of its hypothesis from Workspace . Currently , codelet instances cooperate in the chained order of scouting - testing - building and ﬁghts other incompatible structures . Codelets can be classiﬁed into different groups that corresponds to what type of structure it deals with , with the exception of breaker codelet . Random codelet scouts are posted according to the state of Slipnet and Workspace , which ﬁnds plausible structure that could be applied . Strength - tester codelets will then be posted by scouts to evaluate how well does the structure ﬁt in context of Workspace and Slipnet state . A builder codelet will be eventually posted by strength - testers to generate the structures in Workspace . During these processes , corresponding concepts in Slipnet may be activated to inform related scouts to be posted . In implementation , a codelet is passed around as lambda - function and gets instantiated when arguments applies to it . • Scout codelet probabilistically chooses an object or objects on which to build the structure , and asks " is there any reason for building this type of structure with these objects ? " • If yes , a strength - tester codelet asks " is the proposed structure strong enough ? " • If yes , a builder codelet tries to build the structure , ﬁghting against competitors if necessary . Figure 4 : A runtime example of problem abc : abd : : ijk : ? ’s Slipnet with activations of node displayed , not including links between nodes . Statistical Regulation Coderack also incorporates information — how deep a concept is ( concep - tual depth ) , how well an information is integrated ( happiness ) , how important an information is ( importance ) — to inform the probabilities which information should be used in testing the theory it corresponds to . In general , it uses an mechanism of temperature to gauge how deterministic the 3 program should be . It intends to address the exploration vs . exploitation problem in the face of many distinct possible answers [ 7 ] . Speciﬁcally , codelets measure salience of relevant objects through a function of happiness and importance to make a probabilistic choice . Higher salience will correspond to a higher probability to be used . 2 . 3 DrRacket We implemented the model in DrRacket . Like most lisp languages , DrRacket is designed to be used functionally . Most syntax other than the low level functions does not use mutations to boost performance and encourage coders to be able to test as there should be no global mutable variables present [ 5 ] . In addition , functions can be stored as data to highly abstract . Both factors enable a programmer to understand and write a segment of code quickly . # lang racket ( define X 10 ) ; d e f i n e s a c o n s t a n t of 10 ; myadd1 : number − > number ( a f u n c t i o n a l c o n t r a c t ) ( define ( myadd1 x ) ( + x 1 ) ) ; d e f i n e f u n c t i o n ( check - expect ( myadd1 X ) 11 ) ; t e s t s myadd1 In the context of implementing a complex program such as Copycat , an test or example of the function should be written ﬁrst for future readers to understand what the function does . The function of the code is an hypothesis of how a programmer can implement according to the test . Following is a pseudo - code example of such philosophy . For large projects of implementations , contracts and tests are kept in a separate runnable ﬁle and then copied into a documentation catalog . ; update : world − state − > world − state ( define ( update state ) < code - here > ) ( check - expect ( update < old - state > ) < new - state > ) A data structure is deﬁned and used as follows : ( define - struct mylist ( first rest ) ) ( define example1 - mylist ( make - mylist 1 ( make - mylist 2 empty ) ) ) ( check - expect ( mylist - first example1 - mylist ) 1 ) 2 . 4 Function as Arguments A function can be passed in as an argument into another function . We used this feature to sort through complex data structures in Copycat and abstract operations . For example , the following built in function apply and map takes in function and a list . ( check - expect ( apply + ( list 1 2 3 4 5 ) ) 15 ) ( check - expect ( apply * ( list 1 2 3 4 5 ) ) 120 ) ( check - expect ( map add1 ( list 1 2 3 4 5 ) ) ( list 2 3 4 5 6 ) ) 2 . 5 Macros for Making Domain Speciﬁc Language Macros are preprocessors that transpiles one set of syntax to another . DrRacket itself is built this way that translates # lang racket to a core set of performance effective instructions [ 3 ] . The design originated from a set of questions related to how to pass functions as arguments . Eventually , the designers decided to allow translation between datum and syntax , also exposing the macros library . Using this to advantage , one can build another level up from # lang racket and make an customized language . Details and examples are described in section 4 . 2 . 4 3 Methods 3 . 1 Naming Conventions and Memory Allocation Both OOP and functional language associates the data with the function . The common perception is that OOP has an advantage of inheritance and a one time memory allocation . One can avoid the problem of hard to keep track function names of different data type by proper naming technique . We named all functions with the data type it operates and the operation : " < data - type > - < operation - name > " . For example " workspace - structure - to - pointer : workspace structure - > pointer " and " workspace - object - bonds : workspace object - > ( list - of - bond ) " makes clear of the data it needs and what it does . Memory allocation problem can be solved by a pointer . Surprisingly , it is not necessary to use traditional memory pointers . Instead , usage of an unique identiﬁer when available , or , a functional pointer that stores how can it reach the data should be preferred . These practices prohibit memory leaks and overﬂows . The following example 1 and 2 is for Slipnet and Workspace , respectively representing the previous two usage cases . By referencing what nodes are linked through a unique symbol ( hashed - string in Racket ) , there is no need to have an actual node in the link . We later demonstrate that the node reference checking could be completed during compile - time rather in run - time using macros . Similarly , workspace groups consist pointers to letters . Structures of pointers in example 2 can be reached via ( vector - ref ( ( pointer - target < a - pointer > ) < data - structure > ) ( pointer - index < a - pointer > ) ) . Code 1 : Slipnet References ( define - struct slipnet ( nodes links ) ) ; nodes and l i n k s are l i s t s ( define - struct link ( from to type intrinsic length ) ) ; from , to i s a symbol ( define - struct node ( name depth activation ) ) ; name i s a symbol ( make - node ’a 10 0 ) ( make - node ’b 10 0 ) ( make - link ’a ’b ’lateral ’successor 60 ) Code 2 : Workspace Pointers ( define - struct workspace ( initial modified target answer letters groups descriptions bonds correspondences rules ) # : mutable ) ; p o i n t e r : f u n c t i o n , i n t e g e r ( define - struct pointer ( target index ) ) ; l e t t e r : symbol , p o i n t e r ( define - struct letter ( string pointer ) ) ; group : symbols , p o i n t e r s , symbol ( define - struct group ( type members direction ) ) ( define - struct description ( type pointer ) ) ( define - struct bond ( type from to direction ) ) ( define - struct correspondence ( type from to ) ) ( define example - workspace ( make - workspace " abc " " abd " " ijjkkk " " " ( vector example - letter - initial - a example - letter - initial - b # f example - letter - initial - c ) ( vector example - group - initial - abc # f ) ( vector empty ) ( vector empty ) ( vector empty ) ( vector empty ) ) ) ( define example - group - initial - abc ( make - group ’successor - group ( list ( make - pointer workspace - letters 0 ) ( make - pointer workspace - letters 1 ) ( make - pointer workspace - letters 2 ) ) ’right ) ) ; workspace − pointer − to − structure : workspace p o i n t e r − > s t r u c t u r e ( define ( workspace - pointer - to - structure space ptr ) ( vector - ref ( ( pointer - target ptr ) space ) ( pointer - index ptr ) ) ) 5 ( check - expect ( workspace - pointer - to - structure example - workspace ( first ( group - members example - group - initial - abc ) ) ) example - letter - initial - a ) 3 . 2 Structural Initialization and Testability Comparison Using the previously mentioned recursive syntax for abstraction , the initializations for Copycat are more concise , understandable , and testable . OOP is designed to be ﬂexible and quick to develop , but it also permits bad practices for testing without penalties . Speciﬁcally , the following practices lead to behavior combinatorial explosion [ 10 ] . • Global state dependent behaviors • Encapsulation , inheritance , abstract and generic classes . Comparing to a pure functional context , we are only concerned with the ﬁrst scenario as the rest is not applicable . A well designed functional language such as Racket would make programmers feel syntax resistance and face performance penalties when writing state dependent behavior functions [ 5 ] . The performance penalties are on the set ! functions which mutates a global value . The following two functions of list - sum distinguish in both syntax length and performance . Table 1 demonstrates the clear performance difference when two implementations are running on a list with length 1 , 000 and over 1 , 000 , 000 iterations , with garbage collection included in CPU time . The garbage collection time is signiﬁcantly higher because of higher amount of memory use . ( define ( sum - global lst ) ( let ( [ s 0 ] ) ( for - each ( lambda ( i ) ( set ! s ( + i s ) ) ) lst ) s ) ) ( define ( sum - local lst ) ( apply + lst ) ) Type CPU Time Real Time Garbage Collection Time Global 20938 21001 94 Local 15359 15547 2895 Python - 49900 - Table 1 : Racket Global vs . Local and Python Execution Time ( ms ) All the beneﬁts and drawbacks of both functional and object - oriented implementations are magniﬁed when developing complex programs . The following is a case on initializing the description of a letter , seen on ﬁgure 1 and appendix code listing A . 1 on page 10 . Code 4 shows programmers tend to program linearly when implementing cognitive models in Python . When the procedure’s length starts to increase , it is unavoidable to use global states . How can an global behavioral error be ampliﬁed and still be untraceable in linear programming ? Take the ﬁrst segment of the for loop , and say we made a human error of swapping the order of two lines . This program’s behavior will cascade deep into an experiment trial if there are no proper visualization of the architecture to check or proper tests to write . For researchers , implementation errors will result in either confusion , inaccurate results , or even worse , non - reproducible results . By writing tests for smaller chunks of functions , a programmer can avoid a test - case combinatorial explosion for more complex behaviors . In addition to writing less test , a test error will trace back to the exact function to blame — saving debugging time . Considering context , Copycat’s exploration mechanism is non - deterministic to imitate creativity . In this case , a programmer might know the frequencies of answers are wrong , but to write a test for the entire program is a mere impossibility . With the certainty that a model is implemented properly , a researcher can properly debug the problem of cognitive model instead of code . On the other hand , the memory usage of functional implementation could be abnormally high com - pared to an OOP implementation . This is acceptable in complex softwares of cognitive architectures as a trade off of higher memory usage to higher run time performance and more reliable behaviors . This scenario is preferred in an research environment , where accurate behavior is an priority for understanding something unknown instead of performance . 6 The case in workspace also applies to Slipnet , in appendix code listing A . 2 on page 12 . In slipnet number nodes initialization , functional implementation is more testable due to the separation of each code - block’s functionality . In OOP style , an exhaustive list of initialization in will make the testing function also an exhaustive list . Using a functional approach , only three functions need to be tested — description - tester , description - tester - lambda - get , and the actual abstracted description - tester lambda . 3 . 3 Program Performance Run time comparison test is not conclusive compared to Python , the different graphics and statistical library performances make two programs hard to compare . But in a general benchmark , Racket is faster than Python in run - time ( table 1 ) . This is not a surprise as DrRacket is a functional language with Just - In - Time compiler , while most Python platforms is interpreted . 3 . 4 Teamwork Performance The simple convenience offered by a functional language may not be much of an beneﬁt if there is only one programmer . However , huge research projects like Copycat needs teamwork to be completed on time . Teamwork delegation is very clear for the functional paradigm : cognitive architecture designer can focus on designing experiments to run ; program designers understand what they are doing then write contracts with tests ; programmer can focus on implementing the functions following contracts . Eventually , these groups can meet and receive feedbacks from each other . An more effective understanding of what the program is doing between people should ease the bottleneck on computational implementations of complex cognitive architectures . 4 Future Work 4 . 1 Reinterpretation of Copycat System Traditional Frameworks Artiﬁcial Intelligence Frameworks Environmental Evolutionary ( Ecological ) Philosophy of Artiﬁcial Life Cultural Historical ( Socio - cultural evolution ) Individual evolution Multi - Agent Social Band ( Sociology , Economics ) Integrative Learning Task Rational Band ( Psychology ) Individual Heuristics Unit Task - Deliberate Act Cognitive Band ( Behavioralism ) Cognitive Architectures ; Reinforcement Learning Neural Circuit - Organelle Biological Band ( Neuroscience , Info . Theory ) Machine Learning Table 2 : Hierarchy of Intelligent Systems , adapted from Time Scales of Human Action . These are the factors that should be considered to understand why and how a phenomenon works . [ 13 ] Copycat primarily concerns the problem of ﬂuid analogy behavior , which is an example of individual heuristics . The scale of Copycat’s alike experiments entail architectures larger than a subﬁeld’s concern . As a result , interpretations of the methodologies entailed cannot be simply referred as a localized phenomenon , but a result of multiple factors ( see table 2 ) . Primarily , the problem of exploitation v . exploration has evolved into a larger reinforcement learning ﬁeld that concerns how to achieve goals via actions [ 15 ] , meriting a reinterpretation of Copycat’s strength and weaknesses . Despite Copycat’s handcrafted codelets and slipnet sufﬁces for a controlled experiment , to generalize it to other domains entails a large practical time consuming problem . Reinforcement learning is formalized using Markov decision process as an agent - environment interface : with state , reward , and action . Additionally , the policy space is deﬁned as possible actions associated to state and reward , which a reinforcement learning model optimizes . In terms of reinforcement learning’s terminology , policy corresponds to codelets , and the slipnets are the state - transition model . It could be possible to learn slipnet from model - based learning , and incorporate rewards as maximizing or minimizing statistical regulations within Copycat — conceptual depth , happiness , and importance . The Workspace representations however , are hardwired for the letter 7 domain and we are still searching for a method to overcome . This interpretation needs future experimentation to verify . 4 . 2 Extensions to Domain Speiﬁc Language The ease of testing in pure functional implementation guarantees expected behavior of the architec - tures , but what about structural initialization ? Currently , we are considering to use DrRacket’s built in powerful macros to construct a customized language that simpliﬁes and checks the expressions for Copycat’s structural initializations . Visualization of structure could be one way , but complex network type of structure could be very confusing even when visualized . Referencing to the language - oriented programming philosophy , this approach does follows its two subsidiary guidelines [ 2 ] . • Enable creators of a language to enforce its invariants • Turn extra - linguistic mechanisms into linguistic constructs The designer of a DSL can enforce all users to deliver code that satisﬁes proper reference between structures during compilation . Alternatively , one can enforce code quality during run - time envi - ronment , but it cannot be directly tested . It is worth to note that writing languages do require a higher level of mindfulness during designing and coding compared to run - time checks . Despite the additional effort , hardening a set of conversions after experiments have been completed embodies Lakatosian’s philosophies directly into software . It could provide higher run - time efﬁciency by removing the need to manually check structures during run time . The example below on Slipnet initialization is a draft example of so following the philosophies mentioned above , extended from Racket School 2018’s teaching example [ 4 ] . In table A . 3 on page 14 , we propose to deﬁne and write an example of language # lang s - exp slipnet . The language is used to deﬁne , initialize , and check references of nodes in links , which is important if link lengths can be dependent to a node’s activation . Using macros , racket’s compiler could theoretically transcompile the following to racket code . # lang s - exp slipnet could run ( link a random 50 ) and detect a compile - time error of " link : undeﬁned node : random " . But the original implementation ( on both python and racket’s equivalence ) would only detect error during run time , given a proper checking mechanism exists . We have also improved the deﬁnition of link and nodes to harden proper length checking , when the length between links are labeled ( ﬁgure 3 ) . To unpack what the translation notation means , we use an simple example adapted from racket school 2018 [ 4 ] . Some notations easily convert to normal racket language , such as a value deﬁnition . We refer to those as deﬁnition as variable deﬁnition . For clariﬁcation , " # ‘ " turns the rest of the line into a syntax , while " # , " escapes the literal variable to become an actual value of the variable . If no escapes are needed , " # ’ " will also turn the line into syntax . Definition - Vars = | ( define - value id expr ) = > # ‘ ( define - syntax id ( # % expression expr ) ) Others might not be very straightforward , such as a function . But it can be broken up into the declaration ( deﬁne ) and execution ( apply ) part . We put the declaration part into the evaluable deﬁnition , while the execution becomes an expression of data . Using the racket function deﬁne - syntax , deﬁne - function calls a syntax transformation that matches the identiﬁer of the wanted function . If the function to be deﬁned needs to be executed , function - app will look up the value of the function - id , checks arity ( number of argument ) , then transforms the lambda corresponding to the function - id . Note that deﬁne - function returns a deﬁne - syntax that matches function - id at run - time , while the syntax deﬁne - function itself is executed at compile time . This is not the only way it could be done . For example , the usage of recursion requires more elaborate mechanisms . Definition - Evals = | ( define - function ( id id1 . . . ) expr ) = > # ‘ ( define - syntax id ( cons # , arity ( lambda ( id1 . . . ) expr ) ) ) Expression = | ( function - app id expr1 . . . ) = > # ‘ ( ( lambda ( id1 . . . ) expr ) expr1 . . . ) | Variables : Number , Symbol , List , NULL 8 The macros deﬁne - function is as follows : ; Syntax − > Syntax ( define - syntax ( define - function stx ) ( syntax - parse stx [ ( _ ( f : id param : id . . . ) body : expr ) ( define arity ( length ( syntax - > list # ’ ( param . . . ) ) ) ) # ‘ ( define - syntax f ( cons # , arity ( lambda ( param . . . ) body ) ) ) ] ) ) 5 Conclusion Proper naming , structural reference , testing , and documentation practices in functional language enables cognitive architectures to be more testable , reusable , and understandable . These properties can be used on Copycat to ensure software re - usability . Furthermore , cognitive architectures can beneﬁt from broadening the contextual perspective , as no phenomenons are only caused in a vacuum . 6 Acknowledgement The author would like to thank Mr . Daniel Anderson , the Viewpoint School computer science faculty advisor who suggested Copycat is worth to investigate and advised the approaches to do so . His courses on DrRacket are building a strong computer science community in Viewpoint School . Additionally , the author would like to thank Viewpoint School students who participated in the educational project that helped or attempted to understand what Copycat is and how to implement it efﬁciently : Anthony Pineci , Ben Zebrack , Brandon Frederick , William Parker , Valen Dunn and Artiﬁcial Intelligence Class of 2016 - 2017 . Speciﬁcally , naming conventions and tests were suggested and partially rewritten with Anthony Pineci . The author would also like to thank Dong He and Cheng He for advising the methods of writing academic papers . Finally , we would like to thank the Racket community for providing through documentations and Dr . Hofstadter’s Fluid Analogies Research Group for proposing and advancing the Copycat project . Our contributions are built on these people’s hard work . References [ 1 ] Richard P . Cooper . The role of falsiﬁcation in the development of cognitive architectures : Insights from a Lakatosian analysis . Cognitive Science , 2007 . [ 2 ] Matthias Felleisen , Robert Bruce Findler , Matthew Flatt , Shriram Krishnamurthi , Eli Barzilay , Jay McCarthy , and Sam Tobin - Hochstadt . A programmable programming language . Communi - cations of the ACM , 61 ( 3 ) : 62 – 71 , 2 2018 . [ 3 ] Matthias Felleisen , Robert Bruce Findler , Matthew Flatt , Shriram Krishnamurthi , Eli Barzilay , Jay A McCarthy , and Sam Tobin - Hochstadt . The Racket Manifesto . In SNAPL , 2015 . [ 4 ] Matthias Felleisen , Matthew Flatt , Stephen Chang , Matthew Butterick , Robby Findler , and Jay McCarthy . Racket and Language - oriented Programming , 2018 . [ 5 ] Matthew Flatt , Robert Bruce Findler , and PLT . The Racket Guide v6 . 12 , 2018 . [ 6 ] Douglas R Hofstadter and Melanie Mitchell . The copycat project : A model of mental ﬂuidity and analogy - making . Advances in connectionist and neural computation theory , 1995 . [ 7 ] J H Holland . Adaptation in Natural and Artiﬁcial Systems . Ann Arbor MI University of Michigan Press , 1975 . [ 8 ] Imre Lakatos . Falsiﬁcation and the methodology of scientiﬁc research programmes . In Philoso - phy , Science , and History : A Guide and Reader . 1976 . [ 9 ] J B Marshall . Metacat : A Self - Watching Cognitive Architecture for Analogy - Making and High - Level Perception . Ph . D . thesis , Indiana University , Bloomington , IN . Marshall , J . B . , & Hofstadter , D . R , 1999 . 9 [ 10 ] Aditya P Mathur . Foundations of Software Testing . Addison - Wesley Professional , 1st edition , 2008 . [ 11 ] Marvin Minsky . The society of mind . Simon and Schuster , 1986 . [ 12 ] Melanie Mitchell . Analogy - making as Perception . 1993 . [ 13 ] Allen Newell . Uniﬁed theories of cognition . Harvard University Press , 1990 . [ 14 ] Holger Schultheis . Computation and explanatory power of cognitive architectures : The case of ACT - R . Proceedings of the 9th international conference of cognitive modeling , 2009 . [ 15 ] Richard S . Sutton and Andrew G . Barto . Introduction to Reinforcement Learning . MIT Press , Cambridge , MA , USA , 1st edition , 1998 . A Code Following are tables for the code snippets analyzed in the paper . A . 1 Structural Initialization Functional vs . OOP Code 3 : DrRacket Functional Description Initialization ; s t r i n g − p o s i t i o n : number number − > symbol ( define ( string - position n len ) ( cond [ ( > n len ) ( error " string - position␣description␣position␣must␣be␣ smaller␣than␣string - length " ) ] [ ( = n 0 ) ’leftmost ] [ ( = n ( - len 1 ) ) ’rightmost ] [ ( = n ( / ( - len 1 ) 2 ) ) ’middle ] [ else # f ] ) ) ( check - expect ( string - position 0 1 ) ’leftmost ) ( check - expect ( string - position 1 1 ) ’rightmost ) ( check - expect ( string - position 1 2 ) ’middle ) ( check - expect ( string - position 1 5 ) # f ) ( check - error ( string - position 5 1 ) ) ; workspace − letter − make − descriptions : workspace l e t t e r − > d e s c r i p t i o n ( define ( workspace - letter - make - descriptions space ltr ) ( local ( ( define ltr - ptr ( workspace - structure - to - pointer space ltr ) ) ( define pos ( string - position ( pointer - index ( letter - pointer ltr ) ) ( string - length ( ( pointer - target ( letter - pointer ltr ) ) space ) ) ) ) ( define desc - pos ( if ( boolean ? pos ) empty ( list ( make - description pos ltr - ptr ) ) ) ) ) ( append ( list ( make - description ( string - > symbol ( letter - string ltr ) ) ltr - ptr ) ( make - description ’letter ltr - ptr ) ) desc - pos ) ) ) ( check - expect ( workspace - letter - make - descriptions example - workspace example - letter - initial - b ) ( list ( make - description ’b ( make - pointer workspace - letters 1 ) ) ( make - description ’letter - category ( make - pointer workspace - letters 1 ) ) ( make - description ’middle ( make - pointer workspace - letters 1 ) ) ) 10 Code 4 : Python OOP Description Initialization def add _ descriptions ( self ) : for string in [ self . initial _ string , self . modified _ string , self . target _ string ] : for letter in string . get _ letters ( ) : desc = Description ( self , letter , self . slipnet . plato _ object _ category , self . slipnet . plato _ letter ) letter . add _ description ( desc ) letter . add _ description ( desc ) # Whoops , the l i n e above i s supposed to be down t h e r e # desc = Description ( self , letter , self . slipnet . plato _ letter _ category , self . slipnet . \ get _ plato _ letter ( letter . name ) ) # l e t t e r . a d d _ d e s c r i p t i o n ( desc ) # lmost _ letter = string . get _ leftmost _ letter ( ) if string . length > 1 : rmost _ letter = string . get _ rightmost _ letter ( ) desc = Description ( self , lmost _ letter , self . slipnet . plato _ str _ pos _ category , self . slipnet . plato _ lmost ) lmost _ letter . add _ description ( desc ) desc = Description ( self , rmost _ letter , self . slipnet . \ plato _ str _ pos _ category , self . slipnet . plato _ rightmost ) rmost _ letter . add _ description ( desc ) else : desc = Description ( self , lmost _ letter , self . slipnet . plato _ str _ pos _ category , self . slipnet . plato _ single ) lmost _ letter . add _ description ( desc ) if string . length = = 3 : middle _ letter = string . get _ letter ( 1 ) desc = Description ( self , middle _ letter , self . slipnet . plato _ str _ pos _ category , self . slipnet . plato _ middle ) middle _ letter . add _ description ( desc ) 11 A . 2 Node Initialization Functional vs . OOP Code 5 : DrRacket Slipnet Node Initialization ( define nodes - numbers ( map ( lambda ( name ) ( make - node name 30 0 ) ) numbers ) ) ; D e s c r i p t i o n − t e s t e r implemented in c o d e l e t , f o l l o w i n g code segment from c o d e l e t . ; d e s c r i p t i o n − t e s t e r − n u m b e r : o b j e c t desc − > boolean ( define ( description - tester - number desc ) ( and ( group ? obj ) ( = ( object - length obj ) ( symbol - > number desc ) ) ) ) ( check - expect ( description - tester - number ( group ’ ( letter ) ( list ( pointer workspace - initial 0 ) ( pointer workspace - initial 1 ) ) ) ) ’two ) # t ) ( check - expect ( description - tester - number ( letter ’a ( pointer workspace - initial 0 ) ) ’one ) # t ) ( check - expect ( description - tester empty ’three ( letter ’a ( pointer workspace - initial 0 ) ) ) # f ) ; workspace − description − tester − lambda − get : workspace symbol ( of desc − node ) − > lambda ( define ( workspace - description - tester - lambda - get space desc ) ( case desc [ ( one two three four five ) ( lambda ( obj ) ( description - tester - number obj desc ) ) ] ; o t h e r d e s c r i p t i o n t e s t e r s . . . ) ) ; Examples : workspace i s empty s i n c e o b j e c t − l e n g t h should not need any c o n t e x t ( check - expect ( workspace - description - tester - lambda - get empty ’two ) ( lambda ( obj ) ( description - tester - number obj ’two ) ) ) ; w o r k s p a c e − d e s c r i p t i o n − t e s t e r : workspace d e s c r i p t i o n − t y p e ( c a t e g o r y ) o b j e c t − > boolean ( define ( workspace - description - tester space desc a - obj ) ( ( workspace - description - tester - lambda - get space desc ) a - obj ) ) ; No need to t e s t , t h i s i s a wrapper f o r the b e h a v i o r − c r i t i c a l f u n c t i o n s above . 12 Code 6 : Python Slipnet Node Initialization self . slipnet _ numbers = [ ] node = self . add _ node ( " 1 " , 30 ) node . description _ tester = ( lambda obj : obj . type _ name = = ’group’ and obj . length ( ) = = 1 ) self . slipnet _ numbers . append ( node ) assert node . description _ tester ( exampleLen1Group ) , " Description - tester␣ example␣failed ! " node = self . add _ node ( " 2 " , 30 ) node . description _ tester = ( lambda obj : obj . type _ name = = ’group’ and obj . length ( ) = = 2 ) self . slipnet _ numbers . append ( node ) assert node . description _ tester ( exampleLen2Group ) , " Description - tester␣ example␣failed ! " node = self . add _ node ( " 3 " , 30 ) node . description _ tester = ( lambda obj : obj . type _ name = = ’group’ and obj . length ( ) = = 3 ) self . slipnet _ numbers . append ( node ) assert node . description _ tester ( exampleLen3Group ) , " Description - tester␣ example␣failed ! " node = self . add _ node ( " 4 " , 30 ) node . description _ tester = ( lambda obj : obj . type _ name = = ’group’ and obj . length ( ) = = 4 ) self . slipnet _ numbers . append ( node ) assert node . description _ tester ( exampleLen4Group ) , " Description - tester␣ example␣failed ! " node = self . add _ node ( " 5 " , 30 ) node . description _ tester = ( lambda obj : obj . type _ name = = ’group’ and obj . length ( ) = = 5 ) self . slipnet _ numbers . append ( node ) assert node . description _ tester ( exampleLen5Group ) , " Description - tester␣ example␣failed ! " 13 A . 3 An Domain Speciﬁc Language for Slipnet Code 7 : # lang s - exp Slipnet Elements and Syntax Translation Program = Slipnet - structure | Definition | Expression Slipnet - structure = | ( define - node - properties ( id . . . ) ) = > # ‘ ( define - struct node # , @ ( id . . . ) ) | ( define - link - properties ( id . . . ) ) = > # ‘ ( define - struct link # , @ ( id . . . ) ) Identifiers = | node - all = > # ‘ ( list node - id . . . ) | link - all = > # ‘ ( list link - id . . . ) Definition - Vars = | ( define - value id expr ) = > ( define - syntax id expr ) | ( node id expr . . . ) = > ( define - syntax node - id ( expr . . . ) ) | ( link id1 id2 expr . . . ) = > ( define - syntax link - id1 - id2 ( expr . . . ) ) Definition - Evals = | ( define - function ( id id1 . . . ) expr ) = > # ‘ ( define - syntax id ( cons , arity ( lambda ( id1 . . . ) expr ) ) ) | ( define - definition ( id id1 . . . ) ( list Definition - Vars . . . ) ) = > # ‘ ( define - syntax id ( cons , arity ( list ( lambda ( id1 . . . ) expr ) . . . ) ) ) | ( define - identifiers id ( id1 . . . ) ) = > # ‘ ( define - syntax id ( cons , arity ( list id1 . . . ) ) ) Expression = | link - id = > link - id ( Racket ) = > Variable | node - id = > node - id ( Racket ) = > Variable | ( function - app id expr1 . . . ) = > ( ( lambda ( id1 . . . ) expr ) expr1 . . . ) | ( definition - app id . . . ) = > # ‘ ( define - values ( id - Definition - Vars . . . ) ( values ( lambda ( id1 . . . ) expr ) . . . ) ) | ( identifier - map lambda id - define - identifiers ) = > # ‘ ( define - values ( id - Definition - Vars . . . ) ( values ( lambda ( id1 . . . ) expr ) . . . ) ) ) | Variable : Number , Symbol , List , NULL 14 Code 8 : Initialization Example # lang s - exp slipnet ; d e f a u l t name and from , to in node and l i n k ( define - node - properties ( depth [ intrinsic - length empty ] [ activation 0 ] ) ) ( define - link - properties ( type length / node ) ) ( define - value ALPHABET _ NODE _ DEPTH 10 ) ( define - value NUMBER _ NODE _ DEPTH 30 ) ( define - identifiers ALPHABET _ IDENTIFIERS ( a b c d . . . x y z ) ) ( define - identifiers NUMBER _ IDENTIFIERS ( one two three four five ) ) ( define ( node - group identifiers depth ) ( identifier - map ( lambda ( id ) ( node id depth ) ) identifiers ) ) ( define ( links - group identifiers type length / node ) ( identifier - map ( lambda ( from to ) ( link from to type length / node ) ) identifiers ) ) ( node - group ALPHABET _ IDENTIFIERS ALPHABET _ NODE _ DEPTH ) ( node - group NUMBER _ IDENTIFIERS NUMBER _ NODE _ DEPTH ) ( node length 60 ) ( node string - position 70 ) . . . ( node successor 50 60 ) ( node predecessor 50 60 ) ( define - definition ( links - group - double identifiers type - > node node < - ) ( links - group ALPHABET _ IDENTIFIERS type - > node ) ( links - group ( reverse ALPHABET _ IDENTIFIERS ) type node < - ) ) ( definition - app links - group - double ALPHABET _ IDENTIFIERS ’lateral successor predecessor ) ; Numbers . . . ( definition - app links - group - double ALPHABET _ IDENTIFIERS ’slip successor predecessor ) ; Numbers . . . ( provide node - all link - all ) ( link - length a b ) ( node - activation length ) ( node - depth group - cateogry ) ( check - exn # rx " link : ␣undefined␣node : ␣random " ( lambda ( ) ( convert - syntax - error ( link a random 50 ) ) ) ) 15