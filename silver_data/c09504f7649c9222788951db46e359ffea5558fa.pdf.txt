TEXT FORMATTING BY DEMONSTRATION Brad A . Myers School of Computer Science Carnegie Mellon University Pittsburgh , PA 15213 ABSTRACT In text formatters such as troff , Scribe , and TEX , users write macro procedures to specify the desired visual ap - pearance . In What - You - See - Is - What - You - Get text formatt - ers , such as MacWrite and Microsoft Word , the formatting is specified by directly manipulating the text . However , some important functionality is lost in these systems since they are not programmable , For example , if the user wants to change the formatting and content of all the chapter headings or page headings , each one must be individually edited . If they had been generated by macros , then editing the macro definition would change them all at once . This paper describes the design for a demonstrational text for - matter that allows the user to directly manipulate the for - matting of one example , and then the system automatically creates the macro by generalizing the example . This tech - nique makes the formatting for headers , itemized lists , tables , bibliographic references , and many other parts of documents significantly easier to specify and edit . KEYWORDS : Text Formatting , Demonstrational Inter - faces , Direct Manipulation , Programming - by - Example , In - ferencing . INTRODUCTION We have developed a text formatter that combines the best features of what - you - see - is - what - you - get ( WYSIWYG ) text formatters , such as MacWrite and Microsoft Word , with batch - oriented , embedded - command formatters such as troff , TEX , and Scribe . Our formatter is WYSIWYG , but in addition , the user can define macros to describe how various portions of the document should look . Unlike con - ventional systems , however , our macros are created by demonstration : the user gives an example of the desired formatting , and the system automatically creates a macro that can be used to apply the formatting to different parts of this or other documents . The users do not need to learn a Permission to copy without fee all or part of this material is granted provided that the copies are not made or distributed for direct commercial advantage , the ACM copyright notice and the title of the publication and its data appear , and notice is given that copying is by permission of the Association for Computing Machinery . To copy otherwise , or to republish , requires a fee and / or specific permission . 01991 ACM ( ) . 89791 . 383 . 3 / 91 / 0 ( 3 ( 34 / 025j . . . $ 1 . ~ o 251 complex programming language like those built into embedded - command formatters . However , they can still create macros so that it is easy to ensure that all parts of the document look consistent and make it easy to edit the for - matting of all parts at the same time . For people who only want to follow a pre - defined style sheet , and therefore do not want to create macros , this editor will still be easier to use than conventioml WYSIWYG editors , because demonstrational techniques make it easier to create tables , citations for bibliographic references , and to use the macms created by others . A “demonstrational interface” is one in which the user performs actions on concrete example objects ( often , by direct manipulation ) , but a more general - purpose procedure is created [ 9 , 10 ] . The term “demonstrational” is used be - cause the user is demonstrating the desired result using example values . RELATED WORK One of the first programmable embedded - command text formatters was troff for Unix , which has a complex macro language . Later examples include Scribe and TEX . The first WYSIWYG formatter was Bravo for the Xerox Alto . Other systems include the editor in the Xerox Star [ 15 ] , many editors on the Macintosh , and WriteNow on the NeXT machine . None of these provide the ability to create macros . The new version of WordPerfect for the Macin - tosh reportedly will combine a conventional ( textual ) macro language with a WYSIWYG formatter . Demonstrational techniques have only been used in a very minor way for text formatting . In the Scribe text formatter , when specifying the way the date should be printed , the user can supply an example in “nearly any notation” for the particular date March 8 , 1952 . Scribe will convert this for use with the current date . For example , the user might enter @ Style ( Date = ” 8 - Mar - 52” ) to get the date to come out like ‘ ‘30 - Apr - 9 1 . “ In Edhing - by - Example [ 12 ] , demonstrational techniques are used to create complex query - replace commands from examples , but not for for - matting . The NOTECH text formatter [ 4 ] allows users to type docu - ments in plain text , with no formatting commands , and tries to infer the appropriate formatting from the spacing and contents of the document to produce attractive laser - printer output . For example , a single line is assumed to be header , and a group of short pieces of text separated by tabs are assumed to be a table . Whereas NOTECH guesseswhat type of macro should be applied from plain text , our system tries to create those macros from fully - formatted text . Some word processors , such as Microsoft Word 4 . 0 , provide a “styles” mechanism . The user selects a piece of text and gives the command “Define Styles . . . ” This brings up a dialog box that shows all the properties of the selected text . The user can give a name to this set of formatting properties , and then apply them as a group to a different piece of text . However , this is too limited to solve the macro problem since a style only represents a single set of formatting commands . Figure 1 would require at least 3 styles which the user would have to create and maintain separately . Also , the styles mechanism cannot be used to insert text , such as the word “Chapter , ” so some other mechanism would have to be used if the user wanted to change it to “Section” in all the headings . 2 Chapter II Related Work Figure 1 : A chapter heading that includes different for - matting for different parts and the constant word “Chapter . ” There have been a number of demonstrational systems that were not text formatters . SmallStar [ 2 ] allows the user to create macros for the Xerox Star desktop by recording a sequence of actions and then editing a textual transcription to add control structures and variables . Peridot [ 7 ] introduced the idea of using inferencing from examples in a demonstrational interface for creating user interface elements . One important motivation for the demonstra - tional formatter described here was the positive responses from users to the inferencing in Pendot . MetaMouse . [ 5 ] guesses what the user’s next actions will be in a draw - ing program . MOTIVATION FOR A DEMONSTRATIONAL APPROACH Since most demonstrational interfaces are also direct manipulation interfaces , they share all of the benefits of that style [ 14 ] . In addition , a demonstrational formatter can provide programming capabilities to users without requir - ing any special programming knowledge . Programming in conventional languages is too difficult for most users , whereas people are good at specifying the desired opera - tions using examples , since they can simply use the com - mands they already know . Experiments with other demonstrational systems have shown that non - programmers can create parametrized procedures [ 2 , 8 ] . In addition , a demonstrational formatter can be even easier and more efficient to use than a conventional direct manipulation , WYSIWYG interface . For example , rather than using a plethora of dialog boxes to define the properties of a table , as in Microsoft Word , in our format - ter , the user simply draws an example table using a special - ized graphical editor . DESIGN Demonstrational techniques are used in a number of places in our text formatter , and it is clearly impossible to describe them all in detail in a short conference paper . The follow - ing sections provide an overview of how demonstration is used . Headings The user can type in an example chapter or section heading and apply any desired formatting to it , as in Figure 1 . This example can include special words , including “Chapter , ” “Section , ” ‘‘ SubSection , ” or “Appendix” ( and the list of special words is easily changed ) , numbers in many dif - ferent formats ( 2 , 4 . 3 . 2 , ii , II , etc . ) , separators ( such as colon , hyphen , commas , etc . ) , decorations ( such as lines and boxes ) , and other text . The’ ‘other text” is assumed to be a parameter to the heading . The user selects the ex - ample heading , and gives the “Save Style” command ( see Figure 2 - a ) . This command prompts for a name , and then invokes our parser which tries to guess the parts of the example . If there are any ambiguities or problems with the parsing , the user is queried . Since there is very little variability in the content , the examples are rarely am - biguous . However , if the other text is something like “The 1st 4 Chapters of Computer Graphics” the system reports that it is confused . l From the results of the parsing , the system creates a template which is associated with the supplied name . The example is removed from the document , and replaced with a generated heading based on the template and the example text as the parameter . If the inferencing was performed correctly , this will not change the appearance of the text , except that the numbers might be updated . If the system has guessed wrong , the user can undo the guessing with a command , and supply a different example . The first ex - ample will then be ignored by the system . If the user simply cannot get system to guess correctly , the standard WYSIWYG techniques are still available . Each heading created with a particular style is marked with information about what style name is being used , and what the parts are . These markings are inserted into the docu - ment using invisible text so they will be preserved when the file is written out and retrieved . All of the templates are added to the end of the document when it is written out , atso in a hidden format . A command is available to write out only the styles ( and not the text of the document ) , so the user can easily create a style sheet by example . Other commands can be used to make the lWe are not using natural language underatandirrg ! Only simple pattern matching , 252 & l ez “ / wortitestfLle & lcdmo . CZ * ~ @ l In text S % rmatters such as troff , Xcribe , and TEX , users ‘write macro pmmctures to specify the desired visual appearance , In What - You - Scc - Ia - What - Ymr - Get tr . xt formattrm , such as MacWrite and Micmmfs Word , the formatting tr qxcifled by directly manipuladrrg the text . ‘E ? F” 1 individually edited , If rhcy had Apply SavedStyle I Related Work I I I i The first prrrgrammable embed waff fir Urrix , which has a comp ( a ) q = 2 “ywor ~ testfilctii cdetio . ezw ~ SO Chapter 1 - Introduction In text formatters suchastrnff , Sdbr . , and TEX , wars write macro practdurcs to s ~ ify the dccimcl visual appearance In What - You - See - Jc - What - You - Get text formattecw , such aa MacWrite and Microsaft Word , the formatting is spdfied by directly manipulating the text , Section 1 . 1 - ~ L ; L However , came imp + rtant functionality is lost in them systems since they arc not programmable . Fnr example , ~ ge the formarring and content of all the chapter h h one mucr bc individually edited . [ f thay had Save Style editing the macro definition would change th Renumber . . . . The first programmable embed ly troff for Unix , which hasa comp c ( b ) specmaa Dycurecuy matuptuamrg me text , sectrorr 1 . 1 - ~ t However , same lmportan ~ functionality is lost in these eysterna since they are not programmable , For example , if the user wanta to change the formatting ad content of all the chapter hcnrlhgs or page hcadiugs , eadr one must & individually edited . If they had ken generated by macrm , then editing the macru definition would change them all at once . ‘ $ ” ~ ”” 1 . 2 - ~ The first programmable emkedded - mmmand text formatter was probably tmff fur Unix , which hac a complex macro language . Later examplcc ineludc % , { * . . ( I T , X Th , fir , , WYSIWVG fnrma , t . r w . , , h - avn fm , h , V , rrm Alrn ( c ) Figure 2 : Creating a style by example . ( a ) The user types in the example , selects it then selects “Save Style” from the pop - up menu . This prompts for the style name . Later ( b ) , the user can select a different piece of text and apply this style to it , to get ( c ) . templates visible at the end of the document , in case the user wants to copy them to a different document or ex - plicitly edit them ( but we do not expect that to be neces - w ) - Headings often use multi - level numbering schemes , so that , for example , sections in chapter two would be numbered 2 . 1 , 2 . 2 , etc . When the user gives an example of a heading , the system must know what level it is for ( chapter , section , subsection , etc . ) . This can be specified explicitly by the user , or the system will try to guess using various heuris - tics . If the example number contains multiple parts ( such as “2 . 2’ ‘ ) , then the style is assigned to the appropriate level . If the number has only a single prut ( such as “2” ) , then if the style contains a special word ( such as “chap - ter’ ‘ ) , the level normally associated with that word is used ( chapters are at level 1 , sections are at level 2 , subsections are at level 3 , etc . ) . If none of these rules can be applied , then the number is assumed to be at level one . When the system renumbers the sections , a lower level number is always reset to zero whenever a higher level number is changed . After a style is created , the user can select a piece of text and invoke the command that applies the named style ( see Figure 2 - b ) . This will use the text as the parameter of the style ( the chapter or section title ) , and add the other parts of the template around the text , such as the constant words and the number . The formatting of the text will also be changed based on the style ( except that any explicit format - ting commands applied to the text will not be overridden , in case , for example , the user wants a word in the title to be italic ) . The numbers used in the heading will be updated appropriately . In addition , the system searches for all other headings and updates their numbers appropriately . Unfortunately , in this implementation , it is not possible to detect when the user has deleted a heading . Therefore , we include an explicit “Renumber” command that can be in - voked to fix up the numbering of all headings . This com - mand is automatically run before printing or saving a file . Rather than apply the style to some selected texg the user can instead copy and paste an existing style , and then edit the title portion of the heading . In this case , the numbering of all sections will be automatically updated . The user can also edit any of the headings at any time . If the user only wants to change the parameter ( the title ) , then nothing else needs to be done . To change the formatting of the template , the user invokes the “Save Style” command again . If the user specifies a new style name , then a new style can be created from the old one . If the same name is used however , then the system asks the user to confirm that the style template should be modified . 2 If this is con - firmed , then the system re - parses the style and creates a new template . All the existing headings using that style are immediately updated . Note that the user can select any heading in the document and edit it to change the styl ~ it is not necessary to edit a special prototype or style sheet . Also , the editing can use the standard editing and format - ting commands directly on the example text , rather than working indirectly on a description of the style as in Microsoft Word . Tables One of the most difficult par ~ of documen ~ to format hx been tables . In embedded - command formatters , complex % the future , we also plan tu add a facility for exceptions to previously defiied style , for example to hmrdle a heading that happens to be at the top of a page , or when the parameter string is tuo long . 253 commands are required . In WYSIWYG editors that sup - port tables , such as Microsoft Word 4 . 0 , tables must be constructed indirectly using many dialog boxes and com - mands . We have developed a prototype table editor that allows the users to draw tables in the same way they would on papen a few quick slashes for the lines , type the text into the fields , and the table is complete . The lines jump to ap - propriate places so they are connected nicely , and the text is always lined up inside the fields ( see Figure 3 ) . Also , the user can draw some of the fields , and then type in the data for the rest , and the same formatting will be applied . These uses of inferencing to automatically neaten the picture as it is being drawn , and to maintain the appropriate relation - ships if the picture is edited , differentiates our table editor from a conventional drawing tool . In fact , it is much quicker to use the table editor than a tool like MacDraw , since the user does not have to be careful to put the lines in the correct places . If the user wants some lines to be thick and some thin , or double lines around some fields , they can simply be drawn . All fields do not have to have lines around them . The system will infer fields if separate strings are placed in different parts of the picture . The table system uses a few simple rules to infer the properties of a table . Lines are assumed to attach if they are close together and perpendicular , rows and columns are assumed to be the exactly the same size if they are nearly so , and the placement of strings is adjusted to be exactly centered or justified , depending on where they appear to be in the field . If the right edge of a column is close to the end of a string inside it , then the width of the column is as - sumed to be the width of the widest entry in i ~ and similarly for the rows . If the stings are edited , the lines will move . If the right edge is far from the widest string or if the widest sting contains an explicit carriage return , then the column width is assumed to be fixed , and the text is word - wrapped inside it , if necessary . The inferencing for the tables is much more likely tn be correct than for a conventional drawing program such as PED [ 13 ] due to the restrictions on the ways tables am usually presented . All lines are horizontal or vertical , lines rarely are left dangling , and strings are only allowed in certain places . However , the system does occasionally guess wrong . Unlike Peridot , the sy ~ tem immedktely per - forms the inference , and provides “Undo Guess” and “Guess Again” buttons . These can be used to remove the inference and to try other guesses . This method is faster and seems warranted since the first guess is more often correct than in Peridot . Further study on the appropriate kinds of feedback are ongoing . Once the table is created with example data , the user can just use it as it is ( if the example data is the real data ) , or define it as a style . In this case , the system will allow the real data to have a different number of rows and columns than the sample data , and will replicate the example for - matting as needed . The system tries to be smart about headings in the table , so if they do not appear to be sup - plied in the data , the example headings will be used . Also , if there are headings which span multiple columns or rows ( as in Figure 3 ) , the system will try to replicate them ap - propriately . Bibliographic References Defining the formatting for bibliographic references is quite difficult in most systems . In our editor , the user can specify the formatting by supplying examples of how dif - ferent types of entries should look . For instance , to define the formatting for a conference article , the user might supply the following example : [ Myers 87 ] B . A . Myers . “Creating Dynamic Interaction Techniques by Demonstration , ” CHI + GI ( lm ~ erence Proceedings . Toronto , Ont . Apr . 5 - 9 , 1987 . pp . 271 - 278 . From this , the system can infer the formatting of all con - ference proceedings : the key should be the author’s last name , first names should be abbreviated and in forward order , there should be a period after the name , etc . Similar inputs can be given to define the formatting for other types of entries , such asbooks or journal articles . The data used to drive the bibliography can come from a databasein Unix Refer or Scribe format , for example : @ InProceedings ( Sketchpad , Key = ’’Sutherland” , Author = ’’Ivan E . Sutherland” , Title = ’’Sketchpad : A Man - Machine Graphical Communication System” , BookTitle = ’’AFIPS Spring Joint Computer Conference” , V01ume = 23 , Year = 1963 , Pages = ’’329 - 346” ) This will be automatically converted to [ Sutherland 63 ] I . E . Sutherland . “SketchPad A Man - Machine Graphical Communication System , ” AFIPS Spring Joint Computer Conference . 1963 . pp . 329 - 346 . Alternatively , the user can create the bibliographic database by typing the entries using the full formatting , Having a database of bibliographic references allows the system to create a bibliography using different formatting , for ex - ampkx 3 . Sutherland , I . E . SketchPad : A Man - Machine Graphical Communication System , AFIPS Spring Joint Computer Conference , ( 1963 ) , 329 - 346 . Other Parts In a similar way as chapter and section headers , the format - ting for page headings and footings , entries in a table of contents and index , figure captions , itemized lists , and even the indenting and spacing for normal paragraphs , can be specified by demonstration . The user simply gives an ex - ample of the desired formatting , and the system tries to guess the appropriate macro . In the future , we will also support business graphs , pie - charts , mathematical formulas , etc . 254 I , ’ j m’ n Font Speed cm Elsewhere Eudgetl Actual Budget IActual 97 , 34 . 1 I t I I I Ill String 97 . 34 appears to be at the Center of the box in row 4 , coluxn 1 I i Figure3 : The user specifies a table by drawing an example picture . As each line and string is drawn , it snaps to art appropriate position . The window at fie bottom fi vi ~ ible if the’ ‘Explain” button is c ~ ecked , and it describes the last inference . FEEDBACK Since any inferencing system will sometimes guess wrong , it is important that the system supply appropriate feedback so the users are confident that they are in control and know what the system is doing . An important component of the reseamh into the demonstrational formatter is to determine art appropriate form for the feedback . If the “Explain” button is checked , then all the infenmces in the table subsystem are reported to the user . There are also buttons available for undoing and trying other guesses . In the bibliographic subsystem , a window is popped up with the inferred formatting shown . The user can move around the labels and edit the definition , if necessary . In the headers subsystem , however , there is currently no feed - back for the user , although we are considering a window like that used for the bibliography . Future research will be aimed at evaluating the best forms for all feedback . STATUS AND FUTURE WORK The headers and bibliographic part of the formatter are im - plemented in the Ness language [ 3 ] which is part of the ‘‘ez” WYSIWYG text editor in the Andrew environment [ 6 ] . Ness is an experimental interpretive language which supports text formatting and parsing . The Ness code can be attached to custom menu commands . A prototy ~ of the table subsystem was implemented separately using the Garnet environment [ 11 ] . This was chosen because it allowed the table editor to be created very quickly . Now that the basic ideas have been developed , we need to reimplement the entire system in an integrated way . We will probably redo the entire implementation using the TextView tool from Interviews [ 1 ] since it is easy to modify and we can get the source code . We plan to create a real ( not toy ) version of the editor , and release it for general use . We also want to look at how to make the system use in - ferencing in more places . For example , if the user types “Chapter 5 : Conclusion” , the system might automatically guess that the Chapter macro should be applied to it , rather than requiring the user to explicitly apply it . It may also be possible to create a more general mechanism , so that users can create their own inferencing system for custom parts of documents , An important aspect of the future work will be investigat - ing people’s reactions to this system . We will provide various feedback mechanisms and various levels of guess - ing , to determine the right balance between helping and interfering with the user . CONCLUSIONS The demonstrational formatter described here combines the best features of WYSIWYG and embedded - command for - matters , while often being easier to use than either . This 255 editor , along with demonstrational systems in other domains , show that it is possible to extract useful semantics from the surface form of the user’s input . This is primarily because the systems are constrained in their domain , and the level of semantics to be derived is limited , Further research will be needed to determine the boundaries of this technique , and to what extent users are willing to accept a program that guesses what they are doing and occasionally makes errors . However , based on its successes so far , I believe that demonstrational techniques will be a sig - nificant advance beyond the direct manipulation interfaces of today . The demonstrational formatter described here will help expIore this exciting new user interface paradigm . ACKNOWLEDGEMENTS This research was partially funded by grants from Apple Computer and Siemens . The Andrew portions of the demonstrational formatter were implemented by Richard Chung . Many thanks to Fred Hansen who helped us understand the Ness system and added special features for us . For help with this paper , I want to thank Brad Vander Zan - den , Brad Lincoln and Bernita Myers . REFERENCES 1 . Paul R . Calder and Mark A . Linton , Glyphs : Flyweight Objects for User Interfaces . Proceedings of the ACM SIG - GRAPH Symposium on User Interface Software and Tech - nology , Snowbird , Utah , Oct . , 1990 , pp . 92 - 101 . 2 . Daniel C . Halbert . Programming by Example . Ph . D . Th . , Computer Science Division , Dept . of EE & CS , Univer - sity of California , Berkeley , CA , 1984 . Also Xerox Office Systems Division , Systems Development Department , TR 0SD - T8402 , December , 1984 . 3 . W . J . Hansen . Enhancing documents with embedded programs : How Ness extends insets in the Andrew ToolKit . Proceedings of 1990 International Conference on Computer Languages , IEEE Computer Society Press ( Los Alamitos , CA , 1990 ) , New Orleans , LA , March , 1990 , pp . 23 - 32 , 4 . R . J . Lipton and R . Sedgewick . NOTECH : Typesetting without Formatting . Princeton University , 1990 . 5 . David L . Maulsby , Ian H . Witten , and Kenneth A . Kitt . lit . z . Metamouscx Specifying Graphical Procedures by Example . Computer Graphics , Proccxxiings SIGGRAPH’89 , Boston , MA , July , 1989 , pp . 127 - 136 . 6 . James H . Morris , Mahadev Satyanarayanan , Michael H . Conner , John H . Howard , David S . H . Rosenthal , and F . Donelson Smith . “Andrew : A Distributed Personal Computing Environment” , Communications of the ACM 29 , 3 ( March 1986 ) , 184 - 201 . 7 . Brad A . Myers . Creating Dynamic Interaction Tech - niques by Demonstration . Human Factors in Computing Systems , CHI + GI’87 , Toronto , Ont . , Canada , April , 1987 , pp . 271 - 278 . 8 . Brad A . Myers . Creating User Interfaces by Demonstration . Academic Press , Boston , 1988 . 9 . Brad A . Myers . Invisible Progmmming , 1990 IEEE Workshop on Visual Languages , IEEE Computer Society , Chicago , 111 , Oct . , 1990 , pp . 203 - 208 . 10 . Brad A . Myers . Demonstrational Interfaces : A Step Beyond Direct Manipulation . Tech . Rept . CMU - CS - 90 - 162 , Carnegie Mellon University Computer Science Department , Aug . , 1990 . 11 . Brad A . Myers , Dario A . Giuse , Roger B . Dannenberg , Brad Vander Zanden , David S . Kosbie , Ed Pervin , Andrew Mickish , and Philippe Marchal . “Comprehensive Support for Graphical , Highly - Interactive User Interfaces : The Gar - net User Interface Development Environment” . ZEEE Computer 23 , 11 ( Nov . 1990 ) , 71 - 85 . 12 . Robert P . Nix . “Editing by Example” . ACM Trans - actions on Programming Languages and Systems 7 , 4 ( Oct . 1985 ) , 600 - 621 . 13 . Theo Pavlidis and Christopher J , Van Wyk . An Automatic Beautifier for Drawings and Illustrations . Com - puter Graphics , Proceedings SIGGRAPH’85 , San Fran - cisco , CA , July , 1985 , pp . 225 - 234 . 14 . Ben Shneiderman . “Direct Manipulation : A Step Beyond Programming Languages” . IEEE Computer 16 , 8 ( Aug . 1983 ) , 57 - 69 . 15 . David Canfield Smith , Charles Irby , Ralph Kimball , Bill Verplank , and Erik Harslem . “Designing the Star User Interface’ . . Byte 7 , 4 ( April 1982 ) , 242 - 282 . 256