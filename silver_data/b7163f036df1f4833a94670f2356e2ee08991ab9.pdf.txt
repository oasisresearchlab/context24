Biol Cybern ( 2011 ) 105 : 355 – 370 DOI 10 . 1007 / s00422 - 012 - 0471 - 0 ORIGINAL PAPER Towards a theoretical foundation for morphological computation with compliant bodies Helmut Hauser · Auke J . Ijspeert · Rudolf M . Füchslin · Rolf Pfeifer · Wolfgang Maass Received : 24 April 2011 / Accepted : 8 January 2012 / Published online : 31 January 2012 © The Author ( s ) 2012 . This article is published with open access at Springerlink . com Abstract The control of compliant robots is , due to their often nonlinear and complex dynamics , inherently difﬁcult . The vision of morphological computation proposes to view these aspects not only as problems , but rather also as parts of the solution . Non - rigid body parts are not seen any - more as imperfect realizations of rigid body parts , but rather as potential computational resources . The applicability of this vision has already been demonstrated for a variety of complex robot control problems . Nevertheless , a theoreti - cal basis for understanding the capabilities and limitations of morphological computation has been missing so far . We present a model for morphological computation with compli - ant bodies , where a precise mathematical characterization of the potential computational contribution of a complex phys - ical body is feasible . The theory suggests that complexity and nonlinearity , typically unwanted properties of robots , are desired features in order to provide computational power . We demonstrate that simple generic models of physical bodies , Electronic supplementary material The online version of this article ( doi : 10 . 1007 / s00422 - 012 - 0471 - 0 ) contains supplementary material , which is available to authorized users . H . Hauser ( B ) · R . M . Füchslin · R . Pfeifer Artiﬁcial Intelligence Laboratory , Department of Informatics , University of Zurich , Andreasstrasse 15 , 8050 Zurich , Switzerland e - mail : hhauser @ iﬁ . uzh . ch R . M . Füchslin ZHAW Zurich University of Applied Sciences , Center for Applied Mathematics and Physics ZAMP , 8401 Winterthur , Switzerland A . J . Ijspeert École Polytechnique Fédérale de Lausanne , Biorobotics Laboratory BIOROB , 1015 Lausanne , Switzerland W . Maass Graz University of Technology , Institute for Theoretical Computer Science , 8010 Graz , Austria based on mass - spring systems , can be used to implement complex nonlinear operators . By adding a simple readout ( which is static and linear ) to the morphology , such devices are able to emulate complex mappings of input to output streams in continuous time . Hence , by outsourcing parts of the computation to the physical body , the difﬁcult problem of learning to control a complex body , could be reduced to a simple and perspicuous learning task , which can not get stuck in local minima of an error function . Keywords Morphological computation · Embodiment · Analog computation · Volterra series · Nonlinear mass - spring systems 1 Introduction Most classical robot designs are based on rigid body parts connected by high torque servos and a central controller to coordinate them . This approach follows the view that the physical body is some complex ( dynamic ) system , which has to be dominated by a cleverly designed central controller . Although this is the standard approach , the resulting robots typically perform poorly compared to their biological role models . They are rather inﬂexible , exhibit jerky movements and tend to have a high energy consumption , see for example , Collins et al . ( 2005 ) . On the other hand , the vision of mor - phological computation proposes a radical different point of view , see Pfeifer and Bongard ( 2007 ) . Instead of suppressing the complex dynamics introduced by the compliant physical body , which is the reason why classical robots are built of rigid parts , the body could be potentially employed as a com - putational resource . This suggests that at least a part of the computations , which are needed during interaction , could be outsourced to the physical body itself . Hence , the body is 123 356 Biol Cybern ( 2011 ) 105 : 355 – 370 not seen anymore as a device , which is deemed to merely drag the brain around , but rather that it is highly involved in computational tasks . As a result , the remaining learning or control task and its implementation is less complex , than it would be without the aid of the physical body . The term morphological computation is rather general . It not only includes a broad range of different levels of com - plexity regarding computation but also embraces a huge vari - ety of different morphologies ( e . g . , on the molecular level as well on the level of biological organisms ) . 1 The theoreti - cal framework , which we will present , is not able to cover all these possible types of morphological computation . We will use the term in the context of generic models ( based on mass - spring systems ) of muscle – skeleton systems of biolog - ical systems and the corresponding compliant structures in robots . We address morphological computation in the context where it is possible to outsource relevant parts of the com - putation to the morphology ( i . e . , to the compliant physical body ) . As a consequence , the morphology will allow us to reduce the complex task of emulating nonlinear computation to the much simpler task to adapt some linear parameters for an additional readout . Regarding the type of computation , we considermathematicalmodels , whichcanbecharacterizedas complex mappings of input to output streams in continuous time . There are a lot of cases of biological systems , which sug - gest that the concept of morphological computation is of value for real - world applications . For a number of examples and a general discussion of morphological computation , we refer to Pfeifer and Bongard ( 2007 ) . Inspired by that idea , dif - ferent robots have been designed . A rigorous implementation of this concept are passive walkers . The ﬁrst of a series was developed by McGeer ( 1990 ) . Typically , such a robot has no active controller at all . Only its passive physical struc - ture maintains the balance in a robust fashion , while it walks down a slope . Therefore , one could argue that the computa - tion , which is needed in order to balance the robot robustly , is “computed” by the physical body itself . A further develop - ment are passive walkers with attached ( active ) controllers in order to enable the robots to walk even on ﬂat ground , e . g . , Wisse and Frankenhuyzen ( 2003 ) . The used controllers are remarkably simple , since most of the “computational work” is done by the physical body . A clever design does not only simplify the controlling task but also the task to learn to con - trol . For example , Tedrake et al . ( 2005 ) showed that the com - plexity of the task to learn to walk was drastically reduced by the use of a passive walker . Due to the design of the physical 1 It is also closely related to the concept of embodiment , which is the dynamicandreciprocalcouplingamongbrain ( control ) , body , andenvi - ronment as deﬁned in Pfeifer et al . ( 2007 ) . structure of the robot , the system was able to explore online different walking strategies without loosing balance . Next to the two - legged walking robots , there exist also a number of biologically inspired robots , which mimic a range of species by simultaneously implementing the concept of morphological computation . For example , the simple quad - ruped robot by Iida and Pfeifer ( 2006 ) with a mixture of active and passive joints exhibits a surprisingly robust behav - ior , although no explicit control feedback is used . Another successful implementation is the artiﬁcial ﬁsh “Wanda” by Ziegler et al . ( 2006 ) . It exploits the dynamics between its physical body and its environment . In the physically more complex ﬁeld of ﬂying has also been demonstrated that morphological computation can play an important role , for example , to stabilize ﬂight , e . g . , Wood ( 2007 ) and Shim and Husbands ( 2007 ) . Another more abstract implementation of the idea of mor - phological computation are tensegrity robots , see Paul et al . ( 2006 ) . These robots are built of a special combination of rigid struts and compliant strings . Already simple control - lers ( found by genetic algorithms ) were able to induce loco - motion by indirectly exploiting the dynamics of the physical body . Despite the large body of evidence , which suggests that morphology plays an important role in the successful inter - action of complex bodies with their environment , so far there has been no rigorous theoretical basis for this phe - nomenon . As far as the authors know , there has been only one attempt by Paul ( 2006 ) . Her line of argumentation , based on real - world and thought experiments , resulted in the heuristic that a physical body with a greater amount of “dynamic coupling” ( complexity ) has a higher possi - bility of a reduced control requirement . While her state - ment is correct , as we see later , it is rather vague . On the other hand , we will provide a precise mathematical model to describe the computational power of physical bodies . This will not only enable us to grasp the capa - bilities and limitations of morphological computation but also will give us insight of how to construct physical bod - ies in order to be computationally more versatile than others . This raises the question : What type of computation is use - ful for biological systems and , therefore , for biologically inspired robots ? Classical computation models , such as Tur - ing machines , simply map a batch of input numbers in an off - line computation onto output numbers . However , this type of computation is far from the needs of a robot , which should act in a real environment . It has to integrate continuously information from various continuous input streams ( sensory information ) and map them onto multiple output streams ( motor control ) . Typically , such streams are mathematically encodedasfunctionsoftime . Computations , whichmapfrom such continuous input streams to a continuous output stream , 123 Biol Cybern ( 2011 ) 105 : 355 – 370 357 A B C D Fig . 1 From abstract theoretical models for morphological computa - tion to real physical bodies ( consisting of mass - spring systems ) . a The morphology ( represented here by an array of randomly chosen , time - invariant , fading memory ﬁlters B 1 , . . . , B k ) contributes all temporal integration that is required to approximate a given ﬁlter F . The read - out f is here some memoryless , continuous function and provides the necessary nonlinear combination . Our theory provides evidence for a surprisingly large computational power of this simple architecture . b A possible implementation of ( a ) with a physical body . The ﬁlter array is built of an array of linear mass - spring systems and the readout is imple - mented by a feedforward artiﬁcial neural network ( ANN ) . c In this architecture , the morphology contributes , in addition to the temporal integration via fading memory ﬁlters , generic nonlinear preprocessing in the form of some arbitrary kernel ( i . e . , nonlinear projection of x ( t ) into a higher dimensional space ) . In this case , only a linear readout ( instead of e . g . , an feedforward ANN ) has to be added externally . d A possible physical realization of ( c ) . The array of ﬁlters and the kernel are both implemented by a randomly connected network of nonlinear springs and masses . In the resulting computational device , the output weights [ w out , 1 , . . . , w out , l ] are the only parameters , which are adapted in order to approximate a given complex ﬁlter F are referred to operators or ﬁlters . We will use here the expression ﬁlter , 2 denoted by F . In principle , the compu - tation of a ﬁlter F involves two nontrivial computational processes . First temporal integration of information ( which is needed if the current output y ( t ) does not depend only on the actual input u ( t ) but also on the values u ( s ) for some time points s < t ) , and , second , the nonlinear combination of such temporally integrated information . We will provide two theoretical models , each of which is able to represent both computational processes . The considered models are depicted in Fig . 1a , c . We will demonstrate that both of them can be implemented with the help of generic physical bodies , provided that they are sufﬁciently complex , i . e . , non - rigid and diverse . Fig - ure 1b , d depicts two proposed corresponding real phys - ical implementations of these models with mass - spring systems . Note that physical bodies of biological systems as well of compliant robots can be described by such mass - spring systems . We will provide proofs that such physical realizations tend to represent the two theoret - 2 Note that although the term ﬁlter is often associated with somewhat trivial signal processing or preprocessing devices one should not fall into the trap of identifying the general term of a ﬁlter , as we use it here , with special classes of ﬁlters , like , for example , linear ﬁlters . ical models and , therefore , emulate their computational powers . Furthermore , we will present a number of simula - tions to support this view . For both models , we are able to demonstrate ( with sim - ulations ) the contribution of the morphological structure to the computation . In the ﬁrst setup ( Fig . 1a , b ) , the morpho - logical structure contributes only the temporal integration . Therefore , in order to complete the computation , a nonlin - ear , but static readout has to be added . In the second setup ( Fig . 1c , d ) , the morphology provides both necessary com - putational processes ( i . e . , temporal integration and nonlinear combination ) . As a consequence , only a linear , static readout is needed . The corresponding linear “weights” can be calcu - lated by some simple , supervised algorithms , such as linear regression ( LR ) , but our setup also offers the potential use of some reward based ( as in Legenstein et al . 2010 ) or even completely unsupervised learning rules , such as Slow Fea - ture Analysis as proposed in Wiskott and Sejnowski ( 2002 ) . To put it in other words , the learning of complex , nonlin - ear dynamic ﬁlters can be reduced , through the help of the physical body ( morphology ) , to the much simpler task of learning some static , linear weights . This perspective points to a particularly interesting feature of morphological com - putation , namely that it facilitates the learning of complex ﬁlters . Usually the learning of such ﬁlters requires nonlinear 123 358 Biol Cybern ( 2011 ) 105 : 355 – 370 optimization procedures , which often get stuck in local min - ima of the error function and , which also tend to generalize not too well to new inputs . However , since the morphologi - cal computation reduces this learning problem to the learning of some static output weights , it is guaranteed that learning can not get stuck in local minima of the mean squared error ( mse ) function and has arguably optimal generalization capa - bilities , 3 see Bartlett and Maass ( 2003 ) . Inaddition , wedemonstrateinoursimulationsthatarather arbitrarily given ( or“found” ) physical body can be employed for such morphological computations , since the parameters of the simulated physical bodies were not optimized for the approximation of a given ﬁlter F , but rather randomly chosen from a given probability distribution . 4 This implies that the same physical body can in principle be used for carrying out many morphological computations simultaneously by using a corresponding number of readouts from this physical body . In other words , multitasking of morphological computations is an inherent property of the setups that we describe in this article . In the next section , we provide the theoretical foundations for morphological computations and prove that our proposed physical implementations with mass - spring systems are valid physical realizations of the theoretical models . In Sects . 3 and 4 , we present various simulations to support the results of the theoretical analysis . Finally , we conclude with a discussion . 2 Theoretical foundations In this section , we present the theoretical foundations for morphological computation . We will show that certain ( generic ) types of physical bodies ( i . e . , which consist of mass - spring systems ) can be exploited as computational resources . Enhanced only by a static ( memoryless ) readout they can be used to approximate uniformly any given ﬁlter F ( linear or nonlinear ) from the class of time - invariant ﬁl - ters with fading memory . The restriction to time - invariant , fading memory ﬁlters is requested by the theory we provide . However , such a restriction is not a drawback at all , since all 3 Results from statistical learning theory , see Vapnik ( 1998 ) , imply that the test error of any classiﬁer from a hypothesis class H can be bounded from above by the error on the set of training examples ( drawn from the same distribution D as the test set ) , plus a term that grows with the VC - dimension of H . This upper bound holds for any distribution D , hence , also if there are correlations among different coordinates of examples ( therefore , this upper bound can also be applied to read - outs from a reservoir ) . The hypothesis class H of linear classiﬁers over examples of dimension n has VC - dimension n + 1 ( see Bartlett and Maass 2003 ) , which is the smallest VC - dimension of any nontrivial class H of classiﬁers ( that allows that classiﬁers take all n coordinates into account ) . 4 Note that the optimization of the readout is a convex optimization problem , however , “optimizing” the body ( i . e . , its parameters ) is not . physical systems are time - invariant and a lot of practically interesting ﬁlters have the property of fading memory . Preliminary let us clarify the notation we use . We are con - sidering computations , which map from functions ( or vec - tor of functions ) to functions . We we will refer to them as ﬁlters F . The input is denoted by u : R → R n and the output by y . The argument t of u ( t ) and y ( t ) is interpreted as the time point t . The input domain is denoted by U . Therefore , we write for the ﬁlter F : U → R R , where R R is the class of all functions from R to R . In order to express that the output y ( t ) at time t is the result of applying the ﬁlter F to an input u , we write y ( t ) = ( F u ) ( t ) . Now we are ready to deﬁne the desired properties of time invariance and fading memory for the considered ﬁlters . Fading memory is a continuity property of ﬁlters . It requires that for any input function u ( · ) ∈ U , the output ( F u ) ( 0 ) can be approximated by the outputs ( F v ) ( 0 ) for any other input function v ( · ) ∈ U that approximated u ( · ) on a sufﬁciently long time interval [ − T , 0 ] in the past . 5 Thus , in order to approximate ( F u ) ( 0 ) , it is not necessary to know the precise value of the input function u ( s ) for any time s , and it is also not necessary to have knowledge about values of u ( · ) for more than a ﬁnite time interval back into the past . Time - invariant ﬁlters are ﬁlters , which can be computed by devices that are input - driven , in the sense that the output does not depend on any absolute internal clock of the compu - tational device . Formally one says , a ﬁlter F is time - invari - ant , if any temporal shift of the input function u ( · ) by some amount t 0 causes a temporal shift of the output function by the same amount t 0 , i . e . , ( F u t 0 ) ( t ) = ( F u ) ( t + t 0 ) for all t , t 0 ∈ R , where u t 0 is the function deﬁned by u t 0 ( t ) : = u ( t + t 0 ) . Note that if the domain U of input functions u ( · ) is closed under temporal shifts , then a time - invariant ﬁlter F : U → R R is characterized uniquely by the values y ( 0 ) = ( F u ) ( 0 ) of its output functions y ( · ) at time 0 . In other words , in order to characterize a time - invariant ﬁlter F , we just have to observe its output values at time 0 , while its input varies over all functions u ( · ) ∈ U . Another way to characterize nonlinear , time - invariant ﬁl - ters with fading memory is to describe them with Volter - ra series . 6 A Volterra series is a ﬁnite or inﬁnite sum ( with d = 0 , 1 , . . . ) of terms of the form ∞ (cid:2) 0 . . . ∞ (cid:2) 0 h d ( τ 1 , . . . , τ d ) · u ( t − τ 1 ) · . . . · u ( t − τ d ) d τ 1 . . . d τ d , 5 Formally one deﬁnes : A ﬁlter F : U → R R has fading memory , if for every u ∈ U and every ε > 0 there exist δ > 0 and T > 0 so that | ( F v ) ( 0 ) − ( F u ) ( 0 ) | < ε for all v ∈ U with (cid:5) u ( t ) − v ( t ) (cid:5) < δ for all t ∈ [ − T , 0 ] . 6 Infact , undersomemildconditionsonthedomain U ofinputstreams , the class of time - invariant , fading memory ﬁlters coincides with the class of ﬁlters , which can be characterized by Volterra series . 123 Biol Cybern ( 2011 ) 105 : 355 – 370 359 wheresomeintegralkernel h d isappliedtoproductsofdegree d of the input stream u ( · ) at various time points t − τ i back in the past . Note that the Volterra series presentation is rather general and , therefore , is able to describe a number of interesting ﬁl - ters . For example , it is possible to express a simple integra - tion of information over time , i . e . , memory . However , more interestingly in the context of robotics , a Volterra series is also able to represent any continuous , nonlinear dynamical system with a single exponentially stable equilibrium point , for a proof please refer to Boyd ( 1985 ) . Since our proof will take the Volterra series presentation as a basis , as a conse - quence , our morphological computation devices , which will introduce here , are in principle able to emulate the same class of complex ﬁlters . Inorder toshow that suchcomplexﬁlters F canbeapprox - imated with the help of certain types of physical bodies ( which consist of mass - spring systems ) , we use a theoret - ical result from Boyd and Chua ( 1985 ) . This result builds on the Stone – Weierstrass approximation theorem and it implies that arbitrary time - invariant ﬁlters with fading memory can be uniformly approximated by computational devices , which consist of two stages : – an array or ﬁlter bank of ﬁnitely many “basis ﬁlters” B 1 , . . . , B k in parallel that all receive the same input func - tion u : R → R n , and which are all assumed to be time - invariant with fading memory – a memoryless ( i . e . , static ) readout function f : R k → R that maps the vector of outputs x ( t ) = (cid:6) ( B 1 u ) ( t ) . . . , ( B k u ) ( t ) (cid:7) of the ﬁrst stage at time t onto some output y ( t ) . Figure 1a reﬂects this setup . A remarkable fact , which pro - vides the basis for our theoretical analysis of morphological computation , is that the basis ﬁlters B 1 , . . . , B k of the ﬁl - ter bank are not required to be of a particular form . Rather , they can be chosen from any pool of time - invariant , fading memory ﬁlters , 7 which satisﬁes the following pointwise sep - aration property . Definition A class B of basis ﬁlters has the pointwise sep - aration property , if there exists for any two input functions u ( · ) , v ( · ) with u ( s ) (cid:8) = v ( s ) for some s ≤ t a basis ﬁlter B ∈ B with ( Bu ) ( t ) (cid:8) = ( B v ) ( t ) . This pointwise separation property is satisﬁed by simple , explicitly deﬁned classes B , such as the class of tapped delay lines . However , it tends to be satisﬁed also by classes B of “found” physical realizations of linear and nonlinear ﬁlters . 7 Note that the class of nonlinear ﬁlters F , which we want to approx - imate by our computational device , is much richer than the class of ﬁlters , which can be used to build the ﬁlter bank . We will show that linear mass - spring systems are one type of such physically realizable ﬁlters , which form a class B , which has the pointwise separation property . An interesting fact is that , although no conditions are imposed on partic - ular ﬁlters of B , a substantial diversity among the ﬁlters in B is required . A remarkable consequence is that a physical implementation of such a ﬁlter bank ( in form of a morpholog - ical structure ) has to exhibit this substantial diversity . While classical approaches to control robots try to avoid such com - plexity , or at least try to reduce it , our theoretical model of morphological computation demands it and , therefore , pro - vides potentially an explanation of the complexity of biolog - ical systems . 8 Based on the definition of the pointwise separation prop - erty and the theorem and proof provided by Boyd and Chua ( 1985 ) , we can state the following theorem : Theorem Any time - invariant ﬁlter F with fading memory that maps some n - dimensional input stream u ∈ U onto an output stream y can be approximated with any desired degree of precision by the simple computational model shown in Fig . 1a , 1 . if there is a rich enough pool B of basis ﬁlters ( time - invariant , with fading memory ) , from which the basis ﬁl - ters B 1 , . . . , B k in the ﬁlter bank can be chosen ( B needs to have the pointwise separation property ) and 2 . if there is a rich enough pool R from which the readout functions f can be chosen ( R needs to have the universal approximation property , i . e . , any continuous function on a compact domain can be uniformly approximated by func - tions from R ) . For a detailed proof , we refer to Theorem 1 in Maass et al . ( 2002 ) and Theorem 3 . 1 in Maass and Sontag ( 2000 ) and their corresponding proofs . They applied this theory to arti - ﬁcial and spiking neural networks . However , we are going to use this mathematical framework in the context of mor - phological computation . Hence , we will employ models of compliant bodies of biological systems and real robots instead of neural networks . In order to apply the presented theory to a morphological computation setup , we have to decide on how to implement the basis ﬁlters and the read - out function as depicted in Fig . 1a . One possibility is to use real physical linear mass - spring systems to build the ﬁlter bank and a feedforward artiﬁcial neural network ( ANN ) as readout function . In order to show that this choice is consistent with the previously stated theorem , we have to demonstrate that linear mass - spring systems are time - invari - ant , have fading memory and that a pool of such sys - tems has the pointwise separation property . Regarding the 8 Note that Paul ( 2006 ) came to a similar conclusion . 123 360 Biol Cybern ( 2011 ) 105 : 355 – 370 readout , we have to demonstrate that a pool of ANNs has the universal approximation property . However , the latter one has already been proven by Hornik et al . ( 1989 ) , demon - strating that already feedforward networks with one hidden layer exhibit this property . Note that in a biological system the nonlinear readout might be implemented by a biological neural network . This leaves us with the task to prove the validity of using linear mass - spring systems to build the ﬁlter bank . A sin - gle linear mass - spring system can be described by following equations : ˙ x 1 = x 2 ˙ x 2 = − k m x 1 − d m x 2 + 1 m u ( 1 ) y = x 1 , where x 1 is the displacement relative to the resting length l 0 of the spring , x 2 the rate of change of x 1 ( velocity ˙ x 1 ) , k ∈ R + the linear spring constant , d ∈ R + the linear damp - ing constant , m the mass of the endpoint , and u the sum of all external forces acting on the mass . First , it can be eas - ily seen that the dynamic system of Eq . 1 is time - invariant . Second , we have to show that the system has the property of fading memory . Since it is ﬁnite - dimensional and linear , it is sufﬁcient to demonstrate that it is exponentially stable , see Sect . 5 . 1 in Boyd and Chua ( 1985 ) . The eigenvalues of the system are s 1 , 2 = − d / 2 m ± (cid:3) ( d / 2 m ) 2 − ( k / m ) . Since in real physical realizations of such systems k , m ∈ R > 0 , the real part − d / 2 m is negative for any values of k and m . Hence , the system is exponentially stable and , therefore , has the property of fading memory . Third , the pointwise sepa - ration property of a pool of similar systems was discussed in Sect . 5 . 2 of Boyd and Chua ( 1985 ) , where it was shown that this property holds for a special class of systems , i . e . , Wiener’s Laguerre systems . It can be shown that not only this special subset has the pointwise separation property , but any class of ﬁnite - dimensional , linear dynamic systems , see Boyd and Chua ( 1985 ) , to which the system of Eq . 1 also belongs to . Hence , real physical linear mass - spring systems can be used as basis ﬁlters B 1 , . . . , B k in the setup with feed - forward 9 mass - spring systems as depicted in Fig . 1b . Of course there exist a number of other possible imple - mentations . A closely related morphology in a biological sys - tem is the structure of the wings of a bird . A number of diverse feathers receive the same input ( i . e . , air pressure ) and mechanoreceptors measure the distortions . This could repre - sent a biological implementation of the ﬁlter bank of our proposed theoretical model . Remarkably , the resulting mor - phological computation has already been considered in Shim and Husbands ( 2007 ) . They used nonlinear angular springs to simulate the distortions of the feathers and combined it with 9 As opposed to the recurrent networks as sketched in Fig . 1c , d . simulated mechanoreceptors and a neural network ( i . e . , non - linear readout ) . The network weights were found by genetic algorithms . While their design was inspired by the biological system itself , we provide here a theoretical model , which is able to explain their results . So far , we have only considered a setup with a clear sep - aration of the temporal integration ( implemented by a ﬁlter bank of linear mass - spring systems ) and the nonlinear com - bination ( implemented by an ANN ) . However , one could also consider to merge both stages into one morphological struc - ture . As a consequence , the physical body would be then not only responsible for the temporal integration ( as in the ﬁl - ter bank setup ) but also for the nonlinear combination ( see Fig . 1c ) . In this context , one could choose for R a pool of functions consisting of a ﬁxed nonlinear kernel . The notion of a kernel 10 that we use here is closely related to the notion of a kernel for Support Vector Machines in machine learning as in Vapnik ( 1998 ) . However , whereas a kernel for a Support Vec - tor Machine is a virtual mathematical concept , we are con - sidering here concrete physical implementations of a kernel . As a consequence , such a kernel can only satisfy the kernel property for a ﬁxed ﬁnite range . However , sufﬁciently large and randomly connected analog circuit of sufﬁciently many and diverse nonlinear components tend to map a large class of pairwise different inputs onto linear independent outputs . Therefore , a particularly tempting option for morphological computation is to let both , the ﬁlter bank and the kernel , be realized by a single physical body . We will demonstrate with the help of simulations that random , recurrently connected networks of nonlinear springs and masses tend to have this “kernel property . ” In other words , such a physical body tends to carry out temporal integration and nonlinear combination at once . Note that in contrast to the setup with feedforward mass - spring systems , where the readout was an ANN , in this case only an additional linear readout is required . Hence , learning to approximate a given nonlinear ( time - invariant , fading memory ) ﬁlter F is reduced to the simpler task of learning some weights , providing a number of advantages as already discussed in the introduction . Figure 1c depicts this idea of combing both computational processes in one physical body . Figure 1d depicts the corresponding proposed physical implementation as a random , recurrent network of nonlinear springs and masses . In the context of biological 10 A kernel ( in the sense of machine learning ) is a nonlinear projection Q of k input variables u 1 , . . . , u k into some high - dimensional space . Forexample , allproducts u i · u j couldbeaddedasfurthercomponentsto the k - dimensional input vector (cid:6) u 1 , . . . , u k (cid:7) . Such nonlinear projection Q boosts the power of any linear readout applied to Q ( u ) . For exam - ple , in the case where Q ( u ) contains all products u i · u j , a subsequent linear readout has the same expressive capability as quadratic readouts f applied to the original input variables u 1 , . . . , u k . More abstractly , Q should map all inputs u that need to be separated by a readout onto a set of linearly independent vectors Q ( u ) . 123 Biol Cybern ( 2011 ) 105 : 355 – 370 361 systems , such networks can serve as a model to describe the complex and compliant properties of their muscle – skeleton systems . Moreover , such generic structures can be employed to model compliant body parts of a robot . Note that it is not possible to conclude from our proposed theory anything about the performances of the proposed mor - phological computation devices ( neither for the feedforward structure of Fig . 1a nor for the recurrent network of Fig . 1c ) . The theory only states that sufﬁciently large morphological computation systems of the proposed types will provide sat - isfactory approximation capabilities , as long as the morphol - ogy is dynamic and sufﬁciently diverse . However , for a given ﬁlter F , the theory does not provide bounds for the required size of the approximating system . Neither is it possible to conclude directly 11 from the theory , which mass - spring sys - tems ( i . e . , which physical properties ) are needed for a well performing morphological computation device , except that a diversity of network components is desirable . Hence , we employ mass - spring systems with a diversity of masses and spring parameters in order to construct our generic models for compliant bodies . We present a number of simulations of the proposed physical implementations ( Fig . 1b , d ) applied to real - world computational tasks ( which are of interest for robotics ) and demonstrate that already relatively small generic structures can be used to emulate complex , nonlinear ﬁlters F . 3 Morphological computation with feedforward mass - spring systems In this section , we present simulations of the proposed phys - ical realization of the morphological computation setup with feedforward mass - spring systems ( Fig . 1b ) . The simulations consisted of an array of parallel linear mass - spring systems ( each of them described by Eq . 1 ) . All static , but nonlinear readouts were implemented as feedforward neural networks , each of them with one hidden layer of sigmoidal neurons and one linear gate as output . In the simulation , we used a generic morphological structure , i . e . , the values , which deﬁned the properties of the involved mass - spring systems ( i . e . , spring constants k and damping constants d ) were drawn randomly from a deﬁned range . The simulations were implemented in Matlab and simulated at a time step of 1ms . We demonstrate that our proposed morphological com - putation device with feedforward mass - spring systems is in principle able to emulate a Volterra series operator . In order to have a clear , but nontrivial example , we chose a Volterra series consisting of a quadratic term with a Gaussian kernel . 11 However , itmightbepossibletoﬁndwellperformingphysicalbodies for a given ﬁlter F by optimization schemes ( e . g . , with genetic algo - rithms ) . Fig . 2 Quadratickernel h 2 ( τ 1 , τ 2 ) usedtodeﬁneaVolterraseriesoper - ator V , which should be approximated by our morphological structure with feedforward mass - spring systems in combination with a nonlinear readout ( i . e . , as depicted in Fig . 1b ) The chosen Volterra series operator V is of the form y ( t ) = V u ( t ) = (cid:2) (cid:2) τ 1 , τ 2 ∈ R + 0 h 2 ( τ 1 , τ 2 ) u ( t − τ 1 ) u ( t − τ 2 ) d τ 1 d τ 2 , ( 2 ) where u ( t ) is the input and h 2 is a Gaussian kernel with μ 1 = μ 2 = 0 . 1 , and σ 1 = σ 2 = 0 . 05 ( in seconds ) , i . e . , h 2 ( τ 1 , τ 2 ) = exp (cid:4) ( τ 1 − μ 1 ) 2 / 2 σ 21 + ( τ 2 − μ 2 ) 2 / 2 σ 22 (cid:5) , which is deﬁned for τ 1 , τ 2 ∈ [ 0 , 0 . 2 ] s . A plot of the kernel can be seen in Fig . 2 . For the simulations , we used a discretized version of the kernel with a discretization step of 1ms . Note that this com - putation is not only a simple memorization of past event , but it is more complex . Any computational model , which should approximate this Volterra series operator V , must provide temporal integration ( the delays τ 1 and τ 2 ) and nonlinearity ( the quadratic term u ( t − τ 1 ) u ( t − τ 2 ) ) . For the input , we chose a product of three sinusoidal functions with different frequencies : u ( t ) = sin ( 2 π f 1 t ) · sin ( 2 π f 2 t ) · sin ( 2 π f 3 t ) with f 1 = 2 . 11 , f 2 = 3 . 73 , and f 3 = 4 . 33Hz . The resulting signal has a period of 100s . After some transitional setting time to get rid of the initial conditions of the mass - spring systems , we used 30 s for learn - ing , the subsequent 10 s for validation , and the consecutive 10 s for testing . The ﬁrst 5s of the testing data can be seen in Fig . 3a . The result from applying the given Volterra series operator V to this input signal u ( t ) is used as target output for the computational device . The ﬁrst 5 s of the target output for the testing data can be seen in Fig . 3c , red line . The input signal u ( t ) was applied to ten linear mass - spring systems ( ﬁlter bank ) . They all had different , random spring and damping constants . The values were randomly drawn from a log - uniform distribution from the interval [ 0 . 1 , 150 ] . The responses of all linear mass - spring systems to the input can be seen in Fig . 3b . They served as inputs to the ANN , which consisted of ten hidden sigmoidal nodes and one lin - ear gate as output . The weights of the ANN were adapted via BFGS quasi - Newton algorithm . The learning process was 123 362 Biol Cybern ( 2011 ) 105 : 355 – 370 0 1 2 3 4 5 −0 . 2 0 0 . 2 input u ( t ) A 0 1 2 3 4 5 −2 0 2 responses of all 10 mass−spring systems B 0 1 2 3 4 5 0 2 4 Volterra task C targetsystem output ANN on raw input 0 1 2 3 4 5 −2 0 2 time [ s ] pendulum task D targetsystem output ANN on raw input Fig . 3 Applying a feedforward morphological computation device to approximate the Volterra series operator V ( deﬁned by Eq . 2 ) and the pendulum ( Eq . 3 ) simultaneouslywithonemorphologicalstructure ( i . e . , multitasking ) . a The used input signal u ( t ) , which consisted of a prod - uct of three different sinusoidal functions ( f 1 = 2 . 11 , f 2 = 3 . 73 , and f 3 = 4 . 33 Hz ) . b The responses of all ten mass - spring systems to this input ( for a better readability the outputs were normalized to zero mean and a standard deviation of one ) . c The performance of the proposed morphological computation device for the Volterra task . The red line is the target ( applying the Volterra series operator to the input , i . e . , V u ( t ) ) and the blue line shows the output of the morphological computation device . The green line shows the performance of the device , when no morphological structure was available , i . e . , only the nonlinear readout of the ANN was applied to the raw input data . Clearly this approach fails , since the ANN is only a static readout and is not able to represent the necessary temporal integration , which was contributed in the previ - ous case by the morphological structure . d The pendulum task : the red line is the target , the blue line the output of the morphological compu - tation device and the green line , when no morphological structure was available terminated , when the error of the validation data started to increase . For more details , please refer to the supplementary material . Figure 3c shows the performance after learning . The red line is the target signal , i . e . , V u ( t ) , and the blue line is the output of our morphological computational device . The achieved mse was 6 . 83 × 10 − 3 on the testing data . In order to demonstrate the contribution of the morpho - logical structure to the computation , we compared the results to the case when no physical body ( no array of mass - spring systems ) was available and only the nonlinear readout ( i . e . , ANN ) on the raw input signal remained . In order to have the same number of weights , the ANN was resized accordingly . The results can be seen in Fig . 3c . The green line is the output of the plain ANN after learning . One can see clearly that this approach failed to emulate the given Volterra series operator . The reason is that the ANN is only a static readout and is not able to represent the necessary temporal integration , which was contributed in the previous case by the morphological structure . As already argued in the introduction , the setup offers the possibility of multitasking , i . e . , the same ﬁxed 12 morphological structure can potentially be used for a number of different tasks . Note that the ability of multitasking is a beneﬁcial feature , since the morphological structures of real robots ( and biological systems ) are to a high degree ﬁxed . 13 In order to demonstrate multitasking , we used the same mor - phological structure ( same ﬁlter bank ) and the same input of the previous task and applied it to a new task by simply adding a new readout ( i . e . , an additional ANN ) . For the additional task , we chose from an interesting sub - class of nonlinear ﬁlters , which can be described by Volterra series , namely the class of nonlinear dynamical system with fading memory . 14 An example of such a dynamical system is the damped pendulum , which can be described by the fol - lowing equations ( taken from Khalil 2002 ) : ˙ α = ω ˙ ω = − g l sin ( α ) − μ m ω + 1 ml 2 A τ ( 3 ) y = α , where α is the angle , ω the angular velocity , g = 9 . 81 m / s 2 the gravitational acceleration , l the length , m the mass of the bob , and μ the friction coefﬁcient . The constant A is a pro - portional factor , which was set to A = 40 in order to drive the system into the nonlinear domain of the state space . For the same reason , we set in the simulations l = 0 . 5 , m = 0 . 1 and d = 1 . The input to the system was the torque τ and the output was the angle α . In order to obtain suitable targets , we simulated the system of Eq . 3 at a time step of 1 ms with Matlab’s internal ordinary differential equation solver . The input u ( t ) , now interpreted as torque τ ( t ) , was the same as in the previous task ( Fig . 3a ) . The red line in Fig . 3d shows the corresponding output ( i . e . , target ) . Since we used the same morphological structure ( the same ﬁlter bank array ) and the same input u ( t ) , consequently , the responsesofthemass - springsystemswerethesameasbefore 12 Note that “ﬁxed” is used in the sense of ﬁxing the parameters , which describe the physical models of the springs . The mass - spring systems themselves have to be dynamic . 13 However , for the biological case exists experimental evidence , that thestiffnesscanchangeinordertoadapttodifferentenvironments ( e . g . , Ferris et al . 1988 ) . 14 Boyd and Chua ( 1985 ) have pointed out that fading memory for ( time - invariant ) dynamical systems is related to the unique steady - state property . For a discussion , we refer to Boyd ( 1985 ) . 123 Biol Cybern ( 2011 ) 105 : 355 – 370 363 ( Fig . 3b ) . Based on these responses as inputs , an ANN with ten hidden sigmoidal neurons and one linear output gate was trained ( with the BFGS quasi - Newton algorithm ) to approx - imate the desired targets . The performance can be seen in Fig . 3d . The resulting mse was 1 . 29 × 10 − 4 . Thus , the ﬁxed generic morphological structure in conjunction with two dif - ferent readouts was able to represent the two different non - linear ﬁlters very well . Again , in order to make the contribution of the morpho - logical structure to the computation explicit , we compared the results to the case when no physical body ( array of mass - spring systems ) was available and only the ANN remained . The performance can be seen in Fig . 3d , where the green line represents the output of the ANN . As before , the ANN applied to the raw input stream failed to represent the desired nonlinear ﬁlter ( i . e . , the pendulum equations ) . As previously argued , the morphological structure has to be diverse in order to be computationally powerful . In order to show that this is true , we set the properties of all the mass - spring systems in the ﬁlter bank to the same values ( k and d were the same ) . The best resulting mse for the Volter - ra task in this case was 0 . 960 , which was more than 140 times higher than with the previously used heterogeneous ﬁlterbank . 4 Morphological computation with recurrent networks of nonlinear springs and masses In the previous simulations , we used the approach with a strict feedforward structure ( Fig . 1a ) . It implemented a spatial separation between a linear but dynamic part ( implemented as an array of linear mass - spring systems ) , which provided temporal integration , andthenonlinear , staticreadout ( imple - mented as a feedforward ANN ) , which provided the nonlin - earity . However , as we have already argued in Sect . 2 , there could exist physical realizations which have the property to combine both computational aspects in a single body . We will demonstrate in the following simulations , that random , recurrent networks of nonlinear springs and masses tend to be such physical realizations . A particular interesting property of this setup is that in contrast to the setup with feedforward mass - spring systems , where a nonlinear readout ( e . g . , ANN ) was needed , in this case only a simple linear readout has to be added in order to complete the morphological compu - tation ( compare Fig . 1b , d ) . In addition , such networks can serve as generic models to describe the complex and nonlin - ear dynamics of the compliant bodies of robots and biological systems ( i . e . , muscle – skeleton system ) . We continue with a description of the implementation of the simulation of such networks followed by a number of example tasks . 4 . 1 Implementation of recurrent networks of nonlinear springs and masses We considered an implementation of random , recurrent net - works of nonlinear springs and masses , to which we refer as mass - spring networks or simple as networks . In the next sec - tions , we describe how we constructed such networks , how we simulated them , and how we implemented the learning process for the linear readout . 4 . 1 . 1 Constructing mass - spring networks The construction of the mass - spring networks was based on the following two principles . First , the ﬁnal network should be realizable as a real physical system , and second , it should be generic , i . e . , not constructed for any speciﬁc task . Achosennumberof N nodes ( masspoints ) wererandomly positioned ( uniformly distributed ) within a deﬁned range of a two - dimensional plane . Subsequently , we connected these mass points by nonlinear springs . In order to ﬁnd reasonable , non - crossing spring connections , we calculated a Delaunay triangulation on this set of points , resulting in L non - crossing spring connections . A schematic example of such a mass - spring network can be seen in Fig . 4 . Every single nonlinear spring of such a network can be described by the following nonlinear dynamic system : ˙ x 1 = x 2 ˙ x 2 = − p ( x 1 ) − q ( x 2 ) + u , ( 4 ) where x 1 = l − l 0 is the difference between the actual length l and the resting length l 0 , x 2 ∈ R is the rate of change of x 1 ( velocity ˙ x 1 ) , and u the sum of all external forces acting on it . At the beginning of the simulation , we assumed the mass - spring network to be at rest ( i . e . , all springs were at their point of equilibrium x i = [ 0 , 0 ] T for i = 1 , . . . , N and therefore all masses were at rest ) . In order to accomplish this we set as per definition the resting lengths l 0 of all nonlinear springstothedistances ( atthestartofthesimulation ) between the mass nodes they connected , hence l 0 : = l ( t = 0 ) . The functions p and q were nonlinear and , in order to have a stable and physically reasonable system , had to be mono - tonically increasing and fulﬁll p ( 0 ) = 0 and q ( 0 ) = 0 . 15 Typically nonlinear springs are modeled by 3rd order polyno - mials , e . g . , as described in Palm ( 1999 ) . Therefore , we imple - mented the nonlinear functions as p ( x 1 ) = k 3 x 31 + k 1 x 1 and q ( x 2 ) = d 3 x 32 + d 1 x 2 , where k 1 , d 1 ∈ R > 0 and k 3 , d 3 ∈ R + deﬁned the properties of the spring . In order to get a rich kernel , as argued in Sect . 2 , the springs should be diverse . 15 A proof for that is based on the Lyapunov function V ( x ) = (cid:6) x 1 0 p ( ζ ) d ζ + 12 x 22 , its derivative ˙ V ( x ) = − x 2 q ( x 2 ) and the use of a corollary of La Salle’s Theorem ( see Theorem 4 . 4 and Corollary 4 . 2 in Khalil ( 2002 ) ) . 123 364 Biol Cybern ( 2011 ) 105 : 355 – 370 Fig . 4 Schematic example of a generic mass - spring network . The nodes ( masses ) are connected by nonlinear springs . The red nodes are ﬁxed in order to hold the network in place . The green nodes are ran - domlychoseninputsnodes , whichreceivetheinputinformofhorizontal forces scaled by randomly initiated weights Hence , the parameters describing the spring properties ( i . e . , k 1 , k 3 , d 1 , and d 3 ) wererandomlydrawnfrom adeﬁnedrange , assigned to the connections and subsequently ﬁxed . The left most and the right most mass nodes were ﬁxed in order to keep the network in place ( red squares in Fig . 4 ) . A certain percentage of all nodes were randomly chosen to be input nodes ( green nodes in Fig . 4 ) . During simulation , they received a linearly scaled version of the current input in form of a horizontal force . Before the simulation started , the input scaling factors ( weights w in = [ w in , 1 , w in , 2 , . . . ] T ) had been randomly drawn from a certain range and had been ﬁxed subsequently . The linear readout of the network was deﬁned as the weighted sum of all actual spring lengths y ( t ) : = (cid:7) Li = 1 w out , i l i ( t ) . The output weights ( w out = [ w out , 1 , w out , 2 , . . . , w out , L ] T ) , incontrasttherestofthenetworkparameters , were adapted in the learning process . 4 . 1 . 2 Simulating mass - spring networks We simulated every single mass points ( of a total number of N ) at a time step of 1ms by the following equations : m ¨ p x = F x + w in u ( 5 ) m ¨ p y = F y , ( 6 ) where ¨ p x and ¨ p y were the accelerations of the mass point rel - ative to a global reference frame split up into its two spatial dimensions , F x and F y were the forces acting on the mass in the corresponding spacial dimensions , and w in u was the weighted input . Note that the input was deﬁned as a hori - zontal force ( see Fig . 5a ) and if the mass point was no input node w in u : = 0 . We chose forces as input form , since for a real compliant robot any interaction with its environment results in forces acting on it . 16 For the sake of simplicity , 17 all 16 We chose the forces to be horizontal for the sake of simplicity , how - ever , the proposed setup works for other force directions too . 17 Note that the masses are only linear scaling factors and , since the properties of the springs were randomly drawn , could be set to 1 for all masses without the loss of generality . Nevertheless , in a real biological A B C Fig . 5 Implementation of input , linear readout , and simulation of forces of the mass - spring networks . a The input is applied to an input node as a horizontal force F x proportional to the input signal u ( scaled by a randomly initialized weight w in for this input node ) . b The read - out from the network is the weighted sum of all L spring lengths y ( t ) = (cid:7) Li = 1 w out , i l i ( t ) . In general , the input as well as the output can be multidimensional . c All the spring forces act along their spring axis . The resulting force F sum is the sum of all forces acting on the node and is found by the summation of the force vectors massesweresetto m = 1 . Theforces F x and F y resultedfrom the nonlinear springs , which were connected to this mass point . The forces they applied to the mass point depended on the states of the nonlinear springs , i . e . , x 1 and x 2 in Eq . 4 . The value of x 1 was calculated by the actual length l ( t ) ( Euclidean distance between the two masses which the spring connected ) and the resting length l 0 . The velocity x 2 was approximated by ( x 1 ( t ) − x 1 ( t − (cid:10) t ) ) / (cid:10) t with a time step of (cid:10) t = 1 ms . The resulting forces were calculated by the nonlinear functions p ( x 1 ) and q ( x 2 ) . This procedure was repeated for all springs connected to the mass . We assumed that these forces acted along their corresponding spring axes . Finally , all spring forces acting on the regarding mass node were summed up vectorially ( see Fig . 5c ) . Subsequently , the resulting force F sum was split up into its two spatial dimen - sions and added as forces F x and F y to Eqs . 5 and 6 . If the mass point was an input node , the current input u ( t ) was added in form of a scaled horizontal force ( see Eq . 5 and Fig . 5a ) . The new position and velocity of the mass were found by integrating Eqs . 5 and 6 numerically with the fourth - order Runge – Kutta method . The same procedure was repeated for all masses . At the end of the simulation step , the current output was calculated by a linear combination of the actual lengths of all springs , i . e . , y ( t ) = (cid:7) Li = 1 w out , i l i ( t ) ( see Fig . 5b ) . 4 . 1 . 3 Learning the linear readout of mass - spring networks . The structure of the mass - spring networks , as well as the parameters , which deﬁned the physical behavior , were ran - domly initialized and subsequently ﬁxed . Only the linear readout was adapted during the learning process , i . e . , the weights w out = [ w out , 1 , w out , 2 , . . . , w out , L ] T were adapted . For learning , we considered a networks of N nodes con - nected by L springs . During the simulation , we collected the current lengths of every single spring l i ( t ) for i = 1 , . . . , L body ( or robot ) a diversity of masses is natural and it contributes further diversity . 123 Biol Cybern ( 2011 ) 105 : 355 – 370 365 Fig . 6 Setup for the robot arm task . The blue line is the desired trajec - tory for the end - effector at every time step t = 1 , . . . , M in a L × M matrix L . We dismissed data from an initial period of time ( washout time ) to get rid of initial transients . The target signal was also col - lected over time in a matrix T . Finally , the optimal values for the output weights were calculated by w ∗ out = L † T , with L † being the ( Moore – Penrose ) pseudoinverse , since in gen - eral L was not a square matrix . Note that the same procedure can be applied in the case of multiple inputs and / or multiple outputs . 4 . 2 Representing inverse dynamics by a recurrent mass - spring network As a ﬁrst task , we will demonstrate that a generic mass - spring network can be used to learn the complex mapping of the end - effector trajectory of a robot arm in Cartesian space to its corresponding torques for a given trajectory ( i . e . , it is able to represent the inverse dynamics for a given trajectory and velocity ) . Note that we do not try to learn the full model of the inverse dynamics , but rather we demonstrate that mass - spring systems can be used to learn directly a given mapping . This is somewhat less complex than emulating a nonlinear ﬁlter , nevertheless , it is a relevant task for a number of pos - sible applications for our proposed setup . We used a full dynamic model of a two link robot arm from Slotine and Li ( 1991 ) , which was assumed to move in a hor - izontal plane . Hence , the gravitational forces were ignored . We refer to the supplementary material for further details on the robot model . Figure 6 shows the setup of the task . The end - effector of the robot arm had to move along the blue trajectory . The corresponding trajectories in Carte - sian space , i . e . , x and y positions , are plotted in Fig . 8a . The corresponding targets torques , which allowed the robot arm to move along these trajectories , can be seen in Fig . 8c ( red lines ) . These torques were found by the following process : We chose an arbitrary starting posture . Based on the x - and y - trajectories ( which deﬁned the Fig . 8 trajectory in Cartesian space ) and the Jacobian of the robot arm we calculated the corresponding trajectories of the joint angles . Subsequently , the corresponding torques were found by the Fig . 7 Generic mass - spring network used for the robot arm task and subsequently for the multitasking task in Sect . 4 . 3 . The red nodes are globallyﬁxedandthe green nodesaretherandomlychoseninputnodes . The network consisted of 30 masses and 78 nonlinear springs use of PD - controllers 18 in order to follow those joint angle trajectories . We constructed a generic mass - spring network based on the previously described process ( Sect . 4 . 1 . 1 ) . The param - eters of the springs ( i . e . , k 1 , k 3 , d 1 , and d 3 as deﬁned in Sect . 4 . 1 . 1 ) were randomly drawn from the range [ 1 , 100 ] ( log - uniform distribution ) for the values k 1 and d 1 , and from [ 100 , 200 ] ( uniform distribution ) for the values k 3 and d 3 . We chose randomly 20 % of all nodes to be input nodes for the ﬁrst input ( i . e . , input signal x ) and also 20 % of all nodes for the second input ( i . e . , y ) . For more details , please refer to the supplementary material . One of the obtained mass - spring networks can be seen in Fig . 7 . It consisted of 30 masses and 78 nonlinear springs . As described in Sect . 4 , the randomly chosen input nodes ( green nodes ) received a scaled horizontal force proportional to the input . The scaling weights w in were randomly ( uniform distribution ) drawn from [ − 1 , + 1 ] . The mass - spring network responded to this inputs by changing the mass positions and the spring lengths . Figure 8b shows ten typical spring length trajectories ( out of all 78 ) . For a better readability , the tra - jectories in this plot were normalized to zero mean and a standard deviation of one . Based on the targets , all 78 spring length trajectories and the previously described learning pro - cesswecalculatedtheoptimaloutputweights . Notethatthese weights were static , i . e . , did not provide temporal integration , and that the resulting readout was linear , i . e . , it did not pro - vide any nonlinearity . Figure 8c shows the performance after learning ( using the network of Fig . 7 ) . The red lines are the target torques and the blue lines are the outputs of the mor - phological computation device ( solid blue for τ 1 and dashed blue for τ 2 ) . We can see that the setup was able to represent the dynamic mapping from the Cartesian space to the robot arm torques . In order to demonstrate the contribution of the morpho - logical structure to the computation , we compared the results to the case when no physical body ( i . e . , no mass - spring net - work ) was available and only the linear readout remained . 18 TheusedPandDvalueswereempiricallyfoundtohaveareasonable performance . 123 366 Biol Cybern ( 2011 ) 105 : 355 – 370 In order to do so , we applied LR on the raw input signals . Therefore , we deﬁned the output at time t by τ LR1 ( t ) = w 1 x ( t ) + w 2 y ( t ) + w bias , where x and y were the inputs ( as in Fig . 8a ) and w LR = [ w 1 , w 2 , w bias ] T were some sta - tic weights , which were found by standard LR . Accordingly , we calculated the three corresponding weights for the second output τ 2 . Figure 8d shows the performance of this approach . The red lines are the targets and the green lines are the out - puts . The approach failed because it was no able to represent the necessary temporal integration and nonlinear combina - tion . In the previous case ( with the physical body ) , the mor - phological structure provided both of these computational aspects . 19 The network of Fig . 7 was chosen based on the fact that it was the best performing network out of 400 networks constructed with the same probability distribution , i . e . , the same construction parameters , which deﬁned the ranges for the random values used for the construction process . More specifically , these construction parameters were the deﬁned ranges , from which the spring parameters were drawn from , the percentage of all nodes , which received an input , the range for the input weights w in and the size of the area in which we randomly placed all mass points . This raises the question whether it is easy to ﬁnd such a set of parame - ters , which deﬁnes a pool of well performing networks . Note that , for example , the range of possible values for the spring parameters k 1 and d 1 went over two decades ( [ 1 , 100 ] —see description above ) . This points to the fact that no tedious parameter tuning was necessary . In order to demonstrate that the used ( rather broad ranged ) construction parameters deﬁned a whole set of well performing networks , and the presented network was not just a statistical outlier , we con - structed 400 random networks using exactly these parame - ters . Subsequently , we sorted the networks according to their performances ( i . e . , by their averaged mean squared error over both outputs ; denoted here by mse ) . The results are presented in Fig . 8f . We can see that even the worst performing network had still a mse smaller than 10 − 3 . Out of the 400 mass - spring networks we chose the best network ( blue line ) , the worst ( black dotted line ) , and the median network ( green line ) . 20 The table in Fig . 8 lists the mse of them . Figure 8c shows the performance of the best network . Figure 8e shows the per - formances of the worst network ( black dotted line ) and the median network ( green line ) . Similar results can be obtained for other tasks and construction parameters . This suggests that in general no tedious parameter search has to be done in order to ﬁnd probability distributions to deﬁne a successful pool of networks . This means that the physical body does not 19 Note that in the setup used in the Sect . 3 the physical body only provided the temporal integration . 20 By median , we mean that half of all networks had a better and the other half had an equal or worse performance . 0 2 4 6 8 10 12 14 0 0 . 5 1 the input : desired end−effector trajectories A xy 0 2 4 6 8 10 12 14 −2 0 2 10 out of all 78 reponses of the network , i . e . , spring lengths l ( t ) B 0 2 4 6 8 10 12 14 −0 . 5 0 0 . 5 outputs of the morphological computation device C targets system output τ 1 system output τ 2 0 2 4 6 8 10 12 14 −0 . 5 0 0 . 5 performance when no morphology was available ( only linear regression ) D targets LR τ 1 LR τ 2 0 2 4 6 8 10 12 14 −0 . 5 0 0 . 5 time [ s ] performances of the worst and median network E targetmedianworst 1 100 200 300 400 10 −6 10 −5 10 −4 10 −3 10 −2 # idx [ ] m s e F best net medianworst Fig . 8 Representation of the inverse dynamics of a robot arm with the help of morphological computation . a The desired end - effector tra - jectory split up in its two Cartesian coordinates x and y ( i . e . , inputs ) . b Ten typicalresponses ( out of all 78 ) of the mass - spring network to this input . For a better readability , each signal was normalized to zero mean and a standard deviation of one . c The performance of the morpholog - ical computation device . The red lines are the target torque trajectories and the blue lines are the outputs of the computational device . d The performance when no morphological structure was available , i . e . , only a LR on the actual values of the inputs remained . This approach failed to represent the dynamic and nonlinear mapping . e , f Based on the same construction parameters , we randomly generated 400 networks and sorted them by their mean squared error ( mse ) over its two out - puts . The table shows the performances of the best , the worst , and the median network . The best network was used for the plot of ( c ) . The performances of the worst ( black dotted line ) and the median network ( green ) are presented in ( f ) 123 Biol Cybern ( 2011 ) 105 : 355 – 370 367 have to be tuned for a speciﬁc task in order to be a valid com - putational resource , as long as it is sufﬁciently complex and diverse . Therefore , the same morphological structure could be potentially used for a number of different tasks simulta - neously ( i . e . , multitasking ) . We argued in the Sect . 2 that a diversity , i . e . , different physical parameters , is an important property of a compu - tationally powerful physical body . In order to demonstrate the validity of this assumption , we simulated the same net - work structure ( Fig . 7 ) , but now with all spring having the same physical parameters . We set all k 1 values to the average value of the previously used network . Accordingly , we set the values for k 3 , d 1 , and d 3 . The averaged mse over both outputs was 5 . 2 × 10 − 3 , which was 7 , 600 times higher than the best randomly found network and still about seven times higher than the worst one . 4 . 3 Multitasking property of a mass - spring network In the previous section , we demonstrated that mass - spring networks can be employed to represent a direct mapping . However , the theory suggests that the setup is more powerful and that it even can be employed to emulate complex , non - linear ﬁlters . In this context , we present here three different tasks ( i . e . , ﬁlters to emulate ) and , additionally , we demon - strate that mass - spring networks have the desired property of multitasking . By multitasking , we refer to the ability to carry out various computations simultaneously—in our con - text , employing the same physical body for different compu - tational tasks at the same time . Note that in contrast to the multitasking in the setup with feedforward mass - spring sys - tems ( Sect . 3 ) , where we used different ANNs as readouts , in the case of mass - spring networks only a corresponding num - ber of linear readouts is sufﬁcient . For the following simu - lations , we used therefore one generic network , one input , and three different linear readouts to emulate three different nonlinear ﬁlters . For the ﬁrst target ﬁlter , we chose the previously deﬁned Volterra series operator V ( Eq . 2 ) . The second task was to emulate following second - order nonlinear dynamic system y [ k + 1 ] = 0 . 4 y [ k ] + 0 . 4 y [ k ] y [ k − 1 ] + 0 . 6 u 3 [ k ] + 0 . 1 ( 7 ) where u [ k ] was the input and y [ k ] the output at time step k . The third task was to emulate following nonlinear tenth - order system y [ k + 1 ] = 0 . 3 y [ k ] + 0 . 05 y [ k ] (cid:8) 9 (cid:9) i = 0 y [ k − i ] (cid:10) ( 8 ) + 1 . 5 u [ k − 9 ] u [ k ] + 0 . 1 . Again u [ k ] was the input and y [ k ] was the output at time step k . The systems 7 and 8 were both taken from Atiya and Parlos ( 2000 ) , where they were used in order to demonstrate the performance of a new learning algorithm for recurrent networks . Note that nonlinear systems of the type of Eq . 8 are typi - cally hard to emulate for recurrent networks due to their long - term time dependencies , see Hochreiter and Schmidhuber ( 1997 ) . Note also that our proposed morphological compu - tation device is an analog device , which is able to map contin - uous input streams onto continuous output streams . However , in the simulation of this analog device , we were restricted to discrete time . The simulation time step and the time step of Eqs . 7 and 8 were the same . A real physical ( analog ) imple - mentation of the morphological computation device would emulate the underlying continuous dynamic systems , which correspond to the discrete Equations 7 and 8 and , which min - imize the errors at the discretization time steps . We used the same network as in the previous robot arm task ( Fig . 7 ) . All previously chosen input nodes ( in the robot task assigned for two inputs ) were now deﬁned to receive the single input u [ k ] . As input , we employed the same signal as previously for the experiment in Sect . 3 , where we used the morphological computation device with feedforward mass - spring systems . It was a product of three sinusoidal functions and it is shown again in Fig . 9a . For learning , we used the ﬁrst 95s of the signal . 21 The ﬁrst 50s were deﬁned as washout period and thrown away ( see Sect . 4 . 1 . 3 ) . Thus , we had 45 s for learning . The subsequent 5s were used for testing . Figure 9b shows ten typical trajectory ( out of all 78 ) of the spring lengths as responses of the mass - spring network to this input in the testing phase . The output weights for the linear read - outs were found as previously described . Figure 9c shows the performance of our morphological computation device for the Volterra task . The red line is the target and the blue line is the output of the morphological computation device . The mass - spring network with an additional linear readout is able to emulate the nonlinear ﬁlter deﬁned by the Volterra series operator V . Note that , unlike to the previous Volter - ra task of Subsect . 3 ( with a ﬁlter bank ) , here the physical body ( i . e . , mass - spring network ) provided not only the tem - poral integration but also the nonlinearity . Hence , in order to learn to emulate the given nonlinear ﬁlter V , due to the use of the nonlinear and dynamic morphological structure ( as a computational resource ) , we only had to calculate a simple LR . In order to show the explicit contribution of the mor - phological structure to the computation , we compared the results with the case when no physical body ( no mass - spring network ) was available and only LR on the raw input data remained . We used a LR with two weights , w 1 for the actual input u ( t ) and w 2 to learn a bias . Hence , the resulting output at time step t was y LR ( t ) = w 1 u ( t ) + w 2 . The performance 21 Note that the period of the input signal was 100s . 123 368 Biol Cybern ( 2011 ) 105 : 355 – 370 0 1 2 3 4 −5 0 5 input u ( t ) A 0 1 2 3 4 −2 0 2 10 out of all reponses of the network , i . e . , spring lengths l ( t ) B 0 1 2 3 4 0 2 4 Volterra task C targetsystem output LR on raw input 0 1 2 3 4 −5 0 5 2nd order system D targetsystem output LR on raw input 0 1 2 3 4 0 2 4 time [ s ] 10th order system E targetsystem output LR on raw input Fig . 9 Simultaneous morphological computation of the three nonlin - ear ﬁlters with one generic recurrent mass - spring network ( i . e . , mul - titasking ) . a The input u ( t ) , which consisted of a product of three sinusoidal functions . b The trajectories of ten typical ( out of 78 ) indi - vidual spring lengths l ( t ) as responses to this input . c The performance for the Volterra task . The red line is the target function and the blue line is the output of the morphological computation device . The green line depicts the outputs of the device , when no morphological structure was available , i . e . , only the linear readout was applied to the raw input data . Note that the result is simply a scaled version of the input with some offset . d Performance of emulating system 7 . e Performance for the ﬁlter deﬁned by the system 8 can be seen in Fig . 7c . The output y LR ( t ) is depicted by the green line , which is simply a scaled version of the input ( with a very small amplitude ) with an additional offset . Not sur - prisingly , pure LR on the raw input stream failed to represent the nonlinear ﬁlter V , since all the required temporal integra - tion and nonlinearity was contributed before by the physical body ( mass - spring network ) . Figure 9d , e shows the performances of the morphological computation device in order to emulate the nonlinear systems 7 and 8 using the same morphological structure ( mass - spring network of Fig . 7 ) . Again , the red lines are the targets and the blue lines the outputs of the device . The green lines depict the results , when no morphological structure was available and only pure LR was applied to the input stream . One can see , that also in these cases , the LR , which was static and linear , failed to represent the necessary dynamics and nonlinearity . In summary , we can see that one single mass - spring net - work ( i . e . , one physical body ) can be employed to emulate a number of different nonlinear ﬁlters by simple adding a corresponding number of linear and static readouts . 5 Discussion We introduced two theoretical models , which provide a potential explanation for the computational power of compliant bodies . We applied a theoretical model for com - putation , which allowed us to demonstrate , how body parts , modeled by multiple mass - spring systems , can be employed toemulatearbitrary , time - invariant , nonlinearﬁlterswithfad - ing memory . Since the underlying theoretical framework is not able to provide us with a precise guidance for construct - ing a well performing morphology for a given computational task , we demonstrated the applicability of the approach by simulating a number of generic morphological structures . These simulations also allowed us to indicate qualitatively the contribution of the morphology to the computational task . The proposed setups are formed by a dynamic morpho - logical structure ( i . e . , the physical body with ﬁxed param - eters ) and a static readout ( which can be adapted ) . As we have shown , the readout can be even linear if the morpholog - ical structure is sufﬁciently rich . Remarkably , such simple devices are in principle able to emulate any nonlinear , time - invariant ﬁlter with fading memory by adapting a simple , lin - ear readout . Hence , the complex task of learning to emulate such complex ﬁlters can , due to the help of the morpholog - ical structure ( i . e . , due to morphological computation ) , be reduced to the task of ﬁnding suitable weights for the linear readout . This suggests that physical bodies are potentially able to boost the expressive power of attached linear learn - ing systems ( e . g . , the brain or the controller of the robot ) . Note that the possibility to restrict the readouts to linear ones enableshighlyefﬁcientlearning , becausethenumberoftrain - ing examples required by a linear learning device is minimal according to general results from learning theory ( because of its minimal VC - dimension , see Vapnik 1998 ) . Further - more , it guaranties that the optimization process does not get stuck in a local minimum and it has optimal generalization capabilities . The proposed theory suggests that morphological struc - tures , in order to be computationally powerful ( in the context of our proposed setups ) , should be diverse in their parameters and that they should exhibit high dimensionality . Remark - ably , both aspects are typical properties of compliant , bio - logical body parts . However , in classical robot design , these attributes are suppressed ( by high torque servos and rigid body parts ) in order to have a more tractable model and an 123 Biol Cybern ( 2011 ) 105 : 355 – 370 369 easier controllable robot . Our results point to the fact that the consideration of these dynamic features are essential in order to be able to outsource computational tasks to the morpholog - ical structure and , therefore , simplify the control of the robot . This perspective suggests that the development of novel high - dimensional readouts from artiﬁcial limbs ( e . g . , acceleration sensors at many locations inside the robot ) is a possible way to exploit the morphological structure . The morphologies of biological systems might even be more suitable for this task , sincetheyprovidenaturallyahighnumberofinternalsensory signals and a variety of interconnected dynamic structures . More specifically , the muscle – skeleton system consists of a high number of different parts ( i . e . , bones , muscles , tendons , etc . ) , which have a variety of different physical properties . In addition , the biological system senses the state of its body by numerous sensors located all over the body ( i . e , somatosen - sory system ) . As our theory suggests , both parts are desired for morphological computation . Another interesting aspect of the approach is that real physical bodies provide the necessary nonlinearities and the temporal integration for free . The physical structure simple reacts on its inputs . Actually , it is not even necessary to have real physical interpretations of all the available internal sig - nals in order to exploit them for morphological computa - tion . Furthermore , the bodies of real biological systems are not simply computational devices , but they fulﬁll real func - tions . For example , they provide animals ( and robots ) with the capability to locomote and to interact with their environ - ments . Therefore , a next step will be to apply the proposed theory to morphological structures of real robots . This would also involve the step to move from our presented abstract net - works , which were be chosen to demonstrate the applicability of our presented theory , to more realistic simulations includ - ing the simulation of the interaction between a robot and its environment . In this context , one would have to investi - gated the impact of real - world conditions on the performance of the proposed setups . For example , typical cases for such real - word conditions are the partial loss of the state of the morphology and / or noisy readouts . Another remarkably property of the proposed morpho - logical computation devices is their multitasking capability . One morphological structure is able to provide the neces - sary signals for approximating several different nonlinear ﬁlters—only a corresponding number of readouts has to be added . While this multitasking ability is obviously beneﬁ - cial , since the physical bodies of biological system as well as of robots are to high degree ﬁxed , one would also assume that the computational tasks for the physical body are limited to a set of particular ﬁlters . This suggests that physical bodies or different parts of the body could be optimized regarding to their computational tasks . Note that this optimization , how - ever , would not be a convex problem anymore . Nevertheless , the combination of our presented morphological computa - tion setups with nonlinear optimization schemes could lead to interesting new types of compliant robot parts . The result - ing structures would be inhomogeneous and asymmetric as opposed to the examples presented here . This points to the need for a new type of computational material science and computational robotics , where the geometrical and statistical properties of the ﬁne structure of different materials are ana - lyzed ( and optimized ) with regard to their suitability to sup - port through morphological computation the computations of a particular range of ﬁlters , e . g . , ﬁlters that are needed to control a robot for a particular range of tasks . Obviously , these considerations will also open new per - spectives for our understanding of the shape and structural properties of the body of biological organisms and , conse - quently , will lead to new types of biologically inspired robots . Acknowledgments Written under partial support by the European Unionprojects # FP7 - 216593 ( SECO ) , # 216886 ( PASCAL2 ) , # 248311 ( AMARSi ) , and by the Austrian Science Fund FWF , project # P17229 - N04 . We also want to thank the anonymous reviewers for their very helpful suggestions and comments . OpenAccess ThisarticleisdistributedunderthetermsoftheCreative Commons Attribution License which permits any use , distribution , and reproduction in any medium , provided the original author ( s ) and the source are credited . References Atiya AF , Parlos AG ( 2000 ) New results on recurrent network training : unifying the algorithms and acceleratingconvergence . IEEE Trans Neural Networks 11 ( 3 ) : 697 – 709 Bartlett PL , Maass W ( 2003 ) Vapnik - Chervonenkis dimension of neu - ral nets . In : Arbib MA ( ed ) The handbook of brain theory and neural networks , 2nd edn . MIT Press , Cambridge , pp 1188 – 1192 Boyd S ( 1985 ) Volterra series : engineering fundamentals . PhD thesis , UC Berkeley BoydS , ChuaL ( 1985 ) Fadingmemoryandtheproblemofapproximat - ing nonlinear operators with volterra series . IEEE Trans Circuits Syst 32 ( 11 ) : 1150 – 1161 Collins S , Ruina A , Tedrake R , Wisse M ( 2005 ) Efﬁcient bipedal robots based on passive - dynamic walkers . Science 307 : 1082 – 1085 Ferris DP , Louie M , Farley CT ( 1998 ) Running in the real world : adjusting leg stiffness for different surfaces . Proc Biol Sci 265 ( 1400 ) : 989 – 994 Hochreiter S , Schmidhuber J ( 1997 ) Long short - term memory . Neural Comput 9 : 1735 – 1780 . ISSN 0899 - 7667 Hornik K , Stinchcombe M , White H ( 1989 ) Multilayer feedforward networksareuniversalapproximators . NeuralNetworks 2 ( 5 ) : 359 – 366 Iida F , Pfeifer R ( 2006 ) Sensing through body dynamics . Robot Auton Syst 54 ( 8 ) : 631 – 640 Khalil HK ( 2002 ) Nonlinear Systems , 3rd edn , Prentice Hall , Upper Saddle River LegensteinR , ChaseSA , SchwartzAB , MaassW ( 2010 ) Functionalnet - work reorganization in motor cortex can be explained by reward - modulated Hebbian learning . In : Proceedings of NIPS 2009 : advances in neural information processing systems , vol 22 . MIT Press , pp 1105 – 1113 . 123 370 Biol Cybern ( 2011 ) 105 : 355 – 370 Maass W , Sontag ED ( 2000 ) Neural systems as nonlinear ﬁlters . . Neu - ral Comput 12 ( 8 ) : 1743 – 1772 Maass W , Natschlaeger T , Markram H ( 2002 ) Real - time computing without stable states : A new framework for neural computation based on perturbations . Neural Comput 14 ( 11 ) : 2531 – 2560 McGeer T ( 1990 ) Passive dynamic walking . Int J Robot Res 9 ( 2 ) : 62 – 82 ISSN 0278 - 3649 PalmWJIII ( 1999 ) Modeling , analysis , andcontrolofdynamicsystems , 2nd edn . Wiley , New York . ISBN 0 - 471 - 07370 - 9 Paul C ( 2006 ) Morphological computation : a basis for the analy - sis of morphology and control requirements . Robot Auton Syst 54 ( 8 ) : 619 – 630 Paul C , Valero - Cuevas FJ , Lipson H ( 2006 ) Design and control of tensegrity robots for locomotion . IEEE Trans Robot 22 ( 5 ) : 944 – 957 . ISSN 1552 - 3098 . doi : 10 . 1109 / TRO . 2006 . 878980 Pfeifer R , Bongard JC ( 2007 ) How the body shapes the way we think . MIT Press , Cambridge . ISBN 0262162393 Pfeifer R , Lungarella M , Iida F ( 2007 ) Self - organization , embodiment , and biologically inspired robotics . Science 318 : 1088 – 1093 Shim Y , Husbands P ( 2007 ) Feathered ﬂyer : integrating morphological computation and sensory reﬂexes into a physically simulated ﬂap - ping - wing robot for robust ﬂight manoeuvre . In : Almeida e Costa F et al ( eds ) ECAL . Springer , Berlin , pp 756 – 765 Slotine J - J E , Li J - J W ( 1991 ) Applied nonlinear control , 1st edn . Pren - tice Hall , Englewood Cliffs Tedrake R , Zhang TW , Seung HS ( 2005 ) Learning to walk in 20 min - utes . In : Proceedings of the fourteenth yale workshop on adaptive and learning systems . Yale University , New Haven , CT , 2005 Vapnik VN ( 1998 ) Statistical learning theory . Wiley , New York Wiskott L , Sejnowski TJ ( 2002 ) Slow feature analysis : unsupervised learning of invariances . Neural Comput 14 ( 4 ) : 715 – 770 . ISSN 0899 - 7667 Wisse M , Van Frankenhuyzen J ( 2003 ) Design and construction of MIKE ; a2Dautonomousbipedbasedonpassivedynamicwalking . In : Proceedingsofinternationalsymposiumofadaptivemotionand animals and machines ( AMAM03 ) Wood RJ ( 2007 ) Design , fabrication , and analysis of a 3DOF , 3cm ﬂapping - wing MAV . IEEE / RSJ international conference on intel - ligent robots and systems , 2007 . IROS 2007 , 29 Oct – Nov 2 2007 , pp 1576 – 1581 . doi : 10 . 1109 / IROS . 2007 . 4399495 Ziegler M , Iida F , Pfeifer R ( 2006 ) “Cheap” underwater locomotion : roles of morphological properties and behavioural diversity . In : CLAWAR 123