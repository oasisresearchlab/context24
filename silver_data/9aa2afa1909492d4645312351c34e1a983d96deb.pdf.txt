Challenges : An Application Model for Pervasive Computing Guruduth Banavar (cid:3) , James Beck y , Eugene Gluzberg y , Jonathan Munson (cid:3) , Jeremy Sussman (cid:3) , and Deborra Zukowski y IBM T . J . Watson Research Center 30 Saw Mill River Road Hawthorne , NY 10532 ABSTRACT The way mobile computing devices and applications are de - veloped , deployed and used today does not meet the ex - pectations of the user community and falls far short of the potential for pervasive computing . This paper challenges the mobile computing community by questioning the roles of devices , applications , and a user’s environment . A vision of pervasive computing is described , along with attributes of a new application model that supports this vision , and a set of challenges that must be met in order to bring the vision to reality . 1 . INTRODUCTION Pervasive computing is maturing from its origins as an aca - demic research area to a commercial reality . This transition has not been a smooth one and the term itself , pervasive computing , still means di(cid:11)erent things to di(cid:11)erent people . For some , pervasive computing is about mobile data ac - cess and the mechanisms needed to support a community of nomadic users . For others , the emphasis is on \ smart " or \ active " spaces , context awareness , and the way people use devices to interact with the environment . And still oth - ers maintain a device - centric view , focusing on how best to deploy new functions on a device , exploiting its interface modalities for a speci(cid:12)c task . Pervasive computing encompasses all of these areas , but at its core , it is about three things . First , it concerns the way people view mobile computing devices , and use them within their environments to perform tasks . Second , it concerns the way applications are created and deployed to enable such tasks to be performed . Third , it concerns the environment (cid:3) Email : fbanavar , jpmunson , jsussmang @ us . ibm . com . y This work was done while authors were with IBM Research . Current email : jebeck @ ix . netcom . com , eugene @ newyork . usa . com , deborra @ zedak . com . To appear in the proceedings of the Sixth Annual ACM / IEEE International Conference on Mobile Computing and Networking ( Mobicom 2000 ) and how it is enhanced by the emergence and ubiquity of new information and functionality . Today , pervasive computing is more art than science . It will remain this way as long as people continue to view mo - bile computing devices as mini - desktops , applications as pro - grams that run on these devices , and the environment as a virtual space that a user enters to perform a task and leaves when the task is (cid:12)nished . This paper challenges the mobile computing community to adopt a new view of devices , ap - plications and environment . Speci(cid:12)cally , our vision can be summarized in three precepts : (cid:15) A device is a portal into an application / data space , not a repository of custom software managed by the user . (cid:15) An application is a means by which a user performs a task , not a piece of software that is written to exploit a device’s capabilities . (cid:15) The computing environment is the user’s information - enhanced physical surroundings , not a virtual space that exists to store and run software . A new application model is needed to support this vision . This paper describes the attributes of such a model . 2 . TODAY’S SCENARIO Albert uses his PDA as the main repository for his personal information management , or PIM , data . Yesterday morn - ing , the batteries on his PDA died while he was walking over to Betty’s oÆce for a meeting . Of course , his PDA synchronizes with his laptop , but he did not have his laptop with him , just his mobile phone . So , he was stuck looking at the PIM data that he stores on his phone . This infor - mation is much less likely to be complete , since it is more tedious to enter data on his phone . Why can he not run the same program on his phone as his PDA ? Sure enough , the number he was looking for was not there . Why is his PIM information spread across so many devices , some of which cannot speak to one another ? When he got to Betty’s oÆce , he was a little early . The sec - retary gave him some new batteries for his PDA . He (cid:12)gured he would take the opportunity to print out his daily calen - dar . The oÆces are wired for a common printing service , so this should not have been a problem . He had printed his PIM data from his laptop many times , but the version of this application is di(cid:11)erent on his PDA . He spent an inordi - nate amount of time searching before he found the device’s printing capabilities . Why does the program have to be dif - ferent on the di(cid:11)erent devices , instead of adapting itself to the device ? As it turned out , his PDA has no way to dis - cover services , so it could not access the printer . Why can some devices access some services , and not others ? During the meeting with Betty , Albert complained to her about his morning experience . She showed him a new PIM program that she uses , which looked better to him . He would have liked to start using it immediately , but he could not . Why not have the program live in the environment , so that it is immediately available for use ? He got home that night , and used his laptop to upgrade his PIM program . He saw that this program uses a web - based location service to provide context awareness . He subscribes to a GPS service . Wouldn’t it be nice if the context aware - ness could be provided by any location service ? Given his problems from earlier that day , Albert decided to synchronize all of his PIM information . It had been a while , since he always (cid:12)nds the synchronization process painfully complex . Sure enough , there was a number which he had updated in two di(cid:11)erent places , and he could not remember which was correct . Why is the fact that there are multiple copies of the information exposed to him ? Needless to say , Albert had a frustrating day ! 3 . A NEW APPLICATION MODEL The scenario in the last section illustrates that there are many things people would like to do with their mobile de - vices that are not supported today . These problems are not con(cid:12)ned to today’s devices or networking technology or programming standards and APIs . Improvements in each of these areas would surely help , but the problems are much broader . We believe that the problems are rooted in the notions peo - ple have of computing devices , applications , and the envi - ronment . As mentioned in Section 1 , we believe that these notions need to change fundamentally , and an application model needs to emerge that supports these changed notions . To model the applications that we are envisioning , it is nec - essary to consider the life - cycle of an application . This life - cycle can be divided into three parts : design - time , load - time and run - time . Design - time is when the developer creates , maintains and enhances the application . At load - time , the system com - poses , adapts and loads the application components into an application instance on particular hardware devices . At run - time , the end - user invokes the application and uses its functionality . The system provides an environment in which the application can run , and adapts the application to vari - ations in this environment . In this section , we present a new application model from the perspectives of application design - time , load - time and run - time . For each perspective , attributes of the model are described along with a set of challenges . We show how the attributes of the new model support the precepts \ device as portal " , \ application as task " and \ physical surroundings as computing environment " . 3 . 1 Design - Time Imagine building an application that (cid:12)ts the three precepts that are the basis of this challenge paper . If \ devices are portals , " then the application should not be written with a speci(cid:12)c device in mind . The developer should not make any assumptions about the screen size or device capabilities , or even that there is a screen at all ( for example , an application may be run using a voice synthesizer and a phone ) . The user interface of the application mustnot include any information speci(cid:12)c to a device or set of devices . Instead , the application front - end should be device - neutral . If applications are to be device - neutral , then the developer should not start with the presentation and then (cid:12)ll in the underlying logic . The task logic should not be secondary to the user interaction . The user interface de(cid:12)nition should not include a rigid decomposition of the interaction . Rather , the decomposition of the user interaction should be driven by the de(cid:12)nition and structure of the tasks . The application description should capture the purpose of the user interac - tion at a high level . If the environment of an application is to be context aware , then the developer should not make assumptions about the services that are available . Services that the application needs in order to run should not be explicitly named , but rather speci(cid:12)ed in an abstract manner . Furthermore , there may be services available to the application at run - time that are not known or available to the developer at design - time , but may be useful for the task . Applications should be able to use such services . When appropriate , the designer can abstractly specify optional services that , if present at run - time , enhance the application . 3 . 1 . 1 Programming Model As described above , the programming model must allow for the description of abstract user interfaces and abstract ser - vices . The structure of the program should be described in terms of tasks and subtasks . The granularity at which these tasks are presented to the user is a load - time issue , and therefore the relationship among the tasks must be rich enough that the user interface can be actualized at the var - ious granularities . We call this relationship navigation , as it speci(cid:12)es how the user will navigate the sub - tasks that make up the application . The challenges for this programming model are : (cid:15) Identifying abstract interaction elements . These ab - stract interaction elements must capture user intent , not device mechanism . That is , base elements of user interaction must abstract away the di(cid:11)erences in the devices . For example , an application running on a de - vice with a GUI may o(cid:11)er a button for the user to perform some action ; on a voice - activated device the same action may be performed via a spoken command . (cid:15) Specifying an abstract service description language . Application logic may use existing services or infras - tructure , as well as service instances unanticipated by the designer . A means is needed to express the ex - pected function of a service , allowing for di(cid:11)erent ser - vices to provide this function when the application is running . This must allow for services to be declared optional as well . In the scenario above , Albert’s PIM , instead of having a location service built into it , would specify a require - ment for a location service , using a abstract service - description language . This requirement could be satis - (cid:12)ed by any location service instance in Albert’s current environment . (cid:15) Creating a task - based model for program structure . The application should be delineated into tasks and subtasks . A task includes the abstract interaction and the application logic , including the use of the services . The structure is used by the system to generate device speci(cid:12)c \ presentation units " ; e . g . , screens . For example , in a PIM calendaring application , user authentication is one task , browsing the appointments for a day is another task , and entering a new appoint - ment is another task . On large - screen devices , the browsing and appointment - entry tasks may be pre - sented on the same screen , whereas on small - screen de - vices , these tasks maybe presented on separate screens . (cid:15) Creating a navigation model . The navigation speci - (cid:12)es what causes a task to begin and end ( e . g . , a user action ) , and what tasks precede and follow it . This information is complementary to the task structure , and is used by the system to automate the (cid:13)ow of the \ presentation units " when the application is running . 3 . 1 . 2 Development Methodology The purpose of a development methodology is to take the developer through a step - by - step process of realizing the ap - plication from a set of requirements . An ideal methodology for building an application is to focus on the user task , rather than the user’s interaction with an interface on a speci(cid:12)c device in a speci(cid:12)c environment . This methodology would allow a programmer to build an application by answering questions such as : (cid:15) What task does the user want to accomplish ? If the task is a composite of many subtasks , how are these de(cid:12)ned to assist the user in his / her overall task ? (cid:15) What is the \ (cid:13)ow " through the tasks ? How does each task begin ? How does it end ? How does one subtask initiate another in a dynamic framework ? (cid:15) What is the user interaction for each task ? What user actions are needed to perform the task ? How are user actions a re(cid:13)ection of user intent ? (cid:15) What information does the user need to perform the task ? Where does this information come from ? (cid:15) What logic does the systemperform for each ( sub ) task ? Is it possible for the ( sub ) task logic to adapt itself to a given environment ? By answering these questions , the programmer will have speci(cid:12)ed an application at a high level of abstraction . The concrete results of these questions make up the implemen - tation of the application . Given the programming model explained above , the implementation will be made up of a task structure annotated with navigation (cid:13)ow , an abstract user interface for each task , and scripting logic that details the task function . The major challenge here is to build a development environ - ment that supports the above methodology . This methodol - ogy is not captured by current programming tools . Certain parts of the methodology , such as navigational (cid:13)ow , may lend themselves to visual interfaces , whereas others such as scripting logic may not . 3 . 2 Load - Time An application model derived from the basis of the three precepts requires a more dynamic load - time approach than is traditionally supported . To realize the concept of \ device as portal , " devices must dynamically discover what applica - tions are available , and the system must adapt the applica - tions to the device resources available . An application must be speci(cid:12)ed in terms of its requirements , the device must be described in terms of its capabilities , and some mediating algorithm must be used to negotiate a match between these competing constraints . To realize the concepts of \ application as task " and \ phys - ical surroundings as computing environment " , the system must be dynamic at load - time . That is , the tasks that a user wishes to perform may depend on the physical surroundings . Such tasks are enabled by contextual services . The system must , therefore , be able to discover and compose the services that are available in the physical environment , in order to perform desired tasks . This is in contrast to today’s model , where applications are loaded onto a device manually from a CD or other storage medium , and managed by the user rather than the system . 3 . 2 . 1 Dynamic Discovery Applications and services live in the surrounding physical distributed environment . Discovery mechanisms allow a mo - bile device to dynamically identify and enumerate the ap - plications and services in its local vicinity . The major challenge posed by dynamic discovery is the de(cid:12) - nition of a service adaptation layer . A standard de(cid:12)nition is needed , to both hide the di(cid:11)erences between heterogeneous service frameworks and to maximize the use of legacy code . In our scenario , dynamic discovery is needed both for Al - bert to print his schedule in Betty’s environment | his PDA should ‘discover’ her oÆce’s printing service | and for his PDA to switch from one location service to another . 3 . 2 . 2 Requirements and Capability Negotiation At load - time , a device needs to negotiate with a server that hosts applications and services for several reasons . First , the device may not have all of the resources needed to run some of the applications and services . The set of available soft - ware needs to be pruned so that only the hostable functions are presented to the user . Second , application performance is a concern , so it may be desirable to split the execution burden between the device and available servers . This split , which we call apportioning , uses information about the cur - rently available resources and the resource demands of the application . Some of the challenges related to negotiation are : (cid:15) Modeling device characteristics and application re - quirements . The characteristics that are relevant for di(cid:11)erentiating between devices must be codi(cid:12)ed , and a metric for each of these characteristics must be devel - oped . The application requirements must be speci(cid:12)ed in the same terms . (cid:15) Developing negotiation protocols . Such protocols are necessary for a device to ascertain what subset of appli - cations and services can be hosted within the bounds of its resource limitations . (cid:15) Incorporating fast and eÆcient apportioning algo - rithms . Loading is not necessarily a one - time function . Instead , the load - time mechanisms may be re - invoked when changes in the device or physical environment warrant re - apportioning . 3 . 2 . 3 Presentation Selection , Adaptation and Com - position A good user interface must exhibit qualities such as con - sistency and style , which are diÆcult to quantify and syn - thesize . Indeed these qualities are subject to human taste . These qualities are embodied di(cid:11)erently on devices with dif - ferent interface modalities and form factors ( e . g . , a graphical input device versus one with a speech interface ) . Thus , it may be desirable to have multipleabstract representations of the application interface , one for each combination of inter - face modality and form factor . These will most likely need to be generated by human designers , perhaps through semi - automated tools . The challenges for the load - time system are : (cid:15) The system needs to support dynamic selection of an appropriate application interface from a set of avail - able interfaces , based on the device’s resources and form - factor . The presentation selected in this man - ner will be speci(cid:12)c to an interface modality and form factor . Further adaptation may be necessary for the characteristics of a particular device . (cid:15) The system needs to seamlessly integrate the appli - cations and services found in the environment . This involves composing the functionality ( e . g . , a discov - ered map application should be able to use a discov - ered GPS service ) as well as the user interface ( e . g . , if a service is discovered for controlling a VCR , the interface needs to be integrated and displayed along with the interfaces of other discovered services ) . The composition is subject to the constraints and resource limitations of the device and the composition restric - tions of the discovered entities . In the scenario above , Albert wanted the same PIM appli - cation on his cell phone as the one on his PDA | not two di(cid:11)erent PIM applications accessing the same data . For ex - ample , a PIM application may o(cid:11)er the function of querying for an individual’s manager or other members of the individ - ual’s work group . This function should be available whether the PIM’s interface is presented on Albert’s PDA or his cell phone | appropriately adapted to the device’s capabilities . 3 . 3 Run - Time To realize the precept \ device as portal , " the run - time must monitor the resources for the currently active portal , or por - tal set , and appropriately adapt the application to those re - sources . In addition , the run - time must respond to changes initiated by the user . For example , the user may choose a di(cid:11)erent set of portal devices . To realize \ application as task , " the run - time must allow a user to initiate and perform a task in an uninterrupted man - ner , despite changes in the environment and portal devices . The run - time should support hando(cid:11) of task context from one environment ( e . g . , oÆce ) to another ( e . g . , car ) , possi - bly through a disconnected state . The key to supporting a task - oriented application is that a user’s access to the task be continuous . To realize \ physical surroundings as computing environ - ment , " the run - time must be able to take advantage of services provided by the environment and the physical re - sources available within it . The run - time must handle un - expected failures , such as exhausting batteries or a service crash . Existing failure detection and recovery mechanisms may need to be re - examined for their applicability in this new paradigm . 3 . 3 . 1 Monitoring and Redistribution The application model proposed in this paper requires the run - time to detect changes in the resources of any portal device or environment hosts that participate in application execution . Resource changes include changes in available network bandwidth , introduction of new devices into the environment , introduction of new users and / or applications , etc . In response to detected changes , the run - time must initiate a reapportionment and / or relocation of application components . The challenges introduced by this monitoring and redistribution include : (cid:15) Non - obtrusive re - apportioning . Resource changes may impact the user’s interaction with the application . However , some changes may be transient and unseen by the user . Transient resource changes should be rec - ognized as such and should not impact the application . When changes are signi(cid:12)cant and long - lived , the ap - plication should be automatically re - apportioned , with minimal impact on the user . (cid:15) User initiated re - apportioning . The user may initiate re - apportionment of the application . Reasons for re - apportionment may range from anticipated change in the connectivity of devices to a mobile user entering the proximity of new devices . In the latter case , the user should be given a choice of whether to use the new devices or not . 3 . 3 . 2 Disconnection One of the resources that must be considered when mak - ing apportionment decisions is the communication network . If the network connection between client and server is de - tected to degrade via run - time monitoring , the apportioner may react by migrating code from the server to the client to reduce the application’s demand for communication . In this way , a running application can react to dynamic changes in the quality of the network connection . For some applications and devices , it may be feasible to migrate the entire application to the client in order to ac - commodate brief , sporadic network disconnections . How - ever , this approach is not viable for devices with limited resources , or for sudden , unanticipated network disconnec - tions . Because of this , explicit support for disconnected op - eration needs to be added to the model . In other words , the model needs to be augmented in order to bridge the desire of using a device ( along with its accompanying resource lim - itations ) as a portal while minimizing the impact of network disconnections . The major challenge in this area is automating disconnec - tion and reconnection as much as possible . The run - time should prepare for disconnection without a user’s interven - tion whenever possible ( e . g . , automatic migration as de - scribed above ) . For those scenarios where user intervention is needed , there should be a natural way for a user to pre - pare for disconnection , minimizing overall task disruption ( e . g . , hoarding , as in [ 14 ] ) . While disconnected , a frame - work should be provided to automate tasks such as queuing network requests . A user should be able to reconnect to an application within the user’s current environment . Re - connection in both the original and transitory environments should be supported . 3 . 3 . 3 Failure Detection and Recovery Many existing failure detection and recovery techniques may be applicable to pervasive environments . However , they may need to be modi(cid:12)ed to better serve the particular require - ments of these environments . Some of the challenges here include : (cid:15) Adapting checkpointing strategies . In the application model discussed here , the device is a user’s portal to an application that runs in an environment . This is a model previously unexamined by traditional fault tol - erance research . Requirements on the type and tim - ing of checkpointing may be di(cid:11)erent from the current state of the art . (cid:15) Understanding disconnection . The distinction be - tween failure and disconnection is often blurred in con - ventional systems . In this application model , the dis - tinction is important . Disconnections should not be treated as failures , as they are part of the expected speci(cid:12)cation of the environment . 4 . A GLIMPSE OF TOMORROW Consider the scenario of Section 2 , but within the new en - vironment of tomorrow presented in this paper . At design - time , tomorrow’s developer would realize that PIM infor - mation management is separate from the PIM front - end , and would therefore create a service for information man - agement . This would allow the user to have a single PIM service which is part of the environment , immediately elimi - nating the synchronization problem . When the user updates a phone number , that phone number is the same regardless of the device through which it is accessed . The application is no longer thought of as a selling tool for a device . Instead , the application is built to be run on any device . Therefore a single , consistent , view of the task of accessing personal data is supported by all devices . Tomorrow’s developer would also realize that part of the task of accessing personal information might be to get a hard copy . Because the printer is also seen as a service , run - time discovery of the printer is easily enabled . If the personal data of di(cid:11)erent people is linked on the network , then that information is available to all of the authorized devices in the environment . Similarly , the map program which is linked to the PIM program ( to provide context awareness of schedules ) is described in an abstract manner , and therefore the conversion from the web - based location service to the GPS - based location service is transparent to the user . Finally , because the PIM program is managed by the envi - ronment , if the user \ (cid:12)nds " a new , improved version , he / she can easily update the application on any device without has - sle or delay . From that point on , this device can use the updated application . Indeed , the concept of \ upgrading " software may quickly become anachronistic ! 5 . RELATED WORK The model proposed in Section 3 is not as revolutionary as it might at (cid:12)rst appear . Its roots can be found in sev - eral mature technologies . We believe that there is a natural evolutionary path to realizing this model . Indeed , parts of this model are being realizing in current work in pervasive computing . In this section , we present some existing technologies that provide the underpinnings of the application model . We also present related pervasive computing e(cid:11)orts . Both common and missing elements of each technology will be discussed in relation to the proposed model . 5 . 1 Foundation Technologies 5 . 1 . 1 User - Interface Management Systems ( UIMS ) UIMS e(cid:11)orts identi(cid:12)ed the need to divorce the user inter - face from the rest of the application logic . Examples include the work reported in [ 21 ] and the UIML System at Virginia Tech [ 1 ] . In these systems interaction front - ends are tai - lored to allow users to perform tasks as best supported by the devices . The application model proposed in this paper expands this goal beyond the UI , to handle the heterogeneity of other device capabilities such as compute power , network bandwidth , and available services . 5 . 1 . 2 Client - Server Computing Model The client - server model was introduced as a way to share applications and data within an organization . Applications were generally developed for a speci(cid:12)c set of platforms , but they were divided to better accommodate resource consump - tion . Those parts of the application that were best sup - ported by centralized servers ( e . g . , data access and mem - ory / compute intensive portions ) were included in the server piece of the application . Those that more closely interacted with users were included in the client piece . Standard pro - tocols , such as sockets and RPC [ 19 ] , were developed for communication among the pieces . The client / server division is often statically decided at de - sign time . Such a division may not yield the best per - formance over the full range of network conditions or the full range of client devices , which may vary in processing power . The client is typically assumed to be constantly con - nected to the server , especially for the \ thin - client " varia - tion of the model . Thus , in a mobile environment , the model must be enhanced to accommodate sporadic disconnections , and caching is needed to bu(cid:11)er this e(cid:11)ect from applications ( e . g . [ 14 ] ) . Furthermore , the model supports heterogenous platforms , especially by the acceptance of the standard pro - tocols . However , the application must be recoded to each platform , making it extremely costly and complex to develop and maintain the application code base . 5 . 1 . 3 Java TM Computing Model The Java computing environment [ 3 ] alleviates the re - coding problem described above , in that it enables device - indepen - dent code that can be shared across platforms . Applica - tions are written to a common Java platform consisting of a Java Virtual Machine ( JVM ) and a set of standard libraries . However , some devices are not able to support this standard platform . While there are some e(cid:11)orts to de(cid:12)ne Java sub - sets , this reduces the platform independence of Java . Another problem is that Java uses a least - common - denomin - ator approach for user interfaces . The toolkits Java provides for building interfaces , such as AWT [ 22 ] and Swing [ 8 ] , assume user interface elements that are common to all currently supported platforms . This leads to a less than ideal environment for creating high - quality user interfaces , adapted to the capabilities of individual devices . That is , such interfaces cannot recognize and utilize device - speci(cid:12)c resources available on some devices , such as a scroll wheel or hard buttons . Additionally , Java widgets contain pre - sentation information and maintain assumptions about the underlying structure of the user interface . Because of this , user interfaces written in Java are not portable across de - vices with di(cid:11)erent form factors , not to mention interface modalities . Consequently , this approach is not suitable for the type of device - speci(cid:12)c rendering described in Section 3 . 5 . 1 . 4 Web Technologies The World Wide Web has moved applications away from generalized GUIs towards a more information based inter - face . Users browse global ( virtual ) information . They are able to initiate server actions . These interactions are en - abled by the use of a browser model that provides a con - sistent and uniform user experience across heterogeneous clients . However , much like Java , information on the web is authored for presentation on speci(cid:12)c platforms , and usually cannot take advantage of the resources available on di(cid:11)erent devices . Though the web model o(cid:11)ers promise for pervasive appli - cations , it needs to be augmented to address new concepts , such as context - awareness and intermittent access . More complex server actions need to be supported { users need not only to initiate server actions but to respond to \ un - expected " server information ( called push services ) . Web - based \ applications " are evolving from browsable content to interactive applications with broader user interactions via graphical widgets . To enable such user interactions , tech - nologies such as Java applets [ 12 ] and JavaScript [ 10 ] have been added to the web model . While such technologies do expand the capabilities of the browser , in some regards they are a step backward . For instance , JavaScript is not device independent , violating the reason for using a web browser in the (cid:12)rst place . 5 . 1 . 5 Service Technologies The emergence of distributed object models within the con(cid:12)nes of the client / server computing model ( e . g . , COR - BA [ 17 ] , DCOM [ 16 ] and Java’s Remote Method Invocation ( RMI ) [ 20 ] ) set the stage for service frameworks and re - lated discovery protocols . The subsequent introduction of service frameworks such as SLP [ 11 ] and Berkeley’s Ninja project [ 6 ] are extending the role of the wired Internet and are enabling the discovery and use of functionality based on context . These approaches allow a software service to be discovered dynamically based on attributes supplied by the client . The emergence of Sun’s Jini technology [ 4 ] has enhanced the concept of service frameworks . Jini provides a common framework for registering available services and answering client look - up requests . The combination of downloadable Java code and Java’s RMI model allows a discovered service to be loaded dynamically and then executed either locally on the client , on a service provider , or any combination of the two . However , Jini relies on the use of a central server which acts as a broker ; it registers services on behalf of service providers and answers look - up requests on behalf of clients . Because of this , Jini requires a connected network . More recently , service frameworks have been introduced for use over small proximity wireless networks , such as SDP over Bluetooth [ 13 ] and the MOCA service framework [ 5 ] for ad - hoc networks . The aim of these approaches is to pro - vide transient access to context - sensitive information and functions , as well as gateway access to the larger context of the wired Internet . Consequently , these approaches al - low a mobile device to dynamically discover and adapt its functionality to changes in the user’s environment . These approaches support the application model of this paper . 5 . 2 On - Going Pervasive efforts Perhaps the seminal project in ubiquitous computing was the ParcTab [ 2 , 15 ] e(cid:11)ort at Xerox PARC . The roots of the application model described in Section 3 can be found there . In the ParcTab project , much attention was given to an application traveling with the user , and being accessible from mobile devices . This is an example of devices acting as portals into an information space and lends credence to the proposed vision of pervasive computing . Unfortunately the ParcTab project ended before it could re - alize its potential . At that time , applications were often custom coded , and the project focused on the utility of per - vasive applications rather than application development and an accompanying application model . Recently , other e(cid:11)orts have begun under the designation \ Invisible Computing . " They appear to pick up where the ParcTab e(cid:11)ort left o(cid:11) . These approaches are , by and large , in harmony with the application model described here . Two sample projects , Portolano [ 9 ] and Oxygen [ 7 ] are discussed below . 5 . 2 . 1 Portolano The Portolano Project at the University of Washington fo - cuses on three main areas : Infrastructure , Distributed Ser - vices and User Interfaces . Portolano addresses a particular research area , that of data - centric routing . Such routing facilitates automatic data migration among applications on behalf of a user . Data becomes \ smart " , and serves as an interaction mechanism within the environment . Portolano’s view of horizontal integration is synonymous with our view of composition that we presented in Sec - tion 3 . 2 . Though Portolano proposes an infrastructure based on mobile agents that may appear to di(cid:11)er from our model , agents are an implementation option of our model . That is , agents interact with an application and the user , and appli - cations must be developed to utilize the agents . The service deployment model of Portolano is similar to our view of how applications and services are deployed into an environment . The largest apparent divergence between Portolano and our model concerns the role of user interfaces . Portolano em - phasizes invisible , intent - based computing . The intentions of the user are to be inferred via their actions in the environ - ment and via their interactions with everyday objects . De - vices are still portals into the environment . However , their tasks are implicitly de(cid:12)ned . Our model allows the devices to explicitly run tasks . In either case , the portals capture user input , and re(cid:13)ect that input to the application . 5 . 2 . 2 Oxygen Oxygen is another approach to Invisible Computing , being pursued by MIT . The emphasis is on understanding what turns an otherwise dormant environment into an empowered one . Users of an empowered environment shift much of the burden of their tasks to the environment . The Oxygen project is focusing on eight , environment - enablement technologies . The (cid:12)rst is a new mobile de - vice , the H21 , which relies on software to automatically de - tect and re - con(cid:12)gure itself as a cell phone , pager , network adapter or other type of supported communication device . The H21 is a good example of a mobile device that acts as a portal . The second and third technologies are the E21 , an embed - ded computing device used to distribute computing nodes throughout the environment , and N21 , network technology needed to allow H21s and E21s to interact . These provide some of the load - and run - time requirements described in Section 3 . 2 . The (cid:12)nal (cid:12)ve technologies underlying Oxygen are all aimed at improving the user experience : speech , intelligent knowl - edge access , collaboration , automation of everyday tasks , and adaptation of machines to the user’s needs . Inherent in these technologies is the belief that shrink - wrapped software will disappear as an application delivery mechanism . More dynamic mechanisms will be used instead . This re(cid:13)ects the load - time attributes described in Section 3 . 2 . The technologies underlying Oxygen are complementary to the application model described in Section 3 . Our model also speci(cid:12)es design - time infrastructure , which would enable the development of applications for use in conjunction with Oxygen . 6 . RESEARCH PLAN The PIMA project at the IBM T . J . Watson Research Cen - ter is taking an incremental , evolutionary approach to im - plementing the application model described in Section 3 . PIMA is progressing along a number of concurrent research thrusts . Each thrust is rooted in existing technology , and is gradually introducing new functionality . In this section , we describe our research plan . Our research is based on a number of assumptions . One assumption is that an underlying services - based distributed architecture is a part of interactive environments . Another assumption is that although certain devices may be best suited for certain tasks , users will interact with applications and services via whatever devices are handy at a given time . The emphasis is on task enablement , rather than support for device - speci(cid:12)c applications such as high - end word processors or games . We describe below each of our concurrent research thrusts in three steps : the current status , the next steps , and the eventual goal . (cid:15) Design - time Environment : Currently , the developer uses a programming model to statically specify the application interface , any scripting logic , and the in - terface to back - end services . However , developing a device - independent application is inherently more complex than developing a device - speci(cid:12)c one . In the next steps , the developer’s burden will be alleviated by inferring as much as possible about the designer’s intention , generating design - time artifacts where ap - propriate and providing realistic defaults . Eventually , the goal is to build a development environment that supports a comprehensive methodology and allows de - signers to manage the added complexity . (cid:15) Device - speci(cid:12)c Rendering : Currently , device - speci(cid:12)c rendering is performed via static speci(cid:12)cation of the mapping from the device independent application to the toolkit and the form factor of particular platforms . While this is adequate for adapting the presentation of individual elements of a user interface , it is inadequate for handling di(cid:11)ering form factors and interface modal - ities . In the next steps , capability negotiation is being introduced as a means to select , at load time , an in - terface speci(cid:12)cation from a (cid:12)nite set of speci(cid:12)cations . Eventually , the goal is to investigate the use of auto - matic synthesis to generate device - speci(cid:12)c renderings of an abstract interface speci(cid:12)cation . (cid:15) Distributed Services : Currently , networked - based ser - vices are assumed , such as those supported by SLP . However , applications and services should be associ - ated with a local environment . In the next steps , ser - vice frameworks and discovery mechanisms that are appropriate for use over small - proximity , ad - hoc net - works will be introduced . Eventually , the goal is to develop and deploy a service adaptation layer that al - lows uniform access to services hosted in various frame - works . (cid:15) Application Apportioning : Currently , a capability ne - gotiation session is being used in conjunction with an algorithm such as [ 18 ] to dynamically apportion an application at load - time . However , the resource envi - ronment of a mobile device is hardly static . In the next steps , run - time monitoring and service migra - tion mechanisms will be introduced to dynamically vary the application apportionment between client and server at run - time . Eventually , the goal is to introduce caching and automatic checkpointing to support spo - radic network disconnections and application recovery following a client device failure , respectively . (cid:15) Application Adaptation : Currently , applications are written to accommodate two classes of services : essen - tial services , which must be present for the application to proceed ; and optional services , which , if present , allow the application to provide additional functional - ity . However , the application’s execution environment cannot be known statically at design - time . In the next steps , composition techniques will be introduced to al - low the functions of applications and services to be chained together and enable the integration of their respective user interfaces . Eventually , the goal is to develop the interfaces and mechanisms needed to al - low an application to identify and use a service at run - time that was unanticipated when the application was written . The above research plan takes us from well - understood cur - rent technologies towards realizing the application model envisioned in this paper . However , addressing all the is - sues within this broad research agenda is a challenge for the entire mobile computing community . 7 . SUMMARY This paper began by exposing some of the limitations be - hind the way mobile computing devices are used today . As the scenario illustrated , today’s applications do not enable people to perform many of the tasks they need to do , do not provide satisfying user experiences , and fall far short of the potential for pervasive computing . For pervasive computing to meet the expectations of mobile users , fundamental changes need to occur in the way people perceive the roles of devices , applications and the environ - ment . Again , devices need to be perceived as portals into the application / data space supported by the environment , rather than repositories of custom software . Applications need to be seen as tasks performed on behalf of a user , not as programs written to exploit the resources of a speci(cid:12)c computer . And , the computing environment needs to be recognized as an extension of the user’s surroundings , not a virtual space for hosting and running programs . To realize this vision of devices , applications and environ - ments , we believe a new application model is needed . The model is characterized by a device - independent application development process , which includes abstract speci(cid:12)cation of the application front - end and the application’s resource and service requirements . The model includes a highly dy - namic load - time system supporting application discovery , resource and capability negotiation , and application appor - tioning . The run - time system allows the resources to be dynamically shared among client devices and servers . It also includes monitoring and checkpointing , and enables a running application to migrate from device to device or to simultaneously utilize the interface capabilities of multiple devices . Several on - going thrusts in pervasive computing , such as the Portolano and Oxygen projects , share our view of the roles of devices , applications and environments . The application model presented here strengthens this common vision , par - ticularly in the area of developing , deploying and manag - ing applications . Moreover , the proposed application model provides common underpinnings that can unify the view of applications across such environments . In summary , the application model introduces a number of design - time , load - time and run - time challenges . These chal - lenges expose the boundaries of the current state of the art , and must be addressed if the full potential of pervasive com - puting is to be realized . 8 . REFERENCES [ 1 ] M . Abrams , C . Phanouriou , A . Batongbacal , S . Williams , and J . Shuster . UIML : An Appliance - Independent XML User Interface Language . In Proceedings of the Eighth International World Wide Web Conference , pages 617 { 630 , May 1999 . [ 2 ] N . Adams , , R . Gold , B . Schilit , M . Tso , and R . Want . An Infrared Network for Mobile Computers . In Proceedings of the USENIX Symposium on Mobile and Location - Independent Computing , pages 41 { 52 , August 1993 . [ 3 ] K . Arnold and J . Gosling . The Java Programming Language , Second Edition . Addison Wesley , 1998 . [ 4 ] K . Arnold , B . O’Sullivan , R . Schei(cid:13)er , J . Waldo , and A . Wollrath . The Jini Speci(cid:12)cation . Addison Wesley , 1999 . [ 5 ] J . Beck , A . Ge(cid:15)aut , and N . Islam . MOCA : A Service Framework for Mobile Computing Devices . In Proceedings of the International Workshop on Data Engineering for Wireless and Mobile Access , pages 62 { 68 , August 1999 . [ 6 ] S . Czerwinski , B . Zhao , T . Hodes , A . Joseph , and R Katz . An architecture for a secure service discovery service . In Proceedings of the Fifth Annual ACM / IEEE International Conference on Mobile Computing and Networking , pages 24 { 35 , August 1999 . [ 7 ] M . Dertouzos . The Oxygen Project . Scienti(cid:12)c American , 281 ( 2 ) : 52 { 63 , August 1999 . [ 8 ] R . Eckstein , M . Loy , and D . Wood . Java Swing . O’Reilly and Associates , 1998 . [ 9 ] M . Esler , J . Hightower , T . Anderson , and G . Borriello . Next Century Challenges : Data - Centric Networking for Invisible Computing . The Portolano Project at the University of Washington . In Proceedings of the Fifth ACM / IEEE International Conference on Mobile Networking and Computing , pages 256 { 262 , August 1999 . [ 10 ] D . Flanagan . JavaScript : The De(cid:12)nitive Guide . O’Reilly and Associates , 1998 . [ 11 ] E . Guttman , C . Perkins , J . Viezades , and M . Day . Service Location Protocol , Version 2 . RFC 2608 . IETF , November 1998 . [ 12 ] K . Hopson , S . Ingram , and P . Chan . Developing Professional Java Applets . Sam’s Publishing , 1996 . [ 13 ] R . Mettala . Bluetooth Protocol Architecture , Version 1 . 0 . Bluetooth Special Interest Group , August 1999 . http : / / www . bluetooth . com / v2 / document . [ 14 ] M . Satyanarayanan , J . Kistler , P . Kumar , M . Okasaka , E . Siegel , and D . Steere . CODA : A Highly Available File System for a Distributed Workstation Environment . IEEE Transactions on Computers , 39 ( 4 ) : 447 { 459 , April 1990 . [ 15 ] B . Schilit , N . Adams , R . Gold , M . Tso , and R . Want . The PARCTAB Mobile Computing System . In Proceedings of the Fourth Workshop on Workstation Operating Systems , pages 34 { 39 , October 1993 . [ 16 ] R . Sessions . COM and DCOM : Microsoft’s Vision for Distributed Objects . Wiley Computer Publishing , 1997 . [ 17 ] J . Siegel . CORBA Fundamentals and Programming . Wiley Computer Publishing , 1996 . [ 18 ] H . Stone and S . Bokhari . Control of Distributed Processes . Computer , 11 ( 7 ) : 97 { 106 , July 1978 . [ 19 ] SUN Microsystems Inc . Remote Procedure Call Protocol Speci(cid:12)cation , Version 2 . RFC 1057 , June 1988 . [ 20 ] SUN Microsystems Inc . Remote Method Invocation Speci(cid:12)cation , 1999 . http : / / www . javasoft . com / products / jdk / 1 . 1 / - docs / guide / rmi / spec / rmiTOC . doc . html . [ 21 ] C . Wiecha and S . Boies . Generating User Interfaces : Principles and Use of ITS Style Rules . In Proceedings of the Third Annual ACM SIGGRAPH Symposium on User Interface Software and Technology , pages 21 { 30 , October 1990 . [ 22 ] J . Zukowski . Java AWT Reference . O’Reilly and Associates , 1997 .