Principles of Knowledge Representation and Reasoning Winter Semester 2013 / 2014 University of Freiburg Department of Computer Science Exercise Sheet 4 Due : November 20th , 2013 Exercise 4 . 1 ( Project : Handling Propositional Formulae , 1 + 3 + 2 + 4 ) The aim of this exercise is to write a small program that parses propositional logic formulae , translates them to CNF , and decides their satisﬁability by using an existing satisﬁability solver . You can use any programming language you like ( given that it is usable under Ubuntu 12 ) . It must includes a makeﬁle for compilation . Source code must be submitted to : hue @ informatik . uni - freiburg . de . We restrict ourselves to postﬁx notation 1 to keep parsing of the formula sim - ple . In these formulae propositional variables are written as ( non - zero ) positive integer numbers . Only the following propositional connectives are used : not ( unary ) , or ( binary ) , and ( binary ) . After parsing , a formula is internally repre - sented as a binary tree ( Figure 1 gives an example ) and must be converted to CNF . ¬ ∧ 1 ∨ 2 ¬ 3 Postﬁx notation : 3 not 2 or 1 and not Formula : ¬ (cid:0) 1 ∧ ( 2 ∨ ¬ 3 ) (cid:1) NNF : ¬ 1 ∨ ( ¬ 2 ∧ 3 ) CNF : ( ¬ 1 ∨ ¬ 2 ) ∧ ( ¬ 1 ∨ 3 ) Figure 1 : Example for postﬁx notation , formula , CNF , binary tree . We consider both the standard CNF translation given in the lecture as well as the labeling CNF conversion which is a polynomial CNF conversion that preserves satisﬁability . This conversion is achieved from the NNF by labeling every non - trivial subformulas with a new variable . If b is a new variable the subformula and l 1 , . . . , l n the literals in the formula . The encodings are : • ( l 1 ∨ l 2 ) ↔ b is encoded into ( ¬ l 1 ∨ b ) ∧ ( ¬ l 2 ∨ b ) ∧ ( l 1 ∨ l 2 ∨ ¬ b ) • ( l 1 ∧ l 2 ) ↔ b is encoded into ( l 1 ∨ ¬ b ) ∧ ( l 2 ∨ ¬ b ) ∧ ( ¬ l 1 ∨ ¬ l 2 ∨ b ) If we consider the example above , we denote by b 1 the formula ¬ 1 ∨ ( ¬ 2 ∧ 3 ) and b 2 the formula ¬ 2 ∧ 3 . We have as a translation : b 1 ∧ ( b 1 ∨ 1 ) ∧ ( b 1 ∨ ¬ b 2 ) ∧ ( ¬ 1 ∨ b 2 ∨ ¬ b 1 ) ∧ ( ¬ 2 ∨ b 2 ) ∧ ( 3 ∨ b 2 ) ∧ ( 1 ∨ ¬ 3 ∨ b 2 ) . More explanations can be found on http : / / eprints . biblio . unitn . it / 1573 / 1 / A _ SAT - based _ tool _ for _ solving _ configuration _ problems . pdf 1 http : / / en . wikipedia . org / wiki / Postfix _ notation For evaluating CNF formulae you can use an existing propositional satisﬁability solver ( SAT solver ) , e . g . , the MiniSat solver http : / / minisat . se / . Virtually all SAT solvers accept as input the simple DIMACS format : p cnf 5 2 1 - 2 3 0 - 1 2 5 4 0 The ﬁrst line speciﬁes that it is a CNF problem ( p cnf ) and gives the number of variables and clauses ( in this case 5 variables ; atoms 1 , . . . , 5 and 2 clauses ) . Each of the following lines speciﬁes one clause : positive integers represent posi - tive literals , negative integers represent negative literals with 0 terminating the clause / line . ( a ) Write a parser for the given postﬁx format that generates a binary tree for a given formula ( or use the one provided for the java language ) . ( b ) Write a function to convert an arbitrary formula to CNF both using the standard binary tree representation and the labeling CNF conversion . ( c ) Write a function which can generate random 3 - DNFs . The function must take as input : the number of conjunctions and the number of variables . ( d ) Write a function to output the CNF in DIMACS format and test the satisﬁability of randomly generated DNFs by converting them in CNF then in DIMACS . Discuss the eﬃcciency of the two translations . Your program should take as argument one ﬁlename to read the formula from and output the CNF in DIMACS on the standard output . It should not write anything else than the DIMACS format in order to pipe it as a minisat’s input .