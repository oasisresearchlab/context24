US0060301 . 10A United States Patent ( 19 ) 11 Patent Number : 6 , 030 , 110 Scepanovic et al . ( 45 ) Date of Patent : Feb . 29 , 2000 54 ADVANCED MODULAR CELL PLACEMENT 4 , 850 , 027 7 / 1989 Kimmel . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 382 / 303 SYSTEM WITH MEDIAN CONTROLAND 4 , 872 , 125 10 / 1989 . . . 364 / 578 . . . 364 / 491 364 / 491 364 / 490 INCREASE IN RESOLUTION 4908 , 772 3 / 1990 4 , 910 , 680 3 / 1990 75 Inventors : Ranko Scepanovic ; James S . Koford , 4 , 918 , 614 4 / 1990 both of San Jose , Calif . ; Alexander E . 35 REC . . . 395 / 13 2 - Y - a - 2 / 1990 . . . 364 / 491 Andreev , Moskovskaga Oblast , Russian 5 , 051895 9 / 1991 . . . 395 / 712 Federation 5 , 051 . 938 9 / 1991 - - - - . . . 364 / 578 - 0 5 , 062 , 054 10 / 1991 Kawakami et al . . 364 / 491 73 Assignee : LSI Logic Corporation , Milpitas , 5 , 119 , 313 6 / 1992 Shaw et al . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 364 / 491 Calif . 5 , 124 , 927 6 / 1992 Hopewell et al . 364 / 468 . 28 5 , 136 , 686 8 / 1992 Koza . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 395 / 13 5 , 140 , 402 8 / 1992 Murakata . . . . . . . . . . . . . . . 257 / 499 21 Appl . No . : 08 / 671 , 651 5 , 140 , 526 8 / 1992 McDermith et al . . . . . . . . . . . . . . . . . . . . 395 / 228 22 Filled : 28 , 1996 22 File Jun . 28 , ( List continued on next page . ) ( 51 ) Int . Cl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . G06F 17 / 50 52 U . S . Cl . . . . . . . . . . . . . . . . . . . . . . . . . . . 364 / 490 ; 364 / 488 ; 364 / 489 ; OTHER PUBLICATIONS 364 / 491 Algorithms For VLSI Physical Design Automation , N . A . 58 Field of Search . . . . . . . . . . . . 364 / 489 , 491 Sherwani , Kluwer Academic Publishers , 1993 . s s s Timber Wolf 3 . 2 : A New Standard Cell Placement And 56 ) References Cited Global Routing Package , C . Sechen and A . Sangiovan ni - Vincentelli ; IEEE 23rd Design Automation Conf . , 1986 , U . S . PATENT DOCUMENTS Paper 26 . 1 . 3 , 603 , 771 9 / 1971 Isett . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 364 / 491 3 , 617 , 714 11 / 1971 Kernighan . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 364 / 488 ( List continued on next page . ) 4 , 306 . 286 12 / 1981 Cocke et al . . . . . . . . . . 395 / 800 4 , 342 , 090 7 / 1982 Caccoma et al . . . . . 364 , 491 Primary Examiner - Emanuel Todd Voeltz 4 , 484 , 292 11 / 1984 Hong et al . . . . . . . . . . . 364 , 491 Assistant Examiner Vuthe Siek 4 , 495 , 559 1 / 1985 Gelatt , Jr . et al . . . . . . . . . . . . . . . . . . . . . . . 364 / 148 Attorney , Agent , or Firm - Mitchell , Silberberg & Knupp 4 , 554 , 625 11 / 1985 Otten . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 364 / 148 LLP 4 , 577 . 276 3 / 1986 Dunlop et al . . . . . . . 364 / 491 4 , 593 , 363 6 / 1986 Burstein et al . . . . . . 364 / 491 57 ABSTRACT 4 , 612 , 618 9 / 1986 Pryor et al . . . . . . . 364 / 490 4 , 615 , 011 9 / 1986 Linsker . . . . . . . . . . . . 364 / 491 A System for proportionally partitioning multiple groups of 4 , 621 , 339 11 / 1986 Wagner et al . . . . . . . 395 / 800 cells on the Surface of a Semiconductor chip into Subregions 4 , 630 , 219 12 / 1986 Digiacomo et al . . . . . . . . . 364 / 488 is disclosed herein . The cell groups are separated by dividing 4 , 656 , 580 4 / 1987 Hitchcock , Sr . et al . . . . 395 / 500 lines , and the System comprising a calculator which deter 4 . 675 , 829 6 / 1987 Clemenson . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 395 / 65 mines an offset of the cut line from the dividing line ; a shifter 4 , 686 , 629 8 / 1987 Noto et al . . . . . . . 364 / 491 4 , 688 , 072 8 / 1987 Heath et al . . . . . . . . . . 257 / 202 which moves the location of said groups of cells by the offset 4 , 697 , 242 9 / 1987 Holland et al . . . . . . . . . . . . . . . . . . . . . . . . . . . . 395 / 13 Such that the cut line coincides with the dividing line ; and an 4 . 754 , 408 6 / 1988 Carpenter et al . . . . 364 / 491 overflow evaluator and compensator which shifts any cells : 1 . R " , i . 3 . outside Said region to an edge of Said region . 4 , 829 , 446 5 / 1989 Draney . . . . . . . . . . . . . . . . . 364 / 488 4 , 831 , 725 5 / 1989 Dunham et al . . . . . . . . . . . . . . . . . . . . . . . . . . . 29 / 847 30 Claims , 20 Drawing Sheets - - - - - - - - - - - - - - 88F938 SSS0 , 342 . Fil : 3 : 08 ; 2 filliosis / SS : 03 ERAp 8 : ; 3 SN348 kiSE He varic optivizial - i - 24 / atus causpicing / 5 its , psalut oats - i6 FACE ESQ . HE GRSES : HORIZONAL CRI ) i . Rikar REGAPH - 5ASE FiCSIONS : pristiAife ; CRYSEASON 39 6 , 030 , 110 Page 2 U . S . PATENT DOCUMENTS 5 , 140 , 530 8 / 1992 Guha et al . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 395 / 13 5 , 144 , 563 9 / 1992 Date et al . . . . . . . . . . . . 364 / 491 5 , 157 , 778 10 / 1992 Bischoff et al . . . . . . 395 / 500 5 , 159 , 682 10 / 1992 Toyonaga et al . . . . 364 / 500 5 , 187 , 668 2 / 1993 Okude et al . . . . . . . . . 364 / 491 5 , 191 , 542 3 / 1993 Murofushi . . . . . . . . 364 / 491 5 , 200 , 908 4 / 1993 Date et al . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 364 / 491 5 , 202 , 840 4 / 1993 Wong . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 364 / 490 5 , 208 , 759 5 / 1993 Wong . . . . . . . . . . . . . . . 364 / 491 5 , 218 , 551 6 / 1993 Agrawal et al . . . . . . 364 / 491 5 , 222 , 029 6 / 1993 Hooper et al . . . . . . . 364 / 489 5 , 222 , 031 6 / 1993 Kaida . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 364 / 491 5 , 224 , 056 6 / 1993 Chene et al . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 364 / 490 5 , 224 , 057 6 / 1993 Igarashi et al . . . . 364 / 490 5 , 225 , 991 7 / 1993 Dougherty . . . . . . 364 / 491 5 , 231 , 590 7 / 1993 Kumar et al . . . . . 364 / 491 5 , 239 , 465 8 / 1993 Hattori et al . . . . . . . 364 / 707 5 . 245 , 550 9 / 1993 Miki et al . . . . . . . 364 / 490 5 , 249 , 259 9 / 1993 Harvey . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 395 / 13 5 , 251 , 147 10 / 1993 Finnerty . . . . . . 364 / 490 5 , 255 , 345 10 / 1993 Shaefer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 395 / 13 5 , 267 , 176 11 / 1993 Antreich et al . . . . . . 364 / 491 5 , 267 , 177 11 / 1993 Sato et al . . . . . . . . . . . . . 364 / 491 5 , 303 , 161 4 / 1994 Burns et al . . . . . . 364 / 490 5 , 308 , 798 5 / 1994 Brasen et al . . . . . . . . . 437 / 250 5 , 309 , 371 5 / 1994 Shikata et al . . . . 364 / 491 5 , 341 , 308 8 / 1994 Mendel . . . . . . . . . . . . . . . . 364 / 489 5 , 349 , 536 9 / 1994 Ashtaputreet al . . . . 364 / 491 5 , 363 , 313 11 / 1994 Lee . . . . . . . . . . . . . . . . . . . . . . . 364 / 491 5 , 392 . 222 2 / 1995 Noble . . . . 364 / 490 5 , 398 , 195 3 / 1995 Kim . . . . . . . . . . . . . . . . . 364 / 491 5 , 404 , 313 4 / 1995 Shiohara et al . . . . . . 364 / 491 5 , 404 , 561 4 / 1995 Castelaz . . . . . . . . . . . 395 / 800 5 , 465 , 218 11 / 1995 Handa . . . . . . . . . . . . . . 364 / 489 5 , 495 , 419 2 / 1996 Rostoker et al . . 364 / 468 . 28 5 , 513 , 124 4 / 1996 Trimberger et al . . . . . . . . . . . . . . . . . . . . . 364 / 491 5 , 521 , 837 5 / 1996 Frankle et al . . . . . . . . . . . . . . . . . . . . . . . . . . . 364 / 491 5 , 557 , 533 9 / 1996 Koford et al . . . . . . . . . . . . . . . . . . . . . . . . . . . 364 / 491 OTHER PUBLICATIONS A Genetic Approach To Standard Cell Placement Using Metagenetic Parameter Optimization , K . Shahookar and P . Mazumder ; IEEE Transactions on Computer - Aided Design , vol . 9 , No . 5 , May 1990 . Wolverines : Standard Cell Placement On A Network Of WorkStations , S . Mohan and P . Mazumder ; IEEE Transac tions on Computer - Aided Design of Integrated Circuits and Systems , vol . 12 , No . 9 , Sep . 1993 . The Stanford Dash Multiprocessor , D . Lenoski et al . ; Com puter , Mar . 1992 . Genetic Programming , J . Koza ; MIT Press , Cambridge , MA , 1993 , pp . 94 - 101 and 173 . The S3 . mp Interconnect System & TIC Chip , A . Nowatzyk and M . Parkin ; Proceedings of IEEE Computer Society HOT Interconnect Symposium , Stanford Univ . , 1993 . Gordian : VLSI Placement By Quadratic Programming And Slicing Optimization , J . Kleinhans , G . Sigl , F . Johannes , and K . Antreich ; IEEE Transactions on Computer - Aided Design , vol . 10 , No . 3 , Mar . 1991 . A Loosely Coupled Parallel Algorithm For Standard Cell Placement , W . Sun and C . Sechen ; ACM , 1994 , pp . 137 - 144 . An Improved Simulated Annealing Algorithm For Row Based Placement , C . Sechen and K . Lee ; IEEE Int’l Conf . on Computer - Aided Design , Nov . 1987 , pp . 478 - 481 . A Linear - Time Heuristic For Improving Network Partitions , C . M . Fiduccia and R . M . Mattheyses ; IEEE 1982 , 19th Design Automation Conference , Paper 13 . 1 , pp . 175 - 181 . A Block Placement Procedure Using A Force Model , H . Onodera and K . Tamaru , Electronics and Communications in Japan , Part 3 , vol . 72 , No . 11 , 1989 , pp . 87 - 96 . Champ : Chip Floor Plan For Hierarchical VLSI Layout Design , K . Ueda , H . Kitazawa and I . Karada ; IEEE Trans actions on Computer - Aided Design , vol . CAD - 4 , No . 1 , Jan . 1985 . A Forced Directed Component Placement Procedure For Printed Circuit Boards , N . Quinn , Jr . , and M . Breuer ; IEEE Transactions on Circuits and Systems , vol . CAS - 26 , No . 6 , Jun 1979 . Simultaneous Pin Assignment and Global Wiring for Cus tom VLSI Design , L . Y . Wang , Y . T . Lai , and B . D . Liu , IEEE . Pin Assignment with Global Routing for General Cell Designs , Jingsheng ( Jason ) Cong , IEEE Transaction on Computer - Aided Design , vol . 10 , No . 11 , Nov . 1991 . Floorplanning with Pin Assignment , Massoud Pedram , Mal gorzata Marek - Sadowska , Ernest K . Kuh , 1990 IEEE . A New Approach to the Pin Assignment Problem , Xianjin Yao , Massaki Yamada , C . L . Lis , 25th ACM / IEEE Design Automation Conference , 1988 , Paper 37 . 3 . Placement of Standard Cells Using Simulated Annealing on the Connection Machine , Andrea Casotto , Alberto Sangio vanni - Vincentelli , 1987 IEEE . Parallel Standard Cell Placement Algorithms with Quality Equivalent to Simulated Annealing , Jonathan S . Rose , W . Martin Snelgrove , Zvonko G . Vranesic , IEEE Transactions on Computer - Aided Design , vol . 7 , No . 3 , Mar . 1988 . Performance of a Parallel Algorithm for Standard Cell Placement on the Intel Hypercube , Mark Jones , Prithviraj Baner Jee , 24th ACM / IEEE Design Automation Conference , p . 42 . 3 . A Parallel Simulated Annealing Algorithm for the Placement of Macro - Cells , Andrea Casotto , Fabio Romeo and Alberto Sangiovanni - Vincentelli . Properplace : A Portable Parallel Algorithm for Standard Cell Placement , Sungho Kim , John A . Chandy , Steven Parkes , Balkrishna Ramkumar , Prithviraj Banerjee , 1994 IEEE . A Cell - Replicating Approach to Mincut - Based Circuit Par titioning , Chuck Kring and A . Richard Newton , 1991 IEEE . Simultaneous Floor Planning And Global Routing for Hier archical Building - Block Layout , W . Dai , E . Kuh , 1987 IEEE A New Clustering Approach And Its Application To BBL Placement , M . Y . Yu , X . L . Hong , Y . E . Lien , Z . Z . Ma , J . G . Bo , W . J . Zhuang , 1990 IEEE . Genetic Placement , J . P . Cohoon , W . D . Paris , 1986 IEEE . Toward Efficient Hierarchical Designs . By Ratio Cut Parti tioning , Y . Wei and C . Cheng , 1989 IEEE . Pad Placement And Ring Routing For Custom Chip Layout , D . Wang , 27th ACM / IEEE Design Automation Conference , Paper 10 . 3 . Pin Assignment With Global Routing , J . ( Jason ) Cong , 1989 IEEE An Efficient Heuristic Procedure For Partitioning Graphs , B . W . Kernighan , S . Lin . A Cell - Replicating Approach To Mincut - Based Circuit Par titioning , C . Kring , A . R . Newton , 1991 IEEE . Ten : The Transportation and Assignment Problems . 6 , 030 , 110 Page 3 Equation of State Calculations by Fast Computing Machines , N . Metropolis , A . W . Rosenbluth , M . N . Rosen bluth , A . H . Teller , The Journal of Chemical Physics , vol . 21 , No . 6 , Jun . 1953 . Stochastic Evolution : A Fast Effective Heuristic For Some Generic Layout Problems , Y . G . Saab , V . B . Rao , 27th ACM / IEEE Design Automation Conference , 1990 , Paper 2 . 2 . Linear Network Optimization : Algorithms , and Codes , D . P . Bertsekas , 1991 . Primal - Dual and Dual Algorithms for the Assignment and Transportation Problems , K . G . Murty , 1992 Prentice - Hall , Inc . A New Approach to the Pin Assignment Problem , X . Yao , M . Yamada , C . L . Liu , 1989 IEEE . U . S . Patent Feb . 29 , 2000 Sheet 1 of 20 6 , 030 , 110 7 CELLS CONSTRUCI EACH CELL ' S NEIGHBORHOOD , USING - THE NEW METRICS ON THE HYPERGRAPH ( NETLISI ) ; - IIERATIVE f - d OPTIMIZATION PERFORM DENSITY - DRIVEN 1 - d CHAONIC PREPLACEMENT ITERATE iter O TIMES DRIVEW BY DENSITY AFFINITY - DRIVEN DISCRETE WIRE LENGTH PLACEMENT OPTIMIZATION CUIS WEIGHBORHOODS HIGHEST LEVEL OF THE REGION REGIONAL HIERARCHY REACHED ? HIERARCHICAL DESCENT U . S . Patent Feb . 29 , 2000 Sheet 2 of 20 6 , 030 , 110 LEVELIZATION CELL , DENSITY WITH 9 DISPERSION - DRIVEN SPRING SYSTEM PERFORM UNCONSTRAINED f0 ITERATE SINUSOIDAL OPTIMIZATION iter 1 JIMES r S . 11 PERFORM SINUSOIDAL OPTIMIZATION 12 IIERAIE WITH COWIROL OF CELL COLUMN DENSIIIES iter 2 IMES S . 3 . REMOVE OVERLAP WITH f3 MINIMAl NOISE - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - VERTICAL OPTIMIZATION / If 24 / : Adjust cell spacing / EF , pructus - : iter 3 IIMES PERMUIE CELLS 25 PLACE CELIS ON THE CLOSEST 17 N HORIZONIAL GRID LINE PERFORM NEIGHBORHOOD - BASED 18 OPTIMIZATION IIERAIE FUNCITONAL SIEWE iter 4 IIMES OPTIMIZATION CRYSTALLIZATION 19 IIERATE HYPERGRAPH - BASED I 6 , 030 , 110 Sheet 3 of 20 Feb . 29 , 2000 U . S . Patent CN S UN U . S . Patent Feb . 29 , 2000 Sheet 4 of 20 6 , 030 , 110 U . S . Patent Feb . 29 , 2000 Sheet 5 of 20 6 , 030 , 110 6 , 030 , 110 Sheet 6 of 20 Feb . 29 , 2000 U . S . Patent START 100 INPUI vr NO + ~ ~ ~ ~ - - - - - - - ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ OUTPUT NO , t ) f 12 5 FIG . END U . S . Patent Feb . 29 , 2000 Sheet 7 of 20 6 , 030 , 110 Vo O f ASSIGN INITIAL COORDINAIES TO ALL CELLS FROM N ( Vo , M ) 102 6 , 030 , 110 201 20 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - Sheet 8 of 20 O 204 + - - - - - - - - 1 - - - - - - - - - - - - - - - - - - - - - - - - - - - - FIG Feb . 29 , 2000 203 | U . S . Patent 1 1 FIG . U . S . Patent Feb . 29 , 2000 Sheet 9 of 20 6 , 030 , 110 INITIALIZE 250 COMPUTE NET COORDINAIES COMPUTE NEW CELL COORDINAIES COMPUTE DIFFERENCE BETWEEW LAST CELL COORDINAIES AND NEW CELL COORDINAIES 251 252 25 . 3 LESS THAW IHRESHOLD 2 - E - E - E - - - EE - G - B - EHE U . S . Patent Feb . 29 , 2000 Sheet 10 of 20 6 , 030 , 110 - - HGEE - E - G - E - + - E - - - - EEE 201 300 FIG . 15 FIG . 16 U . S . Patent Feb . 29 , 2000 Sheet 11 of 20 6 , 030 , 110 FIG . 1 7 A B 10 ) ( 200 ) FIG . 20 U . S . Patent Feb . 29 , 2000 Sheet 12 of 20 6 , 030 , 110 FIG . 18 INITIALIZE INDEY CALCULATIOW HEIGHT ACCUMULATION COMPUIE VALUE OF ARRAY ELEMENIS LOCATE CUT POINT INDEY FINER RESOLUTION REQUIRED 2 3 . 25 326 327 328 329 330 SUBDIVIDE CURRENT IWIERAL 3 . 31 322 OFFSET CALCULATION 350 351 352 SET TO BORDER FIG . 19 U . S . Patent Feb . 29 , 2000 Sheet 13 0f 20 6 , 030 , 110 ADJACENT CEll LOCATION 400 F / G . 21 AFFINITY CALCULATION 401 GLOBAL . IHRESHOLD 402 EVALUATION SUBDIVIDE INITIALIZE INDEY CALCULATION CELLAFFINITY SUMMATION GLOBAL . AFFINITY CALCULAION / EVALUATION AFFINITY COMPARISON CELL REPOSITION 450 FIG . 22 452 453 454 455 DAIA SIRUCTURE UPDATE 456 U . S . Patent Feb . 29 , 2000 Sheet 14 of 20 6 , 030 , 110 FIG . 25 PENALTY CALCULATION PRIOR LEVE CALCULATION COMPUTE IOIAL PENALTY IOIAL CAPACITY PENALTY CALCULATION 50f 502 FIG . 24 503 504 Ymay 6 , 030 , 110 Sheet 15 0f 20 Feb . 29 , 2000 U . S . Patent 26 FIG . IY . 1 IX - 1 IY 27 FIG . U . S . Patent Feb . 29 , 2000 Sheet 16 of 20 6 , 030 , 110 F / G . 28 123 4 567 89 f0 ff 13 15 16 17 f . 19 20 DISTANCE FROM CENTER OF WEIGHBORHOOD CALCULATION 601 602 FIG . 29 603 604 U . S . Patent Feb . 29 , 2000 Sheet 17 of 20 6 , 030 , 110 F / G , J 1 Feen IIERATE BASIC FORMULA W IIMES WITH N = 1 651 IIERAIE BASIC FORMULA PTIMES WITH N = 0 AND N = 1 652 He al H - - a H - INCREMENT O COMPUTE AVERAGE COST VALUE 654 655 FIG . 32 ASSIGN INTEGER COORDINAIES TO NODES OF THE MESH ARBIIRARY EQUILATERALS IIERATIVELY RECALCULATE MOVEABLE NODE COORDINAIES IO MINIMIZE COST FUNCIION DENSITY DISPERSION ADJUST COORDINAIES IO MINIMIZE LOCAL COST FUNCION U . S . Patent Feb . 29 , 2000 Sheet 18 of 20 6 , 030 , 110 % 2 2 L % Z2 820 815 U . S . Patent Feb . 29 , 2000 Sheet 19 of 20 6 , 030 , 110 FIG . 35 I ( i ) 3 | | | | | 1H H 3 | | U . S . Patent Feb . 29 , 2000 Sheet 20 of 20 6 , 030 , 110 902 NO 908 YES COUND0 & Zaz ( i ) K maxzaz ZOZ ( i ) K = ZOZ ( i ) + 1 ( i ) ( i ) YES COUNT K = COUNT - f COUNT K = COUNT - 1 YES COUNT K = COUNTHzaz ( ) - maxzaz ) . 4 = zoz ( ) - minzaz COUNT K = COUNTA FIG . 36 6 , 030 , 110 1 ADVANCED MODULAR CELL , PLACEMENT SYSTEM WITH MEDIAN CONTROLAND INCREASE IN RESOLUTION BACKGROUND OF THE INVENTION 1 . Field of the Invention The present invention generally relates to the art of microelectronic integrated circuits , and more specifically to a System for placement of cells on integrated circuit chips . 2 . Description of the Related Art Microelectronic integrated circuits consist of a large num ber of electronic components which are fabricated by lay ering Several different materials on a Silicon base or wafer . The design of an integrated circuit transforms a circuit description into a geometric description which is known as a layout . A layout consists of a set of planar geometric shapes in the various layers of the Silicon chip . The process of converting the Specifications of an elec trical circuit into a layout is called the physical design . Physical design requires arranging elements , wires , and predefined cells on a fixed area , and the proceSS can be tedious , time consuming , and prone to many errors due to tight tolerance requirements and the minuteness of the individual components . Currently , the minimum geometric feature size of a com ponent is on the order of 0 . 5 microns . Feature size may be reduced to 0 . 1 micron within several years . This small feature size allows fabrication of as many as 10 million transistors or 1 million gates of logic on a 25 millimeter by 25 millimeter chip . This feature size decrease / transistor increase trend is expected to continue , with even Smaller feature geometries and more circuit elements on an inte grated circuit . Larger chip sizes will allow far greater numbers of circuit elements . Due to the large number of components and the exacting details required by the fabrication process , physical design is not practical without the aid of computers . As a result , most phases of physical design extensively use Computer Aided Design ( CAD ) tools , and many phases have already been partially or fully automated . Automation of the physi cal design process has increased the level of integration , reduced turn around time and enhanced chip performance . The object of physical chip design is to determine an optimal arrangement of devices in a plane and to find an efficient interconnection or routing Scheme between the devices to obtain the desired functionality . Since Space on the chip Surface is at a premium , algorithms must use the Space very efficiently to lower costs and improve yield . The arrangement of individual cells in an integrated circuit chip is known as a cell placement . Each microelectronic circuit device or cell includes a plurality of pins or terminals , each of which is connected to pins of other cells by a respective electrical interconnect wire network or net . A goal of the optimization proceSS is to determine a cell placement Such that all of the required interconnects can be made , and the total wirelength and interconnect congestion are minimized . Prior art methods for achieving this goal comprise gen erating one or more initial placements , modifying the place ments using optimization methodologies including genetic algorithms . Such as Simulated evolution , force directed place ment or Simulated annealing , described hereinbelow , and comparing the resulting placements using a cost criteria . Depending on the input , placement algorithms are clas sified into two major groups , constructive placement and 15 25 35 40 45 50 55 60 65 2 iterative improvement methods . The input to the construc tive placement algorithms consists of a set of blockS along with the netlist . The algorithm provides locations for the blocks . Iterative improvement algorithms start with an initial placement . These algorithms modify the initial placement in Search of a better placement . The algorithms are applied in a recursive or an iterative manner until no further improve ment is possible , or the Solution is considered to be Satis factory based on a predetermined criteria . Iterative algorithms can be divided into three general classifications : Simulated annealing , Simulated evolution and force directed placement . The Simulated annealing algo rithm Simulates the annealing process that is used to temper metals . Simulated evolution Simulates the biological process of evolution , while the force directed placement simulates a System of bodies attached by Springs . ASSuming that a number N of cells are to be optimally arranged and routed on an integrated circuit chip , the num ber of different ways that the cells can be arranged on the chip , or the number of permutations , is equal to N ( N factorial ) . In the following description , each arrangement of cells will be referred to as a placement . In a practical integrated circuit chip , the number of cells can be hundreds of thousands or millions . Thus , the number of possible placements is extremely large . Interactive algorithms function by generating large num bers of possible placements and comparing them in accor dance with Some criteria which is generally referred to as fitness . The fitness of a placement can be measured in a number of different ways , for example , Overall chip size . A Small size is associated with a high fitneSS and Vice versa . Another measure of fitness is the total wire length of the integrated circuit . A high total wire length indicates low fitneSS and Vice versa . The relative desirability of various placement configura tions can alternatively be expressed in terms of cost , which can be considered as the inverse of fitness , with high cost corresponding to low fitness and Vice versa . a . Simulated Annealing Basic Simulated annealing per Se is well known in the art and has been successfully used in many phases of VLSI physical design Such as circuit partitioning . Simulated annealing is used in placement as an iterative improvement algorithm . Given a placement configuration , a change to that configuration is made by moving a component or inter changing locations of two components . Such interchange can be alternatively expressed as transposition or Swapping . In the case of a simple pairwise interchange algorithm , it is possible that a configuration achieved has a cost higher than that of the optimum , but no Single interchange can cause further cost reduction . In Such a situation , the algo rithm is trapped at a local optimum and cannot proceed further . This happens quite often when the algorithm is used in practical applications . Simulated annealing helps to avoid getting achieving and maintaining a local optima by occa Sionally accepting moves that result in a cost increase . In Simulated annealing , all moves that result in a decrease in cost are accepted . Moves that result in an increase in cost are accepted with a probability that decreases over time as the iterations proceed . The analogy to the actual annealing process is heightened with the use of a parameter called temperature T . This parameter controls the probability of accepting moves that result in increased cost . More of Such moves are accepted at higher values of temperature than at lower values . The algorithm starts with a very high value of temperature that gradually decreases So 6 , 030 , 110 3 that moves that increase cost have a progressively lower probability of being accepted . Finally , the temperature reduces to a very low value which requires that only moves that reduce costs are to be accepted . In this way , the algorithm converges to an optimal or near optimal configu ration . In each Stage , the placement is shuffled randomly to get a new placement . This random shuffling could be achieved by transposing a cell to a random location , a transposition of two cells , or any other move that can change the wire length or other cost criteria . After the Shuffle , the change in cost is evaluated . If there is a decrease in cost , the configuration is accepted . Otherwise , the new configuration is accepted with a probability that depends on the temperature . The temperature is then lowered using Some function which , for example , could be exponential in nature . The proceSS is Stopped when the temperature is dropped to a certain level . A number of variations and improvements on the basic Simulated annealing algorithm have been devel oped . An example is described in an article entitled " Tim berwolf 3 . 2 A New Standard Cell Placement and Global Routing Package” by Carl Sechen , et al . , IEEE 23rd Designed Automation Conference paper 26 . 1 , pages 432 to 439 . b . Simulated Evolution Simulated evolution , which is also known as the genetic algorithm , is analogous to the natural process of mutation of Species as they evolve to better adapt to their environment . The algorithm starts with an initial Set of placement con figurations which is called the population . The initial place ment can be generated randomly . The individuals in the population represent a feasible placement to the optimiza tion problem and are actually represented by a String of symbols . The Symbols used in the Solution String are called genes . A Solution String made up of genes is called a chromosome . A Schema is a set of genes that make up a partial Solution . The Simulated evolution or genetic algorithm is iterated , and each iteration is called a generation . During each iteration , the individual placements of the population are evaluated on the basis of fitness or cost . Two individual placements among the population are Selected as parents , with prob abilities based on their fitness . A better fitness for an individual placement increases the probability that the place ment will be chosen . The genetic operators are called croSSover , mutation and inversion , which are analogous to their counterparts in the evolution process , are applied to the parents to combine genes from each parent to generate a new individual called the offspring or child . The offspring are evaluated , and a new generation is formed by including Some of the parents and the offspring on the basis of their fitness in a manner Such that the size of the population remains the Same . AS the tendency is to Select high fitness individuals to generate offspring , and the weak individuals are deleted , the next generation tends to have individuals that have good fitness . The fitness of the entire population improves with Suc cessive generations . Consequently , overall placement qual ity improves over iterations . At the same time , Some low fitness individual cell placements are reproduced from pre vious generations to maintain diversity even though the probability of doing So is quite low . In this way , it is assured that the algorithm does not lock into a local optimum . The first main operator of the genetic algorithm is croSSover , which generates offspring by combining Sche mata of two individuals at a time . Combining Schemata 15 25 35 40 45 50 55 60 65 4 entails choosing a random cut point and generating the offspring by combining the left Segment of one parent with the right Segment of the other . However , after doing So , Some cells may be duplicated while other cells are deleted . This problem will be described in detail below . The amount of crossover is controlled by the crossover rate , which is defined as the ratio of the number of offspring produced by crossing in each generation to the population size . CroSSOver attempts to create offspring with fitness higher than either parent by combining the best genes from each . Mutation creates incremental random changes . The most commonly used mutation is pairwise interchange or trans position . This is the proceSS by which new genes that did not exist in the original generation , or have been lost , can be generated . The mutation rate is defined as the ratio of the number of offspring produced by mutation in each generation to the population size . It must be carefully chosen because while it can introduce more useful genes , most mutations are harm ful and reduce fitness . The primary application of mutation is to pull the algorithm out of local optima . Inversion is an operator that changes the representation of a placement without actually changing the placement itself So that an offspring is more likely to inherit certain Schema from one parent . After the offspring are generated , individual placements for the next generation are chosen based on Some criteria . Numerous Selection criteria are available , Such as total chip Size and wire length as described above . In competitive Selection , all the parents and offspring compete with each other , and the fittest placements are selected So that the population remains constant . In random Selection , the place ments for the next generation are randomly Selected So that the population remains constant . The latter criteria is often advantageous considering the fact that by Selecting the fittest individuals , the population converges to individuals that share the Same genes and the Search may not converge to an optimum . However , if the individuals are chosen randomly there is no way to gain improvement from an older generation to a new generation . By combining both methods , Stochastic Selection chooses probabilities based on the fitness of each individual . c . Force Directed Placement Force directed placement exploits the Similarity between the placement problem and the classical mechanics problem of a System of bodies attached to Springs . In this method , the blocks connected to each other by nets are Supposed to exert attractive forces on each other . The magnitude of this force is directly proportional to the distance between the blockS . Additional proportionality is achieved by connecting more “springs” between blocks that “talk” to each other more ( volume , frequency , etc . ) and fewer “springs where less extensive communication occurs between each block . According to Hooke ' s Law , the force exerted due to the Stretching of the Springs is proportional to the distance between the bodies connected to the Spring . If the bodies are allowed to move freely , they would move in the direction of the force until the system achieved equilibrium . The same idea is used for placing the cells . The final configuration of the placement of cells is the one in which the System achieves a Solution that is closest to actual equilibrium . The problem of cell placement is compounded by external requirements Specific to each individual integrated circuit chip . In conventional chip design , the positions of certain 6 , 030 , 110 S “unmovable” cells ( external interconnect terminals or pads , large “megacells ' etc . ) are fixed a priori by the designer . Given those fixed positions , the rest of the cells are then placed on the chip . Since the unmovable cells and pads are located or placed before the placement for the rest of the cells of chip has been decided on , it is unlikely that the chosen positions will be optimal . In this manner , a number of regions , which may have different sizes and shapes , are defined on the chip for placement of the rest of the cells . It is desirable to assign individual microelectronic devices or cells to the regions , or “partition ' the placement Such that the total interconnect wirelength is minimized . However , methodologies for accomplishing this goal efficiently have not been proposed heretofore . The general partitioning methodology is to hierarchically partition a large circuit into a group of Smaller Subcircuits until each Subcircuit is Small enough to be designed effi ciently . Because the quality of the design may Suffer due to the partitioning , the partitioning of a circuit requires care and precision . One of the most common objectives of partitioning is to minimize the cutsize which is defined as a number of nets crossing a cut . Also the number of partitions often appears as a constraint with upper and lower bounds . At chip level , the number of partitions is determined , in part , by the capability of the placement algorithm . The prior art accomplishes partitioning by means of a Series of “bipartitioning problems , in which a decision is made to assign a component to one of two regions . Each component is hierarchically bipartitioned until the desired number of components is achieved . Numerous alternate methodologies for cell placement and assignment are known in the art . These include quadratic optimization as disclosed in an article entitled “GORDIAN : VLSI Placement by Quadratic Programming and Slicing Optimization” , by J . Kleinhans et al , IEEE Trans . on CAD , 1991 , pp . 356 - 365 , and simulated annealing as described in an article entitled “A Loosely Coupled Parallel Algorithm for Standard Cell Placement” , by W . Sun and C . Sechan , Proceedings of IEEE / ACM IC - CAD Conference , 1994 , pp . 137 - 144 . These prior art methods cannot simultaneously Solve the partitioning problem and the problem of placing partitions on the chip , and thus the applicability of Such methods to physical design automation Systems for integrated circuit chip design is limited . More specifically , prior art methods do not provide any metric for Specifying distances between cells based on netlist connections . An initial placement must be performed to establish physical locations for cells and thereby distances therebetween . Also , prior art methods fix cells in clusters at the begin ning of optimization , and do not provide any means for allowing cells to move between clusters as optimization proceeds . This can create areas of high routing congestion , which cannot be readily eliminated because cell movements between clusters which could relieve the congestion are not allowed . In Summary , the problem inherent in these prior cell placement methods is that repeated iterations generally do not tend to converge to a Satisfactory relatively uniform overall cell placement for large numbers of cells . The aforementioned methods can take Several days to place a large number of cells , and repeating these methods with 15 25 35 40 45 50 55 60 65 6 different parameterS . or different initial arrangements may not necessarily provide improvements to cell placement . Typical methods for using these designs involve using a chosen method until a particular parameter , for example wire length , achieves a certain criteria or the method fails to achieve this criteria for a predetermined number of runs . The results are inherently non - optimal for other placement fit neSS measurements , having optimized the method based only on a single parameter . Further , results of these place ment techniques frequently cannot be wired properly , or alternately , the design does not meet timing requirements . For example , with respect to Simulated annealing , Setting the temperature to different values may , under certain circumstances , improve placement , but efficient and uniform placement of the cells is not guaranteed . SUMMARY OF THE INVENTION According to the present invention , there is provided a System for optimizing placement of a plurality of cells located in a region on a Surface of a Semiconductor chip . The System executes a one dimensional preplacement optimiza tion a predetermined number of times , and places cells within the region , and Subsequently establishes a dividing line between Subregions of the region . The System then locates a levelizing cut line to divide the cells into multiple groupS using a first evaluation criteria , and modifies Said initial placement of cells Such that the dividing line and the levelizing cut line coincide . The System then computes an overall cost function and repeats all of these functions a predetermined number of times . An average cost function is then computed , the Overall cost function computation , rep etition of prior functions , and average cost computation are repeated until a predetermined criterion is attained . The one dimensional preplacement optimization com prises computing a group coordinate for each group of cells , or net , based on the positions of all cells in the net . One dimensional preplacement optimization then determines a weight for each cell depending on a first parameter of the cell , Such as height , and calculates a cell placement position from the weight received and the Sum of net coordinates for all nets with which the cell is associated . Other objects , features , and advantages of the present invention will become more apparent from a consideration of the following detailed description and from the accom panying drawings . BRIEF DESCRIPTION OF THE DRAWINGS FIG . 1A is a flow chart illustrating the main steps of the process according to the present invention ; FIG . 1B is a flow chart illustrating the main steps of the process according to the present invention ; FIG . 2 is an illustration of an exemplary integrated circuit chip ; FIG . 3 is an illustration of a cell that has one pin connected to each net ; FIG . 4 illustrates seven nets , each of which interconnect a plurality of cells , FIG . 5 is a flowchart illustrating the formation of a cell cluster or “neighborhood” in accordance with the present invention ; FIG . 6 is an illustration of a center cell and nets ; FIG . 7 shows that the cell v is assigned a coordinate between 0 and 1 ; FIG . 8 is a flowchart illustrating the iteration of the recomputing of the net and cell coordinates , 6 , 030 , 110 7 FIG . 9 illustrates a cell having several pins which belong to the net ; FIG . 10 is an illustration of a core divided into Subregions ; FIG . 11 is an illustration of a moveable cell within the core region ; FIG . 12 is a flowchart that demonstrates the procedure for obtaining an initial one dimensional placement of the mov able cells ; FIG . 13 is an illustration of the coordinates of the nets along an imaginary line ; FIG . 14 is an illustration of the coordinates of the nets along an imaginary line ; FIG . 15 is an illustration of the placement of nets along the line in the direction partitioned along a dividing line providing two Subregions containing the cell positions , FIG . 16 is an illustration of a region physically divided in half by a dividing point ; FIG . 17 is an illustration of one cell located in each of the ten Subintervals , FIG . 18 is a flowchart relating finding a levelizing cut point , FIG . 19 is an illustration of the calculation step which determines the offset of the cut line from the dividing line ; FIG . 20 is an illustration of the two regions that are divided using two dividing lines , FIG . 21 is an illustration of adjacent cell location step which initially considerS moving a cell from its current position to each of the adjacent regions , as well as consid ering leaving the cell in the current region ; FIG . 22 is an illustration of the ( A , B ) interval which is Subdivided into equal Subintervals in Subdivision step 450 , FIG . 23 is an illustration of the cell region having a certain number of columns , or possibly rows , located therein ; FIG . 24 is an illustration of the penalty calculation step 501 ; FIG . 25 is an illustration of a three pin net ; FIG . 26 is an illustration of each dividing line partitions regions , and each of these regions has a capacity denoting the volume of cells which can fit within the region ; FIG . 27 represents a region having indices ( TX , TY ) . FIG . 28 illustrates an ordering of cells within the neigh borhood ; FIG . 29 is an illustration of the weight assignment step which assigns each cell a weight equal to the Size of the neighborhood minus the index of the cell ; FIG . 30 is an illustration of the weights of the neighbor hood attraction in a direction ; FIG . 31 is an illustration of the system which iterates a predetermined number of times , preferably once , calculating affinities ; FIG . 32 is a flowchart associated with the density driven Spring System ; FIG . 33 is an illustration of a portion of the chip that has Seven columns which are partitioned into maximal Segments without blockages , FIG . 34 is a preferred order for Scanning the regions , FIG . 35 is an illustration that denotes the top and bottom of the column ; FIG . 36 is a flowchart of a preferred process adjusting cell spacing in the column to remove overlap with minimal noise ; FIG . 37 illustrates a column containing cells of specified heights , and 15 25 35 40 45 50 55 60 65 8 FIG . 38 is an illustration of the cells that are set to the grids by increasing the coordinate until the bottom of each cell reaches the closest horizontal grid line . DESCRIPTION OF THE PREFERRED EMBODIMENTS An overall block diagram of the preferred implementation of the current invention is presented in FIG . 1 . As will become apparent from the following detailed description , other embodiments can be implemented with highly effec tive results while still within the scope of the invention . Section 1 : System Overview FIGS . 1A and 1B comprise a flow chart that illustrates the main Steps of the proceSS according to the present invention . A brief description of the various Steps of the proceSS is presented with reference to FIGS . 1A and 1B . To facilitate describing and understanding the invention , this disclosure is divided into Sections . This first Section is a general Overview of the process according to the present invention . Subsequent Sections describe and explain the algorithms and process steps shown in FIGS . 1A and 1B with reference to other figures of the drawings as appropriate . The Specific algorithms described herein , as well as the basic steps which they represent ( even if they are replaced by different algorithms ) , are designed for implementation in a general purpose computer . Furthermore , each of the algo rithms described herein , as well as the basic Step it represents , can be encoded on computer Storage media Such as CD Roms , floppy disks and computer harddrives , whether alone or in combination with one or more of the algorithms and Steps described herein . Given only the netlist , before the cells have been placed on the chip , there is no way using prior art techniques to compute the conventional geometric distance between two cells ( the “Euclidean distance ' ) because no geometric coor dinates exist for any cell . A new mathematical form of distance is defined in the algorithms according to the present invention in which the distance between cells can be calcu lated from the way in which connections in the netlist interconnect its cells . This distance measure plays a critical role in the analysis of the netlist for placement by the algorithms . The cell placement System according to the present inven tion performs placement as either a uniprocessor or parallel processor procedure . Unlike previous Systems in which a constructive heuristic provided an initial placement fol lowed by a Statistical improvement technique , the process according to the present invention constructs and optimizes placements in a Series of highly integrated Steps . Subsection 1A : Data Preparation The use of placement techniques must , of course , be preceded by the Step 1 of preparation of the netlist . For a large chip , preparation of the netlist is a major design effort that includes System Specification , Synthesis , debugging , preliminary timing , and final netlist construction . The Spe cifics of these complex design Steps are not the Subject of the present disclosure . The description of the present invention begins by assuming that the System to be implemented on the chip has been designed and that the resulting correct netlist is available . The techniques for preparing a netlist are well known in the art . Subsection 1B : Neighborhood Construction As shown at the start of the flowchart of FIG . 1A , the process according to the present invention constructs a neighborhood 2 for each cell in the netlist . Neighborhood 6 , 030 , 110 9 construction is discussed in more detail in S2 below . The neighborhoods are preferably constructed according to the neighborhood construction process described below . After the neighborhood of a cell is constructed , coordinates are assigned to each cell , as described in detail Subsequently in S3 , which describes a preferred technique for optimization of the cell neighborhoods . Subsection 1C : Placement Iteration The cell coordinates are then iteratively optimized under the iterative 1D preplacement optimization procedure described in S4 . The purpose of this iterative 1D preplace ment optimization procedure is to get a fast , good cell preplacement . In the iterative one - dimensional preplace ment optimization procedure of S4 , the cells are pre - placed on a two - dimensional abstraction of the chip Surface . The iterative one - dimensional preplacement optimization proce dure begins with the Step 3 of initializing the coordinates of all cells at the center of the Surface , and then performing the iterations described in S4 in the X - and y - directions . A density - driven one dimensional preplacement is per formed 4 to assign cells to regions in accordance with the capacities of each region of the chip . A preferred proceSS for assigning cells to regions in accordance with region capacity is described in S5 . The surface abstraction is divided into Subregions by bisection in a Selected direction . A preferred levelization by bisection process 5 is described in S5 . A median control procedure 6 is then used to modify coordinates to the cells . A preferred median control proceSS is described in S6 . The 1D preplacement optimization procedure of S4 , the cut - point procedure of $ 5 and the median control procedure of S6 are then iterated for a specified number of times , and the average value of the cost function ( e . g . Wire length ) for the iterations is computed . The 1D preplacement optimiza tion procedure of S4 , the cut - point procedure of $ 5 and the median control procedure of S6 are then again iterated for the Specified number of times as a block 20 and the average cost function is recomputed . If the average cost function is decreased by less than a specified amount , usually 10 , this step ( block 20 ) is exited . Otherwise this step ( block 20 ) is again iterated with the average cost function again computed and compared to the previous average cost function value . At the end of this step the cells have been assigned to Subregions in Such a way that the capacities of the Subre gions are not exceeded . Subsection 1 D : Affinity - Driven Placement Optimization An affinity - driven placement optimization 7 is performed to improve cell placement and to minimize the cost function . A preferred affinity - driven placement optimization proceSS is described in S7 . The affinity optimizations are driven by considerations of cost functions as described in SS8 - 11 . Referring to $ 12 , a functional Sieve optimization technique is also used to perform the cell movement . When the affinity - driven optimization is complete , the level of the subdivision of the chip surface is checked 8 . If the level of Subdivision is not at the specified highest level ( i . e . , the level of hierarchy with the Smallest desired regions ) , block 21 is repeated the chip is further Subdivided in the y - dimension ; the preplacement iteration of S4 - 6 , is reentered with that level of Subdivision for the y - coordinate . The preferred highest level is where the region is one column wide . After processing for the y - coordinate is complete , the X - coordinate is processed , etc . , as X and y alternate . The typical number of iterations of block 21 is 2log - N where N equals the number of columns in the chip . If , for example , the chip has 8 columns , the number of iterations is 2log 8 , or 6 . 15 25 35 40 45 50 55 60 65 10 After a certain level of hierarchy is achieved , it may be desirable to Stop the process at this point and not continue with further cell placement . This is especially true if one wants to obtain a fast estimate of cell placement . Subsection 1E : Cell Density Levelization Finally , when the highest level of hierarchy is reached 8 , the proceSS enters a cell density levelization procedure as shown at the beginning of FIG . 1B . It should be noted that various combinations of the algorithmic StepS described herein can be used . Algorithmic Steps can be deleted as desired and as appropriate for the particular circumstances presented . Once the cell placement is determined by the methods in accordance with the present invention , the cells can then be placed on a Silicon wafer in order to construct the desired integrated circuit . The cell density levelization preferably begins with a dispersion - driven step 9 as described in S16 . As this step is entered , the cells have been placed in positions on the Surface that optimize given cost functions . However , the cell layout may not be feasible because cells may overlap , and the cells may have not been assigned to proper cell columns . Furthermore , the cell density may be very uneven , with resulting Serious consequences for routing the wires on the chip . The sinusoidal optimization step 10 of $ 15 , the dispersion - driven levelizing system 9 of S16 are performed globally to levelize the density of cells using global level ization procedures . Steps 9 and 10 are iterated as a block 22 . Typically , about 5 iterations has proven effective . Continuing with FIG . 1B , after global levelization has been performed , there may still be Some density peaks in the core area of the chip . A preferred procedure for density peaks removal is described in S13 . The procedure for density peaks removal 11 is Sometimes referred to herein as the “bulldozer . ” The bulldozer is applied to remove the density peaks . The sinusoidal optimization procedure 12 of S15 is applied to the chip surface Subdivided into cell columns . The densities of cells in the columns are controlled to prohibit overflow and ensure that the cells are evenly assigned to the columns required by the Structure of the final design . The Sinusoidal optimization procedure is iterated as a block 23 , generally , for a specified number of times , Such as 5 times . Subsection 1E : Cell Overlap Removal The overlap removal procedure 13 of S14 is applied again without controlling the maximum distance between adjacent cells . The Step removes any overlap that exists among cell outlines . This step is used to produce a physically feasible layout . Applying the overlap removal procedure at this part of the process removes cell overlap with minimal increase in average wire length . Subsection 1 F : Final Placement Crystallization After applying the overlap removal procedure to remove the overlap , most of the cells are close to their final posi tions . The crystallization Step places the cells in correct , final positions . Proper vertical cell spacing are computed So that horizontal wires can be routed over and between cells in the Vertical columns . Vertical and local - horizontal " Swaps” may be performed if doing So improves the cost functions . Cells must be assigned proper geometric coordinates So that their positions correspond to legal grid positions Specified by the underlying chip architecture . All of these steps 14 , 15 , 16 , 17 , 18 and 19 are performed by the crystallization proce dures described in S16 . These procedure “freeze” the cells into their final positions . Steps 14 , 15 and 16 are iterated as a block 24 , generally a specified number of times , Such as 10 times . Steps 18 and 19 are also iterated as a block 25 a 6 , 030 , 110 11 Specified number of times . At this point , the placement proceSS is completed , and a data Structure is prepared that can be read by the routing System for chip routing and design completion . An exemplary integrated circuit chip is illustrated in FIG . 2 and generally designated by the reference numeral 26 . The circuit 26 includes a semiconductor Substrate 26A on which are formed a number of functional circuit blocks that can have different sizes and shapes . Some are relatively large , Such as a central processing unit ( CPU ) 27 , a read - only memory ( ROM ) 28 , a clock / timing unit 29 , one or more random access memories ( RAM ) 30 and an input / output ( I / O ) interface unit 31 . These blocks , commonly known as macroblocks , can be considered as modules for use in various circuit designs , and are represented as Standard designs in circuit libraries . The integrated circuit 26 further comprises a large number , which can be tens of thousands , hundreds of thousands or even millions or more of Small cells 32 . Each cell 32 represents a single logic element , Such as a gate , or Several logic elements interconnected in a Standardized manner to perform a specific function . Cells that consist of two or more interconnected gates or logic elements are also available as Standard modules in circuit libraries . The cells 32 and the other elements of the circuit 26 described above are interconnected or routed in accordance with the logical design of the circuit to provide the desired functionality . Although not visible in the drawing , the Vari ous elements of the circuit 26 are interconnected by elec trically conductive lines or traces that are routed , for example , through vertical channels 33 and horizontal chan nels 34 that run between the cells 32 . For a particular electrical circuit having predefined input and output terminals and interconnected in a predetermined way , the problem for the chip designer is in constructing a layout indicating the positions of the modules Such that the area on the chip Surface occupied by wires and the overall layout area are minimized . The system shown in FIGS . 1A and 1B receives inputs for a user - specified integrated circuit design which includes a netlist . A connection between two or more interconnected elements of the circuit is known as a wiring net , or net . A netlist is a list of cells and nets . Section 2 : Neighborhood Construction A hyperedge is a Series of pins which are interconnected , i . e . , wired together with an electrically common connection . For example , a hyperedge having pins A , B , and C means that pins A , B , and C are all connected together with a common metal wire . The “length” log ) of a wiring net or hyperedge is equal to the number of pins ( vertices ) that are interconnected by the net minus one . This can be represented mathematically as 10q ) = q - 1 , where q is the net and q is the number of pins that are interconnected by the net q . A particular cell , especially a large cell , can have two or more pins that are interconnected by one net q , and for this reason q is the number of pins rather than the number of cells interconnected by a net q . However , for simplicity of description and illustration , the following examples will assume that each cell has only one pin connected to each net . An example is illustrated in FIG . 3 . A net q 40 is shown as interconnecting 5 cells 34 , 35 , 36 , 37 and 38 , that are collectively designated as W . The length of the net q is ( 5 - 1 ) = 4 . The cells w are illustrated as being spaced from each other and enclosed in an oblong shape which represents the net q . This is for illustrative purposes only , as it will be understood that the net q does not have any specific shape , 15 25 35 40 45 50 55 60 65 12 and merely specifies that individual pins ( not shown ) of the cells w are to be interconnected . This arrangement is referred to as a hyperedge . A distance p ( VV2 ) between two given vertices V and V2 is defined as the length of the shortest path between the Vertices , where the length of a path is the Sum of the lengths of the nets ( hyperedges ) that constitute the path . FIG . 4 illustrates Seven nets q to q , each of which interconnect a plurality of cells W . The distance between two given cells or vertices V and V is the length of the shortest path through the nets q to q , that interconnects the cells . The cell V is common to the nets q and q . However , there is no path from the cell V to the cell V through the net C1 . There is a path from the cell v to the cell V through the nets q2 , q and q , and another path through the nets q2 , q and qs . The lengths of the nets q2 , qa , q and qs are ( 3 - 1 ) = 2 , ( 4 - 1 ) = 3 , ( 2 - 1 ) = 1 , and ( 3 - 1 ) = 2 respectively . The length of the path through the nets q , q and q is ( 2 + 3 + 1 ) = 6 , and the length of the path through the nets q , q and q is ( 2 + 3 + 2 ) = 7 . The path through the nets q , q and q has the shorter length , more specifically 6 . If there is no other path ( not shown ) that is shorter , the distance between the cells V and V is defined as the length of this path . FIG . 4 also illustrates how to measure a distance p ( V , q ) between a cell V and a net q . This distance can be expressed mathematically as p ( v , q ) = min , p ( v , w ) , and is the shortest path between the vertex v and any pin W in the net q . Measurement of the distance between the cell v and the net q , will be taken by way of example . There is a path from the cell V to a cell V in the net q . 7 . The length of this path is the Sum of the lengths of the nets q and q , which has a value of ( 2 + 6 ) = 8 . However , the path from the cell v to the Vertex V2 through the nets q2 , q and q is the shorter path between the cell V and any cell w in the net qz , having a value of 6 as described above . If there is no other path ( not shown ) that is shorter , the distance between the vertex v and the net q is therefore defined to be 6 . In accordance with the present metric , a “range” range , ( q ) of a net q from a center cell V of a cluster or neighborhood ( to be described in detail below ) can be expressed math ematically as range ( q ) = p ( V , q ) + 1 ( q ) . In other words , the range is the distance from the center cell V to the net q plus the length of the net . The range of the net q , from the cell V , for example , is equal to the distance p ( V , q ) from the cell V to the net q7 , plus the length of the net q7 , or ( 6 + 2 ) = 8 . One further definition is necessary for understanding the present invention . A “border” is a list of all nets that have ranges equal to the index of the border . For example , a border having an index of 7 ( border ) is a list of all nets having ranges of 7 . This can be expressed mathematically as border , G ) = all nets q Such that p ( v , q ) s r and range , ( q ) = j , where j is the index of the border and r is a predetermined maximum distance from the center cell V ( to be described in detail below ) to the net q . The borders can be considered as a Series of concentric shells or quantum levels , with each border having an incre mentally higher indeX and including nets having an incre mentally higher range than the border with the next lower index . FIG . 5 is a flowchart illustrating the formation of a cell cluster or “neighborhood” N ( V . M ) in accordance with the present invention . The term “neighborhood” is illustrative of the fact that the clusters can be “fuzzy” , with one cell being included in two or more clusters , and two or more clusters being allowed to overlap . 6 , 030 , 110 13 Initially , a target number M of cells are designated to be included in a neighborhood . A number of cells between 15 and 30 tends to work best , with the optimal number being about 20 cells in each neighborhood . The algorithm outlined below is executed until C * M cells are collected within various neighborhoods . C is a predetermined parameter . The preferred value of C is 2 . The first Step is to Specify a particular cell V to constitute the center of the cluster N , and a value for M as indicated in a step 100 . The flowchart of FIG . 5 includes a plurality of nested loops indicated by broken lines . This notation indicates that all of the Steps included within each loop are to be performed for all outer loops . A step 102 which follows the first step 100 of inputting values of v and M is to determine which nets include the center cell V , and assigning all these nets to corresponding borders . The next step , designated as 104 , is to examine all borders , starting with border in increasing order of indeX . The next step 106 is to assign nets to borders in index order . A Step 108 includes assigning all cells which are not in the neighborhood from the nets in the current border to the neighborhood . A Step 110 includes assigning all nets which contain cells just included in the neighborhood , if these nets have not been previously assigned to any border , to corre sponding borders . The cluster or neighborhood N ( v , m ) is output in a step 112 . The method of FIG . 5 will be described further with reference being made to an example illustrated in FIG . 6 . This example includes a center cell V and nets q to qs . Step 102 includes assigning all nets that include the center cell V to borders . The nets q , q and q all include the center cell V . Since the distances from the center cell V to these nets is Zero , the ranges of these nets are equal to their lengths . The net q has a length of ( 3 - 1 ) = 2 , and is assigned to border . The nets q and q have lengths 3 and 4 , and are assigned to the borders border and border respectively . In steps 104 and 106 , the borders are examined in increasing order of indeX to determine if they include any nets . Border does not include any nets . Border includes the net q . Therefore , step 108 is performed , in which all cells W in the net q are assigned to the cluster or neighborhood N ( v , i ) . In step 110 , it is determined if there are any other nets connected to cells that were just assigned to the neighbor hood . In this case , there are not , and the processing returns to step 104 to examine the next border . The next border is borders which contains the net q . All of the cells w in the net q ( except V ) are assigned to the neighborhood . The method then performs step 110 to deter mine if any other nets q include any of the cells w ( just included in the neighborhood ) of the net q . In the illustrated example , the nets q and q include cells which are also included in the net q , and are thereby connected to the net q . If these nets have not been assigned to borders , then they are now assigned to the borders having indices equal to their ranges respectively . The ranges of both nets q and q are 5 , So these nets are assigned to borders . The steps 104 and 106 are then performed for the next border , more specifically border which includes the net q . In Step 108 , all cells of the net q are assigned to the cluster or neighborhood . Then , step 110 is performed to determine if any other nets q include cells which are also included in the net qs . In this case , the net q is connected to the net qs . The net q has a range of 5 , and is assigned to borders . 15 25 35 40 45 50 55 60 65 14 The next border is borders , which contains the nets q , qs and q . No other nets are connected to q and qs , but all of the cells of the nets q and qs are assigned to the cluster . All of the cells of the net q are also assigned to the cluster . The net q is connected to the net q - 7 , and q , is added to borders . Examination of the next border , borders , indicates it contains the net q . 7 . All cells of the net q are assigned to the cluster , if they were not assigned previously . Since the net qs is connected to the net q . 7 , the net qs may also be added to the cluster . The net q has a range of 11 , and may be assigned to border . In this manner , clusters or neighborhoods are grown one border at a time until a maximum size is reached . In addition , the borders are grown by “hitting” nets having corresponding ranges through net interconnections Starting at the center cell V . Section 3 : Optimization of Cell Neighborhood System In the foregoing process of constructing neighborhoods , a list of the nets processed is generated . That list of nets includes all nets incident to cells included in the neighbor hood . Once the neighborhood is established , coordinates are assigned to each individual cell . For each cell V , the neigh borhood of the cell is constructed and optimized using the cell as the center . A target number of cells C * M for the neighborhood is also defined . For purposes of relatively large VLSI chips , testing and operation has shown that about a twenty cell neighborhood yields effective convergence results . Larger or Smaller neighborhood sizes may also be employed while still within the scope of the invention . An alternative measure for the parameter M is the total height of all cells in the neighborhood , with height defined as the physical y - axis dimension of an individual cell . A maximum total cell height may alternately be used to define the neighborhood size . In accordance with the current invention , we assign coordinates to each cell and to each net in the neighborhood . We assign the center V of the neighborhood the coordinate 0 . 0 . We also assign the coordinates 1 . 0 to all cells not included in the neighborhood . Neighborhood cell assign ment Step assigns a cell V from the neighborhood coordinate values equal to p ( V , V ) / R , where p ( V , V ) equals the length of the shortest path between the vertices V and V , and R is the maximum radius Value for the neighborhood . AS Seen in FIG . 7 , v is necessarily not less than 0 and not greater than 1 . We term the assigned coordinates “Z ( v ) ” for each v . As shown in FIG . 8 , we then iterate recomputing of net and cell coordinates by iterating two procedures , as follow : Procedure 1 : The new net coordinates are computed Such that for any net q within the Set of nets Q , 1 Zq = file . zil weq where q is the number of pins of the net q . This equation Sums the total of the current coordinates of the cell v and sums this for all cells in an individual net , then divides by the total number of pins on the net . The result of the Summation and division is the coordinate of the net q . Procedure 2 : In new cell coordinate computation , for each cell V , the weight BV is represented by : 6 , 030 , 110 15 where for a net q , V is an element of q . The new cell coordinate Zv is equal to : 1 f3v : 21174 ) We apply the iteration procedure only on cells from the neighborhood except the center and only on nets that have at least one cell in the neighborhood . The iteration is generally accomplished for a pre - determined number of times , preferably 15 to 20 times . Section 4 : Iterative One Dimensional Preplacement Opti mization A one dimensional iterative optimization initially pro vides a fast , good cell coordinate placement . The one dimensional iterative optimization is performed in both the X and y directions . AS may be appreciated by one of ordinary skill in the art , the iterative optimization may be performed in the y direction initially , but the preferred method is to perform it in the X direction . In the X direction , a netlist or hypergraph H includes the set V of cells v and the set Q of nets q . In addition , it should be noted that where “X” or “X” is used below for calculation in the X - direction , when calculating in the y - direction , “y” or “Y” would be used . As used herein , “Z” and “Z” are universal notations representing either “x” and “X” , on the one hand , or “y” and “Y” on the other , depending on which direction is being considered . FIG . 9 illustrates a cell v 102 having several pins which belong to the net q104 . For purposes of pin offset definition for cell shifting and exact positioning purposes , the origin 106 of the cell defines the default “position” of the cell . If a net q104 is being evaluated by the system , then the pin 108 on the cell V 102 which is on the net q 104 is positionally defined relative to the origin 106 . Any point may be defined as the origin of the cell , including its center of mass , but the preferred embodiment is to define the origin at the physical lower left corner of the cell as shown in FIG . 9 . As shown in FIG . 10 , the core 201 is divided into Subregions R . Initially , the preferred value of R is one , indicating the core is not subdivided . The Subdivision of the core is represented by an array Xi of X - coordinates of vertical dividing lines 202 ( 1 ) through 202 ( n ) and an array Y of y - coordinates of horizontal dividing lines . For each interval Xi and Xi + 1 ) , a dividing point is calculated to determine finer resolution . Each cell V belongs to Some of these intervals , and the interval function IV is equal to i if the cell v belongs to the interval Xi , Xi + 1 ) . The current coordinates of the cell v are denoted as ZVI , while the coordinates of the net q are denoted by Zd . In initial placement optimization initialization Step 250 , each movable cell coordinate is assigned a coordinate of a dividing point of the interval the cell occupies . Thus Zvi = DXIV ) . DX is typically the midpoint of the interval , but the dividing point may be at a different location in each interval while still within the scope of the current invention . As shown in FIG . 11 , for each moveable cell within the core region 201 , the movable cell coordinate 203 is located at the dividing point 204 of the interval , which is a point at a percentage of the width or length of the core region 201 . The preferred implementation is locating the dividing point 204 at the center point of the Surface abstraction of the core region . Fixed cells are assigned their real coordinates . 15 25 35 40 45 50 55 60 65 16 The flowchart of FIG . 12 demonstrates the procedure for obtaining an initial one dimensional placement of the mov able cells . The movable cells are assigned the coordinate of the center of the region where they are located in initializa tion step 250 . In net coordinate computation step 251 , new net coordinates are computed . These new net coordinates are computed Such that for any net q within the Set of nets Q , 1 Zq = file . ( ( Zvi + ( v , o where q is the number of pins of the net q . This equation Sums the total of the current coordinates of the cell v and the Z - offset ( X or y depending on the direction ) of the pin on the cell which belongs to the net q , and Sums this for all cells in an individual net , then divides by the total number of pins on the net . The result of the Summation and division is the coordinate of the net q . In new cell coordinate computation Step 252 , for each cell V , the weight BV is represented by : where for a net q , V is an element of q . For each interval Xi , Xi + 1 and each cell v from that interval , the new cell coordinate ZVI is equal to : Z ( qi ) is calculated by determining a temporary value a , where a initially equals Zq . If a is greater than Xi + 1 ) , or is outside the interval , then a is Set to the greater border condition , or equal to Xi + 1 ) . If a is less than Xi , again outside the interval , then a is Set to the lesser border condition Xi . Finally , Z ( qi ) is set equal to a . This set of StepS places the coordinates of the nets along an imaginary line as shown in FIG . 13 , line 225 . Cells are placed along this line based on the results of the initial Z ( v ) calculation described above , and these positions are Subse quently iteratively moved to new positions in the region . The positions of cells within the region are shown in FIG . 14 , which includes positions where Some of the nets are initially outside the region . These out of bounds nets are then Set to the edge of the region . Once the new cell coordinates are computed , the differ ence between the previous value of the cost function and the new value of the cost function is determined in step 253 . The typical cost function used is wire length and the cost function is computed as the average of the half - perimeters of boundary boxes for all nets . The typical cost function used is wire length and the cost function is computed as the average of the half - perimeters of boundary boxes for all nets . This difference is evaluated in step 254 , and if the difference is not below a predetermined threshold , the cell positions are iterated by repeating net coordinate computa tion step 251 and new cell coordinate computation step 252 . This iteration procedure is repeated for a number of times , Such as one hundred times , or until the difference in cost function of two consecutive iterations is less than a prede termined threshold , such as 0 . 001 microns . A unit may be any measure , but the preferred distance threshold is 0 . 001 microns . The number of iterations and the threshold may vary while still within the scope of the invention . 6 , 030 , 110 17 Section 5 : Fast Procedure for Finding a Levelizing Cut Point The Surface abstraction , or core region 201 , denotes a region Rij . The previous one dimensional fast preplace ment procedure provides a given dividing point DXi , if the region is divided horizontally , or DY ) if the region is divided vertically . This dividing point may be anywhere along the line containing the cells from the previous procedure , but the preferred location is the midpoint of the line . The dividing point in the current example generates two subregions in the region Rij ) . As shown in FIG . 15 , the placement of nets along the line in the X direction is partitioned along a dividing line 300 providing two Subre gions containing the cell positions . The capacity of each of these regions is the area of the regions without all fixed cells or blockages . The capacities of the two regions are cap ( ) and cap1 . A cut point , Zo , is desired which divides the cells Such that a percentage of cells or cell heights is proportional to the Size of the region . For example , if a 50 % cut point is desired , the required location for the cut point is where the two regions , defined by the physical 50 % border dividing the Surface abstraction , would have equal numbers of cells or of cell heights . AS shown in FIG . 16 , a region physically divided in half by a dividing point 300 may not have a cut point and cut line 301 coexistent with the region dividing point . The Sum of all heights of all cells having coordinates lower than Zo , or of the total quantity of cells having coordinates lower than Zo must not be greater than cap0 cap ( ) + cap1 and the Sum of all heights of all cells having coordinates greater than Zo , or of the total quantity of cells having coordinates greater than Zo must not be greater than cap1 cap ( ) + cap1 It is preferable to use the total of all cell heights , but other parameters , Such as the number of cells , may be used while still within the scope of the invention . Initially , if all cells within a given region Rij are within an interval ( A , B ) , the ( A , B ) interval is subdivided into N equal Subintervals in subdivision step 325 as shown in FIG . 18 . Initialization step 326 initializes an array Sk having N elements , Stores the Sum of heights of all cells having Subintervals with indices less than or equal to k , and initializes all the elements of array Sk with the value Zero . For each cell V within the region Rij , index calculation step 327 computes an index n ( v ) of the Subinterval where the cell V coordinate is located : ( Z ( v ) - A ) As an example , assume ( A , B ) is an interval from 0 to 200 and 10 equal Subintervals are desired . In fact , a number in the range of 1000 such intervals would normally be desired , but 10 is used here for purposes of illustration . Further , assume that one cell is located in each of the ten Subintervals , as shown in FIG . 17 , although it would be probable that Subintervals would contain more than one cell . ASSigning A has a value of Zero , and B a value of 200 , n ( v ) for a cell in this arrangement is equal to the minimum integer 15 25 35 40 45 50 55 60 65 18 value greater than Z ( v ) / 10 for the cell . The designation “X” denotes take the minimum integer greater than X , Such that for X having a value of 1 . 3 , the value of x is 2 . This results in an integer value for a Subinterval within the ( A , B ) region where the individual cell is located . Height accumulation Step 328 accumulates the heights of the cells in each Subinterval within the array Sk according to the relationship : where h ( v ) is the height of cell v . Value of array elements step 329 calculates the values within Skby iterating fork equal to 2 , k being less than or equal to N , incrementing k , Cut point index locator step 330 locates the minimal index ko Such that cap ( ) - - : SINTs . Sk cap0 + capi " Ns Sko The levelizing cut point , where cell height is equivalent to the percentage of area within the Surface abstraction is equal tO Zo = A + ( ko - 0 . 5 ) : Clustering of cells within a Single region , or at a border of a region , may provide an inaccurate cut point . In Such a case , where the levelizing cut point requires a higher accuracy , the Subinterval where the levelizing cutpoint is located may be again divided into N Subintervals in Subdivision step 332 and the procedure repeated , locating a Second levelizing cutpoint . Once the levelizing cutpoint is located , all cells are shifted according to the following procedure . Section 6 : Median Control and Increase in Resolution For a given region Rij having a dividing point D , the levelizing cut point Zo divides the cloud of cells proportion ally to the capacities of the Subregions induced by the dividing point D . From FIG . 19 , offset calculation step 350 determines the offset of the cut line from the dividing line , where A is the difference between the coordinates of divid ing point D and the levelizing cut point Zo . Coordinates for each cell in the region are modified Such that for any cell V within the region Rij , the cloud of cells is shifted in shifting step 351 such that the cut point is collocated with the dividing point : For cells outside the region , those cells are placed at the border of the region . If a is greater than XIV + 1 then a is equal to XIV + 1 ) . If X is less than Xiv ) , then a is equal to XIV . Zvi is then set equal to this value a . In the preferred embodiment , the System initially places all cells at the center of the two - dimensional abstraction of the chip Surface . The System then performs a predetermined number of iterations of the One Dimensional Preplacement Optimization in one direction , Such as the X direction . The Surface abstraction is then Subdivided into Sub - regions by dividing the Surface abstraction in the opposite direction . The system then uses the Levelizing Cut Point procedure to partition the cells into groups proportional to the capacities of the Subregions . The Median Control procedure then 6 , 030 , 110 19 modifies the coordinates of the cells . The Levelizing Cut Point and Median Control procedures are iterated a specified number of times ( preferably 6 ) with the specified number of iterations comprising a Block . The average cost function is computed after a Block is performed . After each Block , an overall cost function , described below , is computed . After repeating this Block a predetermined number of times ( typically 10 ) , the System computes the average cost of each cost calculated during these Block iterations . The current average cost value is compared with the previous average cost value , and if the difference between the average value and the previous value is less than a predetermined value ( such as 10 ) , the procedure for the first level of hierarchy is complete . Cells are then assigned to the respective Sub regions depending on the calculated coordinates . If the average cost function has not decreased by a Specified amount , further Blocks of computations are required . At the end of this iterative procedure the cells are assigned to Subregions in Such a way that the capacities of the Subregions are not violated . After assignment of the cells to a respective Subregion , as is described in S1 above , the System may repeat the afore mentioned procedures based on a cut in the opposite direc tion . If , for example , the initial iterative one - dimensional preplacement optimization divides the available Space on the Surface abstraction by a vertical line , or divides in the X direction , the System executes the finding of a levelizing cut point procedure and the median control and resolution increase procedure in this direction . Upon completion of these procedures , the cells are assigned to one of the two regions , and the procedure may be repeated in the y - direction , based on the cells located in the two regions , after other optimization procedures discussed below are completed . As shown in FIG . 20 , the two regions are divided using two dividing lines in the y direction and cells are placed along these two lines . The System locates a levelizing cut point for each region and partitions out the cells to the four remaining cells . This division in the y direction creates a Second level of hierarchy . For purposes of this patent Specification , hierarchy levels are determined based on the number of divisions of the surface abstraction . The level of hierarchy is the sum of the number of times the Surface abstraction is divided into Separate regions . For example , if the Surface abstraction has been divided three times in the X direction and two times in the y direction , the system has reached the fifth level of hierarchy . The total number of regions is equal to 2 ' ' ' ' ' ' ' , with “Levelx” meaning the number of occa Sions that the Surface abstraction has been divided in the X direction and “Levely” means the number of occasions that the Surface abstraction has been divided in the y direction . Thus , in the previous example , 32 regions exist at the fifth level of hierarchy . Section 7 : Universal Affinity Driven Discrete Placement Optimization After each Surface abstraction division , the System per forms a discrete placement optimization . For purposes of illustrating this procedure , it is assumed that the previous routines have furnished two sets of cells partitioned into two regions on the Surface abstraction . All cells are located in the centers of each region . The System calculates affinities and cost functions for the arrangement . An affinity is calculated based on current cell placement and blockages in a chip . Affinities are heuristi cally connected with a desired cost function , which should be . minimized . Affinities can be driven by cell density , wire length , minimizing maximal cut , clustering , etc . , or Some 15 25 35 40 45 50 55 60 65 20 combination of these parameters depending on the goal Sought to be achieved . Affinities may be positive or negative , and relate to the quality of an alternate placement of a cell . For example , having a cell with a higher affinity at a first location and a lower affinity at a Second location indicates that the preferred placement of the cell is the first location . The parameter of the discrete placement optimization is e , which represents the accuracy of the placement , and is a small number , such as 10 or 10 ' . From FIG . 21 , adjacent cell location step 400 initially considers moving a cell from its current position to each of the adjacent regions , as well as considering leaving the cell in the current region . For higher levels of hierarchy ( i . e . , a Substantial number of regions ) , nine total regions are evaluated for cells not located on an edge of the Surface abstraction . Affinity calculation Step 401 calculates , for each adjacent region , the maximum affinity of the cell is moved to these adjacent regions . The total number of cells having an affinity greater than a predetermined value p is denoted N . For the initial place ment received from the preceding procedural Steps , the affinities for the cells are calculated and ordered according to these affinities . Global threshold evaluation step 402 finds a threshold number , Globthresh , Such that the total number of cells , Notes , having an affinity greater than the threshold number , is less than e multiplied by the number of all cells having positive affinities , or No . Practice has shown that optimal results occur fore having a value of from 30 to 40 per cent . The overall global threshold is determined using a similar procedure to that described above with reference to the procedure for finding the levelizing cut point . The affinities are ordered sequentially , and all cells are defined to be within an interval ( A , B ) , exclusive of negative affinities . With reference to FIG . 22 , the ( A , B ) interval is subdivided into k equal Subintervals in Subdivision step 450 . Initializa tion step 451 defines an affinity array Ai having i elements . The initial value of all elements of this array is 0 . Aistores the number of cells whose affinities are greater than or equal to ( k - i ) * L , where L is the length of the subinterval within ( A , B ) . For each cell V , calculation step 452 computes an index i ( v ) of the Subinterval where the cell V affinity is located : MaxAff ( v ) is the maximum affinity over all adjacent regions for the cell V . This calculation yields an integer value denoting a Subinterval within the ( A , B ) region where the individual cell affinity is located . Now for each cell v we increase the appropriate element of the array by 1 . Such that A ( i ( v ) ) = A ( i ( v ) ) + 1 . Cell affinity Summation array step 453 calculates the value of Ai by iterating for i equal to 2 , i being less than or equal to k , incrementing i , Global affinity evaluation step 454 determines the global affinity threshold GlobThresh using the previous equation such that GlobThresh is equal to i where i is the minimum i Such that Noe is less than or equal to Ai ) . After calculating GlobThresh , the system evaluates the list of all cells in a predetermined Sequential order . Affinity comparison step 455 calculates the maximal affinity for the present region and for each adjacent region . If the affinity for an adjacent region is greater than the global threshold GlobThresh , the cell is placed in the new region in cell repositioning Step 456 . The original cell position data Struc 6 , 030 , 110 21 ture is updated in data structure update step 457 . Then steps 455 , 456 and 457 are iterated as a block 458 , generally 3 times . The result of this procedure is a global threshold for all cells . Some cells have been moved to adjacent regions , altering affinities of other cells . The procedure is then repeated two more times , for a total of three iterations , through the list of all movable cells using the same thresh old . AS an additional and optional procedure , a local threshold can be calculated in addition to the global threshold . The local threshold is calculated in the same fashion as the global threshold , but with respect to only the cells from the region where the cell is located . If we use this additional , optional procedure , we move the cell only if the maximal affinity is greater than both the global threshold and the local thresh hold . An average cost function , representing the average of the three values of the cost function calculated after each iteration , is computed . Now we compute a new threshold as described above in step 454 . This entire procedure , from threshold computation through cost function computation ( block 459 ) , is repeated a predetermined number of times ( usually 10 times ) . Each time block 459 is repeated the predetermined number of times , the average value of the average cost function is calculated and compared with the previous average value of the average cost function value . If AvgCost < ( 1 + 8 ) ; AvgCost , then the optimization proceSS is halted . 6 is a Small number , typically 10 or 10 ' . Section 8 : Density Driven Capacity Penalty System The Surface abstraction is partitioned alternately in the Vertical and horizontal directions , where each division denotes an additional level of hierarchy . The levels of hierarchy , Lev , and Lev , determine the number of hierarchy levels . The number of grids , or channels of regions , in each direction are given as Grid , equal to 2 ' , and Grid , equal to 2 ' ' . Each region on each level of hierarchy is deter mined by ( Lev . Lev , i , j ) where i and j are the indices of corresponding Surface abstraction Segments . The capacity of each region is a function of these four parameters . The System then calculates the Sum of the heights in each region . The System then calculates a region capacity in terms of the heights of cells which can be located within a single region . This capacity of cell heights accounts for rows or columns of locations where cells may be located . AS shown in FIG . 23 , the cell region will have a certain number of columns , or possibly rows , located therein . The cell height capacity represents the Space available to individual cells within the region and is based on the hierarchy of the Surface abstraction . As outlined below , the highest level of hierarchy defines a single column per region . AS may be appreciated by one of ordinary skill in the art , rows may be used rather than columns to define a total cell width capacity rather than a height capacity . All cells are located at the center of a region during Some phases of the placement procedure . The height of a single cell may extend into more than one region . A parameter Colkey is assigned to this placement System process . The center of each cell is assigned to the center of the region it occupies . If ColKey has a value of 0 , the entire height of the cell is located within a Single region . If Colkey is equal to 1 , the height of the cell is distributed to the regions the cell overlaps . For example , if a cell has a height of 16 units while the region has a height of ten units , three units are assigned to the cell above and three to the cell below the current cell . 15 25 35 40 45 50 55 60 65 22 Cells located in an edge region are assigned to the region away from the edge , and not to any region outside the edge . Hence in the example previously presented , ten units of the cell would be assigned to the edge region and three to the region above the edge region . Movement of the cells from one region to another requires updating the total of the heights in each region . Each cell v is located within regions with indices IV and JV ) , in the X and y directions , respectively . Movement of a cell to an adjacent region is denoted by A , and A , where A , is a movement in the horizontal direction , with a rightward movement being + 1 , and A , representing vertical movement , upward yielding a + 1 value . A , and A , each are set at either - 1 , 0 or + 1 . From FIG . 24 , penalty calculation step 501 computes a penalty , PenCapB ( v , C . A . A . ) , equal to the fol lowing values : Cap Ivy for A , and A , both equal to Zero ; and Sumheight ( II ) + All Ivi All to shev ) . otherwise ( i . e . , either or both A , and A , have a value other than 0 ( - 1 or + 1 ) ) . C . represents the degree of counting , which affects the movability of a cell V to a new region . C . will typically have a value between 0 . 1 and 1 . Prior level calculation step 502 computes the penalty for the regions three levels before the current level . For example , if the current hierarchy divides the Surface abstraction into 64 by 64 total regions , then three levels before has 8 by 8 regions . A total of 64 eight by eight regions will fit into a 64 by 64 area . The total penalty , PenCap8 ( V . A . A ) , is calculated in the same manner as the PenCapB calculation in total penalty computation step 503 . The total capacity penalty is calculated in Step 504 according to the following formula : Pen Cap ( v , Ai , A ) = A 3 : Pen CapB ( v , Q , Ai , A ) + Sw 3 : Ad Pen Cap & ( v , Ai , A + ColKey 3 . At 3 : Pen CapCol ( v , f3 , Ai , Ai ) where 2 is the capacity penalty weight in the total affinity , and SW is a Switch parameter Set to 0 or 1 depending on whether use of the PenCap8 variable is desired . PenCap8 is used only when the area is divided into 16 by 16 regions or more . 2 and 2 are the relative Weights of corresponding penalties . The use of these various penalties allow the user to drive the placement based on predetermined desired characteristics . If capacity in individual columns is to be penalized more than other capacity weights , then the value of 2 is greater than the other factors , i . e . 2 and ) , where all 2 factors are between Zero and one . While design and performance are generally a matter of choice , experi ence has demonstrated that may initially be set to the following value : Corex = n : - - 0 Gidy Gity where ranges between 0 . 5 and 1 . 5 , and Corex is the X dimension of the core . The values initially Selected for 2 . and 2 are 16 and 16 . 6 , 030 , 110 23 Section 9 : Wire Length Driven Affinity System An alternate embodiment of the current design is to calculate affinities and penalties according to the relative wire lengths of different designs . This procedure provides a Set of affinities providing the minimal wire length over all feasible placement Solutions . For each cell V and net q , the minimum and maximum values for the X component penalties are as follows : where X ( w ) is the current coordinate of the cell origin , X ( V , q ) is a pin offset from the origin where the pin belongs to the net q . The y component penalties are similar : These equations define a bounding box 550 containing the net q 551 , as shown for a three pin net in FIG . 25 . The borders of the region where the cell v is located are denoted by : The penalty vector for cell V and net q in the X - direction is : ( PenHP ( x ; q , - 1 ) , PenHP ( ; 4 , 1 ) ) These values correspond respectively to movement of the cell to the left , nonmovement of the cell in the horizontal direction , and movement of the cell to the right . The penalty vector for cell V and net q in the y - direction S . These values correspond respectively to movement of the cell upward , nonmovement of the cell in the vertical direction , and movement of the cell downward . The penalty vector for the individual situation is as follows . If X is less than X , then the vector representa tion for the penalty in the X direction is ( - 1 , 0 , 1 ) , indicating Zero penalty for keeping the cell in its current location , a penalty of one for moving the cell to the right , and a penalty of - 1 for moving the cell to the left . This indicates that a cell in the net is outside the left boundary of the region , and movement of the entire net to the right would be a penalty for the wire length . Movement of the cell to the left would be a negative penalty , or benefit , to the wire length . For X , greater than X , the penalty vector is ( 10 , - 1 ) . For X , less than X , and X , less than or equal to X , the penalty vector is ( 0 . 01 ) . For X , less than X , and X greater than X , the penalty vector is ( 0 , 0 , 0 ) . For X greater than or equal to X , and X , less than or equal to X , the penalty vector is ( 1 , 0 , 1 ) . For X , greater than or equal to X , and X , greater than X , the penalty vector is ( 1 , 0 , 0 ) . Similar vectors result for positions of the cells in the y direction . The total penalty for a cell v in the X direction is a normalized sum of the penalties in the X direction over all nets incident to cell V : 1O 15 25 35 40 45 50 55 60 65 24 PenHPy ( v . , A ) - ( X11 - XIO ) * X . PenHPy ( v , q , A ) gev In the Y direction , PenHPy ( v , A ) - ( YJ1 ) - YJO ) ) * X . PenHP ( v , q , A ) gew The total penalty is the Sum of the X and y components : PenHP ( ; AA ) = - PenHP ( ; A ) + PenHP , ( v . A . ) The affinity is the opposite of the penalty : AffhP ( ; AA ) = - PenHP ( ; A . A . ) and a first combined affinity is calculated based on both capacity and wire length : QEF ( v ) represents a Scaling factor having the following parameters : Height ( v ) log - . . . . . . . . . + A Avg Height of All Cells where Height ( v ) represents the height of the cell v . Although any values may be used for A and B in this equation , experience and testing has shown that the values of 5 and 5 produce the most beneficial results . Section 10 : Minimizing Maximal Cut Driven Affinity System Another parameter used to produce an affinity for improv ing cell placement is minimizing the maximal number of nets that interSect the unit Segment of the grid System imposed of the surface abstraction of the chip . Net overlap inherently yields inefficiency of wiring , and thus minimizing the number of nets which cross other nets improves overall System efficiency . For each level of chip core partitioning hierarchy , the number and position of the vertical and horizontal lines which induced the level of partitioning hierarchy are evaluated , including determining the number of nets which intersect a line partitioning the cell into regions . Initially . the System determines the number of nets which intersect the lines and the relative affinities for these line crossings . The System moves the cells and the nets change position based on relative affinities , and then the number of net crossings and affinities are recomputed . As shown in FIG . 26 , each dividing line partitions regions , and each of these regions has a capacity denoting the volume of cells which can fit within the region . The System performs the following procedure once after each bisection . The System calculates the capacities as an average capacity of regions adjacent to the dividing line . In FIG . 26 , the capacity of dividing line X ( i ) is defined as the average capacity of all regions to the left of the line and all regions to the right of the line . The System calculates average Vertical line capacity and average horizontal line capacity for all lines , representing the amount of wiring which is available over the entire Surface abstraction . The capacity may also represent available Space for wiring available on multiple layers of the chip . The capacity of each horizontal and vertical line is then divided by the corresponding 6 , 030 , 110 25 horizontal or vertical average values . Hence , if the capacity of the line represented by X ( i ) in FIG . 26 has a capacity of 1500 cells and the average capacity of all vertical lines on the Surface abstraction is 1000 cells , the relative cut of the line is 1 . 5 . The ratio of the number of nets crossing a line and the capacity of the line are defined as the relative cut . Before each optimization step in the affinity driven dis crete placement optimization procedure , and particularly before calculation of global and / or local thresholds , the System calculates a midcut for the Surface abstraction . The midcut represents the average relative cut over all lines of the Surface abstraction . FIG . 27 represents a region having indices ( TX , TY ) . The number of cuts represents , with the current cell configuration , the number of times a net crosses a boundary , while the capacity of the line represents the total number of possible crossings of the particular boundary . The System calculates four penalties which represent the cost of a change for a halfperimeter move of cells within the region one unit to the right , left , up , and down : CutXTX DXL = ( XI 1 - XIO ) : ( - B + 3 ( ET / ( MidCap ) CutXTX + 1 DXR = ( XII 1 - XIO ) : ( - B + 3 - ( ET / ( MidCap ) Cut YTY DYB = ( YJ1 - YJO ) : ( 1 - B + 3 ( ET / ( MidCap ) Cut YTY + 1 DYT = ( YJ1 - YJO ) : ( 1 - 6 + 6 ( EEE f ( MidCut ) These equations , as illustrated in FIG . 27 , represent the number of cuts over region dividing lines TX , TX - 1 , TY , and TY + 1 relative to the capacity of the dividing lines . The XI and YJ factors represent the size of one region . The factor B represents the relative penalty associated with cuts , and testing has shown that a reasonable range for B factorS is 0 . 4 to 0 . 5 . As shown in FIG . 27 , for a region twenty units in length on the X and y Sides , with ten cuts along each dimension and a capacity for one hundred cuts , with an average number of cuts equal to twenty cuts , and a B factor of 0 . 45 , the values for DXL and DYB are 11 . 045 each . For 40 cuts on the right hand Side and upper Side of the regions , the values are 11 . 18 . Discrete affinities in the X and y direction represent the numbers of nets whose halfperimeter decreases on move ment of cells across the boundary minus the number of nets whose halfperimeter increases when a cell moves in a given direction . AftXi , i = - 1 , 0 , 1 ; Affi , i = - 1 , 0 , 1 Affinity for Zero movement represents the numbers cal culated above . Movement of a cell in a particular direction , Such as crossing a boundary line , induces an affinity for that cell . From FIG . 27 , movement of the cell to the right and up decreases the penalty , or increases the affinity for the cell . Thus affinity in the X direction , AffX , for movement to the right is - 1 , to the left is 1 , and affinity for movement in the y direction , AffY for movement of the cell upward is - 1 , and downward is 1 . Affinity for keeping the cell in its current position is 0 . The discrete affinities for movement in each of the four directions are multiplied by the corresponding factor : Affcutx1 - 1 = AftX1 - 1 * DXL AffcutY1 - 1 = Aff Y1 - 1 DYB 15 25 35 40 45 50 55 60 65 26 Total affinities for movement of the cell in the vertical and horizontal directions are the Summation of affinities in the X and Y directions : Affcutiji = Affcut Xi + Affcuti An alternative embodiment of this procedure is to use the Square of the number of crossings as a component of the cost of change for the halfperimeter move . For movement to the left , this would yield an equation of : CutXTX DXL = ( XII 1 - XIO ) : ( - i ( CIA ( MidCap ) Squaring the factors increases the emphasis on the number of cuts , and balancing with new B ' factors yields an arrange ment wherein the total number of cuts converge rapidly to a relatively uniform quantity . Section 11 : Neighborhood System Driven Optimization Each moveable cell v is located within a neighborhood Neigh ( v ) constructed in accordance with the optimization of cell neighborhood System procedure outlined above . That procedure yields an ordering of cells according to the cells distance from the center of the neighborhood , after optimi zation . FIG . 28 illustrates such an ordering of cells within the neighborhood , Neigh ( v ) = ( w ( v , 1 ) , w ( v . 2 ) , . . . w ( V . M ) ) , where M is the size of the neighborhood , generally in the range of 20 cells . From FIG . 29 , weight assignment step 601 assigns each cell a weight equal to the Size of the neighborhood M minus the index of the celli . Thus , for a neighborhood of size 20 , the 20th cell has a weight of 0 , while the first cell has a weight of 19 . An alternate preferred method of assigning weights is to declare a number L , where L equals M plus Some positive integer , Such as 2 , and weights range from 21 down to 2 . The reason for this shift is that the weight accorded to a factor of 1 is infinitely greater in terms of multiplications than a factor of Zero . Thus relative weights may be misleading if low number factors , Such as Zero and one , are used as weighting factors . Any monotonically decreasing function may be employed in defining the weights accorded the cells within the neighborhood . The System then calculates attraction weights in Step 602 . The total Sum of the weights attracting the neighborhood to the region are defined as follows : These equations represent the weights of the neighbor hood attraction in a direction . For example , assume a neighborhood ( v , V . , . . . v . ) , as shown in FIG . 30 . The weights assigned to the individual cells in the neighborhoods represent the relative heights of the cells , but can be any measure of load accorded to the individual cell . The relative weights of the cells is ( 7 , 6 , 5 , 4 , 3 ) . From the previous equations , the Sum of weights to the left of the current region minimum line in the X direction , x , ( v ) , is 7 plus 6 plus 4 , or 6 , 030 , 110 27 17 . The sum of weights to the right of the current region maximum line , X ( V ) , is 5 . The Sum of weights within the region bounded by the x , ( v ) and X ( V ) lines is 3 . In affinity definition step 603 , the system then defines the following neighborhood affinities for movement of cells in each particular direction : AfNeighborhood ( ; 0 ) = 0 2 : Gridy 1 AfNeighborhood ( v . - 1 ) = - - : - fiNeighborhood ( , – 1 ) = a or ( Sum Weight , ( v ) - Sum Weight , ( v ) - Sum Weight , ( v ) ) 2 : Gridy 1 : - : AfNeighborhoody ( v . 1 ) = Grid + Grid , M2 ( Sum Weight , ( v ) - Sum Weight , ( v ) - Sum Weight , ( v ) ) These values represent the relative overall benefit of moving the location of the neighborhood in a particular direction or leaving the neighborhood in its current position . Grid and Grid are identical to the values outlined above in reference to the density driven capacity penalty System , and represent the number of grids , or lines of regions , in the X and Y directions . Grid is equal to 2 ' and Grid is equal to 2 , where Lev and Lev , define the number of hierar chy levels . The number M represents the number of cells in the neighborhood . Resuming with the example of FIG . 30 , M is equal to five and we are in the fourth level of hierarchy . Thus , AffNeighborhood ( v . 0 ) equals 0 , and AffNeighborhood ( v , - 1 ) equals ( 2 * 2 / ( 2 + 2 ) ) * 1 / 5° * ( 17 - 5 - 3 ) , or 9 / 25 . AfNeighborhood ( v , 1 ) equals ( 2 * 2 / ( 2 + 2 ) ) * 1 / 5 * ( 3 - 5 - 17 ) , or - 19 / 25 . Hence the X affinities for this example are ( 9 / 25 , 0 , - 19 / 25 ) for leftward , center , and rightward movement , respectively . The Yaffinities for this example are ( - 17 / 25 , 0 , and - 15 / 25 ) . Selecting the highest affinities yields the result that the neighborhood should be moved to the left and remain in its current vertical position . Affinities for the X and Y directions are therefore combined in step 604 to yield a total neighborhood affinity for movement of the current neighborhood to another region within the nine regions adjacent a non - edge region . Affinities may be combined while still within the scope of the current invention . Combinations of capacity affinities , wire length affinities , cut affinities , and neighborhood affini ties present an enhanced System of determining the preferred direction of movement of a cell or net . Such an affinity combination may include combining the following affinities : Af ( v , A . A . ) = AffNeighborhood ( ; A . A . ) + QEF ( v ) AfCap ( v , A . A . ) AS outlined above , QEF ( v ) represents the capacity penalty influence factor , which is a function of cell V relative height . Such a combination of affinities takes into account cell position as well as relative weight accorded to an individual neighborhood . Section 12 : Functional Sieve Optimization Technique The combination of affinities introduces an element of randomization . A deterministic System for combining affini ties which converges at a relatively rapid rate is desired to optimally utilize affinities . Such a system which iteratively optimizes cell placement using a combination of affinities is the functional Sieve approach . The functional Sieve performs Several calculated itera tions of combining affinities and moving cells based on relative affinities and then computing cost functions for the new cell positions . The functional sieve utilizes the follow ing basic formula : 1O 15 25 35 40 45 50 55 60 65 28 Af ( v , A . A . ) = ul AffNeighborhood ( ; A . A . ) + iu . AffhP ( ; A . A . ) + QEF ( v ) . AfCap ( y , A . A . ) As illustrated in FIG . 31 , the system in step 651 iterates a predetermined number of times , preferably once , calcu lating the above affinities with u equal to one and us equal to Zero . This iterative procedure produces affinities and cells which are then repositioned based on the combined neigh borhood and capacity affinities . Subsequently , the System in step 652 performs a predetermined number of optimization iterations with it equal to Zero and u2 equal to one , moving the cells based on cut and capacity affinities . The first iterative procedure involving neighborhood and capacity affinities combined with the second iterative procedure entailing cut and capacity affinities define a major iteration . After this major iteration , the system in step 653 calculates the value of the cost function . The preferred cost function is wire length . After computing the cost function , the System performs a predetermined number of majoriterations and calculates the cost function after each major iteration . The preferred num ber of major iterations and cost function calculations is six . After this predetermined number of majoriterations and cost function value calculations , the System computes the aver age cost value for all of the costs calculated in the previous Steps . This procedure Steps through different affinity evalu ations and obtains a preferred overall movement of cells on the Surface abstraction . The functional Sieve optimization process is halted when two consecutive cost average func tion values satisfy a given accuracy , Such as 10 or 10 ' . During the discrete placement procedure described above , the u parameter is utilized in a larger number of iterations than the u parameter . Subsequently , the System performs several iterations with u equal to Zero . The entire block is iterated a predetermined number of times in this discrete placement procedure , typically three to five times . During final placement , a crystallization procedure pro duces fine placement of the cells after the aforementioned functional Sieve procedure is completed . The System uses a Small nonzero value , Such as 10° , for u , a predetermined number of times , Such as once , in the majoriteration and the Zero value Several times . This procedure produces a detailed placement of cells . An alternate embodiment of the current functional Sieve alters the multiplying factors for the various affinities . Such an embodiment is particularly useful in crowded net Situations , and emphasizes croSS cuts while taking advantage of open nets . The basic equation for the alternative embodiment is : Aff ( v , A . , A ) = u 1 : AffWeighborhood ( v , A . , A ) + u2 : ( 1 - f3 ) : AffHP ( v , A . , A ) + f3 : AffCut ( v , A . , A ) + QEF ( v ) : AffCap ( y , Ai , Ai ) where B is a number between Zero and one , depending on the emphasis desired placed on the number of cuts . The affinity combinations disclosed within this functional Sieve operation are not limited to those disclosed here , and may include other combinations using other weighting fac tors . Such an alternate weighting and affinity Scheme would produce a desirable placement of cells and still within the Scope of the present invention . Section 13 : Coarse Overflow Remover ( Bulldozer ) A coarse overflow remover procedure is applied on the highest level of the chip core region hierarchy when each region contains a piece of only one column . The list of cells 6 , 030 , 110 29 is Scanned in the order of decreasing heights in order to find a new region for each of them . A list of cells in order of decreasing cell height is made . If the height of a cell is Smaller than the available Space in the corresponding col umn Segment , then the cell retains its location . Most of the cells will keep their previous positions if the initial cell density is acceptable . FIG . 33 represents a portion of the chip that has seven columns 800 - 806 . As shown in FIG . 33 , the cell columns 800 - 806 are partitioned into maximal segments without blockages . A plurality of megacells 810 may be located in the upper left corner . The megacells 810 are shown to extend across the columns 800 - 802 . A first blockage 830 extends across the second and third columns 801 and 802 , and a second blockage 832 extends across the column 806 . Col umn 800 has two adjacent regions 812 and 814 that are assigned to a single column Segment 815 . Each of the column Segments actually consists of a few regions , and each region belongs to exactly one of the Segments . For each Segment the total height of all cells assigned to the Segment is retained . For example , The column 806 segment includes a region 816 that has a cell height of twenty - two and an adjacent region 818 that has a cell height of six . Therefore , the column segment 806 includes a column segment 820 that has a cell height of twenty - eight . This proceSS is applied only to cells that have been already Scanned , i . e . in the beginning of the process all those Sums are equal to 0 . The capacity of a column Segment is its height . The next cell from the list will get a new position according to the following rule : look for the closest ( using Manhattan distance ) region to the current cell So that the corresponding column Segment will not have an overflow capacity if the next cell is assigned to that region . A preferred order for scanning the regions is shown in FIG . 34 . First consider the original region ( marked with the numeral 0 ) and then consider the regions having a distance of 1 , then consider the regions having a distance of 2 , etc . This Step considers only cells that already were assigned new positions and the current one . Usually , a cell is going to Stay on the old position . AS Soon as the region is found that Satisfies this condition , the region Scanning is stopped , and assign the cell to that region . If the original region Satisfies the condition , the cell is reassigned to the original region . Section 14 : Overlap Remover With Minimal Noise The purpose of this process is to Smoothly remove cell overlap with minimal increase of the wire length . FIG . 36 is a flow chart of an overlap remover according to the inven tion . The overlap remover proceSS is applied Separately to each column of cells . It is assumed that each column is continuously connected with no blockages between cells of the same column . As shown in FIG . 35 , denote the top and bottom of the column with index j by TL and B , respec tively . Similarly the top and bottom of column k are denoted by Tk and Bk , respectively . The vertical grid step is used as the unit of measure . First the cells in a column are sorted in the order of increasing cell bottom y coordinates . Denote cells in that order by V1 V2 . . . . The bottom coordinates of these cells are Ys Ys . . . sy , As shown in FIG . 35 , the parameter Zaz is defined as the distance between the top of one cell in a column and the bottom of the next cell upward . There must be at least one grid Space between adjacent cells to have a feasible layout . 1O 15 25 35 40 45 50 55 60 65 30 FIG . 37 illustrates a numerical example . Suppose a col umn 850 has a height H = 60 and that the column 850 consists of five regions 852 - 856 that contain cells with heights of 5 , 7 , 3 , 9 and 6 , respectively . The total cell height S Hcell = X . height ( vi ) . we coilinn Hit = 5 + 7 + 3 + 9 + 6 = 30 The average extra Space per cell is now calculated as Hot - Het 60 - 30 total no . of cells + 1 5 + 1 The parameter minZaz Satisfies the condition Ho ! - Hell 3 - - iii . 3a . # cells + 1 Therefore , for the example given a possible value for minZaZ is 3 . The following array is calculated : where Norms V , is the cell height in grids . The parameter of the overlap remover process is integer values of minZaZ , which can be positive or negative . The process further includes the Step of modifying the array ZaZ Such that all its elements are not less than minZaz . The array elements are processed forward and backward alternately . The following procedure is executed : ( a ) At the beginning of the process the counter is initial ized to Zero . If the processing element is less than minZaz , then the element is increased by 1 and the counter is decreased by 1 and the next element is processed . ( b ) If the element is greater than minzaz and also positive , but the counter is negative , then the counter is increased by 1 and the element is decreased by 1 . The steps ( a ) and ( b ) are repeated until the condition is Satisfied . Then we proceed with the next element . ( c ) If all elements became not less than minzaz Zaz ( i ) 2 minzaz ) and the counter has Zero value , the process is Stopped . The cells are moved in one grid interval increments until the condition is Satisfied . FIG . 36 is a flowchart of a preferred process adjusting cell spacing in the column to remove overlap with minimal noise . The process of adjusting cell Spacing begins with a step 900 where all movable cells from i = 1 to i = n are to be considered . For each cell i , the spacing ZaZ ( i ) between the top of celli and the bottom of cell i + 1 is compared to minZaZ in a process step 902 . If Zaz ( i ) is less than minzaz , then Zaz ( i ) is replaced with Zaz ( i ) plus one grid step ( Zaz ( i ) 4 = ZaZ ( i ) + 1 ) in a process step 904 . A counter is then decremented by one in a process step 906 . The foregoing steps 900 , 902 , 904 and 906 are repeated until Zaz ( i ) is not less than minzaz . If Zaz ( i ) is not less than minzaz , then a process step 908 compares Zaz ( i ) a parameter maxZaz , where maxZaz is the largest value of Zaz ( i ) that will be permitted on the chip . If Zaz ( i ) is less than maxZaz and the count is greater than 0 , then Zaz ( i ) is replaced by ZaZ ( i ) plus one grid step ( Zaz ( i ) 4 = Zaz ( i ) + 1 ) in a process step 910 . The counter is then decremented by one in a process Step 912 , and the foregoing steps 902 , 908 , 910 and 912 are repeated until the count becomes Zero . 6 , 030 , 110 31 The remaining situation to be considered is when Zaz ( i ) is not less than minzaz and the condition count > 0 and Zaz ( i ) < maXZaz is not satisfied . In a process Step 914 Zaz ( i ) is compared to maxZaz . If ZaZ ( i ) is greater than maxZaz , then Zaz ( i ) is replaced by maxzaz in a step 916 . The count then is incremented by the quantity ZaZ ( i ) - maXZaz in a step 918 . The steps 902 , 908 , 914 , 916 and 918 are repeated for the Selected cell until the condition Zaz ( i ) > maXZaz of Step 914 is not satisfied . The process of adjusting cell Spacing then proceeds to a step 920 where a parameter A is defined such that A Zaz ( i ) - minzaz . Then in a step 924 the parameter A is compared to the negative of the count to determine whether As - count . If A is not less than or equal to - count , then the parameter A is Set equal to - count in a Step 926 ; and the process proceeds to a step 928 . If in the step 924 , the parameter A is less than or equal to - count , then the proceSS proceeds to the step 928 where Zaz ( i ) is replaced with Zaz ( i ) - A . The count is then incremented by parameter A in a Step 930 , and the process of adjusting cell spacing is completed . The result of adjusting the cell spacing in accordance with this preferred process is that overlap between cells is removed and spacing that were too large have been reduced to acceptable values . Cells that previously overlapped now have a spacing Zaz ( i ) of one grid space . Cells that were too far apart now have spacings ZaZ ( i ) Such that minzazs Zaz ( i ) smaXZaZ . After finishing the procedure the cell coordinates are modified : Y = BI + Zaz , IO ; Y = Y - Norm HVH - Zazi - 1 , For i = 2 , 3 , . . . , n . Section 15 : Sinusoidal Optimization This procedure significantly levelizes the cell density with almost no increase in wire length . The Colkey parameter has been discussed above in the Section that describes the density - driven capacity penalty System . For the Sinusoidal optimization procedure the Colkey parameter should be Set to 1 . Setting the Colkey parameter to 1 means that the height of a cell is distributed over all regions with which the cell overlapS . Precisely , if the cell has been assigned to the highest level hierarchy region with an index j , it is assumed that the cell center is in the center of the region . Depending on the real height of the cell , the occupancy is updated for all regions the cell with which the cell overlaps . The region occupancy is updated after every cell move . Because the number of cells higher than the Smallest region height is relatively Small , updating the region occupancy is not going to affect the complexity of the optimization . In addition to the basic region capacity penalty , which is calculated taking into account real cell dimensions as described above , the Segment column capacity penalty is also used now . It is necessary to consider the capacity penalty to achieve more uniform distribution of big cells on the chip . The main block of the Sinusoidal optimization procedure comprises a number of big iterations of the discrete place ment optimization described previously herein with refer ence to FIGS . 21 and 22 . Denote that main block by Optim ( k ) , where k is the number of iterations . The main parameter is the capacity penalty influence parameter 2 , which has been described previously with reference to FIGS . 23 and 24 . The value of the capacity penalty influence parameter ) . will be changed during the Sinusoidal optimization process . 15 25 35 40 45 50 55 60 65 32 Steps that preferably are included in the Sinusoidal opti mization procedure are as follows : Optim ( m ) ; = . . . i Optim ( 2 m ) ; = . . . i Optim ( m ) A = Optim ( 2 m ) ; A = where m and l are predetermined integer parameters . Typi cally m is one of the numbers 6 to 10 , and 2 is 2 . This Sinusoidal optimization procedure typically is iterated in combination with the other levelizing procedures described herein , Specifically , the dispersion - driven leveling System described in S16 . There are two types of Sinusoidal optimization . One type is unconstrained and contains Standard discrete placement optimization . The other type of Sinusoidal optimization controls cell column densities inside the discrete placement optimization . Section 16 : Dispersion - Driven Levelizing System This procedure does Smooth continuous cell density lev elization on the chip and is illustrated by FIG . 32 . First , a new coordinate System is introduced on the chip by impos ing a mesh on the chip and assigning integer coordinates to the nodes of the mesh . The nodes of the mesh are classified as to whether they are movable or fixed . Nodes of a square that overlaps with a blockage or a megacell are fixed . All other nodes are movable . The densities of the Square regions are calculated as a Sum of portions of the height of the cells that overlap the region . After coordinates are assigned to the nodes of the Square mesh , the node coordinates are transformed Such that the Squares defined by the mesh are deformed into arbitrary equilaterals . A constraint on the deformation of the mesh is that regions that overlap with megacells are not deformed . The coordinates of the movable nodes are iteratively recalculated to minimize the Special cost function density dispersion . To Speed up the convergence , the whole optimi Zation procedure is organized hierarchically . Starting from the mesh Square regions the hierarchy is built up using quadragrouping ( reverse quadrasection ) . On the hierarchy levelk denote by den ( k , i , j ) the density of the region ( k , i , j ) , and by S ( k , i , j ) the area of the region . The total density DEN will be the sum of the densities of the regions for all i and j . DEN = X X . den ( k , i , j ) i i If the total available core area is a fixed number S , then define 6 , 030 , 110 33 DEN M = - S The density dispersion D is then given by ( which is the cost function . The dispersion is minimized by doing coordinate node local moves . Suppose the node is not on the core border and therefore has four adjacent regions . Then for each node A with coordinate ( x , y ) the local average density is computed as den ( k , i , j ) sk , , ) S ( k , i , j ) X . M ) where den are the densities of the four adjacent regions , and S ( x , y ) are the areas of the images after deformation of the original regions assuming A has coordinates ( x , y ) . The local cost function is defined as deni Si ( x , y ) 2 MA ) S The coordinates for A are chosen in order to minimize the local cost function . An algorithm for minimizing the local cost is to separately move each point A ( x , y ) a distance 8 to the left or right ( up or down for they coordinate ) . The value of 6 can change with each coordinate . The value of the cost function is calculated for each move . In each local region the Set of the coordinates that minimizes the cost function is chosen for the cells . After all of the global levelization steps have been performed , there may still be Some density “peaks” in the core region of the chip . The bulldozer procedure described above may be applied to remove these peakS . Finally , the Sinusoidal optimization procedure is applied again to the chip surface , which is by now subdivided into cell columns . Reapplying the Sinusoidal optimization proceSS ensures that the cells will be evenly assigned to the columns as required by the Structure of the final design . Section 17 : Cell Placement Crystallization The purpose of this procedure is to get final cell place ment . First , the height of each cell is increased by one grid plus y percent of the remaining available Space . Then , the dispersion driven levelizing System and the Sinusoidal opti mization procedures are iterated k times ( e . g . 5 times ) . Now , the original height of each cell is increased by one grid plus a certain percentage of the remaining available space . For this purpose , 72 % is preferable . Then the overlap remover procedure is executed with maxZaZ Set equal to the column height to ensure that there is no overflow in any of the connected column Segments . Next the positions of the large cells are fixed and then the Sinusoidal optimization is executed for k iterations where k may be 10 for example . Now the detailed coordinates of each cell are obtained . In the remaining part of the placement crystallization the following three procedures are iterated : 1 . The vertical optimization is performed for k3 iterations . During one iteration , the list of cells is Scanned . For each cell the change in the cost function is calculated if the cell is 15 25 35 40 45 50 55 60 65 34 moved down for a ( parameter ) . The change in cost function is calculated if the cell is moved up . The move that improves the cost function the most ( if any ) is performed . 2 . Overlap remover with minimal noise . 3 . Next k iterations of optimal permutations are per formed . In this process the cost function is calculated if Vertically adjacent cells are interchanged . Any Such change that improves the cost function is performed . Referring to FIG . 1 , if two cells C and C are interchanged , the Space between them is maintained the same as before the inter change . The area occupied by these two cells is kept at a constant value . Finally , referring to FIG . 38 , the cells are set to the grids by increasing the y - coordinate until the bottom of each cell reaches the closest horizontal grid line . At this point , most of the cells are close to their final positions . The crystallization Step places them in correct , final positions . Proper vertical cell spacings are computed , So that horizontal wires can be routed over and between cells in the vertical columns . Vertical and local - horizontal “Swaps” may be performed if doing So improves the cost functions . Cells must be assigned proper geometric coordi nates So that their positions correspond to legal grid posi tions Specified by the underlying chip architecture . All of these Steps are performed by the crystallization process described above , and the cells are frozen into their final positions . At this point , the placement process according to the invention System has completed its work . A data Struc ture is prepared that can be read by a routing System ( not shown ) for chip routing and design completion . While the invention has been described in connection with specific embodiments thereof , it will be understood that the invention is capable of further modifications . This appli cation is intended to cover any variations , uses or adapta tions of the invention following , in general , the principles of the invention , and including Such departures from the present disclosure as come within known and customary practice within the art to which the invention pertains . We claim : 1 . A method for reallocating cells assigned to a region of the Surface of an integrated circuit device , Said method comprising the Steps of : a . dividing Said region into a first Subregion and a Second Subregion with a dividing line ; b . With respect to cells located within Said region , deter mining a desired allocation of cells between Said first Subregion and Said Second Subregion ; c . locating a cut line acroSS Said region Such that Said cut line cuts Said region into a first part and a Second part and an allocation of cells between Said first part and Said Second part Substantially matches Said desired allocation of cells between said first Subregion and Said Second Subregion ; d . determining an offset representing the distance between a first point on the cut line and a Second point on the dividing line ; e . Shifting cells assigned to Said region said offset in the direction from the cut line toward the dividing line ; and f . reassigning any cells located outside the region as a result of Said shifting Step to an edge of Said region . 2 . The method of claim 1 , wherein the allocation of the cells between Said first part and Said Second part in Step c matches Said desired allocation of cells between Said first Subregion and Said Second Subregion determined in Step b . 3 . The method of claim 1 , wherein Said region is rectan gular and both the cut line and the dividing line are Sub Stantially parallel to each other and to two opposing sides of Said rectangular region . 4 . The method of claim 3 , wherein the area of each Subregion is half of the area of the region . 6 , 030 , 110 35 5 . The method of claim 2 , wherein said desired allocation of cells between Said Subregions is a function of the capaci ties of Said Subregions . 6 . The method of claim 5 , wherein ( 1 ) said first Subregion has a first capacity and Said Second Subregion has a Second capacity , ( 2 ) each cell has an associated cell height , and ( 3 ) the desired allocation of cells between Said Subregions is Such that the Sum of the cell heights in the first Subregion divided by the first capacity Substantially equals the Sum of the cell heights in the Second region divided by the Second capacity . 7 . The method of claim 5 , wherein ( 1 ) said first Subregion has a first capacity and Said Second Subregion has a Second capacity , and ( 2 ) the desired allocation of cells between said Subregions is Such that the Sum of the number of cells in the first subregion divided by the first capacity substantially equals the Sum of the number of cells in the Second region divided by the Second capacity . 8 . A machine - readable Storage medium containing instructions for a processor , Said instructions being the Steps for the processor , Said steps comprising : a . assigning cells to a region of the Surface of an integrated circuit device ; b . dividing Said region into a first Subregion and a Second Subregion with a dividing line ; c . with respect to cells located within Said region , deter mining desired allocation of cells between Said first Subregion and Said Second Subregion ; d . locating a cut line acroSS Said region Such that Said cut line cuts said region in a first part and a Second part and an allocation of cells between Said first part and Said Second part Substantially matches Said desired alloca tion of cells between Said first Subregion and Said Second Subregion ; e . determining an offset representing the distance between a first point on the cut line and a Second point on the dividing line ; f . Shifting cells assigned to Said region said offset in the direction from the cut line toward the dividing line ; and g . reassigning any cells located outside the region as a result of Said shifting Step to an edge of Said region . 9 . A Storage medium according to claim 8 wherein Said Storage medium is Selected from a group consisting of floppy diskette , hard drive , and CD - ROM . 10 . A method for optimizing the placement of cells on a portion of the Surface of an integrated circuit device , Said method comprising the Steps of a . dividing Said portion into rectangular regions Such that the regions are arranged in a rectangular grid with horizontal rows of regions and vertical rows of regions Such that each region ( a ) shares an edge with each adjacent region within its horizontal row of regions and ( b ) shares an edge with each adjacent region within its Vertical row of regions , b . assigning to each of the regions a plurality of cells , c . dividing a first row of regions with a first region dividing line Such that each region in Said first row of regions is divided into a first Subregion and a Second Subregion ; and d . for each region in Said first row of regions , performing the following Substeps : i . With respect to cells located within the region , determining a desired allocation of cells between the region ' s first Subregion and Second Subregion ; ii . locating a cut line across the region Such that Said cut line cuts the region into a first part and a Second part and an allocation of cells between Said first part and Said Second part Substantially matches Said desired 15 25 35 40 45 50 55 60 65 36 allocation of cells between the region ' s first Subre gion and Second Subregion ; iii . determining an offset representing the distance between a first point on the region ' s cut line and a Second point on Said first region dividing line , Said Second point being within the region ; iv . Shifting cells assigned to Said region said offset ; and V . relocating any cells located outside the region as a result of Said shifting Step to an edge of Said region . 11 . The method of claim 10 , wherein , for each region within Said first row of regions , the allocation of the cells between Said first part and Said Second part in Substep ii matches the desired allocation of cells between the region ' s first Subregion and Second Subregion determined in Substep 1 . 12 . The method of claim 10 , wherein , for each region within Said first row of regions , the region ' s cut line and Said first region dividing line of Said first row of regions are Substantially parallel . 13 . The method of claim 12 , wherein , for each region within Said first row of regions , the shortest distance between the first point on the region ' s cut line and the region ' s Second point on the first region dividing line is a line Substantially perpendicular to the first region dividing line . 14 . The method of claim 10 , wherein , for each region in Said first row of regions , the area of each Subregion is half of the area of the region . 15 . The method of claim 11 , wherein , for each region within Said first row of regions , Said desired allocation of cells between Said Subregions is a function of the capacities of Said Subregions . 16 . The method of claim 15 , wherein , for each region within said first row of regions , ( 1 ) said first Subregion has a first capacity and Said Second Subregion has a Second capacity , ( 2 ) each cell has an associated cell height , and ( 3 ) the desired allocation of cells between Said Subregions is Such that the Sum of the cell heights in the first Subregion divided by the first capacity is Substantially equal to the Sum of the cell heights in the Second region divided by the Second capacity . 17 . The method of claim 15 , wherein , for each region within said first row of regions , ( 1 ) said first Subregion has a first capacity and Said Second Subregion has a Second capacity , and ( 2 ) the desired allocation of cells between said Subregions is Such that the Sum of the number of cells in the first subregion divided by the first capacity substantially equals the Sum of the number of cells in the Second region divided by the Second capacity . 18 . The method of claim 10 , wherein steps ( c ) and ( d ) are repeated for the rows of regions which are parallel to Said first row of regions with each parallel row of regions having its own dividing line . 19 . The method of claim 18 , wherein the following additional StepS are taken : e . dividing a first row of Subregions , Said first row of Subregions being perpendicular to Said first row of regions , with a first Subregion dividing line Such that each Subregion in Said first row of Subregions is divided into a first Sub - Subregion and a Second Sub - Subregion ; and f . for each Subregion in Said first row of Subregions , performing the following Substeps : i . locating a cut line acroSS the Subregion ; ii . determining an offset representing the distance between a first point on the Subregion ' s cut line and a Second point on the first Subregion dividing line , Said Second point being within the Subregion ; iii . Shifting cells assigned to Said Subregion Said dis tance ; and 6 , 030 , 110 37 iv . relocating any cells located outside the Subregion as a result of Said shifting Step to an edge of Said Subregion . 20 . The method of claim 19 , wherein steps ( e ) and ( f ) are repeated for the rows of Subregions which are parallel to Said first row of Subregions with each parallel row of Subregions having its own dividing line . 21 . The method of claim 10 , wherein the number of regions in Said grid is 4 . 22 . The method of claim 10 , wherein the number of regions in Said grid is 8 . 23 . The method of claim 10 , wherein the number of regions in Said grid is 16 . 24 . A machine - readable Storage medium containing instructions for a processor , Said instructions being the Steps for the processor , Said steps comprising : a . dividing a portion of the Surface of a integrated circuit device into rectangular regions Such that the regions are arranged in a rectangular grid with horizontal rows of regions and vertical rows of regions Such that each region ( a ) shares an edge with each adjacent region within its horizontal row of regions and ( b ) shares an edge with each adjacent region within its vertical row of regions , b . assigning to each of the regions a plurality of cells , c . dividing a first row of regions with a first region dividing line Such that each region in Said first row of regions is divided into a first Subregion and a Second Subregion ; and d . for each region in Said first row of regions , performing the following Substeps : i . With respect to cells located within the region , determining a desired allocation of cells between the region’s first Subregion and Second Subregion ; ii . locating a cut line across the region Such that Said cut line cuts the region into a first part and a Second part and an allocation of cells between Said first part and Said Second part Substantially matches Said desired allocation of cells between the region ' s first Subre gion and Second Subregion ; iii . determining an offset representing the distance between a first point on the region ' s cut line and a Second point on Said first region dividing line , Said Second point being within the region ; iv . Shifting cells assigned to Said region said offset ; and V . relocating any cells located outside the region as a result of Said shifting Step to an edge of Said region . 25 . The machine - readable storage medium of claim 24 , wherein the instructions thereon further comprise repeating Steps ( c ) and ( d ) for the rows of regions which are parallel to Said first row of regions with each parallel row of regions having its own dividing line . 26 . The machine - readable storage medium of claim 25 , wherein the instructions contained therein further comprise taking the following additional Steps : e . dividing a first row of Subregions , Said first row of Subregions being perpendicular to Said first row of regions , with a first Subregion dividing line Such that each Subregion in Said first row of Subregions is divided into a first Sub - Subregion and a Second Sub - Subregion ; and f . for each Subregion in Said first row of Subregions , performing the following Substeps : i . locating a cut line acroSS the Subregion ; ii . determining an offset representing the distance between a first point on the Subregion ' s cut line and a Second point on the first Subregion dividing line , Said Second point being within the Subregion ; 15 25 35 40 45 50 55 60 65 38 iii . Shifting cells assigned to Said Subregion Said dis tance ; and iv . relocating any cells located outside the Subregion as a result of Said shifting Step to an edge of Said Subregion . 27 . A Storage medium according to claim 24 wherein Said Storage medium is Selected from a group consisting of floppy diskette , hard drive , and CD - ROM . 28 . An integrated circuit device having cells placed on a portion of its Surface , wherein Said cells are allocated on Said portion with a method comprising the following Steps : a . dividing Said portion into rectangular regions Such that the regions are arranged in a rectangular grid with horizontal rows of regions and vertical rows of regions Such that each region ( a ) shares an edge with each adjacent region within its horizontal row of regions and ( b ) shares an edge with each adjacent region within its Vertical row of regions , b . assigning to each of the regions a plurality of cells , c . dividing a first row of regions with a first region dividing line Such that each region in Said first row of regions is divided into a first Subregion and a Second Subregion ; and d . for each region in Said first row of regions , performing the following Substeps : i . With respect to cells located within the region , determining a desired allocation of cells between the region ' s first Subregion and Second Subregion ; ii . locating a cut line across the region Such that Said cut line cuts the region into a first part and a Second part and an allocation of cells between Said first part and Said Second part Substantially matches Said desired allocation of cells between the region ' s first Subre gion and Second Subregion ; iii . determining an offset representing the distance between a first point on the region ' s cut line and a Second point on Said first region dividing line , Said Second point being within the region ; iv . Shifting cells assigned to Said region said offset ; and V . relocating any cells located outside the region as a result of Said shifting Step to an edge of Said region . 29 . The integrated circuit device of claim 28 wherein said method further comprises repeating Steps ( c ) and ( d ) for the rows of regions which are parallel to Said first row of regions with each parallel row of regions having its own dividing line . 30 . The integrated circuit device of claim 29 wherein said method further comprises the following additional Steps : e . dividing a first row of Subregions , Said first row of Subregions being perpendicular to Said first row of regions , with a first Subregion dividing line Such that each Subregion in Said first row of Subregions is divided into a first Sub - Subregion and a Second Sub - Subregion ; and f . for each Subregion in Said first row of Subregions , performing the following Substeps : i . locating a cut line acroSS the Subregion ; ii . determining an offset representing the distance between a first point on the Subregion ' s cut line and a Second point on the first Subregion dividing line , Said Second point being within the Subregion ; iii . Shifting cells assigned to Said Subregion Said dis tance ; and iv . relocating any cells located outside the Subregion as a result of Said shifting Step to an edge of Said Subregion .