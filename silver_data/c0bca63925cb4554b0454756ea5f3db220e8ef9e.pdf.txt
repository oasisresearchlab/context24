Test - Driven Roles for Pair Programming Max Goldman MIT CSAIL 32 Vassar St . Cambridge , MA 02139 maxg @ mit . edu Categories and Subject Descriptors D . 2 . 2 [ Software Engineering ] : Design Tools and Tech - niques Keywords Pair programming , test - driven development , visualizations 1 . INTRODUCTION Pair programming is the practice of having two program - mers work together on the same code in a single develop - ment environment . The goals of pair programming are to improve communication and the sharing of knowledge within a team ; to increase productivity ; to improve developer pro - cess and help team members stay productive ; and ultimately to strengthen the quality of the resulting software [ 1 ] . The most common structure prescribed for pair program - ming is a division of labor between driver and navigator , where “one partner , the one with the keyboard and the mouse , is thinking about the best way to implement this method right here , ” and “the other partner is thinking more strategically” about the overall problem and the pair’s ap - proach to solving it [ 1 ] . But evidence for this structure in practice is inconsistent , a sign that pair programming is in - suﬃciently understood and there is room for innovation in structures and tool support . Cockburn , for example , pro - poses side - by - side programming , where “two people sit close enough to see each others’ screens easily , but work on their own assignments” as a more ﬂexible arrangement [ 3 ] . We propose a new model of two - person programming with a new structure based on test - driven development . In test - driven development , developers follow two rules : “write new code only if an automated test has failed , ” and “eliminate duplication” [ 2 ] . The result is short , rapid development cy - cles in which an initially failing test is written to specify new functionality , code is written to make the test pass , and the code is then refactored to eliminate newly - introduced duplication . In our new model , the process of test - driven development is parallelized , with one member of the pair Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for proﬁt or commercial advantage and that copies bear this notice and the full citation on the ﬁrst page . To copy otherwise , to republish , to post on servers or to redistribute to lists , requires prior speciﬁc permission and / or a fee . ICSE ’10 , May 2 - 8 , 2010 , Cape Town , South Africa Copyright 2010 ACM 978 - 1 - 60558 - 719 - 6 / 10 / 05 . . . $ 10 . 00 . working primarily on tests , while the other works primar - ily on implementation . While developers can and will swap roles as it suits them , authoring tests and implementation gives structure to the developers’ collaboration . In the initial research stage , the software developer pair works to understand their programming problem : they ex - plore the domain and research appropriate resources , sketch out solutions , and agree on a strategy for approaching the problem . The pair then decides on a division of labor into testing and implementation , and agrees on the next module of functionality they will implement and test . The implementor starts developing implementation code , and the tester starts writing tests . Initially , these tests are black - box tests against the module’s speciﬁcation . Failing tests are sent from tester to implementer as they are written so the implementer can write the code needed make them pass ( or initiate a discussion with the tester to reﬁne the speciﬁcation ) . Once passing , tests are sent from the im - plementor back to the tester with pointers to the new im - plementation code . The tester can examine the code and write glass - box tests to probe for weaknesses . When both the tester and implementor are satisﬁed , the pair returns to the researching stage for the next problem . 2 . USER STUDY As a formative evaluation of test - driven roles for pair pro - gramming and associated user interface ideas , we built a prototype development environment and conducted a pilot user study with professional software developers . The pro - totype Python development environment , called Collabode , is a web - based editor with simultaneous editing , in which multiple collaborating programmers see others’ changes to code ﬁles immediately . The editor also implements continu - ous execution of implementation and test code : every time a ﬁle is changed , the editor attempts to re - execute that ﬁle , displaying any output generated or errors encountered . We used this environment to create a low - ﬁdelity proto - type of an interface designed to support pair programming with test - driven roles . In this conﬁguration , a project is made up of separate implementation ﬁles and test ﬁles . Test ﬁles use the Python unit testing framework , and the results of the tests are therefore displayed at the bottom of the screen whenever a test ﬁle is viewed . One developer edits implementation while the other edits tests ; both can view the output of the tests at any time . For the user study , six software developers working at the local oﬃce of a large technology company were divided into three pairs , with each pair completing three programming 515 5 6 from sat import * from parse import parse ! ! import unittest import sys ··· def testEmptyFormula ( self ) : self . assertEqual ( Formula ( [ ] ( [ ] ) , parse ( " " ) ) passdef testPositiveLiteral ( self ) : ! ! self . assertEqual ( Formula ( [ Literal ( ' a ' , True ) ] ) , parse ( " a " ) ) # 303 parsetestpy < t32 < test sattestpy < t32 < test sattestpy < t32 < impl googlecom / CNF wiki / Conjunctive _ normal _ form parsepy < t32 < impl I ' m going to write , a test for that . so . . . from parse . . . import parse . Hoping that works . Um Formula , literal , a true OK So currently , it ' s failing because it wants the parse function to be defined Awesome Oh Sounds good I ' m still understanding sat . py ok , so I don ' t really care about , care about formulas and literals I can fix that for you Can I have two , of these , open at once ? Yes I can . Hot . Uh . . . so , you ' re importing . . . Code edits Opening a new tab Editing sattest . py ( implementer role ) Searching for " CNF " Reading Wikipedia Switching tabs Transcribed speech Test Coverage Code : Executable Execution error 0 400 800 1200 1600 0 5 10 15 20 25 30 35 C o d e l e n g t h ( c h a r ac t e r s ) 100 75 50 25 0 T e s t c o v e r a g e ( p e r ce n t ) parse . py parsetest . py Not shown : sat . py and sattest . py , unedited Figure 1 : Two visualizations of pair programming sessions : the timeline ( left ) shows browsing , code editing , and speech ; the code progression ( right ) shows execution status and test coverage . sessions of up to 40 minutes each on three diﬀerent tasks ( parsing RSS feeds , ﬁnding the roots of polynomials , and parsing and solving boolean formulas ) . In four of the nine sessions , pairs used the test - driven interface conﬁguration . 3 . VISUALIZING & UNDERSTANDING Seeking compact representations of the data collected dur - ing our user study that would help reveal qualitative trends or critical incidents , we developed two visualizations of the programming sessions . The timeline visualization proved most useful , summariz - ing the web browsing , code viewing and editing , and verbal - izations of a pair . Each participant is a represented with a column of code edits ( grouped into diﬀs ) , editor and browser state , and transcribed utterances . Each vertical bar is a browser tab ( including tabs for the web - based Collabode editor ) ; the shaded browser tab has focus , others are in the background . In Figure 1 , the programmer on the left spends about 20 seconds making changes to code . Then the programmer on the right opens a new browser tab to search Google for “CNF” and browses from the results to the Wikipedia page on the topic . This timeline visualiza - tion was our primary tool for navigating the data . The code progression visualization communicates some of what the timeline does not about the status of the code as it was written . The length of the code ﬁles is given in charac - ters ( left axis ) , and the percentage of executable lines in the implementation ﬁle that are covered by the test ﬁle is given by the blue bars ( right ) . In Figure 1 , from approximately minutes 5 to 15 , neither the tests nor the implementation are working ; however , once they do , test coverage rapidly becomes very respectable . This is evidence of paralleliza - tion : the tester and implementer were separately developing solid code that , once ready , worked well . We also used these visualizations to apply two taxonomies from existing literature : cooperation episodes , when paired developers communicated and coordinated with one another with a particular goal in mind [ 5 ] ; and programming modes , the general orientations of developers towards each other and the code [ 4 ] . 4 . CONCLUSIONS & FUTURE WORK At the end of each session , participants completed a post - task questionnaire that included open - ended prompts for the most negative and most positive aspects of working on the task . In every task using the test - driven interface , at least one member of the pair wrote positively , e . g . : • “Splitting tasks on the implementation / testing line is very simple and natural . ” ( Pair 3 User 1 , Task 2 ) • “Having the tests being written with immediate feed - back was awesome . ” ( Pair 2 User 2 , Task 3 ) Our structured approach to programming in a pair will enable us to build tools to support it . Passing unit tests back and forth is the central activity of pair programmers using test - driven roles and deserves ﬁrst - class user interface aﬀordances . Using code coverage analysis , we can link tests to the code they execute . Developers must also be able to easily discover which unit tests are passing or failing , and how unit tests are moving between tester and implementer . With the positive response from professional software de - velopers using our prototype – along with eﬀective visualiza - tion techniques to reveal how pair programmers are working together – we plan to continue iterative development and evaluation of our user interface ideas . Future work will in - volve the design of feedback for both tester and implementer roles and improved simultaneous editing with synchroniza - tion mediated by code state , with the goal of evaluating a complete implementation in a full user study . With eﬀective user interface support for a useful role - based development structure , we aim to keep both program - mers engaged , and to have programmer engagement be mu - tually supportive : as I become more productive , you beneﬁt , and vice versa . Testing and implementing is a natural divi - sion of labor for programming in a pair , and the potential for developing user interface support appears promising . 5 . ACKNOWLEDGEMENTS Sincerest thanks to Rob Miller , the UID group , and the study participants . This work was supported in part by the National Science Foundation , award number IIS - 0447800 . 6 . REFERENCES [ 1 ] K . Beck . Extreme Programming Explained : Embrace Change . Addison - Wesley , 1999 . [ 2 ] K . Beck . Test - Driven Development : By Example . Addison - Wesley , 2003 . [ 3 ] A . Cockburn . Crystal Clear : A Human - Powered Methodology for Small Teams . Addison - Wesley , 2004 . [ 4 ] P . Dewan , P . Agarwal , G . Shroﬀ , and R . Hegde . Distributed side - by - side programming . In Proc . CHASE , page 7 , 2009 . [ 5 ] L . Prechelt , U . St¨ark , and S . Salinger . Types of cooperation episodes in side - by - side programming . In Proc . PPIG , 2009 . 516