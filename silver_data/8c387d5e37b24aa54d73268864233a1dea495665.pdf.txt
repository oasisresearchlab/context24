CHI ? 30 l’mcedings Apill End - User Modifiability in Design Environments Get - hard Fischer and Andreas Girgensohn Department of Computer Science and Institute of Cognitive Science Campus Box 430 University of Colorado , Boulder , Colorado 80309 e - mail : gerhard @ boulder . colorado . edu ; andreasg @ boulder . colorado . edu ABSTRACT Convivial systems encourage users to be actively engaged in generating creative extensions to the artifacts given to them . Convivial systems have the potential to break down the counterproductive barrier between programming and using programs . Knowledge - based design environments are prototypes for convivial systems . These environments support human problem - domain communication , letting users work within their domains of expertise . One of the design rationales behind design environments is to ease the construction and modification of artifacts designed within the environment . But because design environments are intentionally not general purpose programming environments , situations will arise that require modifications to the design environment itself . The rationale and the techniques for these later modifications are discussed in this paper . Our conceptual framework for end - user modifiability is il - lustrated in the context of JANUS , an environment for ar - chitectural design . Evaluating our system building efforts against our objectives shows the subtleties of integrating end - user modifiability in these kinds of systems . INTRODUCTION Convivial tools and systems ( as defined by [ 8 ] ) allow users “to invest the world with their meaning , to enrich the en - vironment with the fruits of their vision and to use them for the accomplishment of a purpose they have chosen . ” Con - viviality is a dimension which sets computers apart from other communication and information technologies ( e . g . , television , videodiscs , interactive videotex ) that are passive and cannot conform to the users’ own tastes and tasks . Passive technologies offer some selective power , but they cannot be extended in ways which the designer of those systems did not directly foresee . Permission to copy without fee all or part of this material is granted provided that the copies are not made or distributed for direct commercial advantage , the ACM copyright notice and the title of the publication and its date appear , and notice is given that copying is by permission of the Association for Computing Machinery . To copy otherwise , or to republish requires a fee and / or specific permission . Unfortunately , the potential for conviviality exists only in principle for most current computer systems . Many users perceive computer systems as unfriendly , uncooperative and too time consuming . They find that they are dependent on human specialists for help , they notice that software is not soft ( i . e . , the behavior of a system can not be changed without reprogramming it substantially ) , and they spend more time fighting the computer than solving their problems . Knowledge - based design environments contribute to the goal of convivial computing . They resolve the conflict between the generality , power and rich functionality of modem computer systems and the limited time and effort that domain specialists are willing to spend in solving their problems . In this paper we fmt develop a conceptual framework for end - user modifiability . We illustrate this framework in the context of JANUS , a knowledge - based design environment for architectural design that allows end - user modifiability . These system building efforts are compared to the concep - tual framework , providing ideas for extensions and future research in the conceptual as well as the system building area . END - USER MODIFIABIUN : WHAT IS IT AND WHY IS IT IMPORTANT ? Most current computer systems belong into one of two categories : 9 General purpose programming languages : Users can do anything with them , but they are hard to learn . They are too far removed from the conceptual structure of the problem , and it takes too long to get a task or a problem solved . l Turn - key systems : They are easy to use , but they do not support the broad range of activities required by many problem domains . Starting at either end , there are promising technologies for making systems more convivial , Coming from the general purpose programming languages end , object - oriented pro gramming , user interface management systems , program - 0 1990 ACM 0 - 89791 - 345 - O / 90 / 0004 - 0183 1 . 50 183 CHI 90 Pnzceedngs Problem Domain Transformation Distance1 General Programming Environment Figure 1 : Layers of Abstraction to Reduce the Transformation Distance between Problem Domain and System Space ming environments and command languages like the UNIX shell are efforts to make systems more accessible and us - able . Coming from the other end , good turn - key systems contain features that make them modifiable by users with - out having to change internal structures . Editors allow users to define their own keys ( e . g . , “key - board macros” ) , and modem user interfaces allow users to create and manipulate windows , menus , icons etc . at an easy to learn level . In our work we have tried to replace human computer communication with human problem domain communication [ 33 . The latter approach makes the com - puter an invisible instrument allowing knowledgeable , task - oriented scientists and designers to work with the absiractions and concepts of their domains . To achieve this goal , we have constructed knowledge - based design en - vironments with an underlying layered architecture [ lo . , 61 . Figure 1 shows the layered architecture underlying the JANUS system discussed in this paper . End - user modifiability in the context of a layered architec - ture means that users can change the behavior of the system in the layers near the top where changes remain in the context of the problem space . If a change extends beyond the functionality provided by one layer , users are not im - mediately thrown back to the system space but can descend one layer at a time . A Taxonomy of End - User Modifiability . End - user modifiability is of crucial importance in knowledge - based design environments , because these systems do not try to serve as general purpose programming environments but provide support for specific tasks . In cases where desig ners of these environments have not anticipated specific activities , users must be able to modify the design environ - ment itself . The changes supported by a modifiable system include the following ( for slightly different taxonomies see [ 161 and [ 4 ] ) : l setting parameters ( e . g . , with the help of property ~ = ts ) , l adding functionality to existing objects , l creating new objects by modifying existing objects , and l defining new objects from scratch . End - user modifiability makes systems adaptable , in con - trast to adaptive systems [ SJ which change themselves based on the user’s behavior , Why is End - User ModifiaMy Important ? Pre - designed sys - tems are too encapsulated for problems . whose nature and specifications change and evolve . A useful system must accommodate changing needs , Domain experts must have some control over the system because they understand the 184 CHI 90 F’aeedings Apiill990 Low - Functionality Computer System High - Functionality Computer System Existing Object 0 New Object Figure 2 : End - User Modifiability in a Low - Functionality System versus a High - Functionality System The trade - off between low - functionality and high - functionality systems with respect to end - user modifiability is : it is easier to locate existing objects in low - functionality systems , but the potential for finding an existing object , which is close to what one needs , is higher in high - functionality systems . The figure also illustrates that the extend of the required modification depends on the desired new object : object “1” is closer than object “2” to the existing functionality . semantics of the problem domain best . End - user modifiability is not a luxury , but a necessity in cases where the systems do not fit a particular task , a particular style of working or a personal sense of aesthetics . End - user modifiability is equally important for knowledge - based systems which by their nature are never completely specified , and undergo continuous change and growth . The evaluation of the MYCIN system [ 2 ] showed that one of the major reasons that MycIN was never used in a real setting was that the system’s knowledge base was outdated by the time the system was finished . This lack of modifiability prohibited an evolution of the underlying knowledge base . Before machine learning can make major contributions to the knowledge acquisition problem , end - user modifiability is a promising approach to increase the amount of shared knowledge between a system and a user . There are high costs associated with a failure to support end - user modifiability . Users are not in control of the in - teraction designed to achieve their goals . They have to put up with an unsatisfactory state of affairs , or they may not use a system at all , if it does not fit their needs . ISSUES FOR END - USER MODIFIABILITY High - Functionality Computer Systems . High - functionality computer systems [ lo ] contain a large number of abstrac - tions in an integrated software environment . Such systems can increase our productivity and efficiency by providing many built - in facilities that users would otherwise have to construct . They have the potential to support a ‘ ‘copy & edit” strategy [ 11 , 121 for making modifications from a rich , initial foundation . Instead of starting from scratch , new functionality can be achieved by modifying an existing part of the system . Figure 2 illustrates the dif - ference of supporting end - user modifiability in a low - functionality system versus a high - functionality system . Locating Existing System Functionality . The limited suc - cess of modification as a major programming methodology is in our opinion directly related to the lack of support tools for exploiting the power of high - functionality systems . Having a large set of existing building blocks without good retrieval tools is a mixed blessing . The advantage of reuse and redesign is that existing buildings blocks - which have been used and tested before - already fits the users’ needs or comes close to doing so . The problem is that it may take a long time to discover these suitable building blocks or to find out that none exists . Comprehending Existing System Functionality . Locating promising parts of the system is just the first step in the modification process . In the next , step users have to com - prehend an existing object in order to carry out the modifications . External modifications that do not require an understanding of the internal workings of an existing object are preferable to internal modifications . In addition , a system constructed using a layered architecture ( see Figure 1 ) is very helpful . In such an architecture , users can remain in the higher layers during the comprehension pCW3 . Supporting Changes . The last step in the modification process is to carry out the modifications . To do so , users should have a clear understanding of the implications of the change with respect to the problem domain . The system should support the mechanics of the change ( e . g . , with property sheets , animated examples , context - sensitive help at every stage ) . A uniform interface for the comprehension process and the modification process makes changes more natural , a principle violated by many systems ( e . g . , the Symbolics Document Examiner [ 17 ] offers a different writer’s and reader’s interface ) . 185 CHI 90 Proceedings Janus - CR4CK dirhwarhers L - Shnpad - Kitohm Figure 3 : JANUS - CRACK : the Constructive Design Component of JANus This screen image shows the different components of JANUS - CRACK : the Palette contains the building blocks ; the Work Area is used for the & sign and modification of a kitchen ; the CatuZog offers existing kitchen designs which can be , used for redesign ; the menu bar contains often used commands ; the Commands pane is used issuing less frequently used commands ; the Messages pane shows the critique generated by the clitics and the Design State pane enumerates the objects in the current design . END - USER MODIFIABILITY IN KNOWLEDGE - BASED ENVIRONMENTS The JANUS System JANLJS [ 6 , 7 ] is a design environment that allows designers to construct architectural floor plan layouts of kitchens and at the same time to learn about the general principles un - derlying such constructions . JANUS does not try to - automate the design process by replacing the human des : ig - ner with an expert system , but rather it cooperates with lhe designer to enrich traditional design practices , amplifying the power of , human designers rather than “deskilling” them . JANUS contains two integrated subsystems : JANUS - CRACK and JANUS - VIEWPOINTS . JANUS - CRACK ( see Figure 3 ) is a knowledge - based system supporting the construction of designs , JANUS - VIEWPOINTS is an issue - based hypertext system containing useful information about general prin - ciples of design . This integration allows argumentation to resolve problematic situations encountered during con - struction . JANUS - CRACK SUPports human problem - domain communication as a construction kit . The building blocks ( contained in the Palette ) represent a ~ ~ p ~ ~ bul ~ and define a design space . . . evidence [ 14 , 6 ] demonstrates that construction kits are necessary but not sufficient conditions for useful design environ - ments . Design environments need embedded knowledge for distinguishing “good” designs from “bad” designs and explanations for justifying these distinctions . Kitchen design is more than selecting appliances from a palette ; it also involves knowing how to combine these simple build - ing blocks into functional kitchens . Knowledge about kitchen design includes design principles based on building codes , safety standards , and functional preferences . This knowledge , combined with critics which can use it , extend construction kits to design environments . Critics in JANIJS - CRACK are implemented as rules . They detect and critique partial solutions developed by the desig - ner . The critics display critiques ( such as : “sink nor in front of a window” ) in a critic window ( the message win - dow in Figure 3 ) . If designers want to get more informa - 186 CHI 90 l’rweedm Pm 1990 INew Class fCoc & d from Chess Stove1 n I Attributei YIDTH Difault 55 RtOrlbW . , DEPTH Ocf ~ ult 44 Attrlbutm , ENERQY - SOURCE Type ( nmnbw g . r . lmx . ridty ) Pronpt ' Energy Sow - o . ' D . f . u , tiS " S Attrlbut ~ : HERTIliQ - ELEHEMS Type ( nenbcr 4 - ryntwtric 3 - trirtigulw I - wymetric ) Prmpt ' HeatlnS Elenmts Rttributct ma attribute dcsortptlon D1splw Nethod : Inherltsd Dsfault Abstract Claesr Yes " o I Abort Figure 4 : Definition of a New Class by Copying an Existing One This figure illustrates how a copy of the class stove is used for the definition of a microwave . A class has the attributes name , super classes , attributes , dispIay method , abstract class , purpose , and belongs - to . tion , request a suggestion , an explanation or want to under - stand the argumentation behind the critic’s view ; they can switch to the JANUS - VIEWPOINTS subsystem . JANUS - VIEWPOINTS is a hypertext system for argumen - tative kitchen design based on the PHI design methodology [ 13 ] , an extension of IBIS [ 9 ] . The elements of VIEWPOINTS are issues , answers , and arguments . JANUS - VIEWPOINTS is implemented within the Symbolics Document Examiner [ 171 . End - User Modifiability In JANUS The possibilities for modification in earlier versions of JANUS were restricted to making modifications easy for artifacts constructed within the design environment . Ex - perimental use of JANUS by professional and amateur kitchen designers indicated that situations arise that require the modification of the & sign environment itself . We have extended the JANUS systems with knowledge - based components to support the following types of modifications : 1 . introducing new classes of objects into the palette ( e . g . , a “microwave” ) , 2 . adding new critic rules to the system ( e . g . , “the microwave should be next to the refrigerator” ) , 3 . allowing the definition of new relationships ( e . g . , “between” ) , and 4 . supporting the creation of composite objects ( e . g . , a “cleanup center” ) . These different types of modifications will be described below in more detail . The knowledge - based components supporting these modifications provide a uniform interface for all modifica - tions in the form of property sheets . These components give context - sensitive help at each step in the modification process , allow users to modify an existing example , take advantage of the layered architecture of the system by min - imizing the number of layers that users have to cross , and exploit the properties of object - oriented representation sup - porting differential descriptions . Definition of New Classes . Situations will arise in which users want to design a kitchen with appliances that are not provided by the design environment . For example , the palette in JANUS ( see Figure 3 ) does not contain a microwave . The command “New Class” activates a sys - tem component supporting the addition of new elements to the palette . Property sheets help users define new design unit classes or modify existing ones by eliminating the need to remember names of attributes . The modification process is supported with context - sensitive help ( e . g . , showing users constraints for the value of a field ) . If values are required , users cannot leave the sheet without providing these values . Although a new class can be defined from scratch , it is much easier to find an existing class that comes closest to the new one and to copy and edit it ( see Figure 4 ) . This changes the modification task from “telling the system about x’ ’ to “finding an already known x’ that’s similar to X “ . Even if a new class is defmed from scratch , it is not necessary to specify it completely by integrating it into the inheritance hierarchy below an existing class . The system supports the finding of an appropriate class by displaying the class hierarchy . Under the assumption that each class in the hierarchy has a name meaningful in the problem space , the classification of the new class is reduced to a selection problem among meaningful names . In addition , users can look at the definition of each existing class and list their applicable critic rules ( see Figure 5 ) . Depending on the type of the modification , it is sometimes better to introduce a new common superclass ( of the exist - ing and the newly defined class ) rather than making the new class a subclass of an existing one . For example , a microwave and a stove could have the common superclass cooking unit . The rules and attributes of stove that also apply to microwave can then be moved to cooking unit [ 13 . The support of the system for this modification can be further improved by describing the purpose of every class with respect to the problem space . A classifier ( such as the one in KL - ONE [ l ] ) can then try to find the correct place for the new class in the hierarchy from its descrip - 187 CHI 90 Proceedngs ' cocks food ' Eclongs lo : COOKIWO - CEtllER Abort . Rpelicable ~ U , CI for Gtcue stove - door - rule - P P r - , # Cove - ulndau - rulc ctovc - ~ ink - rulc - 2 1 rtov ~ - slnk - rul ~ refrle ~ r ~ tor - stcve - rul8 l Ink - stOu . - rul ~ - 2 rink - stow - rule ucrk - trimole - rulm - 3 uork - trlmglc - rule - 2 I m - k - trlsnglc - rule - 1 Press any kcv to PC ~ OYC this ulndou : Rrpun . nt . 1 rt rtou . P . r . fri & mr . tor cOnditt0nf ( NEXT - TO sr RE ) ct - itiqult thn SW " m ie next tc l rafriB @ ratcr Prairc ~ the stove Is not Innedl & rly ncnt to . rcfrisai - ator RrQunentmtlon Toplo : . " , U . P ( stove , r * frlg ~ r * tor ) Outline lopicl lssuc ( stove ) au ore bdne asked to enter c set of dcolcn wit classes 7 . ‘ . w . thr porslblr desisn unit ol ~ ssms ~ , md - rr ~ t * r Press any key to rcncve this windcut 1 Figure 5 : Rules Applicable for a Class After the user presses the HELP key in the field “Super Classes , ” a window with the class hierarchy is displayed ( 1 ) . Every class in the hierarchy is mouse - sensitive . A window with the list of rules that are applicable to a class is displayed by a mouse click on that class ( 2 ) . The role names are also mouse - sensitive , and a mouse click opens a window with the definition of a rule ( 3 ) . tion . It may not bc possible to do this automatically but the system could at least assist the user . For example , if an existing class and a new class both have the description “cooks food” ( see Figure 4 ) , the system could offer three options : make the new class a subclass of the old one , do it vice versa , or generate a common superclass that contains the common feature . After a new class is located within the hierarchy , the dif - ferences between it and its superclass need to be defined . This is done by defining new attributes and redefining in - herited ones . The system supports users in this task by providing a list of all inherited attributes and by giving help for the definition of new ones ( see Figure 6 ) . Definition of New Critic Rules . A new rule can be defined with the “New Rule” command . A property sheet similar to the one used for the definition of design unit classes helps the user define the rule ( see Figure 7 ) . The system provides additional support for the specifica - tion of a rule condition . JANUS contains different hinds of rules . On the one hand , a statement such as , “a sink should be under a window , ” means that for every sink there should be a window behind it . But the converse is not lrue , that there should be a sink in front of every window . On the other hand , users probably do not want to have different rules for the statements “a refrigerator should be near a sink” and “a sink should be near to a refrigerator . ” If there is more than one sink or more than one refrigerator , a mechanism is necessary for specifying whether these state - ments should apply for all possible combinations or only for one sir & - refrigerator pair . Definition of New Relatbns . Relations usually describe spatial relationships between design units ( near , next - to , away - from , etc . ) . They are used in rule conditions . In JANUS , most relations are defined in terms of distance be - tween design units . As shown in Figure 8 , the between relation can be defined in terms of other relations . A deeper knowledge about the relations in the system helps to detect conllicts between rules . For example , it is not possible for design units to accommodate the . relations near and away - from at the same time . It is desirable for a user to be able to describe spatial relationships by showing an example to the sysbm . Unfortunately , one can usually extract more than one relationship from an example . A solution could be a system that presents all relationships exrracted from an example to users allowing them to select the relationship that is closest to their purpose and to refine it . 188 Cl - II 90 Proceedirgs 1990 Figure 6 : Definition of Attributes for a Class An attribute is described by a name and “keyword - value” pairs . When specifying a new attribute , pressing the HELP key shows all inherited attribute descriptions . Users can redefine inherited attributes , e . g . , by specifying a new prompt or a new default value . The attributes inherited from the class design - unit deal with size and position of a design unit . Other classes define problem - domain specific attributes ( e . g . , energy - source in the class & me ) . The relations have a layered architecture . In the current version of the system , any LISP expression can be used to define the condition part of a relation making it hard to assist users in the definition of relations . At least three layers are required : 1 . existing relations and logical operators ( and , or , not ) , 2 . distance functions between design units , accessing functions for the position and size of design units , arithmetic and comparison functions ( + , * , . . . . c , > , a . . ) , and 3 . more useful LISP functions ( trigonometric func - tions , conditionals , . . . ) . New relations should bc defined within the top layer when - ever possible . Cornposits Objects . Our cooperation with domain experts [ 6 ] showed that kitchen designers use intermediate abstractions , i . e . , a combination of several design units , during design . In JANzTs , these intermediate abstractions are called “work centers . ” For example , a sink and a dishwasher could be combined into a cleanup center . Designers start designing a kitchen with work centers and replace them later with their components ( see Figure 9 ) . The components supporting end - user modifiability in JANUS allow the creation of composite objects to be per - formed on different levels ( similar to macro definitions in editors ) . On a lower level , JANUS supports user - definable grouping of graphical presentations df design units so that they can be moved and rotated together . On a higher level , JANUS provides a palette of work centers : the command “Switch Context” switches between the palette of work centers and the palette of appliances . Each work center has its own critic rules . Composite objects introduce an ad - ditional layer of abstraction for a design environment . EVALUATION The described end - user modifiability features have only been informally evaluated in order to help us understand to what extend our current system building efforts have in - stantiated our conceptual framework . The informal evalua - tions indicated that the additional power and flexibility does not come for free , Learning is required at different levels : users have to operate on different descriptive levels and they must familiarize themselves with the interaction mechanisms that are necessary for the modifications . Explorations with the current systems taught us the follow - ing lessons : l Modifiable systems may have side - effects on other system components ( e . g . , static structures such as the layout of the palette suddenly need to be changed ) . l Making systems modifiable has to be a design goal for the original system . Adding system components to allow for end - user modifiability in a system con - structed without this goal in mind is a nearly impos - sible task . l A deeper understanding of the cognitive issues sur - rounding end - user modifiability is required [ 12 ] , e . g . , it is necessary to understarid when classes or in - stances should be changed and how these different changes affect each other . l The taxonomy needs to be extended and refined . It should include an illustration of the consequences of different approaches . Modifications need to be clas - sified whether they are local to one user’s envimn - ment or global to a whole user community , and whether they are temporary or permanent . l End - user modifiable systems have the potential drawback that they result in multiple versions of the same systems violating standardization and por - tability goals . EXTENSIONS In the current implementation , design units are presented as icons by using methods that call graphics functions . Modifying icons or creating new ones requires changing method definitions . That forces users to descend into the lower layers of our architecture ( see Figure 1 ) . Another solution must be found . In the meantime , users have the choice between an inherited , predefined display method 189 CHI 90 Pmcedings I , the c . nt . ~ d1st . m . b . tu . . n th . " 1s rt most , 108 inoh . 8 . Figure 7 : Definition of a Rule After the user presses the HF ! LP key in the field “Cond ? tion , ” a window with the names of all currently available relations between design units is shown . These names are mouse - sensitive , The definition of a relation is displayed by a mouse click . condition : ( I ~ NC ( LEFT - OF w y ) ( RIGHT - OF Y . z ) ) Dcrcript ~ onr A kri , v writ li bmtmm two othm - s IF it lm left ol on * . nd right OF the other Figure 8 : Property Sheet for the Definition of a Relation and a default display method drawing a rectangle with , the class name in it . The current system also makes it impossible to define an on - top - of relation at a higher layer in the architecture , ‘be - cause the system represents only a two dimensional space . A on - top - of relation is needed if users want to have a rule that enforces that one design unit is always on top of another ( e . g . , a microwave on top of a cabinet ) . An alter - native solution for this problem might be the introduction of a new class that models the two units together . The system should have knowledge structures that assist users in exploring these alternatives . Modifiable systems generate new problems as con - sequences of these modifications . In earlier versions of JANUS , the layout of the palette could be determined at the time the design environment was created . The current layout of the palette puts classes that have the same super - class in the same row . Designers might wan & to have dif - ferent layouts , e . g . , positioning the design units most im - portant to their work at the top of the palette . By allowing users to dynamically add new objects to the palette , the layout of the palette will change as well . This requires either that users determine the new structure ( and are able to save it ) or that the system has enough knowledge to compute it . At the current stage of development , our efforts towards making JANUS more end - user modifiable have concentrated on JANUS - CRACK , the constructive design component , , In the future , we will investigate modifiability issues in relationship to the Catalog ( see Figure 3 ) and JANUS - VIEWPOINTS . Hypertext systems 1161 have to be treated differently , because information structures can be interpreted by other humans and need not be understood by the system . CONCLUSIONS The goal of making systems modifiable by users does not transfer responsibility for good system des & n to users . Average users will never build systems of the quality a professional designer would ; but this is not the goal of convivial systems . Only if a system does not satisfy the needs and the taste of its users ( which they know best themselves ) should they be able to carry out a constrained design process to modify it . The strongest test of a system with respect b user modifiability and user control is not how well its features conform to anticipated needs , but how easy it is to modify it in order to perform a , task the desig - ner did not foresee . ACKNOWLEDGMENTS The authors would like to thank Raymond McCall and Anders March , who were major contributors in the development of the JANUS system . Thomas Mastaglio , David Redmiles , Brent Reeves , and Curt Stevens provided valuable comments on earlier drafts of this paper . The research was partially supported by grant No . HI - 8722792 from the National Science Foundation , grant No . MDA903 - 86 - CO143 from the Army Research Institute , and grants from the Intelligent Systems Group at NYNEX and from Software Research Associates ( SRA ) , Tokyo . 190 Figure 9 : Work Centers Composite objects allow designers to design at different levels of abstractions . After having completed the design of the kitchen at the work center level , users can proceed to the detailed design of the centers . The figure shows how the cleanup center is expanded to its components sink and dishwasher . PEFERENCES 1 . R . J . Brachman . On the E Semantic Networks . In Pf istemological Status of . V . Findler ( Ed . ) , Associative Networks - Representation and Use of Knowled e by Computers , Academic Press , New York , 1999 . 2 . 3 . 4 . 5 . 6 . 7 . 8 . 9 . B . G . Buchanan , E . H . Shortliffe . Rule - Based Expert S stems : The MYCIN E d eriments o the Stan ord euristic Programmin “5 : Publishing Company , lf reject . Addison - dsley eading , MA , 1984 . G . Fischer , A . C . Lemke . Construction Kits and Design Environments : Steps Toward Human Pmblem - Domain Communication . Human - Computer Inter - action 3 , 3 ( 1988 ) . 179 - 222 . G . Fischer , AC . Lemke . Constrained Design Processes : Ste R . Guindon s Towards Convivial Computing . In tion for $ d . ) , Cognitive Science and rts Applica - HumanCo @ % l Fi & aum Assocrates , uter Interaction , Lawrence llsdale , NJ , 1988 , Chap . 1 , pp . - . G . Fischer , A . C . Len & e , T . Schwab . Knowledge - Based He1 Systems . Human Factors # in Computing Systems , cp HI 85 Coderence Proceedrn s ( San Fran - caa ~ ~ ~ % A ) , ACM , New York , Apnl , 19 & , pp . - * G . Fischer ; R . McCall , A . March . Design Envimn - ments for Constructive and Ar umentauve Desi n . Human Factors in Computing b stems , CHI’89 E on - erence Proceedin La 1989 , pp . 26 s ( Austin , d ) , ACM , New York , y , d - 275 . G . Fischer , R . McCall , A . March . JANUS : Integrat - ing Hypertext With a Knowled Proceedin s of Hypertext’89 , 1 e - Based Design , pp . 105 - 11 g7 CM , November , 1989 , . I . Illich . Tools or Conviviality . Harper and Row , New York , 19 / 3 . W . Kunz , H . Rittel . Issues as Elements o Systems . Working Pa r 13 1 , Center for 4 Information r lanning and Development Researc , University of California , Berkely , CA , 1970 . 10 . AC . Len & e . Design Environments or Hi Functionality Computer S stems . f Ii h - P . D . T esis , De artment of Corn Co orado , Boulder , P uter 6 i cience , University of 0 , July 1989 . 11 . D . Lenat , M . Prakash , M . Shepherd . CYC : Using Common Sense Knowledge to Overcome Brittleness and Knowled Magazine 6 , P e Acquisition Bottlenecks . AI ( winter 1986 ) , 65 - 85 . 12 . C . H . Lewis , G . M . Olson . Can the Principles of Co - nition Lower the Barriers of Rogrammin EB ? In G . d . Olson , E . Soloway , S . She Studies of Programmers ( P ard ( Eds . ) , “g irical 01 . 2 ) , Ablex Pu lishing Corporation , Lawrence Erlbaum Associates , Nor - wood , NJ - Hillsdale , NJ , 1987 . 13 . R . McCall . PHIBIS : procedurally hierarchical issue - based information systems . Proceedings of the Con - ference on Architecture at the Internattpnal Congress g . Pmun eaf andDesrgn Theory , Amencan Society of Engmeers , New York , 1987 . 14 . D . A . Norman . Co man . , S . W . Draper itive Engineering . In D . A . Nor - 8 ds . ) , User Centered System Destgn , New Perspectives on Human - Computer Interaction , Lawrence Erlbaum Associates , Hillsdale , NJ , 1986 , Chap . 3 , pp . 31 - 62 . 15 . MJ . Stefik , D . G . Bobrow . Object - Oriented Pro am - ming : Themes and Variations . AI Magazine 6 , f ( Winter 1986 ) . 16 . R . H . Trigg , T . P . Moran , F . G . Halasz . Adaptability and Tailorabiiity in NoteCards . H . - J . Bulls er , B . Shackel ( Eds . ) , Proceedin & 87 , 2nd IFIP Conference on Human - 8 s of INTERA omputer Interaction ( Stuttgart , FRG ) , North - Holland , Amsterdam , Sep - tember , 1987 , pp . 723 - 728 . 17 . J . H . Walker . Document Examiner : Delivery Interface for Hypertext Documents . Hypertext’87 P University of North Carolina Chapel Hill , November , 1987 , pp . 307 - 323 . 8 ers , C , 191