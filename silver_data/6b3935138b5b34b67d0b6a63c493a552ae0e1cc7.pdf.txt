1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 Notes on Notebooks : Is Jupyter the Bringer of Jollity ? Anonymous Author ( s ) Abstract As the interactive computational notebook becomes a more prominent code development medium , we examine advan - tages and disadvantages of this particular source code format . We specify the structure of a coding notebook layout . We describe complexities in notebook programming ; some of these are incidental whereas others may be inherent com - plexities . We outline how we envisage research and devel - opment might proceed to advance the cause of notebook programming . ACM Reference Format : Anonymous Author ( s ) . 2020 . Notes on Notebooks : Is Jupyter the Bringer of Jollity ? . In Proceedings of ACM Conference ( Conference’17 ) . ACM , NewYork , NY , USA , 7pages . https : / / doi . org / 10 . 1145 / nnnnnnn . nnnnnnn 1 Introduction Over the past decade , we have witnessed a quiet revolution in the way that software developers interact with source code . If mainstream software development practice in the nineties and noughties was dominated by the Integrated Develop - ment Environment ( IDE ) , then the teens and twenties appear to be the era of the Computational Notebook . The growth in popularity of notebook programming coincides largely with the democratization of software development , considering concerted advances in school - age computer science as well as increasing emphasis on end - user software engineering . It seems that novices and non - specialist developers are the principal audience for computational notebooks . One still meets some die - hard , traditionalist , software developers who have ‘never heard of Jupyter’ and scoff at the idea of ‘cod - ing in an HTML textbox . ’ However , a trivial crawl of github shows around 8 million notebooks have been checked in [ 17 ] over the past decade . Given that a large number of people are engaged in note - book programming , many of whom may have never expe - rienced other source code development modalities , These people may not know very much about software engineering Permission to make digital or hard copies of all or part of this work for personalorclassroomuseisgrantedwithoutfeeprovidedthatcopiesarenotmadeordistributedforprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitationonthefirstpage . Copyrights for components of this work owned by others than ACM must be honored . Abstracting with credit is permitted . To copy otherwise , or republish , to post on servers or to redistribute to lists , requires prior specific permission and / or a fee . Request permissions from permissions @ acm . org . Conference’17 , July 2017 , Washington , DC , USA © 2020 Association for Computing Machinery . ACM ISBN 978 - x - xxxx - xxxx - x / YY / MM . . . $ 15 . 00 https : / / doi . org / 10 . 1145 / nnnnnnn . nnnnnnn and have never seen better source code preparation systems . How can we characterize the ‘state of the notebook’ and consider ways to improve it ? These are the key motivations underlying this paper . Computational notebook programming has its origins in Knuth’s notion of literate programming [ 10 ] in which docu - mentation and source code are seamlessly interleaved in a single textual entity that may have multiple views or inter - pretations . Software development with interactive notebooks differs significantly from standard coding practice . Notebooks re - side in a browser - based coding environment with no complex installation steps required . Typical notebook frameworks fea - ture direct integration with popular languages and libraries , avoiding the overheads of user package management and dependency resolution . An interactive notebook provides rich inline textual and graphical commentary on the code , interwoven with the source code itself . Further , the output of source code execu - tion is immediately visible in the same inline representation , by means of live code and interactive interpretation . 1 . 1 Autoethnography Disclaimer Where did this paper come from ? The research method is largely autoethnographic 1 , based on three kinds of personal experience . 1 . I have a range of individual interactions with notebook programming in various incarnations of the Jupyter framework over the past few years , particularly in the context of university learning and teaching . 2 . I was involved in the development and deployment of a beginner - friendly hosted notebook development en - vironment called ErysNotes , which is used for practical exercises in a massive open online course called ‘Get - ting Started with Teaching Data Science in Schools . ’ 3 . I have initiated a series of useful workshop discussions titled ‘Notebook Programming Considered Harmful ? ’ This conversation commenced with colleagues within my institution , and later spread to national level , about the relative merits of notebook programming . Drawing on these activities , this paper encapsulates the arguments and points out some potential directions for im - provement . 1 . 2 Contributions This paper makes the following original contributions in the field of computational notebook research and development : 1 massively challenging to explain in a double - blind review ! 1 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 Conference’17 , July 2017 , Washington , DC , USA Anon . 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 1 . It provides a syntactic definition of notebooks , viewed from both client and server perspectives . 2 . It identifies a number of issues with the current state - of - the - art in notebook programming . 3 . It outlines promising avenues for future enhancements in the notebook programming model , including sup - port for modularity , versioning , distribution , and in - trospection . 2 Popularity of Notebooks Notebooks are universally popular . There is incontrovertible evidence for this . For example , the number of notebook files stored in the github centralized repository is around 8 million ( as of May 2020 ) and growing exponentially [ 17 ] . In this section , I examine various potential reasons for this growth in notebook usage . 2 . 1 Learner Testimony The appeal of notebooks springs from their apparent simplic - ity and accessibility [ 27 ] . The following verbatim quotes are all taken from online learners participating in our Teaching Data Science MOOC . These feedback comments were cap - tured immediately after their initial exposure to interactive notebook programming in the first week of the course . In terms of the exploratory , interactive nature of the live code blocks with instant feedback , learners felt they were ‘playing around’ ( two people said this ) and ‘having a go . ’ Others commented that ‘it was fun’ and ‘made sense to me . ’ In terms of the highly structured notebooks with small code blocks interspersed by small text blocks , one learner said they ‘do really like the simplicity . ’ Another felt the exer - cise was ‘very interactive yet supportive at the same time . ’ A further participant stated , ‘I like the way you explained what would happen in each section . ’ 2 . 2 Channelling Zeitgeist Notebook programming appropriately fits contemporary coding practice . Programmers hunt for useful code snippets via highly specialized online search . This ‘stack overflow mentality’ which leads to ‘cut - n - paste coding’ is increasingly common [ 2 , 26 ] . It is a natural tendancy in the era of post - modern programming [ 16 ] . The notebook format—small cells containing inline code , output , and explanatory rich text scaffolding—lends itself to code borrowing and sharing in an exploratory , interactive manner . Further , notebooks are a highly sharable format , particularly with the nbviewer tool enabling a notebook to be exported as a HTML document . Notebook programming involves browser - based interac - tions . In that sense , notebook development is platform ag - nostic , tapping into the Bring Your Own Device trend for the different kinds of developers . The next section identifies where these developers come from . 2 . 3 Diverse Audience Appeal While computational notebook usage is widespread , there appear to be three concentrated domains where notebooks are particularly prevalent . 2 . 3 . 1 Novice Developers . Inexperienced coders generally appreciate the exploratory nature of interactive interpreters or read - eval - print - loop ( REPL ) systems . The notebook is one step up from that in terms of its structure , but it retains the immediate feedback of a REPL . Well - designed notebooks are effectively interactive textbooks for learners . Typical notebook environments for beginners require min - imal client - side toolchain installation or they use a hosted solution with no client - side requirements apart from a web browser . The familiar browser interface also helps reassure novices . One learner from our Teaching Data Science MOOC , who had never encountered notebooks before , commented : ‘What a wonderful intro into data science and Jupyter Notebook . I still love these independent cells . Smart ; ) ’ 2 . 3 . 2 Scientific End - user Developers . End - user software developers [ 11 ] who work in scientific research [ 25 ] are the original intended audience for Jupyter [ 9 ] . For such scien - tists , their code is not the primary output . They care more about the results of the analysis . However code is necessary so a computational notebook acts as a reporting tool , much like a lab notebook [ 24 ] . Reproducibility is a key goal in scientific research . Com - putational notebooks facilitate reproducible experiments [ 19 , 22 ] . 2 . 3 . 3 Data Scientists . Professional data scientists are in - tensive ‘power users’ of notebooks [ 8 , 18 ] . The interactive nature , coupled with convenient integration to standard li - braries , enables efficient exploratory data analysis . 3 History of Notebooks The importance of lab notebooks as a permanent scientific record is increasingly recognized [ 5 ] . There is a slow progres - sion towards electronic lab notebooks in traditional sciences [ 6 ] . This trend is more rapid in information sciences [ 24 ] . The concept of literate programming was introduced by Knuth to combine source code and rich textual commentary into a single coherent document [ 10 ] . The REPL facility , for interactive interpretive execution with inline execution feed - back , was pioneered in LISP [ 14 ] with the eval function . Computational notebooks blend both these notions by pro - viding interactive code execution with interleaved output , in context of a richly annotated text document . The proprietary Mathematica package introduced the com - putational notebook in 1988 ; this has since evolved into the online Wolfram Computational Notebooks system 2 . 2 https : / / www . wolfram . com / notebooks / 2 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 Notes on Notebooks : Is Jupyter the Bringer of Jollity ? Conference’17 , July 2017 , Washington , DC , USA 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 Figure 1 . Architecture of the Jupyter Notebooks system Notebook - based data analysis is supported in R , with sys - tems like Sweave [ 13 ] and knitr [ 28 ] . Currently , the most popular notebook framework is Jupyter [ 9 ] . This system supports a massive range of languages , using a pluggable kernel framework for language interpretation . Jupyter is a distributed system : • the client operates in a web browser , rendering the notebook and capturing user interaction • the server is integrated as a web server host , serving data to one or more clients • the kernel is responsible for interactive program ex - ecution , it runs on the server and accumulates state for each client ( e . g . defined variables and dynamically allocated in - memory data structures ) • the filestore saves notebook files as persistent JSON records , which are stored on the server but can be downloaded by the client Figure 1 gives a schematic overview of the Jupyter system . Jupyter is available for users to install locally , in which case the client and the server are the same machine . Commercially hosted versions of Jupyter are commonplace : these include Binder 3 , Google’s Colab 4 and the Noteable system 5 . Our notebook programming course , Getting Started with Teaching Data Science in Schools , was aimed primarily at novice coders . We felt that the meandering menu system of Jupyter was unsuitable ( cf . Figure 2 , as were some of its code execution features . We chose to implement a cut - down hosted notebook execution framework called ErysNotes 6 . 3 https : / / mybinder . org 4 https : / / colab . research . google . com 5 https : / / noteable . edina . ac . uk / 6 https : / / github . com / citizendatascience / ErysNotes 4 Abstract Description of Notebooks In this section , we intend to capture the inherent character - istics of interactive notebooks . Section 4 . 1 describes a mathe - matical characterization of the structure of a static notebook as a sequence of consecutive cells , visible on the client - side . Section 4 . 2 outlines the dynamic view of a notebook from the server - side . 4 . 1 Notebook Structure We consider a notebook to be a linear sequence of cells . The order of cells is specified , so we cannot denote a notebook by a set of cells , instead we need to use a list . Alternative note - book geometries are being explored , such as a spreadsheet - style , two - dimensional grid of cells [ 15 ] . However , we restrict attention to one - dimensional notebooks for now . Each cell has a specific type , which is either code or mark - down . A code cell contains source code in a specified pro - gramming language . A code cell optionally has output as - sociated with it , if it has been executed and the execution caused a visible side - effect ( such as a print statement ) . A markdown cell contains text that can be rendered by a mark - down formatter . Figure 3 presents a context - free grammar to express this linear sequence of cells in a notebook . A Jupyter notebook is encoded as a JSON data structure . Further cell metadata may be captured , such as the number of times each code cell has been executed . Notebook metadata including the source language and version number are stored as key / value pairs . This is the static , client - side view of a notebook . The user may manually edit the structure of the notebook , adding new cells , rearranging cell order or changing cell type between code and markdown . 4 . 2 Dynamic View When a notebook is executing , it dynamically accumulates state . A kernel process runs on the server , acting as an in - teractive interpreter for the client . Execution state builds up over a sequence of code cell invocations from the notebook . However this ordering of code cell invocations is arbitrary , as far as the notebook structure is concerned , since the user selects cells to execute . Notebook execution appears to be a sequence of code block executions , which is simply a series of lines of source code interpreted consecutively to accumulate program state , con - sisting of variables , data structures , etc . Observable outputs such as graphics and print statement results are transmitted back from the kernel to the server using the standard IPython messaging protocol 7 and then relayed from the server to the client as HTML for display in output blocks . When the client is ‘attached’ to a server ( more precisely , to a kernel ) then state can be queried by and communicated to the executing notebook on the client . However this program 7 https : / / jupyter - client . readthedocs . io / en / latest / messaging . html 3 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 Conference’17 , July 2017 , Washington , DC , USA Anon . 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 Figure 2 . Comparison of interface on Jupyter Notebook ( left ) and ErysNotes ( right ) ⟨ notebook ⟩ : : = ⟨ cell ⟩ * ⟨ cell ⟩ : : = ⟨ codecell ⟩ | ⟨ textcell ⟩ ⟨ codecell ⟩ : : = ⟨ codeblock ⟩ ⟨ outputblock ⟩ ⟨ outputblock ⟩ : : = output | ϵ ⟨ codeblock ⟩ : : = source ⟨ textcell ⟩ : : = markdown Figure 3 . BNF grammar for static notebook structure as a sequence of cells state is transient , so when the notebook instance is discon - nected from the server ( perhaps due to a network issue ) then all the underlying runtime state is lost . The notebook is still visually complete , in terms of output cells previously com - puted . This output may be persisted by saving the notebook locally . However once the notebook is disconnected , no fur - ther incremental execution is possible . When the notebook is reconnected to the kernel , or reloaded in a new Jupyter context , execution recommences with an empty runtime state . 5 Notebook Complexity This section examines some of the difficulties associated with notebook programming , particularly in the context of the Jupyter Notebook framework . I divide complexities into incidental ( Section 5 . 1 ) and intrinsic ( Section 5 . 2 ) and describe them separately below . 5 . 1 Incidental Complexities of Notebooks These presentational worries are mostly caused by the Jupyter Notebook user interface . Our ErysNotes system bypassed these complexities in a refactored interface , while preserving the underlying JSON - based notebook file format . 5 . 1 . 1 Cell Execution Order . A key problem with compu - tational notebooks where source code is split across multiple cells is that these cells may be executed by the user in an arbitrary order . A non - linear execution sequence is possible , including multiple executions of the same , non - idempotent cell . Although the order of cell execution can sometimes be inferred from Jupyter ( see sequencing labels on left of executed cells ) , in the case where multiple cells are executed multiple times then the execution order is no longer appar - ent . Generally , notebook developers follow standard conven - tions like expecting cells should be executed in sequential ( top - to - bottom ) order . In our online course for Teaching Data Science , we respected this sequential cell execution conven - tion in all template notebooks for learners , and also ensured that that all cells had idempotent code so multiple execu - tions of the same code block would not change the notebook behaviour . It seems that other educators adopt similar self - imposed constraints on their notebooks . For instance , one colleague told me : ‘I put all the code in a single block to avoid sequenc - ing issues . ’ Another said : ‘I click ’Run all’ when first open a notebook . ’ There is an open issue 8 on github for the Jupyter Notebook project to ‘enforce a top - down order of execution’ which imposes the behaviour educators are trying to encourage . Some extensions to Jupyter Notebook support an explicit dependence graph for cell execution encoded directly into the notebook structure , providing users with a clear view of inter - cell dependences [ 12 ] . An alternative solution might involve a script manage - ment system like Proof General [ 3 ] . This system handles interactive execution of scripts for theorem proving , distin - guishing between code already executed and code remaining to be executed . It manages the dialogue between a user and an interactive text - based shell interface , which is entirely unconstrained in Jupyter at present . 5 . 1 . 2 Decoupled Persistence . As outlined in Section 4 . 2 , it is possible for a notebook to be disconnected from a server kernel , at which point that notebook loses its runtime state . This occurs when a client is disconnected from a server or 8 https : / / github . com / jupyter / notebook / issues / 3229 4 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 Notes on Notebooks : Is Jupyter the Bringer of Jollity ? Conference’17 , July 2017 , Washington , DC , USA 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 when a notebook file is saved and reloaded in a different server context . The confusion arises because outputs from executed code cells are retained , so a user intuitively ( but incorrectly ) as - sumes that any state which generated these outputs is still available . Our ErysNotes system incrementally serializes the Python interpreter kernel state on the server immediately after each code block execution . Thus the notebook state and the back - end kernel state are both persisted and synchronized . This requires unique user identification ( we used LTI 9 ) to serve each user with their own saved notebook and interpreter state . In the worst case , it means there is lots of duplicated data on the server . In practice we did not find this to be a problem : for our beginner course , we had 500 learners and only 2 . 3MB of pickled Python state in total across all learner profiles . Admittedly , all our course notebooks were short and simple to suit the novice audience . 5 . 1 . 3 Schrödinger’s Notebook . The simple operation of loading and inspecting a notebook has the potential to mod - ify it . At the very least , it can change OS timestamps on a file’s access times . More significantly , the notebook metadata might be updated . Once the user begins to make changes to the notebook cells , then any rolling back of edits is subject to the vagaries of the web browser undo facility or check - pointed saves of the notebook state . In our ErysNotes system , we implemented a readonly cell feature , to prevent user editing of fixed cells ( instructional text cells or essential library imports , for instance ) . Further , we provided a ‘reset’ button on the toolbar to allow users to roll back the notebook state to a default ‘clean’ notebook , which is predefined by the course educator for each notebook activity . 5 . 2 Intrinsic Complexities of Notebooks In this section , I examine some intrinsic notebook complexi - ties . Solving these challenges will require more significant engineering effort . Possibly this is a subjective assessment on my part , but no satisfactory solutiona for these problems exist to date . Mature programming language system must facilitate ap - propriate encapsulation , efficient software process integra - tion and reflective programmatic interaction . 5 . 2 . 1 No Modularity . Notebooks support basic scripting activity , but it is unclear how to scale notebooks to handle large - scale software engineering projects . Each program is contained in a single notebook ; it is not straightforward to construct notebooks that contain other notebooks . The standard programming language approach to building larger scale systems is modularity . While notebooks might 9 http : / / www . imsglobal . org / activity / learning - tools - interoperability support modularity , e . g . it is possible to import Python mod - ules into a Jupyter notebook , but notebooks cannot be di - rectly mapped onto Python modules themselves . How can we import one notebook’s code into another notebook ? The most common approach appears to be a copy - and - paste op - eration [ 20 ] . It is impossible to inherit a notebook and simply override one part . Instead we must clone the notebook and modify the required cells in place . The key issue is that the notebook is designed to be the top - level orchestration script for a computation ; anything un - derneath should be developed and deployed using traditional code preparation techniques . It’s not fractally recurring note - books , or‘notebooks all the way down’ , in terms of the source code . The notebook contains the top - level script ; currently it is only practical for this purpose . There are complex workarounds like the ipynb module 10 and registering callbacks for Python import hooks 11 . Neither is a particularly satisfactory solution . 5 . 2 . 2 No Concurrency . The idea that there is a single thread of execution , with code executing in one place at one time , is ideal for beginner programmers using notebooks . In a Jupyter notebook , it is only possible to execute a single cell at once , or to queue a sequence of cells for consecutive execution . What would a distributed system look like when written as a notebook , or a set of notebooks ? Could it be developed and coordinated easily in a notebook framework ? There are some specialized systems for data parallel com - puting . For example , ipyparallel 12 coordinates a cluster of indexed kernels to compute Python code on a set of server nodes . However , this maps awkwardly onto the single note - book model . 5 . 2 . 3 No Versioning . Since notebooks are structured JSON documents , it is difficult to use standard text - based source code management tools like diff and patch . This difficulty extends to version control systems like git that operate prin - cipally on text - based source code artifacts . Typical advice on git version control for Jupyter [ 23 ] seems simplistic . It involves scrubbing outputs , reverting to HTML or Python , then saving text files . This is a ‘lowest common denominator’ approach . There is no version control infor - mation for Jupyter encoded in notebook metadata . Specialist tools are coming into play , such as nbdime 13 . This supports ‘intelligent’ diffing of notebooks , since it can show differences in code blocks and highlight differences in outputs . Is it necessary for every source code processing tool ( e . g . diff , merge , patch ) to be ‘ported’ to a version that parses 10 https : / / ipynb . readthedocs . io / en / latest / 11 https : / / jupyter - notebook . readthedocs . io / en / stable / examples / Notebook / ImportingNotebooks . html 12 https : / / ipyparallel . readthedocs . io / en / latest / 13 https : / / nbdime . readthedocs . io / en / stable / 5 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 Conference’17 , July 2017 , Washington , DC , USA Anon . 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 JSON format explicitly . If this is the case , the tools will be closely coupled with the notebook format . A fundamental problem is that text - based checkin of ver - sions does not fit well with the interactive nature of notebook development . Users might prefer some kind of sophisticated checkpointing and rollback , like the time travel feature of Cocalc 14 . While there are plugin modules to supply this fa - cility for Jupyter , none are integrated by default and they are complex to configure . 5 . 2 . 4 No Introspection . In some senses , a HTML docu - ment with its associated Document Object Model ( DOM ) , is like a computational notebook . Both HTML documents and computational notebooks contain interwoven marked up text and executable source code . The distinguishing feature of HTML is that Javascript , when executed , can modify the DOM dynamically . In that sense , the document structure is exposed to the Javascript , and therefore can be subject to live programmatic updates . On the other hand , notebook code—although more visible than Javascript in a web page—does not have any direct links between the documentation ( markdown cells ) and the source code . There is no dynamic interaction between them . For instance , there is no way Python code in a notebook can determine which cell block it belongs to . There is some limited introspection capapibility with the inspect module in Python and the get _ ipython method . However these relate to Python code that has been executed by the kernel , and do not provide meaningful handles back to the client - side notebook structure . Each code block effectively exists in independent isolation . The kernel on the server is unaware of the overall notebook structure . Unfortunately this makes the notebooks somehow static and unresponsive . The notebook is not reified at run - time , so cannot be introspected or updated programmatically . In the same way as Smalltalk introduced the concept of re - flective programming [ 7 ] we need a meta notebook protocol to enable reflective programming for Notebooks . The last resort is to use Jupyter magic directives . This is a kludge to support specific hard - coded kernel runtime behaviour . However end users should never need to resort to magic ; they should be able to accomplish elegant , rich reflective programming in their source code language of choice . 6 Related Work Grus [ 4 ] identified some of these shortcomings before me : notably problems with out - of - order code block execution , lack of modularity , and lack of version control . These pitfalls are documented elsewhere [ 1 ] but without proposals for solutions . There are many online blog articles with titles 14 https : / / cocalc . com / doc / jupyter - notebook . html like ‘Why I don’t like Jupyter Notebooks’ containing similar arguments . Pimentel et al [ 20 ] report on a study of over 1 million Jupyter notebook files downloaded from github ; they dis - cover that only 4 % of these notebooks generated reproducible results . Rule et al [ 21 ] report on a different study of over 1 million Jupyter notebook files downloaded from github ; they dis - cover that only 25 % of these notebooks contain explanatory text cells—the remainder consist entirely of source code and saved outputs . 7 Conclusions We have outlined the ‘state of the notebook’ at present , par - ticularly focusing on the Jupyter Notebook ecosystem . We have examined a range of challenges facing compu - tational notebook users and have pointed out promising solutions , some of which have commenced in development already . Note there is no extant solution to the problem of notebook reflection ; there is no meaningful notion of meta notebook programming . This could be a rewarding area for future investigation . References [ 1 ] Aalto Science . Pitfalls of Jupyter notebooks , 2020 . [ 2 ] L . An , O . Mlouki , F . Khomh , and G . Antoniol . Stack overflow : A code laundering platform ? In 2017 IEEE 24th International Conference on Software Analysis , Evolution and Reengineering ( SANER ) , pages 283 – 293 , 2017 . [ 3 ] David Aspinall . Proof general : A generic tool for proof development . In International Conference on Tools and Algorithms for the Construction and Analysis of Systems , pages 38 – 43 , 2000 . [ 4 ] Joel Grus . I don’t like notebooks , 2018 . [ 5 ] Frederic Lawrence Holmes , Jürgen Renn , and Hans - Jörg Rheinberger . Reworking the bench : Research notebooks in the history of science . Springer Science & Business Media , 2006 . [ 6 ] SamanthaKanza , CerysWilloughby , NicholasGibbins , RichardWhitby , Jeremy Graham Frey , Jana Erjavec , Klemen Zupančič , Matjaž Hren , and Katarina Kovač . Electronic lab notebooks : can they replace paper ? Journal of Cheminformatics , 9 ( 1 ) : 31 , 2017 . [ 7 ] Alan C . Kay . The Early History of Smalltalk , page 511 – 598 . Association forComputingMachinery , NewYork , NY , USA , 1996 . ISBN0201895021 . URL https : / / doi . org / 10 . 1145 / 234286 . 1057828 . [ 8 ] Mary Beth Kery , Marissa Radensky , Mahima Arya , Bonnie E . John , and Brad A . Myers . The story in the notebook : Exploratory data science using a literate programming tool . In Proceedings of the 2018 CHI Conference on Human Factors in Computing Systems , page 1 – 11 , 2018 . doi : 10 . 1145 / 3173574 . 3173748 . [ 9 ] Thomas Kluyver , Benjamin Ragan - Kelley , Fernando Pérez , Brian E Granger , Matthias Bussonnier , Jonathan Frederic , Kyle Kelley , Jessica B Hamrick , Jason Grout , Sylvain Corlay , et al . Jupyter notebooks - a pub - lishing format for reproducible computational workflows . In ELPUB , pages 87 – 90 , 2016 . [ 10 ] Donald Ervin Knuth . Literate programming . The Computer Journal , 27 ( 2 ) : 97 – 111 , 1984 . [ 11 ] Andrew J . Ko , Robin Abraham , Laura Beckwith , Alan Blackwell , Margaret Burnett , Martin Erwig , Chris Scaffidi , Joseph Lawrance , Henry Lieberman , Brad Myers , Mary Beth Rosson , Gregg Rother - mel , Mary Shaw , and Susan Wiedenbeck . The state of the art in 6 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 Notes on Notebooks : Is Jupyter the Bringer of Jollity ? Conference’17 , July 2017 , Washington , DC , USA 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 end - user software engineering . ACM Comput . Surv . , 43 ( 3 ) , 2011 . doi : 10 . 1145 / 1922649 . 1922658 . [ 12 ] David Koop and Jay Patel . Dataflow notebooks : encoding and tracking dependencies of cells . In 9th USENIX Workshop on the Theory and Practice of Provenance ( TaPP 2017 ) , 2017 . [ 13 ] Friedrich Leisch . Sweave : Dynamic generation of statistical reports using literate data analysis . In Compstat , pages 575 – 580 , 2002 . [ 14 ] John McCarthy . History of LISP . SIGPLAN Not . , 13 ( 8 ) : 217 – 223 , August 1978 . doi : 10 . 1145 / 960118 . 808387 . [ 15 ] Hisham Muhammad . Userland : creating an integrated dataflow envi - ronment for end - users , 2019 . [ 16 ] James Noble and Robert Biddle . Notes on notes on postmodern pro - gramming : Radio edit . In Companion to the 19th Annual ACM SIGPLAN Conference on Object - Oriented Programming Systems , Languages , and Applications , page 112 – 115 , 2004 . doi : 10 . 1145 / 1028664 . 1028710 . [ 17 ] Peter Parente . Estimate of public Jupyter notebooks on github , 2014 . https : / / github . com / parente / nbestimate . [ 18 ] Jeffrey M Perkel . Why Jupyter is data scientists’ computational note - book of choice . Nature , 563 ( 7732 ) : 145 – 147 , 2018 . [ 19 ] Stephen R Piccolo and Michael B Frampton . Tools and techniques for computational reproducibility . GigaScience , 5 ( 1 ) , 07 2016 . doi : 10 . 1186 / s13742 - 016 - 0135 - 4 . [ 20 ] J . F . Pimentel , L . Murta , V . Braganholo , and J . Freire . A large - scale study about quality and reproducibility of Jupyter notebooks . In 2019 IEEE / ACM 16th International Conference on Mining Software Reposito - ries ( MSR ) , pages 507 – 517 , 2019 . [ 21 ] Adam Rule , Aurélien Tabard , and James D . Hollan . Exploration and explanation in computational notebooks . In Proceedings of the 2018 CHI Conference on Human Factors in Computing Systems , page 1 – 12 , 2018 . doi : 10 . 1145 / 3173574 . 3173606 . [ 22 ] Adam Rule , Amanda Birmingham , Cristal Zuniga , Ilkay Altintas , Shih - Cheng Huang , Rob Knight , Niema Moshiri , Mai H Nguyen , Sara Brin Rosenthal , Fernando Pérez , et al . Ten simple rules for writing and shar - ing computational analyses in Jupyter notebooks . PLoS computational biology , 15 ( 7 ) , 2019 . [ 23 ] David Schmüdde . How to version control Jupyter notebooks , 2019 . https : / / nextjournal . com / schmudde / how - to - version - control - jupyter . [ 24 ] Helen Shen . Interactive notebooks : Sharing the code . Nature , 515 ( 7525 ) : 151 – 152 , 2014 . [ 25 ] James Somers . The scientific paper is obsolete . The Atlantic , 4 , 2018 . [ 26 ] B . Vasilescu , V . Filkov , and A . Serebrenik . Stackoverflow and github : Associations between software development and crowdsourced knowl - edge . In 2013 International Conference on Social Computing , pages 188 – 195 , 2013 . [ 27 ] Greg Wilson , Fernando Perez , and Peter Norvig . Teaching computing with the IPython notebook ( abstract only ) . In Proceedings of the 45th ACM Technical Symposium on Computer Science Education , page 740 , 2014 . doi : 10 . 1145 / 2538862 . 2539011 . [ 28 ] Yihui Xie . knitr : A general - purpose tool for dynamic report generation in R , 2013 . 7