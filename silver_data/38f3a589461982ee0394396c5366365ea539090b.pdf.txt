Software Development with Real - Time Collaborative Editing by Max Goldman S . B . , Massachusetts Institute of Technology ( 2004 ) M . S . , Technion - Israel Institute of Technology ( 2006 ) Submitted to the Department of Electrical Engineering and Computer Science in partial fulﬁllment of the requirements for the degree of Doctor of Philosophy at the MASSACHUSETTS INSTITUTE OF TECHNOLOGY September 2012 © Massachusetts Institute of Technology 2012 . All rights reserved . Author . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Department of Electrical Engineering and Computer Science August 30 , 2012 Certiﬁed by . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Robert C . Miller Associate Professor Thesis Supervisor Accepted by . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Leslie A . Kolodziejski Professor Chair , Department Committee on Graduate Students 2 Software Development with Real - Time Collaborative Editing by Max Goldman Submitted to the Department of Electrical Engineering and Computer Science on August 30 , 2012 , in partial fulﬁllment of the requirements for the degree of Doctor of Philosophy Abstract This thesis presents Collabode , a web - based integrated development environment for Java . With real - time collaborative editing , multiple programmers can use Collabode to edit the same source code at the same time . Collabode introduces error - mediated integration , where multiple editors see the text of one another’s changes while being isolated from errors and in - progress work , and error - free changes are integrated auto - matically . Three models of collaborative programming are presented and evaluated using Collabode . Classroom programming brings zero - setup web - based programming to computer science students working in a classroom or lab . Test - driven pair program - ming combines two existing software development strategies to create a model with clear roles and explicit tool support . And micro - outsourcing enables one programmer to easily request and integrate very small contributions from many distributed assis - tants , demonstrating how a system for highly - collaborative programming enables a development model infeasible with current tools . To show that highly - collaborative programming , using real - time collaborative edit - ing of source code , is practical , useful , and enables new models of software develop - ment , this thesis presents a series of user studies . A study with pairs of both student and professional programmers shows that error - mediated integration allows them to work productively in parallel . In a semester - long deployment of Collabode , students in an MIT software engineering course used the system for classroom programming . In a lab study of a Collabode prototype , professional programmers used test - driven pair programming . Finally , a study involving both in - lab participants and contractors hired online demonstrated how micro - outsourcing allowed participants to approach programming in a new way , one enabled by collaborative editing , automatic error - mediated integration , and a web - based environment requiring no local setup . Thesis Supervisor : Robert C . Miller Title : Associate Professor 3 4 Acknowledgments Stephen Benton , Holographic Imaging My advisor , Rob Miller . The other members of my thesis committee , Daniel Jackson and Li - Te Cheng . Greg Little . Angela Chang , Patrick Yamane , and Robin Cheng , who contributed to this project . All the members of the User Interface Design Group : Michael Bernstein , Adam Marcus , Katrina Panovich , Igor Kopylov , Vikki Fritz , Matthew Webber , Juho Kim , Lydia Chilton , Chen - Hsiang Yu , Tom Lieber , Mason Tang , David Huynh , Eirik Bakke , Max Van Kleek , Tsung - Hsiang Chang , Sangmok Han , Michael Bolin , and all those I have failed to mention . Many other researchers at CSAIL and elsewhere : Eunsuk Kang , Eugene Wu , Hubert Pham , Andrew Begel , Jeﬀ Bigham , Joel Brandt , Elena Agapie—and all those I have still failed to mention . My academic advisor , Silvio Micali . And my master’s degree advisor at the Technion , Shmuel Katz . Other professors , lecturers , recitation instructors , teaching assistants , lab assis - tants , and teachers far too numerous to mention . Maria Rebelo and Sally Lee , administrative assistants . Jack Costanza , Anthony Zolnik , and the other members of The Infrastructure Group at CSAIL . Tayeb Karim , Jay Goldman , Adam Marcus , and Matti Klock , all instrumental in organizing user studies . The many people who participated in those studies . Yaron Binur , Anat Binur , Theodore Golﬁnopoulos , and other MEET staﬀ and students too numerous to mention . Michael Ouellette . David Signoﬀ , Michael Zhivich , Alex Hill , Lisa Messeri , and others . My parents Marianne and Jay , my sister Julie , and my family ; Alice Reyzin . 5 This work was supported in part by the National Science Foundation under award numbers IIS - 0447800 and SOCS - 1111124 , and by Quanta Computer as part of the T - Party Project . oDesk Research provided funding to hire contractors . Any opinions , ﬁndings , conclusions , or recommendations in this thesis are the author’s , and they do not necessarily reﬂect the views of the sponsors . 6 Contents 1 Introduction 17 1 . 1 Collabode : A Web IDE . . . . . . . . . . . . . . . . . . . . . . . . . . 17 1 . 2 Error - Mediated Integration . . . . . . . . . . . . . . . . . . . . . . . . 18 1 . 3 Models of Collaborative Programming . . . . . . . . . . . . . . . . . 19 1 . 4 Contributions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20 1 . 4 . 1 A Web - Based Collaborative IDE . . . . . . . . . . . . . . . . 20 1 . 4 . 2 Novel Applications . . . . . . . . . . . . . . . . . . . . . . . . 21 1 . 5 Outline . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21 2 Related Work 23 2 . 1 Programming Methodologies . . . . . . . . . . . . . . . . . . . . . . . 23 2 . 1 . 1 Pair Programming . . . . . . . . . . . . . . . . . . . . . . . . 23 2 . 1 . 2 Side - by - Side Programming . . . . . . . . . . . . . . . . . . . . 25 2 . 1 . 3 Chief Programmer Teams . . . . . . . . . . . . . . . . . . . . 25 2 . 2 Collaborative Editing . . . . . . . . . . . . . . . . . . . . . . . . . . . 26 2 . 3 Development Tools . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26 3 Collabode 29 3 . 1 Architecture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30 3 . 2 IDE User Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 3 . 3 Error - Mediated Integration . . . . . . . . . . . . . . . . . . . . . . . . 33 3 . 3 . 1 From One to Many . . . . . . . . . . . . . . . . . . . . . . . . 34 3 . 3 . 2 Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37 7 3 . 3 . 3 Merging and Transforming Edits . . . . . . . . . . . . . . . . 39 3 . 3 . 4 Editing Edits . . . . . . . . . . . . . . . . . . . . . . . . . . . 40 3 . 3 . 5 Initial Conditions . . . . . . . . . . . . . . . . . . . . . . . . . 41 3 . 3 . 6 Limitations and Assumptions . . . . . . . . . . . . . . . . . . 42 3 . 3 . 7 Implementation with Coordinate Maps . . . . . . . . . . . . . 43 3 . 3 . 8 User Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . 45 3 . 4 Evaluation : Comparison to Manual Integration . . . . . . . . . . . . 47 3 . 5 Evaluation : Side - by - Side Programming . . . . . . . . . . . . . . . . . 48 3 . 5 . 1 Procedure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48 3 . 5 . 2 Does the Set of Un - Integrated Regions Remain Small ? . . . . 50 3 . 5 . 3 Is the Algorithm an Improvement Over Integrating Only Error - Free Code ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51 3 . 5 . 4 Can Developers Work Concurrently ? . . . . . . . . . . . . . . 52 3 . 5 . 5 Feedback : Collaborative Coding . . . . . . . . . . . . . . . . . 53 3 . 5 . 6 Feedback : Automatic Integration . . . . . . . . . . . . . . . . 54 3 . 5 . 7 Feedback : Missing Pieces . . . . . . . . . . . . . . . . . . . . . 55 3 . 6 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56 4 Classroom Programming 59 4 . 1 Inspiration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60 4 . 2 6 . 005 Recitations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61 4 . 2 . 1 Cloning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62 4 . 2 . 2 Deployment . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62 4 . 2 . 3 To Each His Clone . . . . . . . . . . . . . . . . . . . . . . . . 63 4 . 2 . 4 Show and Tell . . . . . . . . . . . . . . . . . . . . . . . . . . . 63 4 . 2 . 5 Collaboration . . . . . . . . . . . . . . . . . . . . . . . . . . . 64 4 . 3 Mobile Instructor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65 4 . 4 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66 5 Test - Driven Pair Programming 67 5 . 1 Prototyping the Model . . . . . . . . . . . . . . . . . . . . . . . . . . 68 8 5 . 1 . 1 Procedure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68 5 . 1 . 2 Visualizing Programming Sessions . . . . . . . . . . . . . . . . 70 5 . 1 . 3 Examining Cooperation . . . . . . . . . . . . . . . . . . . . . 71 5 . 1 . 4 Examining Modes . . . . . . . . . . . . . . . . . . . . . . . . . 75 5 . 1 . 5 Developer Feedback . . . . . . . . . . . . . . . . . . . . . . . . 76 5 . 1 . 6 Design Implications . . . . . . . . . . . . . . . . . . . . . . . . 78 5 . 2 Test Lifecycle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78 5 . 3 User Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79 5 . 4 Jacto : JUnit AspectJ Coverage Tool . . . . . . . . . . . . . . . . . . 82 5 . 5 Formative Evaluation . . . . . . . . . . . . . . . . . . . . . . . . . . . 83 5 . 5 . 1 Procedure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83 5 . 5 . 2 Programming . . . . . . . . . . . . . . . . . . . . . . . . . . . 84 5 . 5 . 3 Developer Feedback . . . . . . . . . . . . . . . . . . . . . . . . 85 5 . 6 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87 6 µoutsourcing 89 6 . 1 Prototyping the Model . . . . . . . . . . . . . . . . . . . . . . . . . . 89 6 . 1 . 1 Laziness , Impatience , and Hubris . . . . . . . . . . . . . . . . 90 6 . 1 . 2 Breadth and Depth . . . . . . . . . . . . . . . . . . . . . . . . 91 6 . 1 . 3 Integrating Work . . . . . . . . . . . . . . . . . . . . . . . . . 92 6 . 2 User Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92 6 . 3 Instawork . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94 6 . 4 User Study . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96 6 . 4 . 1 Crowd Programmers . . . . . . . . . . . . . . . . . . . . . . . 96 6 . 4 . 2 Original Programmers . . . . . . . . . . . . . . . . . . . . . . 98 6 . 4 . 3 Procedure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98 6 . 4 . 4 Outsourced Work . . . . . . . . . . . . . . . . . . . . . . . . . 100 6 . 4 . 5 Specifying Tasks . . . . . . . . . . . . . . . . . . . . . . . . . 104 6 . 4 . 6 Work in Progress . . . . . . . . . . . . . . . . . . . . . . . . . 107 6 . 4 . 7 Management and Communication . . . . . . . . . . . . . . . . 109 9 6 . 4 . 8 Task Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112 6 . 4 . 9 Prospects for µoutsourcing . . . . . . . . . . . . . . . . . . . . 114 6 . 4 . 10 Design Implications . . . . . . . . . . . . . . . . . . . . . . . . 118 6 . 5 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119 7 Future Work 121 7 . 1 Collaborative Real - Time Software Development . . . . . . . . . . . . 121 7 . 2 Error - Mediated Integration . . . . . . . . . . . . . . . . . . . . . . . . 122 7 . 3 Models of Collaborative Programming . . . . . . . . . . . . . . . . . 123 7 . 4 Changing the Game . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124 8 Conclusion 127 10 List of Figures 1 - 1 The Collabode web - based IDE for Java allows multiple programmers to work together on the same code . The top window shows three programmers editing HelloWorld . java on the right , with feedback from unit tests on the left . In the bottom window is console output from running the program . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18 3 - 1 The Collabode web - based IDE allows multiple programmers to work together using a familiar interface and tooling . . . . . . . . . . . . . . 30 3 - 2 High - level overview of the Collabode server - side system architecture . Highlighted components are original development . EtherPad was heav - ily modiﬁed . Other components are frameworks . . . . . . . . . . . . . 31 3 - 3 Alice and Bob are working concurrently to deﬁne methods a and b . ( a ) The view copy contains all of their changes , shown here from Bob’s perspective : his un - integrated change is in yellow , with an outgoing arrow ; Alice’s is in gray , with an incoming arrow . ( b ) Alice’s working copy and ( c ) Bob’s working copy contain only their own changes . ( d ) The master copy does not reﬂect their work - in - progress , since both of their changes still contain errors . . . . . . . . . . . . . . . . . . . . . 36 3 - 4 After Alice and Bob ﬁnish deﬁning methods a and b , the view copy , both working copies , and the master copy will all contain the same , error - free code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37 11 3 - 5 Alice is working on method a while Bob has completed b . ( a ) The view copy contains all of their changes , shown here from Bob’s per - spective : Alice’s un - integrated change is in gray . ( b ) Alice’s working copy contains Bob’s completed code in addition to her own , but ( c ) Bob’s working copy does not contain Alice’s work - in - progress . ( d ) The master copy contains Bob’s completed error - free code . . . . . . . . . . 39 3 - 6 Bob has made an edit to Alice’s in - progress work on method a . The edit is merged with Alice’s , so ( a ) the view copy from Bob’s perspective shows the entire in - progress method in gray . ( b ) Alice’s working copy contains Bob’s edit , while ( c ) Bob’s working copy does not . ( d ) The master copy does not reﬂect their work - in - progress . . . . . . . . . . . 42 3 - 7 Visualization of the coordinate mapping between the view copy , Alice’s working copy , Bob’s working copy , and the master copy after Alice and Bob have started to deﬁne methods a and b . . . . . . . . . . . . . . . 44 3 - 8 Bob’s view of a collaboration with Alice : ( a ) Hello . java as both he and Alice begin adding to the main method ; ( b ) after he edits the initial println , and his change is immediately integrated ; ( c ) and after Alice completes her contribution , which is also automatically integrated . . . 46 3 - 9 The output from running the program after Alice and Bob’s collabo - ration : changes on lines 3 and 4 are integrated , but the unﬁnished line 5 exists only in Bob’s working copy . . . . . . . . . . . . . . . . . . . . 46 5 - 1 An example of the timeline visualization ( approximately 90 seconds of Pair 2 , Task 3 ) with various features called out . Each vertical bar represents a browser tab : (cid:4) empty , (cid:4) Collabode , (cid:4) Google , (cid:4) Python docs , (cid:4) Wikipedia , or (cid:4) other . . . . . . . . . . . . . . . . . . . . . . 71 5 - 2 A segment of one programming session ( Pair 3 , Task 3 ) summarized in the timeline visualization , highlighting several diﬀerent cooperation episodes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72 12 5 - 3 An excerpt of a debug work product cooperation episode from one programming session ( Pair 1 , Task 2 ) summarized in the timeline vi - sualization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72 5 - 4 Durations of cooperation episodes by type . Dot indicates median , dia - mond indicates arithmetic mean , dotted lines are standard error , and red circles show minimum and maximum . . . . . . . . . . . . . . . . . 74 5 - 5 Total time spent in cooperation episodes . Diamonds indicate session length ; unshaded time was spent not in a cooperation episode . . . . . 75 5 - 6 Total time spent in each programming mode . Diamonds indicate ses - sion length ; unshaded time could not be categorized . . . . . . . . . . 76 5 - 7 Implementer’s view of a collaboration , with @ NeedsImpl testB , passing @ Accepted testD and a regression in @ Accepted testE . . . . . . . . . 80 5 - 8 Tester’s view of a collaboration , with new testA and @ NeedsReview testC . The tester is using the code coverage panel to review the imple - mentation of testC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80 5 - 9 Tests written during the two TDPP sessions . Width indicates test state : new , needs implementation , needs review , accepted . Color indicates test result : (cid:4) passed , (cid:4) assertion failed , (cid:4) exception or error . Horizontal scale shows time after the ﬁrst code edit of the session . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85 6 - 1 The original programmer’s view of a collaboration . The OP has the outsourcing dialog open and is writing a new request . The sidebar shows a new task ( grayed out ) , one in - progress , and one completed ( checked ) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93 6 - 2 The contribution view for a single task . The OP is viewing changes made by worker ‘glittle’ for the request to ﬁx the greetBob method . . 93 13 6 - 3 The worker’s view of a collaboration . The task request is displayed across the top of the browser window , with a button to press when work is complete . The chat panel is open , where the OP has replied to the worker’s question . . . . . . . . . . . . . . . . . . . . . . . . . . 94 6 - 4 An Instawork task oﬀer as it might appear in Google’s Gmail instant messaging interface , and a task conﬁrmation page . . . . . . . . . . . . 95 6 - 5 Locations of crowd programmers according to their oDesk proﬁles . . . 98 6 - 6 Histogram of task work time . 60 % of tasks were completed in 15 min - utes or less , 75 % in 20 or less . . . . . . . . . . . . . . . . . . . . . . . 100 6 - 7 Partially - or fully - authored lines written by OPs ( numbered ) and work - ers ( lettered ) during each session . . . . . . . . . . . . . . . . . . . . . 101 6 - 8 Histogram of task success as rated by OPs . Each bar shows worker success ratings for those tasks , which roughly agree with OP ratings . 102 6 - 9 Tasks plotted according to work time and number of chat messages , categorized by OP ( top ) and worker ( bottom ) success ratings . Margin lines show median work times and message counts for tasks with each rating . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103 6 - 10 OP self - reported estimates of time spent ( normalized ) , showing a per - ceived median 50 % of session time spent outsourcing , managing , re - viewing , and ﬁxing ; oﬀset by a median 32 % of time working in parallel with crowd programmers ( CPs ) . . . . . . . . . . . . . . . . . . . . . . 109 6 - 11 OP post - session responses to : “How comfortable did you feel working with recruited programmers during this session ? ” . . . . . . . . . . . 111 6 - 12 Worker ratings for ( a ) how much they would want to work on a hy - pothetical oDesk micro - outsourcing platform , and ( b ) whether they would want to work in the future on tasks similar to the ones they received during the study . . . . . . . . . . . . . . . . . . . . . . . . . 117 14 List of Tables 3 . 1 Per - session and mean statistics from the side - by - side programming user study . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50 15 16 Chapter 1 Introduction When it comes to working together on code , software developers collaborate almost exclusively using one of two strategies : editing a single copy of the code using a single integrated development environment ( IDE ) ; or editing separate copies in parallel , integrating their eﬀorts using a source code version control system . Neither approach , however , is ideal for close collaboration where multiple programmers are actively contributing to the same piece of code . Using a single IDE ( e . g . for pair programming ) means only the programmer who controls the keyboard and mouse can navigate , search , and write code . Using version control requires programmers to manually push and pull changes , while striving to avoid merge conﬂicts that require manual resolution . This thesis examines real - time collaborative editing of source code as an alternative approach that enables close collaboration . 1 . 1 Collabode : A Web IDE Collabode is a web - based IDE for Java designed to support close collaboration where multiple programmers work together simultaneously on the same code ( Figure 1 - 1 ) . In Collabode , changes can be shared immediately , without the manual overhead of version control , and each programmer can navigate the code independently , without the need to share a single view . As web - based programming environments become increasingly common ( e . g . Cloud9 , cloud9ide . com ) , close real - time collaboration , 17 Figure 1 - 1 : The Collabode web - based IDE for Java allows multiple programmers to work together on the same code . The top window shows three programmers editing HelloWorld . java on the right , with feedback from unit tests on the left . In the bottom window is console output from running the program . of the style embodied by many popular web applications ( e . g . Google Docs , docs . google . com ) will be an important new way that programmers work together . One beneﬁt of implementing Collabode as a web application is that new program - mers can join a project and immediately start working together simply by visiting the same URL . There is no need to check out code or set up a local development environment . When deployed in 25 - person recitations in a class on software engineer - ing , for example , this allowed the instructors to quickly have students working on individual and small group programming exercises ( Chapter 4 ) . And in a 30 - person study of collaborative programming with Collabode , participants could jump into an in - progress project with only a short tutorial and no local setup ( Chapter 6 ) . 1 . 2 Error - Mediated Integration Real - time collaborative editing alone works well for text documents , but source code presents additional challenges . Programmers expect to receive feedback , such as errors and warnings ; use tools , such as code completion ; and take actions , such as running 18 or testing the code , all of which may be disrupted by a collaborator’s unﬁnished work . In order to make the simultaneous editing in Collabode useful , error - mediated integration ( EMI ) provides an experience akin to automated version control : multiple programmers can work in parallel , aware of one another’s work , but not disrupted by one another’s bugs . Error - mediated integration was understood and appreciated by participants in lab study designed to evaluate it directly , then taken for granted in studies where it was only mentioned to participants in passing . EMI works by tracking new edits from diﬀerent programmers who are editing the same shared code ﬁle . As long as those edits introduce errors , they are visible to other programmers , but they are not part of the working copy of the code used to generate feedback—errors , code completion , etc . —for those programmers . Once a set of edits can be integrated error - free , the integration occurs automatically . In the simple case , this allows programmer Alice to work on , say , line 30 of a ﬁle even while programmer Bob introduces nasty syntax errors on line 10 . Alice can see what Bob is working on but isn’t aﬀected by his broken work in progress . But if Alice asks for Bob’s help , say a ﬁx on line 20 , Bob can make that ﬁx and the change is integrated with no manual work . Without EMI , Bob might have to ﬁrst “stash” away his work on line 10 , or pick out the change on line 20 from a diﬀ . By eliminating manual change - management activities , EMI helps collaborative programming work and feel like a natural extension of individual programming . 1 . 3 Models of Collaborative Programming The future of collaboration in software development will include new models of collab - orative work enabled by systems designed for close collaboration on the same modules of code . This thesis explores three : Classroom Programming : Deployed in recitations for a software engineering class , students used Collabode for individual and group programming exercises . In - structors were able to view student work immediately and were excited about the possibility of designing exercises around close collaboration . 19 Test - Driven Pair Programming : This model combines the practices of pair pro - gramming [ 3 ] with test - driven development . In test - driven development , devel - opers follow two rules : “write new code only if an automated test has failed , ” and “eliminate duplication” [ 4 ] , with short , rapid development cycles as a result . In the test - driven pair programming model , the process of test - driven develop - ment is parallelized , with one member of the pair working primarily on tests , while the other works primarily on implementation . Collabode implements con - tinuous test execution [ 43 ] to enable this model . Micro - Outsourcing : In this model , one programmer draws on the distributed ex - pertise of a crowd of other programmers who make small contributions to the project . Micro - outsourcing allows the original programmer to remain “in the ﬂow” at one level of abstraction or in one critical part of the code , while a crowd of assistants ﬁll in the details or “glue” code elsewhere in the module or project . In contrast to traditional outsourcing , which typically operates at the granularity of a whole module or project , micro - outsourcing requires a highly collaborative development environment and user interface support to make the collaboration eﬀective for both original programmer and workers . 1 . 4 Contributions The thesis of this dissertation is that highly - collaborative programming with real - time collaborative editing of source code becomes practical and useful with the addition of error - mediated integration , and it enables new models of software development where programmers work together more closely than before . Micro - outsourcing in particular is infeasible without a system designed for collaboration at micro - scale . 1 . 4 . 1 A Web - Based Collaborative IDE To demonstrate how highly - collaborative programming is practical , the Collabode IDE implements real - time collaborative editing for the Java programming language . 20 Laboratory studies and classroom usage demonstrate that working with multiple si - multaneous editors is practical—by being put into practice . The design and implementation of Collabode will hopefully prove a useful case study for future work on collaborative programming tools . Collabode combines server - side compilation , tool support , and program execution ; a client - server real - time collaborative editing architecture ; and a client side code editor and user inter - face . Error - mediated integration controls how changes by multiple programmers are shared without causing interference . The system is open source at github . com / uid / collabode . 1 . 4 . 2 Novel Applications Evaluation of the three programming models described above—classroom program - ming , test - driven pair programming , and micro - outsourcing—shows that all three can be useful , and all three are supported in novel ways by a highly - collaborative IDE . In the largest study presented in this thesis , programmers were able to coordi - nate the work of collaborators who , in less than 15 minutes , joined , understood , and contributed to a project they could edit and run with zero setup cost . Collabode is a new tool that enables new work practices , which are diﬃcult to explore in the span of only a few hours ( or in the case of one study , a single academic semester ) . In addition to all the usual mental demands of programming , study par - ticipants must also tackle the learning curve of a new way of working , with only a brief introduction from experimenters . But the evaluations can and do demonstrate the potential of these models and the value of further research . 1 . 5 Outline Chapter 2 discusses related work on programming methodologies and collaborative tools . Chapter 3 presents the design and implementation of Collabode , a collaborative web - based IDE for Java . Chapters 4 through 6 present three programming models that take advantage of highly - collaborative programming . These models are evaluated 21 in studies using Collabode . Chapter 7 discusses future work , and Chapter 8 concludes . Assuming this document has not reached you on the pulped ﬁbers of dead trees , your PDF viewer might be able to display an outline of chapters and sections , and the table of contents entries should be navigable hyperlinks . 22 Chapter 2 Related Work Real - time collaborative editing has a long ( by computer science standards ) history of research in the computer - supported cooperative work community , going back to Engelbart’s famous “mother of all demos” [ 20 ] where he demonstrated remote col - laboration on a shared screen . Programming methodologies and tools naturally also have a long history , as both academics and practitioners of computer science try to understand how humans might best practice software engineering . 2 . 1 Programming Methodologies Several existing models of collaborative programming inspired the work in this thesis , and a dissatisfaction with the current understanding of and prescriptions for pair programming was an initial motivation for the project . 2 . 1 . 1 Pair Programming Pair programming is the practice of having two programmers work together on the same code in a single development environment . The goals of pair programming are to improve communication and the sharing of knowledge within a team ; to increase productivity ; to improve developer process and help team members stay productive ; and ultimately to strengthen the quality of the resulting software [ 3 ] . Various studies 23 support these claims : in their analytical comparison of solo and pair programming [ 17 ] , Dawande et al . cite a number of studies validating pair programming’s reduction of developer eﬀort , software errors , and code complexity . Bryant et al . investigated programmers’ roles in a pair [ 11 ] and cite several of the same studies , as well as evidence that programming in a pair could reduce errors of conﬁrmation bias or incorrect mental models . Williams et al . presented a case based on experimental results [ 56 ] . Werner et al . reported on the beneﬁts of pair programming for women in undergraduate computer science programs [ 55 ] . The most common structure prescribed for pair programming is a division of labor between driver and navigator , where “one partner , the one with the keyboard and the mouse , is thinking about the best way to implement this method right here , ” and “the other partner is thinking more strategically , ” about the overall problem and the pair’s approach to solving it [ 3 ] . But evidence for this structure in practice is inconsistent . Driver - navigator structure was not found by Bryant or by Höfer in studies of stu - dent pair programmers [ 9 , 29 ] , nor by Bryant et al . in their study of pair programmer verbalizations [ 11 ] , where the “navigator” appeared to act neither as a “reviewer” who “reviews the code that the driver is typing in , pointing out any syntax and spelling errors , ” nor as a “foreman” who “thinks about the overall structure of the code - base and whether the code is solving the business problem” while the partner codes with a narrow focus . Chong and Hurlbutt did not ﬁnd driver and navigator roles in their ethnographic study of two software development teams , writing : “pair programmers did not think on diﬀerent levels of abstraction while working ; instead they moved across these levels of abstraction together” [ 15 ] . They quote Bryant , who points out that “one might question how it would even be possible for two people working at diﬀerent levels of abstraction to successfully sustain a conversation at all” [ 10 ] , and suggests that we must “move beyond the ‘driver’ and the ‘navigator’ ” as canonical pair programming roles , as well as design pair programming tools and practices that “help programmers stay focused and engaged . ” 24 2 . 1 . 2 Side - by - Side Programming In his Crystal Clear methodology , Cockburn proposes side - by - side programming , where “two people sit close enough to see each others’ screens easily , but work on their own assignments” as a ﬂexible arrangement suitable for pair programming , solo program - ming , and low - overhead collaboration between those extremes [ 16 ] . Prechelt et al . documented a variety of diﬀerent purposes behind collaborative episodes between side - by - side programmers [ 40 ] , discussed in more detail in Chapter 5 . The side - by - side programming style of interaction can also be supported remotely . Dewan et al . found that a remote analog to side - by - side programming allowed pro - grammers to collaborate with one or both of them browsing through the code , rather than only edit or watch their parter edit [ 19 ] . Collabode was designed to realize this same beneﬁt . 2 . 1 . 3 Chief Programmer Teams Asking how to reconcile the desire for clarity and eﬃciency ( best served by a small team ) with the need to tackle large projects ( only feasible with a large team ) , Brooks describes the surgical team approach to software development [ 8 ] , credited to Mills and Baker who call them chief programmer teams [ 36 , 1 ] . In this proposal , the chief programmer is responsible for designing , implementing , testing , and documenting a project , but he or she draws on the expertise of a team of specialists who take on a variety of roles : a co - pilot who advises , a language lawyer who optimizes , a tester who crafts tests and test data , an editor who copyedits documents , and so on . The notion of a chief programmer is similar to the original programmer proposed for micro - outsourcing in Chapter 6 , who also takes ultimate responsibility for the entire project and oversees the contributions of many subordinates . Micro - outsourcing is a more ﬂexible model , both in that any number of specialist roles might be invented in the course of a project , and in that subordinates may have a much more active code - writing role than chief programmer teams prescribe . It shares , however , the goal of allowing for clarity of design while providing additional programmer - power . 25 2 . 2 Collaborative Editing In a system for real - time collaboration , a protocol is required that allows multiple users to make changes concurrently . Operational transform ( reviewed in [ 50 ] ) is the technique for maintaining a consistent view of the shared document that underlies most real - time collaborative editing systems , including Collabode . When multiple users make concurrent edits to the document , their individual edit operations are transformed to take place in a serial order . Previous work in collaborative editing systems has examined the problem of main - taining semantic consistency , for example in graphic design [ 7 ] and hierarchical doc - uments [ 32 ] . In the context of software development , change impact analysis computes the set of unit tests impacted by a collection of code changes [ 42 ] and was implemented in Chianti [ 41 ] ; and safe - commit analysis determines code changes that can safely be committed to version control without breaking tests [ 57 ] . Those authors also demonstrated the JUnitMX tool , which enhances the JUnit testing framework with feedback to assist programmers in writing unit tests that cover any changes they make to existing code [ 58 ] . Also closely - related is the use of data dependencies and program slicing to perform semantic interference detection between changes made in parallel [ 49 ] . 2 . 3 Development Tools There are a variety of commercial and open source systems for web - based program - ming , some of which integrate collaboration . Non - collaborative editing components : Ace ( ace . ajax . org , formerly Skywriter , formerly Mozilla Bespin ) , CodeMirror ( codemirror . net ) , and Ymacs ( ymacs . org ) are web - based code editing components designed to be embedded in an IDE or other application . They do not provide real - time collaboration . Non - collaborative IDEs : jsFiddle ( jsfiddle . net ) , CodeRun Studio ( coderun . com ) , 26 Kodingen ( kodingen . com ) , and Orion ( eclipse . org / orion ) are environments for web programming . All four oﬀer collaboration mediated by copying or version control ; multiple programmers cannot edit the same ﬁles simultaneously . The Palm Ares environment ( ares . palm . com ) demonstrated an online graphical ap - plication development environment . Collaborative editing components : An early Collabode prototype used MobWrite ( code . google . com / p / google - mobwrite ) , and the current system uses EtherPad ( etherpad . org ) , to enable collaborative editing . Collaborative IDEs : Studio SketchPad ( sketchpad . cc ) uses EtherPad for collab - orative graphics programming . Cloud9 IDE ( cloud9ide . com ) includes real - time collaboration in their web - based development environment . Most recently , Google released their work on Collide ( code . google . com / p / collide ) , an IDE with real - time collaborative editing based on the Wave protocol ( waveprotocol . org ) . These environments do not yet attempt to address the problem of inter - ference between programmers working concurrently . Collaborative development environment research projects include Adinda [ 52 ] , a web - based editor backed by Eclipse , and CoRED [ 35 ] , a web - based Java IDE for de - veloping web applications . CoRED ( Collaborative Real - time EDitor ) uses diﬀerential synchronization [ 21 ] to enable collaborative editing , a technique in which clients and server exchange diﬀs rather than edit operations . This can result in edit conﬂicts when multiple editors manipulate the same region of text . CoRED does not address the problem of one programmer’s in - progress work interfering with a collaborator , but it does implement notes , which allow programmers to leave messages attached to locations in the code , and locks , where a programmer can obtain exclusive rights to edit a region of code . Flesce was one early implementation of a shared IDE to support authoring , testing , and debugging code [ 18 ] . The Jazz project [ 14 , 31 ] brought collaboration tools to Eclipse to support both awareness ( e . g . via annotated avatar and project item icons ) and joint work ( e . g . with instant messaging and screen sharing ) . Diﬀerent features 27 of Jazz provide developer support throughout the software development process [ 51 ] . The CollabVS tool for ad - hoc collaboration shares similar awareness and collabo - ration goals [ 27 ] , and the Sangam system was developed to support distributed pair programming [ 28 , 39 ] . Many other systems have focused on awareness features to keep loosely - collaborating software developers aware of others’ work , e . g . : Palantír [ 47 ] , Syde [ 26 ] , Saros [ 44 ] , CASI [ 48 ] , and YooHoo [ 30 ] . The current Collabode sys - tem omits many useful awareness features described in the literature in order to focus engineering eﬀort on the collaborative editing experience . 28 Chapter 3 Collabode Collabode is a web - based collaborative integrated development environment designed for experimenting with how programmers can write code in close collaboration with one another . Since the editor is a web application , programmers use a standard web browser to connect to a Collabode server that hosts their projects . The user interface is implemented in standard HTML and JavaScript and runs entirely in the browser . New programmers can join a project and immediately start working together simply by visiting the same URL . There is no need to check out code or set up a local development environment . This feature enables some of the new collaborative models discussed in the subsequent sections , and motivates the implementation of Collabode as a web application . Collabode uses EtherPad ( etherpad . org ) to support collaboration between multi - ple simultaneous editors . Any number of programmers can open the same ﬁle simul - taneously , and their concurrent changes are shared in near real - time to enable smooth collaboration whether they are working together remotely or at the same desk . On the server side , Collabode uses Eclipse ( eclipse . org ) to manage projects and power standard IDE services : syntax highlighting , continuous compilation , compiler errors and warnings , code formatting and refactoring , and execution . The system also supports continuous test execution [ 43 ] . Collabode currently supports Java editing , and any Eclipse Java project can be compiled and modiﬁed using the system ( in - cluding Collabode itself ) , with an interface familiar to anyone who has used Eclipse 29 Figure 3 - 1 : The Collabode web - based IDE allows multiple programmers to work together using a familiar interface and tooling . ( Figure 3 - 1 ) . Project code is executed on the server and clients can view console output , so Collabode is not currently suited for developing programs with desktop graphical user interfaces . As with source code , all collaborators can observe pro - gram output or open the console to view it after the fact , to support collaborative debugging . Portions of this chapter were published in the proceedings of UIST 2011 [ 23 ] . 3 . 1 Architecture Eclipse is widely known as a Java IDE , but the IDE components are built on top of a general application framework that manages plug - ins , individual modules that can provide standalone functionality or hook into extension points provided by other plug - ins to alter or extend their functionality . The Eclipse Java Development Toolkit ( JDT ) is a large collection of back end and user interface plug - ins that together make up the Eclipse IDE . Collabode is implemented as an Eclipse application , a plug - in that has additional control over the Eclipse framework startup . Collabode depends on various framework 30 EtherPaddatabase Eclipse workspace Eclipse Runtime AppJet Runtime Eclipse JDT File controller Error - mediated integration Continuous testing Working copy management other IDE backend modules Console controller other controllers Request handler EtherPad Figure 3 - 2 : High - level overview of the Collabode server - side system architecture . Highlighted components are original development . EtherPad was heavily modiﬁed . Other components are frameworks . and JDT plug - ins , and runs as a ( nearly ) headless instance of Eclipse . In practice , some of the JDT plug - ins Collabode uses require a display ( an X server , OS X Win - dowServer , etc . ) because their designers did not foresee using them without a native UI—syntax highlighting is one example . In this sense , Collabode pushes the bound - aries of how the JDT can be deployed in a server - side conﬁguration with the current version of Eclipse . Figure 3 - 2 shows the high - level architecture of Collabode on the server . Eclipse is implemented in Java , and Collabode runs in a single Eclipse - framework - managed Java virtual machine ( JVM ) . Many components of Collabode are implemented in Java . EtherPad is a real - time collaborative editor implemented on top of the AppJet framework . Both were released under an open source license when the AppJet com - pany was acquired by Google . AppJet is implemented in Java , Scala , and JavaScript , and provides a framework to implement web applications with server - side JavaScript . AppJet uses the Rhino JavaScript compiler and interpreter ( mozilla . org / rhino ) to run JavaScript on the JVM . In Collabode , the AppJet framework and EtherPad run inside the Eclipse JVM . For this reason , the system can use Rhino’s built - in cross - border calling to integrate 31 JavaScript and Java components . In Figure 3 - 2 , note that all incoming client requests are handled in JavaScript controllers which call directly up to Java components . EtherPad operates in terms of pads , database - backed documents identiﬁed by a unique ID . Eclipse operates in terms of ﬁles in a workspace directory hierarchy . In Collabode , both storage mechanisms are maintained , with each ﬁle in the workspace given a corresponding pad ( additional pads are used , for example , for console output ) . All new edits must be applied ﬁrst on the EtherPad pad , and changes are synchronized to Eclipse : the EtherPad pad storage component has been modiﬁed to notify the working copy management component which manipulates in - memory and on - disk workspace contents . With the exception of a few instances in which JavaScript components pass call - back functions to Java methods , the Java components of the system call JavaScript only asynchronously , using a task scheduling facility of AppJet . In general , both Eclipse and EtherPad are highly - concurrent systems , and Collabode adds additional concurrency . While there were a variety of engineering challenges in implementing Collabode , managing concurrency was the most pernicious . Eclipse , in particular , makes heavy use of locks , both exposed to API consumers and internal to plug - ins , presenting many opportunities for deadlock and requiring further layers of locking for thread safety . 3 . 2 IDE User Interface For basic development environment functions , Collabode was designed to mimic Eclipse . A sidebar on the left shows projects and ﬁles , and the text editor is on the right ( Figure 3 - 1 ) . Errors and warnings appear in the gutter along with line numbers . Code completion and “organize imports” ( for adding Java package import statements ) are designed to work like their Eclipse counterparts . Collabode uses the Eclipse syntax highlighter to show semantics - aware highlighting . The goal of the basic interface design of Collabode was to construct an environ - ment good enough for users to treat it as a programming environment where they 32 could do real work . In pilot experiments and a user study on an early Collabode prototype , with no syntax highlighting , error markers , code completion , etc . , users immediately had the reaction that they were using a ‘toy’ system . While laboratory study programming is inevitably less like systems programming and more like puzzle solving , this change in mindset was a troubling threat to external validity . Hopefully the IDE features of Collabode mitigate this threat to some degree . 3 . 3 Error - Mediated Integration Collaborative editing of source code ﬁles presents the particular problem that program errors introduced by one collaborator may disrupt the progress of their colleagues . Source ﬁles must conform to a particular programming language syntax and seman - tics , but it is impossible to expect users to maintain semantic validity throughout the coding process : almost any partially - written expression , statement , block , method , class , or program is likely to contain errors according to the parser or compiler . Structured editors [ 37 ] address this problem only at the signiﬁcant cost of requiring convoluted steps to make certain simple changes [ 54 ] , and most programmers do not use them . To see how errors introduced by one user can make it more diﬃcult for another user to continue , consider Alice , who is working on the following simple program : class Hello { int x ; void a ( ) { x = true ; } } Alice’s work contains an error , since the integer ﬁeld x cannot be assigned a boolean value . However , suppose another user—Bob—begins deﬁning a new method : class Hello { void b ( ) { int x ; void a ( ) { x = true ; } } 33 At this point the Eclipse compiler will report instead that “ x cannot be resolved to a variable , ” masking the true error from Alice because x now appears to be a local variable of Bob’s method b . The particular set of failure cases and their likelihood and severity will depend on the compiler . Eclipse attempts to prevent common problems such as unbalanced braces from generating opaque errors elsewhere , but it cannot always succeed . The problem is much worse in the case of running the program : although Eclipse will allow the programmer to launch an error - containing program , any attempt to execute an error - containing line will result in failure . This has the potential to pre - vent collaborating programmers from writing and testing their code incrementally , as was observed during pilot studies with both Python and Java programmers . Rather than constrain collaborating programmers to agree on and reach points at which the program is suﬃciently error - free for them to run it and test code in progress , the system instead accounts for the semantic content automatically in the synchronizing behavior . 3 . 3 . 1 From One to Many When a single programmer is working independently , we can distinguish between between three versions of the program source code , used for diﬀerent purposes , which may or may not be the same at diﬀerent points in time : Master copy : the source code used to compile and run the program . View copy : the source code that appears in the programmer’s editor . Working copy : the source code used to give feedback to the programmer . If this single programmer is using a basic text editor to work on the project , perhaps running the compiler manually : • The master copy is the code saved to disk , where the compiler can read it . • The view copy is the ( potentially unsaved ) code in the editor . 34 • The working copy is the same as the master copy , since the compiler is the only source of feedback , and the compiler only operates on the master copy . If the compiler reports errors e . g . as console output , those errors do not update as the view copy is modiﬁed . If , on the other hand , the programmer is using an IDE with a continuous compi - lation feature , such as Eclipse : • The master copy is still the code saved to disk ; only this code can be run . • The view copy is again the potentially unsaved code in the editor . • The working copy is now the same as the view copy : Eclipse is continuously attempting to compile the program and generate feedback immediately based on the in - progress source code ( with the caveat that this is a simpliﬁcation , since some feedback is generated only from the master copy ) . With naive collaborative editing , all users share the same master , working , and view copies , resulting in the problems discussed above . Those problems are a con - sequence in particular of the shared working copies—the source code used to give feedback to the programmers is the same for everyone . Therefore , in error - mediated integration : • The master copy remains the single copy of the code , saved to disk , that is used to compile and run the program . • The view copy is still a single copy of the code , which all collaborating pro - grammers will see and edit . • Instead of a single working copy , each programmer has a working copy which contains the text of the master copy plus changes introduced by that program - mer that are not yet shared with other programmers . If all programmers share the same view copy , but their working copies are diﬀerent , how does the system choose which changes in the view copy to apply to the master and other working copies ? In error - mediated integration , changes made to the view 35 ( a ) view copy , rendered for Bob public class Hello { String a ( ) { return " Alic } ( b ) Alice’s working copy public class Hello { String b ( ) { return " Bo } ( c ) Bob’s working copy public class Hello { } ( d ) master copy Figure 3 - 3 : Alice and Bob are working concurrently to deﬁne methods a and b . ( a ) The view copy contains all of their changes , shown here from Bob’s perspective : his un - integrated change is in yellow , with an outgoing arrow ; Alice’s is in gray , with an incoming arrow . ( b ) Alice’s working copy and ( c ) Bob’s working copy contain only their own changes . ( d ) The master copy does not reﬂect their work - in - progress , since both of their changes still contain errors . copy by each programmer are initially applied only to their own working copy . It is only after a change ( or a collection of changes ) is error - free that the change is integrated into the master copy , and into collaborators’ working copies . For example , consider a collaboration between Alice and Bob . The view copy will contain all changes applied by both of them , and the system renders it with highlighting and icons to indicate provenance . If Alice has begun deﬁning method a and Bob is writing method b , the view copy contains both in - progress methods , and both methods appear in the user interface ( Figure 3 - 3a ) . As long as their methods contain compilation errors , the working copies of Alice and Bob will each contain only their own method ( 3 - 3b & c ) and the master copy will contain neither ( 3 - 3d ) . To indicate that code has not been integrated into the master copy , it is highlighted for each user according to who wrote that code . In the ﬁgure , Bob sees his own un - 36 public class Hello { String a ( ) { return " Alice " ; } String b ( ) { return " Bob " ; } } Figure 3 - 4 : After Alice and Bob ﬁnish deﬁning methods a and b , the view copy , both working copies , and the master copy will all contain the same , error - free code . integrated change highlighted in yellow , with an outgoing arrow in the margin ; and he sees Alice’s change in gray , with an incoming arrow . Once their methods compile , their changes will be shared both with their collaborator’s working copy , and with the master copy , which is written to disk ( Figure 3 - 4 ) . It is this master copy that is run when either programmer elects to run the program . Except for instances discussed later where programmers force integration of error - containing code , the master copy is always free of compilation errors . 3 . 3 . 2 Algorithm Deﬁne an edit as a triple ( oﬀset , length , content ) where length characters at location oﬀset are removed from a document and replaced with new text content . Conven - tional additions and deletions are both special cases : an addition has zero length and nonempty content , and a deletion has nonzero length and empty content . Given n users , error - mediated integration ( EMI ) operates on several initially - identical ( or empty ) error - free documents : master , view , and working copies wc 1 , . . . , wc n . At all times , we can deﬁne view and the working copies in terms of master by considering the sequence E of edits that have been made to view but which the algorithm has not yet integrated into master : view = master with edits E wc u = master with edits (cid:104) e ∈ E | e authored by user u (cid:105) The algorithm maintains these invariants while attempting to integrate edits into master as follows : 37 • Each new edit e u from user u is displayed to all users in view , and is applied to wc u for computing the compilation errors to display to u . • e u is appended to sequence E of edits that have not been applied to master . • We ﬁnd the largest subsequence S of E such that when S are applied to master , the resulting code is error - free . This sequence may be empty , and need not be a continuous sequence of edits , or edits by only one author . • If S is nonempty , we apply each s ∈ S to master and therefore to all working copies where s was not already applied , and remove them from E . The result is that after each edit , we attempt to ﬁnd a largest subsequence of out - standing un - integrated edits that can be applied cleanly to the shared master copy , and apply those edits , if any . In the following sections , this basic outline of the al - gorithm is reﬁned by examining how edits are grouped together and transformed to apply to diﬀerent documents . In the example of the previous section , Figure 3 - 3 is the state with two un - integrated edits in E , because applying either or both of them would result in a compilation error : e 0 alice = append on line 2 : String a ( ) { return " Alic e 0 bob = append on line 3 : String b ( ) { return " Bo Suppose Bob makes an additional edit : e 1 bob = append on line 3 : b " ; } At this point , the algorithm will identify subsequence S = (cid:104) e 0 bob , e 1 bob (cid:105) of E that , when applied to master , results in no compilation errors . The state of each document will be updated to that of Figure 3 - 5 . 38 ( a ) view copy , rendered for Bob public class Hello { String a ( ) { return " Alic String b ( ) { return " Bob " ; } } ( b ) Alice’s working copy public class Hello { String b ( ) { return " Bob " ; } } ( c ) Bob’s working copy public class Hello { String b ( ) { return " Bob " ; } } ( d ) master copy Figure 3 - 5 : Alice is working on method a while Bob has completed b . ( a ) The view copy contains all of their changes , shown here from Bob’s perspective : Alice’s un - integrated change is in gray . ( b ) Alice’s working copy contains Bob’s completed code in addition to her own , but ( c ) Bob’s working copy does not contain Alice’s work - in - progress . ( d ) The master copy contains Bob’s completed error - free code . 3 . 3 . 3 Merging and Transforming Edits In our example , Alice and Bob were described as authoring only one or two edits , each of which contained several inserted characters . In practice , edits in Collabode are roughly the size of individual text operations , such as the insertion or deletion of a single character . The EtherPad component of Collabode is responsible for handling user edits to the text , which it does on as small a scale as possible in order to maintain synchronization of the shared view . EtherPad implements simultaneous editing ( using operational transform ) so that other components , including the error - mediated integration , see only a sequence of edits as deﬁned above . It would not be useful for EMI consider each of these character - sized edits in isolation : imagine integrating a subsequence of the characters in un deﬁned identiﬁer delegateAndNotifyOwner that happen to match one that is deﬁned , deleteNow . In 39 general , the algorithm should avoid picking out a random subset of edits that happen to be error - free , but which do not reﬂect the intentions of the programmers . Instead , adjacent edits are grouped together and are considered as a single , larger edit . Thus , e 0 alice and e 0 bob from the previous section would each have been the result of merging together many smaller edits . And rather than consider e 0 bob and e 1 bob separately , they would be merged into a single edit : e 0 (cid:48) bob = e 0 bob + e 1 bob = append on line 3 : String b ( ) { return " Bob " ; } So far , the examples have avoided mentioning the oﬀset coordinate of edits , be - cause a diﬀerent oﬀset is required to apply the same edit to diﬀerent documents— consider in Figure 3 - 5 applying e 1 bob to Alice’s working copy , where it appears at character oﬀset that includes Alice’s in - progress work , as opposed to Bob’s working copy or master , where it appears at a much smaller oﬀset . Operational transform is precisely the transform required : Bob’s edit e 1 bob , which is performed on view after e 0 alice , is transformed when applied to his working copy and to master as if it took place before e 0 alice . 3 . 3 . 4 Editing Edits Merging adjacent edits is straightforward when they are authored by the same user , but what if users decide to collaborate very closely ? For example , after Alice has made e 0 alice , suppose Bob adds to method a : ﬁx bob = append on line 2 : e and Bob " There are several possible design choices : Ownership : The system might consider these edits separately , and if e . g . Alice even - tually continued with an edit e 1 alice that appended the semicolon and close brace , the algorithm would successfully integrate S = (cid:104) e 0 alice , ﬁx bob , e 1 alice (cid:105) . But in gen - eral , it will never make sense to consider Bob’s changes to Alice’s code in the 40 context of his own working copy : the feedback will always be meaningless to Bob , and Alice won’t receive feedback at all . Contribution : The system might consider the edit as a contribution to Alice’s ex - isting edit , so that it creates a merged e 0 (cid:48) alice = e 0 alice + ﬁx bob owned by Alice . This is in fact how the system is implemented . It works well in the common case , where editors make small changes to their collaborators’ code , often at that person’s request . It suﬀers from the drawback that , in this example , Bob will not receive feedback about his edit in - progress . The edit is considered a contribution to Alice’s , and feedback is directed to her . Stealing : The system might change the authorship of e 0 alice to Bob , stealing the edit from Alice’s working copy and applying it to Bob’s . Sharing : Or the system might assign authorship of e 0 alice to both Alice and Bob , shar - ing it between them and giving both authors feedback . These designs deserve serious consideration in future work . Since Collabode uses the contribution model , the actual state is shown in Figure 3 - 6 , where Bob’s edit has been applied to Alice’s working copy instead of his own . At the time of the user study presented below in section 3 . 5 , the implementation was incomplete and participants were given instructions not to edit other users’ un - integrated changes . This system design is not recommended . 3 . 3 . 5 Initial Conditions In the simple description of error - mediated integration , the system searches for edits that can be applied without introducing any compilation errors . This requires that master be initially error - free . But if master does contain errors , the system can search instead for edits that can be applied without introducing any new errors . The description also supposed that all working copies existed at the start of the session , were identical to master , and were updated continuously . What if a new programmer v joins the collaboration in progress , with un - integrated errors in E ? 41 ( a ) view copy , rendered for Bob public class Hello { String a ( ) { return " Alice and Bob " } ( b ) Alice’s working copy public class Hello { } ( c ) Bob’s working copy public class Hello { } ( d ) master copy Figure 3 - 6 : Bob has made an edit to Alice’s in - progress work on method a . The edit is merged with Alice’s , so ( a ) the view copy from Bob’s perspective shows the entire in - progress method in gray . ( b ) Alice’s working copy contains Bob’s edit , while ( c ) Bob’s working copy does not . ( d ) The master copy does not reﬂect their work - in - progress . In that case , according to the deﬁnition in subsection 3 . 3 . 2 , this new programmer’s working copy wc v has the same content as master , since none of the edits in E were authored by v . As edits in E are integrated into master and the other working copies , they will also now be integrated into wc v . 3 . 3 . 6 Limitations and Assumptions One consequence of implementing the view by including all edits by all authors is that , since deletions by one author are seen by all authors , others can no longer modify the text that was deleted , even if their working copy still contains that text because the deletion induces an error and is waiting in E . Assuming , however , that the authors have coordinated at some level regarding the deletion , in many cases there should be little need to modify code that they have already decided to remove . An alternative implementation of the view might lift this limitation , for example if un - integrated 42 deletions were displayed in gray text or stricken out . A crucial assumption required by this algorithm is that the set E of merged edits not yet applied to master never grows too large , since it examines a number of possible combinations of those edits that grows exponentially with 2 | E | . This assumption is evaluated empirically below , but it is justiﬁed by two assumptions about programmer behavior : Contiguity assumption : a programmer’s own edits tend to be consecutive or over - lapping . In this case , the edits can be merged and E remains small . Refactor - ings , which may require a large number of widely distributed small edits , break this assumption and would be better handled as single multi - location edits to be integrated whole . Hygiene assumption : programmers tend to keep their code clean , fulﬁlling error - eliminating obligations actively rather than allowing large blocks of code to accrue with simple errors . Examples include balancing braces before working on their contents , and ﬁxing minor syntax errors as they write rather than in a later proofreading step . Evidence for both of these editing patterns exists in the case of Java programmers performing software maintenance [ 34 ] . The hygiene assumption will be especially impacted by the details of compiler feedback . A tool such as DuctileJ [ 2 ] , which allows programmers to temporarily relax static typing requirements and still run the program to see feedback , may reduce the scope of this assumption by giving the programmer ﬂexibility to ignore what would otherwise be an error . 3 . 3 . 7 Implementation with Coordinate Maps Error - mediated integration in Collabode is not implemented by manipulating edits , but instead by manipulating coordinate maps which deﬁne the relationship between master and view and between each working copy and view . A coordinate map is a list of integer pairs that specify the relationship between two documents . The initial 43 view wc alice wc bob master ← | ← | ← | ← | ← | ← | ← | ← | ← | ← | ← | ← | ← | ← | ← | ← | public class Hello { String a ( ) { return " Alic String b ( ) { return " Bo } 78 public class Hello { String a ( ) { return " Alic } 50 55 public class Hello { String b ( ) { return " Bo } 53 public class Hello { } 0 25 30 Figure 3 - 7 : Visualization of the coordinate mapping between the view copy , Alice’s working copy , Bob’s working copy , and the master copy after Alice and Bob have started to deﬁne methods a and b . pair is always ( 0 , 0 ) , indicating that character index 0 in document D 1 corresponds to 0 in document D 2 . Let D [ start , end ] denote the text in document D from index start inclusive to end exclusive . If the pair is ( i , j ) is in the map , then the text in D 1 at character i matches the text in D 2 at character j for zero or more characters . If pair ( i , j ) is followed by pair ( i + a , j + b ) , then : • If a < b , the text D 1 [ i , i + a ] is the same as D 2 [ j , j + a ] , followed by additional text D 2 [ j + a , j + b ] that is not found in D 1 . • If a > b , the text D 1 [ i , i + b ] is the same as D 2 [ j , j + b ] , followed by additional text D 1 [ i + b , i + a ] that is not found in D 2 . • If a = b , the coordinate pair provides no additional information and should be omitted from the map . The ﬁnal pair in the map always indicates that the remainders of D 1 and D 2 are identical . Figure 3 - 7 shows the four documents from our example after Alice and Bob have both made their initial edit . The coordinate maps are : master - view map = ( 0 , 0 ) , ( 25 , 50 ) , ( 30 , 78 ) wc alice - view map = ( 0 , 0 ) , ( 55 , 78 ) wc bob - view map = ( 0 , 0 ) , ( 25 , 50 ) 44 The master - view map indicates that two pieces of text in view that are not in master . The ﬁrst of these is Alice’s edit at index 0 + 25 = 25 of length 50 − 25 = 25 , and the second is Bob’s edit at 50 + 5 = 55 , length 28 − 5 = 23 . The wc alice - view indicates that Bob’s work is not in her working copy . And the wc bob - view map indicates Alice’s work is omitted . Instead of storing sequences of edits , Collabode maintains these coordinate maps . Merging of edits occurs naturally as they are updated . The set E of un - integrated edits corresponds to the non - matching regions in the view - master map : text only in the view in an un - integrated insertion , and text only in the master is an un - integrated deletion . 3 . 3 . 8 User Interface Given the error - mediated integration algorithm and implementation , we can now see how to realize the user interface described in subsection 3 . 3 . 1 . Figure 3 - 8 shows another example of collaboration between Alice and Bob . First Alice and then Bob begin making changes that do not compile ( 3 - 8a ) . Each of them sees only their own errors , and in - progress code is highlighted according to its origin . The ﬁgure shows Bob’s view of their collaboration , so his un - integrated edits are highlighted in yellow , while Alice’s are shown in gray . Arrows in the margin indicate Bob’s ‘outgoing’ changes by pointing out of the text , while Alice’s ‘incoming’ work is marked with inward - pointing arrows . Once each of them completes edits that can be introduced to the project error - free ( 3 - 8b & c ) , those edits are applied to the master copy . Then , even though one of Bob’s changes still has errors , this does not aﬀect either programmer’s ability to run the project and debug their code ( Figure 3 - 9 ) . In this case , even though Bob began working ﬁrst on line 5 and abandoned that work in progress to make a critical change on line 3 , that completed change is not held back by his incomplete earlier work , and he needs to take no extra steps to share only the working contribution . That the interface displays the work of both contributors is a crucial feature of the system . Each programmer has speciﬁc awareness about what other users are working 45 ( a ) ( b ) ( c ) Figure 3 - 8 : Bob’s view of a collaboration with Alice : ( a ) Hello . java as both he and Alice begin adding to the main method ; ( b ) after he edits the initial println , and his change is immediately integrated ; ( c ) and after Alice completes her contribution , which is also automatically integrated . Figure 3 - 9 : The output from running the program after Alice and Bob’s collaboration : changes on lines 3 and 4 are integrated , but the unﬁnished line 5 exists only in Bob’s working copy . 46 on , and can shift attention to their code at any time . Both the clear beneﬁts as well as some drawbacks to the interface were identiﬁed by participants in the user study discussed below . 3 . 4 Evaluation : Comparison to Manual Integration In order to evaluate whether error - aware integration would be useful in practice , a ﬁrst study examined how the algorithm would perform in comparison to manual integration performed by programmers . Edit logs from pilot experiments conducted in Collabode without automatic integration were reviewed , then replayed against a version of the system with the algorithm . In the experiments , participants were research lab members engaged in micro - outsourcing as described in Chapter 6 . An original programmer ( OP ) directed co - located workers to complete various tasks ; for example , perform research , implement a method , or design a representation . Workers were not editing collaboratively , but instead worked in clones of the original project . When tasks were done , the OP was required to manually copy workers’ contributions back into the original . Across three pilot sessions , 18 instances where the OP copied worker code into the original project were identiﬁed . In 14 of these instances ( 78 % ) , the error - aware integration algorithm also would have automatically integrated the identical block of code into the project . All four cases where the algorithm did not match manual integration were in - stances where the OP chose to integrate error - containing code . In two of those cases , the worker’s contribution could reasonably be judged to satisfy the OP’s speciﬁcation : the OP requested that workers create a number of methods with correct signatures but empty bodies , yielding compilation errors in a number of places . In the other two cases , workers failed to meet the OP’s speciﬁc instruction to “get rid of compile errors” in the initially broken code he provided them . It is therefore unclear whether the failure of the algorithm to integrate these contributions would have violated the OP’s expectations . 47 The 78 % of manually - integrated contributions that were also automatically in - tegrated is a measure of the recall of this approach : what fraction of contributions judged “good” by humans are also selected algorithmically . The same data are not useful to estimate the precision ( that is , what fraction of algorithmically - selected contributions are “good” ) because in all of the pilot experiment sessions , there were large amounts of working code that OPs failed to integrate due to insuﬃcient time or attention , not because the code was unacceptable . This result instilled conﬁdence that the algorithm could operate in a collaborative programming scenario without requiring programmers to change their behavior to meet its requirements . In fact , there were several instances where the OP incorrectly copied too little or too much code from the worker’s project and had to correct the mistake . This eﬀort would have been eliminated by the automatic approach . 3 . 5 Evaluation : Side - by - Side Programming To evaluate whether programmers could understand and use error - aware integration and the entire Collabode collaborative programming system , we conducted a user study in which pairs of programmers worked for approximately 30 to 40 minutes to complete a coding task , working together in a single source code ﬁle . 3 . 5 . 1 Procedure Four student participants were recruited from the author’s institution , and ten profes - sional participants were recruited from local oﬃces of two large technology companies . The average self - reported age of participants was 36 , two of the 14 participants were female , and ﬁve were studying for or held a bachelor’s degree while the other nine were studying for or held a master’s degree . Participants were asked to rate their proﬁciency in Java on a 7 - point Likert scale ( min = 2 , max = 7 , mode = 6 ) and their experience with pair programming ( min = 1 , max = 5 , mode = 1 ) . Pairs were not randomly assigned , and pair familiarity ranged from students who had never met prior to the study to co - workers who are also good friends . For this 48 reason , and because of the wide variance in behavior and ability between program - mers , there is no attempt here to compare the performance of diﬀerent pairs ; results are broken down by session only to illuminate this variance . In each one - hour session , participants : • completed a demographic questionnaire ; • received a brief tour of the Collabode interface and the operation of the auto - matic integration algorithm , with the opportunity to ask questions ; • worked together on a programming task ; • completed a post - task questionnaire to give written feedback regarding their experience ; • and discussed the experience with the experimenter and their partner based on questions from the experimenter . This experiment was not designed to test the learnability of Collabode , since it is by its nature a system for expert users who invest time to learn the complex tools of their trade . Participants were shown how to edit and run the project , and the experimenter demonstrated how multiple editors would see each other’s changes . Participants took part in the demonstration but could not make edits , in order to keep idle experimentation to a minimum in the limited time . Participant pairs were ﬁrst explicitly instructed that they could use “any web resources” in order to complete the task and that they could organize their work any way they liked . All pairs used Google to conduct searches and referenced the Java API documentation at some point . Pairs were initially seated at a 90 ◦ angle at the corner of a rectangular table or at a small circular table , and the majority moved to sit side - by - side during the session . This move enabled easier sharing of documentation or other web pages , and also allowed those pairs to see one another’s focus or cursor location ( not implemented in Collabode at the time ) . Pairs were also informed that they could only edit a single shared source code ﬁle ; this restriction was designed to maximize opportunities to exercise the synchronization algorithm and UI . 49 1 2 3 4 5 6 7 1 . 6 per edit 3 . 0 per minute 1 . 3 per minute 2 . 3 per error - free block 59 % 41 % 14 % 0 % 1 . 7 2 . 3 1 . 0 2 . 3 58 38 20 20 1 . 6 0 . 9 0 . 7 1 . 4 52 43 41 0 1 . 4 1 . 1 0 . 8 1 . 4 49 38 19 0 2 . 4 2 . 3 0 . 5 5 . 1 80 48 65 0 3 . 2 1 . 5 0 . 4 3 . 6 72 31 43 100 3 . 2 1 . 3 0 . 4 3 . 3 72 26 50 25 Mean 2 . 2 per edit 1 . 8 per minute 0 . 7 per minute 2 . 8 per error - free block 63 % 38 % 36 % 21 % S e ss i o n C o m m i t b l o ck r a t e E rr o r - f r ee b l o ck r a t e C o m m i t b l o ck r a t i o C o m m i t b l o ck s w i t h E d i t s b y U n i n t e g r a t e d r e g i o n s P r og r a m r un s E d i t s w h e r e bo t h un i n t e g r a t e d r e g i o n s e d i t o r s h a v e e rr o r s w i t h e rr o r s l o w e r c o n t r i b u t o r Table 3 . 1 : Per - session and mean statistics from the side - by - side programming user study . The task was : Using the nytimes . com RSS feeds , display a list of recent headlines from the New York Times “Science” category . Use regular expressions or other string processing , not an RSS or XML processing library . Don’t worry about converting XML entities or other encoding issues . Participants were also given several hints in the initially - provided source code : pointers to the Times’ directory of RSS feeds ; to a class and a method relevant to retrieving the contents of a URL ; and to the reference for Java regular expressions . While interesting , the research and API understanding stages were not the focus of this study , so we attempted to equip participants as well as possible to get to work quickly . Nevertheless , understanding the minutia of , variously , URL retrieval in Java , regular expressions in Java , and RSS consumed signiﬁcant participant time . 3 . 5 . 2 Does the Set of Un - Integrated Regions Remain Small ? The eﬃciency of the automatic integration depends strongly on the assumption that there are few outstanding un - integrated regions . Considering all 4 , 543 edits per - formed in the course of the study , the average number of un - integrated regions for the algorithm to consider ( that is , | E | ) has a mean of 2 . 2 and a median of 2 . The mode is 1 , and since an edit has just occurred , the number is zero only when that edit precisely eliminates the only current region ( this occurs 23 times ) . As shown 50 in Table 3 . 1 , pairs 6 and 7 tended to have about twice as many un - integrated re - gions , on average , as pairs 1 through 4 ( up to the observed maximum of 15 ) . Both of the these pairs experienced bugs in Collabode that prevented the shared code ﬁle from updating correctly , leading to invisible unresolved errors participants could not correct until they reverted to an earlier version . These results validate the assumption that the set of such regions remains small , at least in the case of two programmers . Since we might expect this number to grow in proportion to the number of concurrent contributors , the eﬃciency of this algorithm beyond pair programming remains to be seen ( although in the micro - outsourcing study presented in section 6 . 4 , the median number of un - integrated regions at every edit in each session ranged from 1 to 3 ) . 3 . 5 . 3 Is the Algorithm an Improvement Over Integrating Only Error - Free Code ? For each edit recorded during the study , we can ask whether that edit resulted in ( a ) an error - free source ﬁle and in ( b ) an automatic integration . Since sequences of edits where participants wrote inside comments or string literals result in rapid sequences of commits to the project that are not useful to count as separate instances , we collapse consecutive edits into blocks for which the answers to ( a ) and ( b ) remain constant . An error - free block is an edit sequence where every edit results in an error - free source ﬁle , and a commit block is a sequence where every edit can be automatically integrated . In Table 3 . 1 we see a mean number of commit blocks per minute of 1 . 8 , compared to a mean number of error - free blocks per minute of 0 . 7 . This gives an average increase in the rate of commits by 2 . 8 times over a scheme that commits only when error - free ( the result is an equivalent 2 . 6 times if we consider all edits individually , without blocking ) . If we asked developers to integrate code manually using version control , this frequency of error - free states is likely an upper bound on the frequency with which they could reasonably go through the overhead of committing it . A diﬀerent way to view this result is to observe that 63 % of commit blocks occurred 51 with other error - containing regions still outstanding ; that is , only some of the available edits were integrated into the project ( this number falls to 58 % when we examine edits individually , due to the eﬀect of e . g . comments and strings noted above ) . We conclude that this algorithm is signiﬁcantly diﬀerent from integrating only error - free versions . More frequent integration means less opportunity for programmers’ code to diverge and reduced lag between authorship by one programmer and use by another . 3 . 5 . 4 Can Developers Work Concurrently ? Table 3 . 1 also shows the proportion of edits attributed to the member of each pair who contributed the least . We see that in the most unequal case , that person still contributed more than one quarter of the edits ( this is not necessarily a measure of how much code that participant wrote if , e . g . , they copied an example from the web , or they tended to add but then delete ) . And on average , over one third of the edits occur in a state where both participants have an error , from which we might infer that they are actively working on or thinking about some part of the task . Based on experimenter observation , in every session , the two programmers were at some point actively working on incomplete code at the same time . We argued earlier that , in addition to allowing participants to write independently and see appropriate IDE feedback , error - aware integration also allows programmers to run the program more often without worrying about their collaborators’ errors . As shown in the last column of Table 3 . 1 , the results from this study do not support such a hypothesis . Pairs ran the project only 5 . 7 times on average ( 4 . 7 times excluding consecutive runs with no intervening edits ) , and did so almost exclusively when the project had no outstanding error - causing code ( with the exception of session 6 ) . This is in contrast to statements made by participants during the post - task interview , which we discuss below . Overall , participants made many edits where the errors reported were computed without regard to error - containing code concurrently introduced by their partner , and this oﬀers strong support for the claim that developers are able to make concurrent progress using the system . 52 3 . 5 . 5 Feedback : Collaborative Coding Study participants were largely positive about the experience of working together collaboratively , making statements such as “I found it really useful , ” “I thought it was a lot of fun , ” and “that was pretty cool . ” In many instances , developers began to brainstorm diﬀerent use cases for the system : • “You could essentially be real - time debugging each other’s code” • “If you laid out an entire class with methods that needed to be implemented , [ . . . ] it would be pretty cool to see how that would work , if you were implementing one method , I was implementing another method” ( cp . micro - outsourcing ) • From an operations engineer , “we have a lot of time - critical stuﬀ , I could see this being occasionally useful” for “crisis programming” Participants also suggested that the system could improve communication between collaborators , who can easily reference one another’s code , and would be useful for learning . One participant said during the discussion , “I [ . . . ] gained an insight into how you [ my partner ] think , how you problem solve . ” While pair programming works well for many developers , several participants reported that Collabode would work better for them than the traditional approach . One summarized the sentiments of many : “It always seemed that if you had one or two people looking over your shoulder , you became a puppet , and you just are doing what they’re telling you to do . But when we each had a keyboard , it didn’t feel that way . I was thinking one step ahead , and whether it was just going to the Java API documentation to see what’s the next little thing that we can do to push this forward , [ or working in parallel , ] it was both of us trying to actually program this thing , instead of just one person . ” Some participants were more ambivalent : 53 • “I think it boils down to , if you buy into pair programming , then this is a very good way to do it” • “Once your task is well - deﬁned , the module is well - deﬁned , I wanted to go into a separate page” One participant stated ﬂatly , “overall , I wasn’t a huge fan of it , ” and continued : “no , I don’t like other people touching my stuﬀ . ” While this is certainly a disappointing attitude from the perspective of collaborative software development , it is only one point along a spectrum of reasonable concern developers must have for their ability to think and code independently . 3 . 5 . 6 Feedback : Automatic Integration Asked whether they thought the automatic error - aware integration was “useful” or perhaps “confusing , ” developers were generally positive : • “I found it really useful , I liked the fact that you can see what they’re doing , but that it doesn’t interfere with the functionality” • “I think that it’s hugely useful” • Without it , “I would have been totally hung up on , ‘oh , what the heck is my stupid syntax error there , ’ and [ . . . ] that would have just stopped me in my tracks ; ” this participant’s partner replied : “right , and we have an alternative , which was , you try your way , and I’ll try my way , ” which they did during the session • “I can picture myself spending ten minutes writing a method , [ . . . ] and if it doesn’t compile , then [ . . . ] I don’t want you to wait [ on me ] , or me to wait on you” • “I think you deﬁnitely don’t want it to commit with errors , because then you can’t test things as you’re [ . . . ] making small changes that you want to be able to just test immediately” 54 • “I really like the idea that essentially whatever’s in the system , whatever that is , will always run” No developer reported being confused by the system as designed , although several reported being confused when bugs in Collabode were exposed . Nevertheless , com - ments made by some participants suggest they had incorrect or incomplete mental models of the system , in particular with respect to what version of the program would run in the console . Developers who thought error - mediated synchronization was less important tended to focus on running the program . One developer suggested that holding back changes with errors was unnecessary for a task of this size , although this participant’s partner responded that they should have tried to run the code sooner , and that “we should have tested running the program with just my changes [ and ] when there was a compi - lation error with his changes , I should have tested running it . ” Another participant’s statement that “I don’t mind about the compilation errors because , when we cooper - ate , I think , ‘I do not mind , if it’s not ready , I just do not run”’ also seems more closely aligned with the data presented above . We hypothesize that two factors combined to limit participants’ use of this feature : • First , the notion of a console that runs only the working parts of the code is novel , and participants may have preferred to synchronize rather than consider what would be run . • Second , because the console output was shared , participants may have thought of running the program as a shared activity best done together when both were ready . 3 . 5 . 7 Feedback : Missing Pieces Hitting on two of the limitations of the evaluated system , several participants wanted to be able to see their partner’s errors and to be able to edit their partner’s un - integrated changes ( the latter is now supported in the current system ) . One par - ticipant described how the incoming and outgoing change icons in the margin could 55 provide an aﬀordance for taking ownership of a change , which might help clarify for the change’s originator why their code was now being edited . Several participants articulated how the ability to see collaborators’ errors ( perhaps with indicators to diﬀerentiate them from their own ) was crucial for collaborative debugging . Some developers also mentioned wanting a changelog , and rightly pointed out that the cur - rent user interface becomes confusing with more than two collaborators because the speciﬁc owners of changes other than one’s own are not displayed . Several participants also made the case for when manual integration might be preferable in place of or in combination with automatic integration : • “I like this as a default , but I think , it would be nice if you could hit a button that says , ‘stop committing what I’m going to write , ’ [ . . . ] if I know I’m going to be working on a large chunk of code” • “One place I see [ manual ] coming in really useful is , if you’re working with someone , and you’re pounding through the problem really quickly , and you solve it really ineﬃciently . . . and , say [ . . . ] I decided to go back and try to make some early part more eﬃcient , I don’t want to just delete the ineﬃcient part , because then she can’t test any more” if the intermediate state ever compiles This is a particularly insightful observation from only half an hour of experience with the system : while error - aware integration is helpful , it might be straightforward to produce error - free programs that nevertheless impede the progress of collaborators . Improving the automatic integration algorithm and adding both language - speciﬁc and language - agnostic heuristics to detect “good” and “bad” changes is future work . 3 . 6 Conclusion Overall , it was pleasing to hear from several user study participants statements such as “I want it” and questions about when the system would be production - ready for their own programming . 56 Error - mediated integration turns multi - editor real - time collaborative program - ming from a novelty into a practical tool , and the user study presented in this chapter demonstrates its eﬃcacy . Chapter 6 discusses a user study in which EMI was intro - duced to participants only brieﬂy , and in general , participants simply took it for granted : it felt natural to be able to have other programmers working in the same ﬁle at the same time , without their unﬁnished code causing a problem . The automatic nature of EMI makes it categorically diﬀerent from version control , and indeed this work is solving a diﬀerent collaborative problem . Combining EMI with version con - trol is the logical next step , to enable collaboration on both shorter and longer time scales . Collabode serves as the foundation for research , presented in the following three chapters , on diﬀerent models of collaborative programming . Those models demon - strate how software development with real - time collaborative editing is not only a useful idea for current programming scenarios , but also enables new scenarios to ex - plore . 57 58 Chapter 4 Classroom Programming Computer science has long been perceived as the domain of solitary asocial hackers . As a result , computer science programs struggle to attract and retain women and minority students [ 6 , 12 ] , and many courses teach fundamentals of computer pro - gramming without equipping students to work on the large teams required to develop software at nontrivial scale . At the university level , computer science departments have responded to these problems by increasing the amount of student collaboration and teamwork in their courses . A collaborative IDE is a natural ﬁt for this student collaboration . The relationship between students and instructors is also collaborative . Screen sharing tools ( such as iTALC , italc . sf . net ) have been the state - of - the art for al - lowing instructors , especially at the secondary school level , to view and sometimes take control of student computers . But for viewing , Collabode can oﬀer a far richer interface—instead of transmitting pixels the instructor must interpret , the system op - erates on text and data it can analyze and aggregate . And for interacting , Collabode allows the instructor to view , navigate , highlight , or edit student code without taking control of the IDE from the student . Online learning sites have grown from repositories , such as MIT OpenCourse - Ware ( ocw . mit . edu ) , into organizations that use web - based tools to create person - alized learning programs , among them Khan Academy ( khanacademy . org ) , Coursera ( coursera . org ) , Udacity ( udacity . com ) , and EdX ( edxonline . org ) . Online learning 59 for programming is a particular hot - spot . Codeacademy ( codeacademy . com ) made headlines with their “Code Year” initiative to teach JavaScript online . Collabode is at the leading edge of what will be a wave of web - based tools for programming ed - ucation , and having collaboration at its core makes it unique among many systems designed for individual learners . 4 . 1 Inspiration Middle East Education through Technology ( MEET , meet . mit . edu ) is a nonproﬁt organization that aims to bring together Israeli and Palestinian high school students , break down the misconceptions they have about each other , and instead create an en - vironment where students work together and build long - term relationships with their peers . Started at MIT , the MEET program uses a rigorous computer science and entrepreneurship curriculum to achieve its goals , at its core a programming curricu - lum that brings students from no programming knowledge to developing , e . g . , web applications in a little over two years . The goals of MEET’s educational program are uniquely challenging : while any grade school or university will value collaboration , communication , diversity , respect , and so on , for MEET the primary goal is to bring students together . The values , skills , and practice of teamwork are highest priority . Skills in programming , while important and worthwhile , are secondary . As a MEET instructor and head of instructors for several years , the author found this collaboration imperative a constant , exciting , diﬃcult challenge . One frustrating aspect of the challenge was tools : the collaborative programming tools of pair pro - gramming and version control ( see Chapter 1 ) were often inadequate to the task of enabling students to work together . A beginning programmer who is not yet com - fortable navigating directory hierarchies to edit and compile source ﬁles is not ready to contend with version control . And while some students have the intellectual and interpersonal maturity to work eﬀectively in a pair ( where their partner is likely of a gender or nationality they ﬁnd discomﬁting ) , most need systematic help from tools and practices that will guide them . 60 It was this tool frustration that initially inspired the Collabode research project . While it was not feasible to deploy Collabode for study in MEET , the system was used in a software engineering course at MIT , in a semester - long deployment that frustrated teaching assistants and students alike , but also yielded a variety of insights . 4 . 2 6 . 005 Recitations MIT course 6 . 005 , Elements of Software Construction , teaches the basics of software engineering : “how to write software that is safe from bugs , easy to understand , and ready for change , ” according to its description in the course catalog . In the fall of 2011 oﬀering , one goal was to increase the amount of code students wrote during the course , pushing students towards the point where syntax and language constructs become automatic , making it easier for larger concepts to come to the fore . One way to increase the quantity of student coding was to add coding to recita - tions . Traditionally , recitations might include coding on paper or on the board , a valuable exercise that was by no means removed from them , as well as all the discus - sion , diagramming , and other activities associated with recitations . But while working problems by hand , in diagrams , or in pseudocode is valuable for many purposes , it is not useful for forcing students to write more code , to exercise the mechanics of code writing to the point where they no longer require time and attention . The ﬁrst challenge in adding coding exercises to recitations was the mechanics : how will students receive skeletons , examples , or templates from which to start ; and how will recitation instructors ( TAs ) observe and collect student work so it can be discussed during the class period . Here , Collabode was a perfect ﬁt . Students did not have to use version control or even have a development environment set up on their laptop , only a browser and a TA - provided URL . And TAs had an up - to - the second view of every student’s progress . With mechanics conquered , the next challenge is to make productive use of the capabilities Collabode could provide , and here the deployment was less successful : as an additional responsibility on top of an already - packed schedule of preparing 61 recitation materials , problem sets , projects , and so on , exploring the best ways to use this new teaching tool was not a top priority . There were also technical issues , where system bugs would sometimes derail an entire recitation . TAs or the author hosted the Collabode server for each recitation on their laptop , a less - than - ideal conﬁguration that often strained the system with too little computing horsepower or a poor wireless network connection . 4 . 2 . 1 Cloning The basic mechanism Collabode provided for distributing code to students was to clone a project . The instructor would prepare a skeleton project , e . g . with empty classes or methods . Each student would visit a URL provided by the instructor that would authenticate them and create a copy of the skeleton project , accessible only to the student and the instructor . By modifying the access control permissions on the clone , instructors or students could set up collaboration with other students . Collabode retained a pointer from the clone to its origin , allowing for a clone diﬀ view that would show all the clones of a project ﬁle with diﬀerences highlighted . 4 . 2 . 2 Deployment The six TAs used Collabode in 12 out of 17 one - hour recitations , although not every TA used Collabode in every recitation . There were approximately 30 students in each recitation , with a total of at least 169 students using Collabode over the course of the semester ( TAs returned Collabode logging data for study , but a some recitations were not returned or were incomplete ) . A subset of the recitations were observed , and these observations form the basis of the discussion below . In general , TAs did not use the clone diﬀ view , did not have students collaborating , and did not use Collabode in a mode that could not be replicated by screen sharing or similar tools . TAs did have students work inde - pendently on cloned code , often while navigating in Collabode to view individual students’ progress . They sometimes used a projector to display student code for the 62 class to see , and often asked students to discuss the problems and their solutions out loud or on the board . 4 . 2 . 3 To Each His Clone The typical usage scenario for Collabode in 6 . 005 was for students to work on indi - vidual clones of the TA’s provided code . In some recitations , TAs used Collabode in interesting ways : Code & discuss : The TA would ask students to work on one method or part of a problem for only a few minutes , then ask the class to discuss their results , perhaps by having one student read their solution or write it on the board . Diversity : The TA would present a problem , ask students to work individually , and then aggregate diﬀerent ideas or solutions , such as diﬀerent test cases to include in a test suite . Reference : The code in Collabode was provided as a reference , which students could navigate or tinker with , but students did not spend time working individually on writing code . But in most cases , Collabode usage ( in observed recitations ) amounted to individual coding time with little or no discussion afterwards . This lack of any beneﬁt from using Collabode , combined with frequent bugs and stability problems , led many students to criticize it in their course evaluations . One generous student suggested : “Ditch Collabode . It’s a decent idea for developers , but in recitation all it really amounted to was ‘hey students , copy this code from my computer screen . ’ ” 4 . 2 . 4 Show and Tell Beyond individual clones , the most frequent Collabode use case was for the instructor to review student work and select code to project on the board for the class to read 63 and discuss together . In some instances , instructors used the Collabode equivalent of ‘cold calling’ and selected a student at random or according to their own objectives . More frequently , instructors asked for volunteers to display their work . In one disappointing exchange several weeks into the semester , a TA projected a student’s code for the class to discuss . As an issue was revealed , the student started ﬁxing his code—and was surprised to see the changes show up on the screen ! A few minutes later , the student was again surprised when the TA decided to illustrate a point by editing the student’s code himself ! Being precisely the sort of real - time collaborative scenarios Collabode was built to support , it was disappointing to see how clearly the deployment was not yet taking advantage of the system’s capabilities . TAs generally did not use the clone diﬀ view to see student work . The view was diﬃcult to make sense of ; it was easier for TAs to navigate into individual student projects and observe their work there . 4 . 2 . 5 Collaboration On only one occasion did the author and the course staﬀ attempt a collaborative exercise . A theretofore undiscovered Collabode concurrency bug , triggered by the Java particulars of the exercise , doomed the attempt to failure within minutes . But the fact that the exercise could fail in only minutes , with more time spent rearranging students and chairs than on downloading code or setting up version control , oﬀered some hope that a more stable web - based collaborative IDE could have provided a worthwhile experience . The collaborative model proposed for the exercise was straightforward : a two - module problem to be worked on in parallel , with an interface in which one module depends on the other . In this particular exercise , the interface was a shared data structure , with one module producing data and the other consuming it . The use of a shared data structure provides the beneﬁt that both groups can easily test their work independently without having to write mock or stub objects , assuming the datatype in the shared structure is already deﬁned . The producers can verify they are adding correct data to the queue , and consumers can verify they behave correctly when the 64 queue is artiﬁcially ﬁlled . The exercise was to implement grep - style search where a Producer read an in - put stream and queued lines to search , and a Consumer ﬁltered lines oﬀ the queue into a collection of matching lines . The shared structure was a BlockingQueue of im - mutable objects representing lines of text with line numbers , whose implementation was provided . 4 . 3 Mobile Instructor From the beginning of the Collabode project , one goal was to demonstrate the ﬂex - ibility of a web - based platform by reaching beyond the desktop browser . While a laptop works well enough when the instructor is lecturing from the front of the room , in a lab or studio setting instructors need to be free to move around the classroom and work one - on - one with students . Those students can still use the familiar IDE user interface , but instructors use a mobile device interface that might summarize student progress , identify outliers or struggling students , or enable remote control of students’ environments . Since the Collabode server has centralized up - to - the - second knowledge of every student’s code , it can provide this analysis in real - time without requiring students to interrupt their work . Angela Chang’s CollabodeTA user interface [ 13 ] , prototyped on the Apple iPad , demonstrated how Collabode could support : Class layout view : a spatially - arranged overview of the entire class , with the ability to ﬁlter students by instructor - selected criteria and annotate student photos with various indicators . Console output view : a summary of the current output produced by all student programs , normalizing and clustering outputs into groups , and showing diﬀs from the most popular cluster . This view was designed to work well for a class of students working on an assignment where their console output evolves over time towards an expected correct output . 65 Student view : a timeline view of an individual student’s work , showing successful and unsuccessful program executions and a history of exceptions encountered . 4 . 4 Conclusion The strong positive reactions from students who used Collabode in the side - by - side programming study ( Chapter 3 ) provide some counterbalance to the negative reac - tions of students who were unimpressed by the deployment of Collabode in 6 . 005 . Pair or small group collaboration is possible with Collabode with an ease that screen shar - ing , pair programming , or version control cannot duplicate . And real - time student - teacher interaction around code , whether in a lab or in a distance learning scenario , is also impossible without a collaborative IDE . More research is needed to develop appropriate educational scenarios for Collabode , and more engineering work is re - quired to make the platform reliable for use by hundreds of students in the course of a day . 66 Chapter 5 Test - Driven Pair Programming The test - driven pair programming ( TDPP ) model combines the practices of pair pro - gramming with test - driven development . In test - driven development , developers fol - low two rules : “write new code only if an automated test has failed , ” and “eliminate duplication” [ 4 ] , with short , rapid development cycles as a result . In test - driven pair programming , the process of test - driven development is paral - lelized , with one member of the pair working primarily on tests , while the other works primarily on implementation . To begin work on a particular feature or module , the tester might write a black - box test , which the implementer will then satisfy . The tester can then investigate the implementation and write glass - box tests to weed out errors . These further tests will be addressed by the implementer , and the testing and implementing continues . Rapid collaboration in this model will rely on interface support for visualizing passing and failing test cases and who in the collaboration is responsible for taking the next step to address any failures , and for navigating between test cases and code . Portions of this chapter were presented at the ICSE 2010 workshop on Cooperative and Human Aspects of Software Engineering [ 25 ] . 67 5 . 1 Prototyping the Model We conducted an early formative evaluation of test - driven pair programming us - ing a prototype version of Collabode in a user study with professional software de - velopers . This Collabode prototype supported Python development using Google App Engine ( developers . google . com / appengine ) and MobWrite ( code . google . com / p / google - mobwrite ) to support simultaneous editing . The prototype implemented continuous execution of implementation and test code : every time a ﬁle was changed , the editor attempted to re - execute that ﬁle , displaying any output generated or er - rors encountered . It also implemented a read - only view in which ﬁles were syntax highlighted but not editable . This environment was suﬃcient to create a low - ﬁdelity prototype of a TDPP UI : • projects contain separate implementation ﬁles and test ﬁles ; • test ﬁles use the Python unit testing framework , so test results are displayed whenever a test ﬁle is viewed ; • and one developer edits implementation while the other edits tests , with both able to view the test output . The read - only view was used to enforce this division of work . 5 . 1 . 1 Procedure We conducted the user study with six software developers working at the local oﬃce of a large technology company . All participants were male , with an average age of 29 years . The participants were divided into three pairs , with each pair completing three programming sessions of a maximum of 40 minutes each on three diﬀerent tasks : • Parsing RSS feeds on the New York Times website to ( 1 ) display a list of recent headlines from the “science” category , ( 2 ) display a list of headlines from the intersection of two categories , and ( 3 ) display a list of authors of articles from three categories along with their article headlines . This three - part task was used as a warm - up . 68 • Finding the roots of a polynomial , in the case of arbitrary complex - coeﬃcient polynomials of degree three , by implementing the Durand - Kerner method , using Wikipedia as a reference . This task was based on the Polynomial task used by Müller in comparing pair programming to peer review [ 38 ] . • Writing a parser for human - readable strings containing boolean formulas in con - junctive normal form ( e . g . ( a | b ) & ( c ) & ( ~ c | ~ a ) ) , and using a provided boolean satisﬁability ( SAT ) solver to report solutions for the formulas . The SAT solver implemented the Davis - Putnam - Logemann - Loveland ( DPLL ) algorithm and included unit tests . Participants completed the programming tasks on provided laptops , seated facing one another approximately one meter apart across a table . They were instructed not to get up and look at their partner’s screen or to turn their laptop around for the other to look at , but were otherwise encouraged to utilize any and all resources at their disposal to complete the tasks . In two sessions , a pair used pen and paper to work out formulas ; otherwise , the participants used only the web - based editor and other web resources . Both participants could view the code and output of every ﬁle , but only edit either test or implementation ﬁles . The study included additional conditions where both participants could edit all code and where one participant could edit none , but the data from these conditions were not used . The Firefox web browser was instrumented to record participants’ web browsing activity , including URLs visited and browser tabs selected . Since the prototype editor was web - based , this log included browser tabs used for viewing and editing ﬁles . Collabode took snapshots of the code as it was written , with a granularity of 5 seconds to 500 milliseconds depending on the rate of editing activity . The audio of participants’ discussions was recorded during the sessions and subsequently transcribed . We gave participants a target time of 30 minutes to work on each task , and ended the sessions after 40 minutes regardless of completion . Participants then ﬁlled out a post - task questionnaire with Likert scale and open - ended questions about their 69 experience doing the task and their interactions with their partner and the Collabode interface . 5 . 1 . 2 Visualizing Programming Sessions In order to reveal qualitative trends and critical incidents from the programming ses - sions , a timeline visualization proved most useful , summarizing the web browsing , code viewing and editing , and verbalizations of a pair . An example of this visualiza - tion is shown in Figure 5 - 1 , which shows about 90 seconds starting from minute 5 of one session . • Each participant is a represented with a column of code edits , editor and browser state , and utterances . • Each vertical bar is a browser tab ( including tabs for the web - based Collabode editor ) . In the example , at minute 6 of the session , the programmer on the right opens a new tab , uses Google to search for “CNF , ” and browses from the results to the Wikipedia page on conjunctive normal form . • The shaded browser tab has focus ; others are in the background . The color of the shading indicates the kind of content in the tab : (cid:4) empty tab , (cid:4) Collabode editor , (cid:4) Google search results , (cid:4) Python documentation , (cid:4) Wikipedia page , or (cid:4) other web page . • Transcribed utterances are placed alongside editing and browsing . • Code edits are grouped by time . In Figure 5 - 1 , the programmer on the left spends about 20 seconds making the deletions highlighted in red and the addi - tions highlighted in green . The timeline visualization was our primary tool for navigating the data , and allowed for rapid coding of the data according to the taxonomies discussed in the following sections . 70 5 6 from sat import * from parse import parse ! import unittest import sys ··· def testEmptyFormula ( self ) : self . assertEqual ( Formula ( [ ] ( [ ] ) , parse ( " " ) ) passdef testPositiveLiteral ( self ) : ! ! self . assertEqual ( Formula ( [ Literal ( ' a ' , True ) ] ) , parse ( " a " ) ) # 303 parsetestpy < t32 < test sattestpy < t32 < test sattestpy < t32 < impl googlecom / CNF wiki / Conjunctive _ normal _ form parsepy < t32 < impl I ' m going to write , a test for that . so . . . from parse . . . import parse . Hoping that works . Um Formula , literal , a true OK So currently , it ' s failing because it wants the parse function to be defined Awesome Oh Sounds good I ' m still understanding sat . py ok , so I don ' t really care about , care about formulas and literals I can fix that for you Can I have two , of these , open at once ? Yes I can . Hot . Uh . . . so , you ' re importing . . . Code edits Opening a new tab Editing sattest . py ( implementer role ) Searching for " CNF " Reading Wikipedia Switching tabs Transcribed speech Figure 5 - 1 : An example of the timeline visualization ( approximately 90 seconds of Pair 2 , Task 3 ) with various features called out . Each vertical bar represents a browser tab : (cid:4) empty , (cid:4) Collabode , (cid:4) Google , (cid:4) Python docs , (cid:4) Wikipedia , or (cid:4) other . 5 . 1 . 3 Examining Cooperation Using the detailed pair programming foundation layer activity terminology developed by Salinger and Prechelt [ 45 ] , Prechelt et al . analyzed side - by - side programming ses - sions of three programmer pairs to identify seven types of cooperation episodes , when programmers “get together in order to work cooperatively towards some subgoal” [ 40 ] . We paraphrase the deﬁnitions given there and illustrate the episodes by example : Exchange project details : partners discuss project status or other project - speciﬁc information . In the example of Figure 5 - 2 , one partner clariﬁes for the other the semantics of the provided Literal class . Exchange general knowledge : partners discuss generally - applicable technical or domain knowledge . In Figure 5 - 2 , the same partner veriﬁes the naming standard for string representation methods in Python . Discuss strategy : the partners discuss and agree on high - level requirements and design . Figure 5 - 2 shows an uncharacteristically short example of strategy , where the partners tersely agree on the high - level structure for their solution . Discuss step : more low - level than strategy discussion , partners talk about concrete next steps . Figure 5 - 2 illustrates a discuss step episode where the pair agree that they should implement a string representation method in the Literal class . 71 17 18 19 s s . strip ( ) if len ( s . empty ( ) : ) 0 : raise " empty literal " ··· return Literal ( s , false ) s ParseLiteral ( " fh " ) ! print ParseLiteral ( s . variable ! ! print s . 246 raise " Literal is just a " return Literal ( s [ 1 : ] . strip ( ) , trueFalse ) return Literal ( s , falseTrue ) s ParseLiteral ( " ( " fh " ) print s . variable print s . positive 246 return not self . eq ( other ) def str ( self ) : ! ! if self . p ! ! class Formula : " " " Represents a formula in conjunctive normal form . " " " 249 def testBasic ( self ) : print self . buildClauses ( [ ' ( [ [ ' a ' , True ] ) ] , [ ' b ' , False ] ] ) pass 2458 satpy < t23 < impl satpy < t23 < test parsetestpy < t23 < test python _ _ str _ _ I ' m actually starting with a parse literal function . Ill just , have , one for each , level Oh wait , positive in a literal means , it ' s not negated Oh , ok , I ' ve got this backwards . I was thinking it meant . . . I was thinking that , that input was , meant negated alrighthold on And , boolean variables start with a capital , or , boolean literals start with a capital letter , alright What ? Oh yeah , good idea Is it , uh , underscore underscore , cap , is it capitals ? to string , under - - under under Oh ok mm [ sigh ] that ' s not very informative Ah , damnit , [ unintelligible ] modify sat . py to add some string methods Correct . that ' s fine m hm Could you add a , a to string to , uh , literal ? Can you add a me - - a to string method to literal , in sat . py ? Uh , I think lower case um , give a second , let me check Underscore underscore , s t r , underscore underscore Discuss strategy Exchange project details Discuss step Exchange general knowledge Figure 5 - 2 : A segment of one programming session ( Pair 3 , Task 3 ) summarized in the timeline visualization , highlighting several diﬀerent cooperation episodes . 16 17 while p ! = old _ p or q ! = old _ q or r ! = old _ r : print old _ p , old _ q , old _ r ! ! p = self ( old _ p ) / ( ( old _ p - old _ q ) * ( old _ p - old _ r ) ) q = self ( old _ q ) / ( ( old _ q - p ) * ( old _ q - old _ r ) ) 782 old _ p = 01 . 4 + 0 . 9j + 0j old _ q = 0 . 4 + 0 . 9j old _ r = complex ( - 0 . 4 + 65 , 0 . 9j72 ) p , q , r = 0 , 0 , 0 789 So the while guarantees that . . . Right , it , so , it looks like one of those divisions must be dividing by zero So , uh , why don ' t you print out what ' s going on in each iteration , Wikipedia has a table of what should be on each iteration Uh , not sure um . . . main test , line 34 , still get a complex division Yeah Ah . . . I ' m not . . . Um , it , magically fixed itself Well it said the method terminates when the things aren ' t . . . When the things stop changing Yeah , dividing by zero , um What do we do about that ? [ unintelligible ] anything about it ? Uh , what does the comma do in Python , in print ? Does it like space the things out nicely ? Well we ' ll try it What does that look like ? Let me try it with those same initial values that the Wikipedia one ' s using But , you , is it printing anything first ? By the way , how did you solve the , uh , constructor not working with the minus thing ? Weird Figure 5 - 3 : An excerpt of a debug work product cooperation episode from one pro - gramming session ( Pair 1 , Task 2 ) summarized in the timeline visualization . 72 Debug work product : partners work to turn broken code into working code by testing , code review , discussion , and so on . Figure 5 - 3 represents an excerpt from a roughly four - minute debugging session , where the pair is attempting to ﬁx a division - by - zero error . Integrate work products : not observed in our study ( for reasons detailed below ) , such episodes are deﬁned as version - control - mediated code integrations that include synchronization , testing , and debugging . Make remark : observed only twice by Prechelt et al . and only once in our study , these episodes consist of remarks about the other person’s situation to which that person does not reply . We coded the data from the test - driven interface sessions according the deﬁnitions in the paper , but did not formally use the foundation layer coding ﬁrst . Rather , the primary tool for coding the data was the timeline visualization . We did not observe any integrate work products episodes ; Prechelt et al . deﬁne these as “necessarily phys - ical , ” since in their study programming pairs had to physically rearrange themselves in front of a single machine in order to do verson - control - mediated integration . In our user study , not only were participants not permitted to move to their partner’s com - puter , but there was no version control synchronization to perform . We observed the constituent exchange project details , discuss step , and debug work product episodes that comprised integrations and coded them as such . While this taxonomy of cooperation episodes was generally satisfactory , we recom - mend the addition of discuss work practice episodes to the vocabulary . For example , during one session ( Pair 2 , Task 3 ) , the implementer and the tester agree that the implementer will do brainstorming in comments . This constitutes neither a discus - sion of strategy nor of next steps , nor is it simply the exchange of project status or details . The negotiation and revision of work practices , made easily expressible and actionable with a supportive user interface , seems a beneﬁcial interaction worth noting . 73 0 2 4 6 8 10 Debug work product Discuss step Discuss strategy Exchange general knowledge Exchange project details Duration ( minutes ) Min Median Mean ± 1 std . err . Max N = 10 N = 32 N = 8 N = 11 N = 32 Figure 5 - 4 : Durations of cooperation episodes by type . Dot indicates median , dia - mond indicates arithmetic mean , dotted lines are standard error , and red circles show minimum and maximum . Overall , our results are similar to those Prechelt et al . observed , modulo the lack of integrate work products . We initially hypothesized that make remark episodes would be more frequent than in their study , but this was not the case . Remarks were almost invariably either about the speaker’s own situation , or if they were about his partner , his partner would respond , even if only with “yeah” or “OK . ” A graph of cooperation episode durations in Figure 5 - 4 shows the mean and median length of individual episodes . While other cooperation episodes generally last at most one minute , debug work product episodes lasted on average more than two minutes . After debugging , strategy discussions are the next - longest cooperation type . Figure 5 - 4 has the same design as Figure 2 of [ 40 ] to ease comparison . The most notable diﬀerence is in the length of discuss step episodes , which appear qualitatively shorter in our study . This may be a systematic error in our application of the vocabulary ; but it may be that the continuous code synchronization and interdependent test - driven programming practices our participants experienced led to closer collaboration with more frequent synchronization and therefore next - step discussions of smaller scope . Figure 5 - 5 shows the distribution of cooperation episode types in the four test - driven interface sessions . In the second session , the pair spends considerable time in exchange project details episodes as they work to understand the problem . This pair never cooperates on debugging work products because they did not make suﬃcient progress on the task to have work products to debug . 74 Pair 1 , Task 2 Pair 3 , Task 2 Pair 2 , Task 3 Pair 3 , Task 3 Average 0 5 10 15 20 25 30 35 40 45 Time spent ( minutes ) Exchange project details Discuss step Discuss strategy Exchange general knowledge Debug work product Figure 5 - 5 : Total time spent in cooperation episodes . Diamonds indicate session length ; unshaded time was spent not in a cooperation episode . 5 . 1 . 4 Examining Modes Dewan et al . studied distributed side - by - side programming , in which each member of a geographically separated pair has an “awareness computer [ that ] shows the screen of the partner’s desktop” [ 19 ] . Based on their observation of ﬁve programmer pairs , they identiﬁed ﬁve main modes , or diﬀerent ways “programmers divided their work and collaborated with each other : ” Concurrent uncoupled programming : programmers work on diﬀerent tasks with - out communication . Concurrent coupled programming : programmers work on diﬀerent tasks , but continue to communicate . Pair programming : although participants never used the same computer , we clas - siﬁed activity as pair programming when one participant was viewing a ﬁle while the other edited it . Concurrent programming / browsing : similar to pair programming , but in this mode the non - editing partner is browsing through other code or web sites . Concurrent browsing : in this mode , both programmers are browsing though code or web sites . Again , we coded the data from the four test - driven interface sessions according to the deﬁnitions given . This presented some diﬃculty given the ﬂuid , constant move - 75 Pair 1 , Task 2 Pair 3 , Task 2 Pair 2 , Task 3 Pair 3 , Task 3 Average 0 5 10 15 20 25 30 35 40 45 Time spent ( minutes ) Concurrent uncoupled programming Concurrent coupled programming Pair programming Concurrent programming / browsing Concurrent browsing Figure 5 - 6 : Total time spent in each programming mode . Diamonds indicate session length ; unshaded time could not be categorized . ment between tasks , modes of operation , and degrees of collaboration our partici - pants exhibited . Classiﬁcation as pair programming , as opposed to the closely - related concurrent programming / browsing mode was diﬃcult , since the non - coding partner’s view was never bound to that of the editing partner . Pairs spent roughly half of their time on concurrent programming , visible in Fig - ure 5 - 6 , which shows the distribution of time spent in diﬀerent programming modes . We observed one session ( Pair 2 , Task 3 ) with no uncoupled programming . On a de - mographic questionnaire at the beginning of the user study , the members of this pair rated themselves with the highest combined familiarity of any pair in both experience with pair programming ( in a tie ) and experience with test - ﬁrst development . This familiarity may have led the pair to work in a particularly integrated manner . 5 . 1 . 5 Developer Feedback At the end of each session , participants were asked to complete a short post - task ques - tionnaire . The form included open - ended prompts for the “most negative ( frustrating , disappointing , . . . ) ” and “most positive ( eﬀective , pleasing , . . . ) ” aspects of working on the task . In every instance , at least one member of the pair wrote positively about the experience , e . g . : • “Nice to have a second set of eyes . ” ( Pair 1 User 1 , Task 2 ) • “We managed to talk about the programming task and agree on interfaces before 76 starting to write code” ( Pair 3 User 2 , Task 2 ) • “Splitting tasks on the implementation / testing line is very simple and natural . ” ( Pair 3 User 1 , Task 2 ) • “Instant feedback on tests” ( Pair 2 User 1 , Task 3 ) • “Having the tests being written with immediate feedback was awesome . ” ( Pair 2 User 2 , Task 3 ) • “Again , I liked the division of tasks between an implementer and a tester , in spite of the division being very unequal in this case . ” ( Pair 3 User 1 , Task 3 ) Many of participants’ negative comments focused on user interface issues in the prototype : slow editor synchronization , lack of line numbers for following stack traces , and various keyboard and display glitches . But several of the negative comments speak to important issues to be resolved : • “Tests are usually failing because the implementation writer is usually editing code , so it’s usually in an inconsistent state . ” ( Pair 3 User 1 , Task 2 ) “Inability to work against a stable version of the parse code means that edits to the parse code break my test code in unexpected ways . It is not an easy issue since you sometimes want to look at the current version of the main code also , so having ways to specify what version we’re interested in using would be good . ” ( Pair 3 User 2 , Task 2 ) It was precisely this feedback , on the question of how to combine stability with awareness , that led to the development of error - mediated integration , discussed in Chapter 3 . • “Not being able to edit the non - test code to add some basic debugging func - tionality that was missing ( _ _ str _ _ ) was frustrating . ” ( Pair 3 User 2 , Task 2 ) “Hard to write code without also running some code on toy inputs . ” ( Pair 3 User 2 , Task 3 ) 77 The implementer must be free to do “println debugging” and other informal testing , and the testing role might include implementation of representation - invariant - and abstraction - function - related code . • “Also , the testing in this task was much easier than the implementation , so the test writer ( me ) ended up either sitting around or trying to help the implemen - tation writer without being able to type code” ( Pair 3 User 1 , Task 3 ) In addition to encouraging ﬂuid roles that are ﬂexible to accommodate diﬀerent workloads , the user interface can throttle the rate of tests passed in one direction or the other to balance the work . 5 . 1 . 6 Design Implications The results from this preliminary study suggested a number of important changes to the system—we have already mentioned the most important of them , error - mediated integration . Two other ideas were implemented and are discussed in the subsequent sections : the test lifecycle and code coverage . Since passing unit tests back and forth is the central activity of test - driven pair programming , tests and test status deserve ﬁrst - class user interface support . Expe - rience with the prototype suggested that developers must be able to easily discover which unit tests are passing , which are failing , and how unit tests are moving between tester and implementer . Using code coverage analysis , we can link tests to the code they execute . This helps the implementer ﬁx bugs , since they can easily bring up all the code responsible for a failing test . Code coverage also helps the tester , who can formulate glass - box tests based on the passing implementation of a black - box test . 5 . 2 Test Lifecycle The test - driven pair programming model deﬁnes a sequence of responsibilities for testers and implementers : 78 Tester writes a new test : perhaps a black - box test for as - yet unwritten code , or a new test of existing code . Implementer writes code to satisfy the test : writing new methods , ﬁxing bugs , and so on . Tester reviews the test : and may decide to write additional tests of the same code , or move on to a new one . Implementer doesn’t break the test : the test is retained to prevent regressions . In some circumstances , tests might also need to be revised , in which case the sequence of responsibilities begins again with the modiﬁed test . These responsibilities correspond to a four - stage test lifecycle implemented in Col - labode . Tests are assigned a lifecycle state by giving them a special Java annotation directly in the code . New tests : tests start out with no annotation—the programmer is still crafting the test code . @ NeedsImpl : tests that need implementation are ready for the implementer to consider and write code to satisfy . @ NeedsReview : tests that need review are working to the implementer’s satisfaction , and are ready for the tester to review . @ Accepted : at the end of the progression , both tester and implementer have moved on to other testing and implementing . 5 . 3 User Interface Based on the results of the preliminary evaluation , Collabode supports test - driven pair programming with a sidebar that shows tests moving through the four - stage lifecycle ( left side of Figures 5 - 7 and 5 - 8 ) . Passing tests are in green , while failing tests are 79 Figure 5 - 7 : Implementer’s view of a collaboration , with @ NeedsImpl testB , passing @ Accepted testD and a regression in @ Accepted testE . Figure 5 - 8 : Tester’s view of a collaboration , with new testA and @ NeedsReview testC . The tester is using the code coverage panel to review the implementation of testC . 80 in red ( for assertion failures ) or blue ( for exceptions ) . New tests have a thought - bubble shape to suggest that they are still in progress , while tests in other stages are rectangular with jagged edges on failures . By default , new and needs review tests are hidden when editing implementation ﬁles , and needs implementation and accepted tests are hidden when editing tests , although these sections can be expanded . The UI provides a button to move a test from one stage to the next ; this simply adds or modiﬁes the Java annotation automatically . Continuous test execution ensures that test results are always up - to - date . Clicking on a test name opens a test code coverage panel , shown in Figure 5 - 8 . At the top of the panel is the test code . This is designed to be useful to the implementer , who can quickly open up the code for a needs implementation test and see exactly what the tester is expecting . The rest of the panel shows method - level code coverage obtained from Jacto , described below . This is designed to be useful to the tester , who can quickly review the code written to implement a needs review test . The panel shows the full source code of methods called in the control ﬂow of the test , ordered with a simple TF × IDF weighting ( term frequency times inverse document frequency , [ 46 ] ) . For each method m called by test t in test suite T : TF ( m , t ) = number of calls to method m in the control ﬂow of t IDF ( m , T ) = log number of tests in T number of tests in T that call m This ordering brings to the top methods that are called more more frequently ( or perhaps exclusively ) in the given test than by other tests . Finally , while error - mediated integration is the default behavior of the system , one important TDPP scenario necessitates the ability to integrate code even when it contains errors . Consider the case where the tester wants to demand a piece of unimplemented functionality : public class Greeter { / / no methods yet } 81 public class GreeterTest { @ Test public void testGreet ( ) { assertEquals ( " Hello , world ! " , Greeter . greet ( " world " ) ) ; } } The attempt to call undeﬁned method Greeter . greet will result in a compilation error . Depending on how the test is written , the entire test method might therefore remain un - integrated , the test will not run , and will not appear in the sidebar ; or just the assertEquals line might remain un - integrated , in which case the test will show up as trivially passing . In this case , the tester needs to demand that the changes be integrated , errors notwithstanding , because those errors are important information for the implementer . Therefore , Collabode provides a force commit toolbar button which integrates any of the author’s outstanding changes in a selected region . 5 . 4 Jacto : JUnit AspectJ Coverage Tool Code coverage enables the system to link each unit test to the code it executes . We attempted to use the EclEmma ( eclemma . org ) Java coverage tool for Eclipse and its JaCoCo coverage library , but found the architecture unsuitable for eﬃciently obtain - ing per - test coverage . Instead , we developed Jacto ( JUnit AspectJ Coverage Tool ) using a simple AspectJ ( eclipse . org / aspectj ) aspect [ 33 ] . Jacto reports coverage at the method level , a much coarser - grained measure than the statement - level coverage provided by JaCoCo . The Jacto aspect is compiled as a library and woven at runtime with the launched JUnit tests ( which do not need to be compiled with AspectJ ) . It reports a stream of coverage events over a socket : starting a new test , and invoking a method or constructor . Three basic pointcuts are deﬁned : pointcut testing ( ) : execution ( @ org . junit . Test void * ( . . ) ) ; pointcut constructor ( ) : execution ( new ( . . ) ) ; pointcut method ( ) : execution ( * * ( . . ) ) ; 82 The testing ( ) pointcut identiﬁes the start of a new unit test . Two further point - cuts identify constructor and method invocations : cflowbelow ( testing ( ) ) & & constructor ( ) & & ! within ( Jacto ) cflowbelow ( testing ( ) ) & & method ( ) & & ! within ( Jacto ) Each of these pointcuts triggers advice that outputs the event type and method signature to a socket speciﬁed at launch . In Collabode , the system uses these reports to build the code coverage panel interface described in the previous section . 5 . 5 Formative Evaluation To evaluate the TDPP model with full system and interface support , two pairs of professional developers were asked to use the system to work on a programming problem and give their feedback about the interface and collaboration style . 5 . 5 . 1 Procedure Both pairs knew one another but worked either at diﬀerent companies or on diﬀerent teams . Self - reported ages ranged from 24 to 36 , and one participant was female . Participants’ ratings of their proﬁciency in Java on a 7 - point Likert scale ranged from 2 to 5 , with between 1 and 14 years of industry experience . All rated their experience with pair programming at the lowest level on a 7 - point scale . In the sessions , participants : • completed a demographic questionnaire ; • received a tour of Collabode and editing with error - mediated integration ; • saw how to write tests and use the testing sidebar to advance tests through the TDPP lifecycle ; • worked together on a programming task , starting with one assignment of tester and implementer roles , and switching approximately half way through ; • completed a post - task questionnaire to give written feedback ; 83 • and discussed the experience with the experimenter and their partner . Participants were seated side - by - side for the duration of the programming task , using their own computer or a provided laptop , and were encouraged to use whatever web resources they found helpful . The task was : Implement the state machine for a bus fare collector that can be used to : pay a full $ 1 bus fare with a $ 1 bill ; pay a discounted $ 0 . 75 bus fare with a fare card ; and add value to a card with $ 1 bills . The speciﬁcation went on to describe input and output symbols , required behaviors , and several implementation suggestions . Participants were also provided with an example input ﬁle along with the expected output . 5 . 5 . 2 Programming Both pairs began by diagramming a two - state solution to the problem ( one for accept - ing payments and another for loading a fare card ) and discussing their implementa - tion strategy . One pair chose a more elaborate object - oriented design approach , with objects to represent inputs and states , and spent all of their time building that infras - tructure . The other chose a string - manipulation approach and moved toward basic functionality more rapidly—but their session was cut oﬀ early by a issue with Col - labode and a scheduling error on the part of the experimenter . Counting non - blank non - punctuation lines , both pairs wrote approximately 40 lines of implementation and 40 lines of testing code . Figure 5 - 9 shows the state of the tests written by both pairs over time . The top pair wrote several tests , most of them very simple , and generally did push them through the lifecycle states . The bottom pair wrote fewer but more substantive tests ( judging by their scope and length ) , and generally were not paying as much attention to their state . Both pairs relied extensively on conversation and on looking at one another’s code . 84 0 10 20 30 40 50 60 minutes InputObjectTest . testAddConstructor InputObjectTest . testBalanceConstructor InputObjectTest . testCardConstructor InputObjectTest . testCashConstructor OutputObjectTest . testEmptyConstructor FareMachineTest . testBalanceSimple FareMachineTest . testCashSimple FareMachineTest . testBalanceAdd Figure 5 - 9 : Tests written during the two TDPP sessions . Width indicates test state : new , needs implementation , needs review , accepted . Color indicates test result : (cid:4) passed , (cid:4) assertion failed , (cid:4) exception or error . Horizontal scale shows time after the ﬁrst code edit of the session . 5 . 5 . 3 Developer Feedback Asked to give their feedback in free - response questions about the costs and beneﬁts of TDPP and positive and negative experiences during the session , participants focused on three categories : Communication , interaction , and coordination : every participant wrote posi - tively about some aspect of their interaction with their partner . A recurring theme was that TDPP helped them discover unshared assumptions and resolve diﬀerences in problem understanding . They appreciated the ability to work closely and in parallel without disruption . Coordinating tests with implemen - tation was noted as a cost , but no participant described being distracted : on the contrary , one participant wrote that having a partner made it easier to remain focused . Making progress : A couple of the participants felt that the up - front cost of writing tests was too great , and that writing tests was not as enjoyable . On the other hand , in addition to their progress uncovering assumptions and incomplete spec - iﬁcations , some participants felt that their own progress was signiﬁcantly helped by working with their partner . Participants deﬁnitely appreciated having their own editor , with the ability to navigate and edit any of the code . In contrast 85 to traditional test - driven or pair programming , both members of the pair had full ownership over one part of the code and did not have to switch contexts continuously . Quality : One participant felt TDPP compelled them to focus more on code read - ability , and other participants noted that TDPP would result in more tests and higher test coverage , with presumed beneﬁts to correctness later . This was an - other recurring theme : test - driven pairing incurred up - front costs that might be a bad ﬁt for some programming scenarios ( e . g . quick prototyping ) and a good ﬁt for others ( e . g . larger systems , systems where the cost of bugs is high , systems that will be maintained long - term ) . Two more categories rounded out the feedback and point to future work : UI problems : The most speciﬁc UI complaint related to stack traces of failing tests , which were inconvenient to read while also looking at and editing code , and the inability to see console output from tests for debugging purposes . Participants did appreciate the workﬂow and structure provided by TDPP , but did not rely heavily on the test lifecycle feedback in the UI , favoring conversation or directly looking at their partner’s code . For the pair with the simpler design , test feedback was generally accurate and the force - commit capability was never used ; for the pair who used an object - oriented design , test feedback was sometimes out - of - date due to uncommitted changes , and force - commit was used several times . More work is needed to reﬁne the approach to testing with error - mediated integration . Learning and apprenticeship : Both pairs brought up learning as a potential ap - plication of TDPP , and of the Collabode real - time collaborative editing interface in general . Whether the structured approach of TDPP would be good ﬁt for the apprenticeship model , where newcomers to a team or module work with more experienced mentors , is an open question . 86 5 . 6 Conclusion Test - driven pair programming was originally conceived as a way to demonstrate the power of diﬀerent interfaces to the same code for developers working with diﬀerent roles . The tester would see an interface about testing , and the implementer would see one about implementing . Ultimately , these interfaces grew together rather than apart , for all the same reasons that in traditional pair programming , the strictly - deﬁned driver and navigator roles appear to dissolve into a single shared mode of thinking and communicating ( see section 2 . 1 ) . The test - driven pair programming model does demonstrate how programming with real - time collaborative editing and error - mediated integration enables new col - laboration models that build on existing ones , making practices such as test - driven development and pair programming more accessible and directly supported by the IDE . Positive comments from every developer who participated in the two user stud - ies described in this chapter , especially comments that TDPP made both testing and pair programming more enjoyable , are evidence that these new models are worth continued exploration . 87 88 Chapter 6 µoutsourcing In the micro - outsourcing model of collaboration , one developer draws on the dis - tributed expertise of a crowd of other developers who make small contributions to the project . Micro - outsourcing allows the original programmer to remain “in the ﬂow” at one level of abstraction or in one critical part of the code , while a crowd of assistants ﬁll in the details or “glue” code elsewhere . In contrast to traditional outsourcing , which typically operates at the granularity of a whole module or project , micro - outsourcing requires a collaborative development environment in order to make the model eﬀective . This chapter describes pilot experiments conducted to reﬁne micro - outsourcing , which were presented at the ICSE 2011 workshop on Cooperative and Human Aspects of Software Engineering [ 22 ] . It then discusses at length a user study with crowd programmers hired on oDesk ( odesk . com ) , a realistic source of developers available for short - term hire . These programmers worked on short tasks requested by students and professional programmers acting as original programmers , with an overall success rate around 70 % . 6 . 1 Prototyping the Model Design of this new model started with research group pilot experiments . Students , professors , and visitors volunteered as original programmers ( OPs ) and crowd con - 89 tributors ( workers ) , working on a variety of tasks . Results informed the development of both the micro - outsourcing model and Collabode’s user interface to support it . These informal experiments suﬀered from several threats to validity . The OP felt a certain pressure to outsource as soon and as often as possible , knowing this was the point of the exercise . The crowd was not an anonymous pool of people , but rather a small group of colleagues waiting for the next chance to contribute . And both the eagerness and the skill level of these assistants overestimated the eﬀort and experience oﬀered by real - world workers . Nevertheless , some clear trends emerged , described in the following sections . 6 . 1 . 1 Laziness , Impatience , and Hubris Programming Perl ( the book ; the activity is not one this thesis intends to endorse ) oﬀers three facetious “great virtues of a programmer : laziness , impatience , and hubris” [ 53 ] . Micro - outsourcing showed potential in the pilot experiments in part because programmers know how to use these virtues eﬀectively . Lazy programmers on the one hand write only as much as they need at the mo - ment , but on the other hand write reusable code up front rather than re - write tedious routines again later . Lazy OPs are also happy to micro - outsource pieces of their code to others , and are able to navigate the tradeoﬀ of spending energy to deﬁne and outsource tasks as long as their overall energy expenditure decreases . In several pilot sessions , both OPs and workers remarked at the amount they could accomplish in little more than an hour , with very little per - task pressure . Impatient programmers ( according to Programming Perl ) write fast , eﬀective pro - grams that waste neither user time nor CPU cycles . But in the context of collabora - tion with many others , impatience becomes the grease that keeps the wheels turning . Workers are impatient to complete their tasks and make a contribution , and the OP is impatient to see the results and build on them . Fast failure , when either workers or the OP abandon or rescind a task , is a feature we anticipate will make micro - outsourcing eﬀective for rapid iterative development , and too - patient programmers might fail to fail . 90 Finally , hubris — the ( excessive ) pride that drives programmers to write great code — plays an important role . With micro - outsourcing , workers have continuous opportunities to prove their mastery of one idea , their skill with one construct , or their unmatched ability to answer one question . Just as programmers are proud to contribute excellent content to community wikis or sites such as Stack Overﬂow ( stackoverflow . com ) , so we have observed in our experiments how contributors strive to do good work . And the OP can still play Zeus and strike down the work of unhelpful workers if necessary . 6 . 1 . 2 Breadth and Depth Micro - outsourcing permits a wide variety of worker contributions , and several classes of work were requested during the pilots : implementing a function or part of a class from a speciﬁcation ; writing test cases ; searching for code examples , documentation , or libraries on the web ; integrating a found code snippet into existing code ; and others , including domain research . Asking workers to implement code , the OP sometimes left the speciﬁcation im - plied ( “implement iterator ( ) please” ) At other times the OP would write a complete speciﬁcation in a Javadoc comment and point the worker there . One interesting case serves as an illustrative example . The OP decided to imple - ment a bag data structure , and began by asking a worker to outline the interface : Please write the method signatures for some operations I’m likely to need ( use java . util . Set as a model ) : add , isEmpty , size , getCount ( T element ) From two more workers , he requested : “Please choose a representation for this . I’m thinking a HashMap , ” resulting in two independent opinions on implementation strategy . Workers also assisted with refactoring : Please change the bodies of the remaining methods ( removeAll onward ) so that they throw UnsupportedOperationException 91 And with testing : Please write an @ Test exercising Bag . add ( ) and Bag . getCount ( ) , using Bag < String > 6 . 1 . 3 Integrating Work The original programmer usually began by setting up a skeleton project ready to accept contributions . The experience from there was dominated by the strategy used to integrate everyone’s work : OPs used diﬀerent work integration interfaces in diﬀerent experiments . At one end of the spectrum , workers contributed in real - time to a single copy of the project , and OPs had diﬃculty reaching any steady - state where they could test and iterate on a partially - working program ; the project always had errors . At the other end , workers were given clones of the project in which to make undisturbed progress , and OPs were required to integrate work by hand ; outsourcing small pieces of code now entailed too much overhead . Error - mediated integration ( Chapter 3 ) was developed in response to these observations . 6 . 2 User Interface After conducting pilot experiments with several iterations of diﬀerent interfaces for micro - outsourcing , the current system was designed for real - time contribution . The OP creates a new task by clicking a toolbar button , which prompts for the task description as shown at the top of Figure 6 - 1 . Outsourcing the task adds it to the task sidebar , shown from the OP’s perspective on the left of Figure 6 - 1 . Unassigned tasks are grayed out , in - progress tasks show the assigned worker and a summary of changed code , and completed tasks are marked with a green check . The change summary on in - progress and completed tasks is a list of modiﬁed ﬁles , each with the approximate number of lines inserted and deleted . Clicking on the change summary opens a panel that shows all changes made by the worker for that task ( Figure 6 - 2 ) . Crowd programmers see only their current and previously - assigned tasks high - lighted in the sidebar ( left of Figure 6 - 3 ) . The current task includes a link to open a 92 Figure 6 - 1 : The original programmer’s view of a collaboration . The OP has the outsourcing dialog open and is writing a new request . The sidebar shows a new task ( grayed out ) , one in - progress , and one completed ( checked ) . Figure 6 - 2 : The contribution view for a single task . The OP is viewing changes made by worker ‘glittle’ for the request to ﬁx the greetBob method . 93 Figure 6 - 3 : The worker’s view of a collaboration . The task request is displayed across the top of the browser window , with a button to press when work is complete . The chat panel is open , where the OP has replied to the worker’s question . chat window with the OP , and the OP has a similar link for all in - progress tasks . The chat interface , visible in Figure 6 - 3 , is quite minimal , designed to mimic the opera - tion of a typical instant messaging client . Messages can only be exchanged between individual users ; there is no facility for group chat . Crowd programmers also see the current task request across the top of their browser window ( top of Figure 6 - 3 ) and a button to mark their work as complete . A worker’s ability to view and edit the project , granted when a task is accepted , is immediately revoked upon pressing ‘work complete . ’ 6 . 3 Instawork In addition to the collaborative IDE , micro - outsourcing requires a task assignment and notiﬁcation system . In order to prototype the system with minimal setup for prospective participants , we built such a system , called Instawork , using instant mes - sages as the delivery mechanism . 94 Figure 6 - 4 : An Instawork task oﬀer as it might appear in Google’s Gmail instant messaging interface , and a task conﬁrmation page . Instawork is implemented in Python , deployed on Google’s App Engine service , and uses the Google chat XMPP API to deliver task notiﬁcations . These instant mes - sage notiﬁcations link to a conﬁrmation page that allows the user to accept the task . Figure 6 - 4 shows an instant message as it might appear in Google’s Gmail interface ( although recipients can use any Google chat client ) and the task conﬁrmation page . After immediately oﬀering each newly - created task to a single worker , Instawork oﬀers the task to additional prospective workers over time , with a delay of approx - imately 30 seconds between each oﬀer . The ﬁrst user to follow the link and accept the task is assigned to it , and other users are no longer able to accept the task . The system will assign only one user to a task , and a user can be assigned to only one task at a time . Instawork will only contact an individual worker at most once every ﬁve minutes , regardless of the number of unassigned tasks , to prevent spamming . But if a task is oﬀered to every available worker with no success , the system will simply start oﬀering the task to those workers again . Neither of these behaviors played a role in the user study of micro - outsourcing , because workers generally accepted tasks quickly , 95 and there was almost always at least one idle worker available when new tasks were created . 6 . 4 User Study To evaluate the potential usefulness of the micro - outsourcing model and Collabode’s support for it , we conducted a user study in which original programmers recruited from our research lab and industry worked on small programming problems with the ability to outsource work to crowd programmers hired on oDesk . The suggested task size for this experiment was 15 minutes , and OPs were given a brieﬁng that described micro - outsourcing and oﬀered a number of recommendations based on the pilot experiments . The participation of remote anonymized workers from oDesk makes this study a much more realistic simulation of micro - outsourcing as it might be deployed . And while OPs generally had at least some success requesting work during the two - hour study sessions , the learning curve was a problem . One of the outcomes was repeated feedback from participants who felt , at the end of the study , that they were only just starting to understand how to employ micro - outsourcing successfully , and that they could be much more eﬀective at micro - outsourcing in the future . 6 . 4 . 1 Crowd Programmers Crowd programmers were hired on oDesk , an online marketplace that makes it possi - ble to hire contractors with various skills—data entry , graphic design , programming , and so on—from around the world . Contractors maintain proﬁles with feedback from previous clients and examples of their work . In general , a project begins with a job posting that deﬁnes the timeframe , requisite skills , and budget . Contractors bid for the project by submitting cover letters and prices , which the client can negotiate . For this study , programmers were hired in a three - stage process that required ap - plicants to complete two easily - evaluated programming problems and de - emphasized subjective judgement of their proﬁles or job applications : 96 1 . Contractors responded to a job post that speciﬁed a date and time when they should be available for two hours to work as an “on - call Java programmer . ” Ap - plicants were required to provide the solution to a small programming problem : “determine whether a String [ ] input is a ‘Word Square’ , using the deﬁnition from en . wikipedia . org / wiki / Word _ square . ” Applications that did not include a solution , or in which the solution was not minimally correct , were not con - sidered . This was designed to screen for basic programming ability as well as English reading comprehension . 2 . Up to four applicants were hired for each time slot with the requirement that they ﬁrst complete a paid qualiﬁcation task : implementing a class CountingMap , “a java . util . Map that records the number of times each key is assigned a value , ” including method public int countPuts ( Object key ) . Applicants whose im - plementation was not minimally correct were paid only for the qualiﬁcation task and did not participate further . This task was designed to screen for basic object - oriented Java understanding . 3 . Successful applicants completed a tutorial that required them to sign up for Instawork and introduced them to receiving , accepting , working on , and com - pleting work requests in Collabode . oDesk programmers were paid $ 10 for completing the qualiﬁcation task ( regardless of success ) and $ 20 for being available and participating during the two - hour study session . A total of 74 programmers applied across all job postings . 31 were hired , and 21 passed the qualiﬁcation task and participated in the study ; six of them participated in two sessions . Among the 21 programmers who participated , their mean self - reported age was 27 and two were female ( one participant declined to report age & gender ) . The mean advertised hourly rate displayed on their oDesk proﬁles was $ 14 . 95 , and they were located around the globe ( Figure 6 - 5 ) . Twelve had been hired for zero previous oDesk jobs . Because of the study’s unusual requirement that contractors be available for a very short , very speciﬁc time , we believe it was not an appealing job to 97 Figure 6 - 5 : Locations of crowd programmers according to their oDesk proﬁles . established contractors . At the same time , our hiring process largely ignored previous oDesk experience , making it an appealing way for contractors with no reputation to begin establishing a work history . 6 . 4 . 2 Original Programmers Seven students and two professional software developers participated as OPs . Their mean self - reported age was 25 and three were female . Participants rated their proﬁ - ciency in Java on a 7 - point Likert scale ( min = 2 , max = 6 , mode = 5 ) and reported their years of industry experience ( min = 0 , max = 3 , mean = 1 . 1 ) . Industry par - ticipants worked remotely , with a voice chat connection to the experimenter ; others completed the study in the lab , using their own laptops . Study sessions were two hours in length , with 60 to 80 minutes of programming . They were compensated $ 40 in cash or as a gift certiﬁcate . 6 . 4 . 3 Procedure In each session , original programmer participants : • completed a demographic questionnaire ; • received a brief tour of the Collabode interface and collaborative editing ; 98 • learned about micro - outsourcing , along with suggestions , guidelines , and exam - ples of tasks from the pilot experiments ; • received the programming problem and were directed to spend ﬁve to ten min - utes reading and planning ; • worked on the programming problem , outsourcing tasks as desired ; • completed questionnaires to give written feedback about each outsourced task and their overall experience ; • and , time permitting , discussed the experience with the experimenter . Crowd programmer participants were instructed to contact the experimenter via instant message at the start of the session to conﬁrm their readiness to receive tasks . These individual backchannels were maintained during the session and used to inform workers of delays and answer questions about technical issues . Crowd programmers had already completed a Collabode and micro - outsourcing tutorial as part of the hiring process , so during each session they : • waited for the OP to begin working and sending task requests ; • worked on one or more outsourced tasks ; • and completed questionnaires to give written feedback about each task they completed and their overall experience . Original programmers were given one of three randomly - assigned programming problems : Big Image : “identify the largest images on a web page by ( 1 ) ﬁnding referenced images using regular expressions , ( 2 ) downloading and determining the size of those images , and ( 3 ) sorting by size . ” Provided code included a class that could be used with the standard Java collections to sort images given their dimensions , and a comment with the URL of a Stack Overﬂow answer containing code for computing image dimensions . 99 0 1 2 3 4 5 6 0 10 20 30 40 Work time ( mins ) N u m be r o f t a sks Figure 6 - 6 : Histogram of task work time . 60 % of tasks were completed in 15 minutes or less , 75 % in 20 or less . Max - ﬂow : “solve the maximum ﬂow problem by ( 1 ) parsing a textual representation of directed graphs whose edges have a ‘capacity’ value and ( 2 ) computing the maximum ﬂow from a ‘source’ node to a ‘sink’ node within a capacities graph . ” Provided code included a small example graph ﬁle , a main method that called stub methods to compute a maximum ﬂow in that example , and a comment with the grammar for the textual format . Max - ﬂow variant : identical in problem statement , this task had additional pro - vided code . The Graph class contained a complete and correct parser imple - mentation that called an unimplemented stub method for every edge speciﬁed in the ﬁle . This variant was included to ensure that the algorithmic part of max - ﬂow would be attempted in some sessions . 6 . 4 . 4 Outsourced Work OPs outsourced a total of 45 tasks ( per - session min = 3 , max = 9 , median = 4 ) . The distribution of task work time ( from assignment to completion ) is shown in Figure 6 - 6 ( min = 1 : 53 , max = 36 : 10 , median = 13 : 21 ) . The amount of code written varied widely for OPs and workers , as shown in Fig - ure 6 - 7 , which plots total lines by each author in the ﬁnal code ( many lines were 100 0 25 50 75 100 125 150 175 6 3 8 2 5 4 7 9 1 V Q K I T R L MU H Y B Z A E G R S N E S C P P J MUM L i n e s a u t h o r e d Figure 6 - 7 : Partially - or fully - authored lines written by OPs ( numbered ) and workers ( lettered ) during each session . written but subsequently deleted ) . These totals include lines of whitespace or punc - tuation , and count partially - authored lines as a single line for each author . By this metric , OPs wrote a median 62 lines , and workers a median 14 . OPs were asked to rate how successful each task was “at moving [ their ] work forward” according to a ﬁve - point scale : • Negative progress - e . g . broke something , deleted code • No progress - e . g . no result , didn’t use the result • Minimal progress • OK progress • Excellent progress Workers were asked to rate their own success on a similar scale : no progress , minimal progress , OK progress , or excellent progress . Figure 6 - 8 shows the results . Each bar counts tasks by OP rating—no tasks were rated “negative progress . ” Bars are broken down by worker rating , showing general agreement between workers and OPs about what constituted success . Overall , 71 % of work was given one of the top two OP ratings . The number of chat messages exchanged during a task gives some measure of the amount of OP attention it consumed . Figure 6 - 9 shows a pair of plots where quick low - attention tasks are near the origin , and long high - attention tasks are up and to 101 0 5 10 15 No progress Minimal progress OK progress Excellent progress OP success rating N u m be r o f t a sks Worker success rating No progress Minimal progress OK progress Excellent progress Figure 6 - 8 : Histogram of task success as rated by OPs . Each bar shows worker success ratings for those tasks , which roughly agree with OP ratings . the right . Successful tasks tended to be of the quick low - attention variety ( note the shorter median work time and zero median messages ) . Characterizing tasks at the extremes of work time vs . success : Quick successes : Six OPs gave top success ratings to 13 tasks with below - median work time . These were generally requests to implement a fragment of code or a small method : getters and setters , constructors , or clearly - speciﬁed tests . Slow successes : Four OPs gave top success ratings to 4 tasks with above - median work time . Two of these asked workers to devise an image - ﬁnding regular ex - pression for the big image task and a third involved parsing a line from the max - ﬂow ﬁle format , all tasks core to the programming problem . Quick failures : Four OPs rated 4 below - median work time tasks “no progress , ” and in all cases the worker appears not to have understood the task . Low skill may also have contributed to their inability to make good progress . Slow failures : Two OPs rated 2 above - median work time tasks “no progress . ” In one case a worker was assigned to ﬁx broken code—code that worker had originally 102 0 10 20 30 0 10 20 30 Work time ( mins ) C ha t m e ss age s OP success rating No progress Minimal progress OK progress Excellent progress 0 10 20 30 0 10 20 30 Work time ( mins ) C ha t m e ss age s Worker success rating No progress Minimal progress OK progress Excellent progress Figure 6 - 9 : Tasks plotted according to work time and number of chat messages , categorized by OP ( top ) and worker ( bottom ) success ratings . Margin lines show median work times and message counts for tasks with each rating . 103 written . The OP thought the worker was making better progress , but ran out of time and cut them oﬀ . In the other case , the worker made a serious attempt to understand a diﬃcult request : translating Python code from the Ford – Fulkerson algorithm Wikipedia page into Java . They could not make progress , pointed out how the example Python assumed a diﬀerent data structure than what had been implemented in the project , and cut themselves oﬀ after 15 minutes as instructed . The OP agreed the task was too diﬃcult . The following sections discuss four aspects of the task lifecycle : specifying tasks , working on them , managing that work , and using the results . 6 . 4 . 5 Specifying Tasks Successful instances of micro - outsourcing began before the task request was written : Creating appropriate context : Several OPs described in the post - task interview how it was important to ﬁrst create the surrounding context or underlying foun - dation for worker contributions . Sometimes this was design , working out the overall structure of the problem . Sometimes this was implementation , making data structure or representation choices that would allow the OP to structure code and tasks . And sometimes this was instructions , pointing the worker to relevant code or speciﬁcations elsewhere . Setting boundaries : OPs used diﬀerent techniques to delineate the boundaries in - side which workers should contribute , to varying success . Most tasks were speciﬁed with one or a few methods the worker should implement , in whole or in part . One OP who opted to use lines of commented dashes to separate tasks later decided it “would have been better to create separate methods for each of the tasks” ( OP 5 ) . Sizing tasks : Both OPs and workers were instructed that tasks should take up to 15 minutes . Combined with uncertainty about workers’ skill level ( OPs were not told anything about the workers beyond that they were programmers hired on 104 oDesk ) , this sometimes made it diﬃcult to select tasks of an appropriate size . However , OPs who outsourced a larger number of tasks began to gauge worker skill and plan their work accordingly : “this is easy enough for [ worker V ] to do , [ . . . ] so I should maybe try to do [ step ] ﬁve” ( OP 5 ) . OPs were advised during the brieﬁng to write speciﬁc but concise task requests , and to write additional information or speciﬁcations in comments in the code . Expe - rience from pilot experiments suggested that this would yield clearer requests while keeping design information in the code where the OP and workers , present and future , could reference and potentially update it . This advice generally served them well , but it by no means guaranteed task requests were understood : English : One of the beneﬁts of micro - outsourcing is the ability to express tasks in natural language . oDesk requires contractors to rate their English proﬁciency ; all 21 workers in the study rated their writing level as “ﬂuent” , and 20 reported a verbal level of “good” or “ﬂuent , ” but these evaluations were clearly inﬂated . While English diﬃcultly often appeared to be a smaller factor compounded with a deeper programming skill problem , poor English in chat messages was a sign that some workers were struggling to understand task requests . Ambiguous references : OPs would sometimes make references that required work to disambiguate—e . g . “implement this method” ( OP 3 ) , which required the worker to check the line number of the task to ﬁnd the method . Such refer - ences are quite natural and the system should support them with stronger links between task and code , discussed in subsection 6 . 4 . 10 below . Expecting code : OPs were encouraged to outsource any sort of task , but almost all tasks were primarily about writing code in the project . Workers generally assumed that they should be writing code , which sometimes led to confusion . For example , in the max - ﬂow problem , two OPs requested that someone compute by hand the correct max - ﬂow value for a test graph . OP 8 created the task : 105 Could you please hand - calculate the max - ﬂow from node A to node E of the graph in abcde . txt , and assert that variable maxFlow contains the correct answer ? The worker did not understand “hand - calculate” and began an attempt to write code to solve the problem , not understanding that this algorithm was the big - picture goal of the project , and a rather challenging one . The task ended unsuccessfully , and the OP tried again : Could you please calculate the max - ﬂow of the graph above by hand ? Thanks . The format of the graph is Nodes - - capacity - > Nodes . This time they also included a ﬁll - in - the - blank comment in the code : The max - flow of this graph from A to E is _ _ _ _ _ . The revised request was successful , but had incurred signiﬁcant overhead . A ﬁnal pitfall of task speciﬁcation was failure to export to workers all the appro - priate context , and this is again a clear opportunity for better system support . Exporting vision : Some stronger workers , whose contributions made it clear they were capable programmers , were concerned that they could not understand the “bigger picture” ( worker N ) or “the problem being solved” ( worker R ) . And in the “hand - calculate” failure above , big - picture clarity might have changed the outcome . But this problem appeared to be the exception rather than the rule . Exporting state : Failures to export the state of the project were more pressing , and compounded other problems . Workers saw failing test cases and worried that they were responsible , even if the failures were expected and outside the scope of their task . Workers wanted to test their code , and didn’t know where or how to write main methods or test cases that could exercise their contribution to the larger system . Exporting pain : Even when OPs foresaw the need to export context , they did not necessarily want to : “I already have the image of the data structure and algo - 106 rithm in mind , and I would just go ahead and implement that instead of having to explain the whole thing again to everybody” ( OP 8 ) . Worker context , too : The same context export problem exists in reverse . When workers asked unclear questions , OPs found themselves reading code and trying to reverse - engineer the worker’s thought process . 6 . 4 . 6 Work in Progress Even for well - prepared , well - chosen , well - speciﬁed tasks , work could still be derailed : System failures : In a few instances , Collabode system design made it harder for workers and OPs to work successfully . As detailed in the Chapter 3 description of error - mediated integration , both algorithm and UI were designed with the assumption that programmers generally prefer to eliminate outstanding errors . OP 5 broke this assumption by instructing workers to declare syntactically - invalid methods inside of an existing method . The result was slower perfor - mance and confusing error feedback from Collabode , but the OP feared dis - rupting progress if a ﬁx was attempted . OP 6 requested implementation work inside an un - integrated stub method . Collabode’s simple model of code and error ownership ( see subsection 3 . 3 . 4 ) meant that the worker could not see compilation errors on their in - progress code because it was considered part of the OP’s un - integrated change . Focus : Task requests were presented in large type on the Instawork job acceptance screen , and persisted across the top of the browser until workers completed them ( Figure 6 - 3 ) . But any weak points in task understanding ( discussed above ) or distractions from concurrent editing ( discussed below ) were threats to focus . Eagerness and laziness : Experience on Mechanical Turk ( mturk . com ) suggests that roughly 30 % of crowd work products are unusable , and two producers of prob - lematic work are eager beavers and lazy workers [ 5 ] . The 13 out of 45 tasks ( 29 % ) rated by OPs as “no” or “minimal” progress continues that pattern . OPs 107 certainly experienced eager beavers in a few instances ; one worker asked “should I colaborate [ sic ] with other guys ? ” ( ignoring the task request ) , then asked if he could add a library to the project , and then decided to work in his own editor instead of in Collabode—all in order to open InputStream s for a List of URL s , accomplishable with the URL . openStream method call . Skill : Programming requires the ability to apply focused eﬀort ( avoiding laziness ) on a speciﬁed , bounded task ( avoiding eagerness ) . It requires skill—and worker skill level was frequently an issue . OP 1 watched as a worker declared a private static final local variable , then attempted to resolve the compilation error by trying public and various other illegal modiﬁer combinations . The OP in - structed the worker to mark the task complete rather than engage in a poten - tially frustrating conversation to correct the simple issue . While some workers clearly lacked Java or general programming competency , other workers were more than competent . Some OPs with less Java experience worked with crowd programmers who were more proﬁcient at Java syntax , APIs , and idioms . OP 2 , with “rusty” Java , requested : Please implement initialization and equality based on names for this class The worker correctly knew to override Object . equals ( Object ) and employed a stan - dard idiom for checking the run - time type of the argument . The OP’s evaluation : I don’t know how structural equality is usually implemented in Java pro - grams ; this programmer obviously knows the pattern and did a good job . Workers produced regular expressions , used Java collections APIs , and wrote algo - rithmic fragments that OPs predicted would have taken them longer to discover or write themselves . The real - time collaborative editing was generally accepted without issue . OPs were able to work in parallel with workers , and to have multiple workers contributing at the same time . In the instance of maximal parallelism , OP 6 worked on an algo - rithm in GraphMath while four workers added to GraphTest . OP 2 said , “the ease with 108 0 % 25 % 50 % 75 % 100 % 5 2 6 9 8 1 4 7 3 S e l f - r e p o r t e d % o f t i m e outsourcing tasks & managing CPs reviewing , fixing , and integrating CP work working in parallel with productive CPs working with no productive CPs Figure 6 - 10 : OP self - reported estimates of time spent ( normalized ) , showing a per - ceived median 50 % of session time spent outsourcing , managing , reviewing , and ﬁxing ; oﬀset by a median 32 % of time working in parallel with crowd programmers ( CPs ) . which I was able to parallelize the tasks was something that I didn’t expect , ” and reported not outsourcing some tasks simply because all the available workers were already occupied . And these workers were not always working simultaneously but separately . OP 8 , for example , was pleased when a worker pointed out an issue with the chosen graph data structure . Real - time collaboration was , however , sometimes a source of distraction . OP 7 mentioned this problem several times , and felt that the real - time mode should be optional : for working directly on code , “I’d want to have a more focused environment” without the distraction of others’ changes . But for “orchestrating” the work of crowd programmers , real - time changes were the right interface . This OP went on to say that real - time collaboration did eliminate conﬂicts and conﬂict resolution , making it a more diﬃcult trade - oﬀ . 6 . 4 . 7 Management and Communication When asked to estimate time spent on diﬀerent activities during the study , OPs estimated that they spent an average of 47 % of their time managing workers and re - viewing their work ( Figure 6 - 10 ; estimates of two OPs have been normalized to sum to 100 % : one reported percentages summing to 95 % , with no time spent on other activities , and one reported 110 % ) . One component of this overhead was communi - 109 cating with workers . A total of 261 chat messages were exchanged during the study , and 26 of the 45 tasks included chat ( messages - per - task median = 2 , max = 36 ) . If we deﬁne initiating a chat conversation as either sending the ﬁrst chat message of a task , or sending a chat message after not exchanging messages with the recipient for at least ﬁve minutes , then under this deﬁnition 8 of 9 OPs initiated a total of 20 conversations , and 11 of 21 workers initiated a total of 15 conversations . Six workers never sent any chat messages . Two categories of messages were clearly deserving of user interface support : Mark as complete : Many of the OP - initiated conversations were requests to mark the task as complete . OPs had no way to end a worker’s assignment to a task , and so were forced to ask workers to push a button only the worker could push . In a few instances workers were confused about why they were being asked to stop work ( usually the OP was themselves out of time and wrapping up ) , but generally these requests were not an issue . The need to make these requests was anticipated and explicitly mentioned in the brieﬁng . All but one OP asked at least one worker to mark a task complete , so the system does need to support this explicitly without making it sudden or unpleasant for the worker . Request for review : Many of the worker - initiated conversations were questions about the task or project , but several workers made requests for the OP to review their work . These were often in the form of a question : “is it ok , ” “can I press work complete , ” etc . Workers also asked questions about the time limit ( should they continue working on a task past 15 minutes ) and acceptance ( should they write or pass certain tests ) that implied a need for review . Another element of the communication was social interaction , such as writing “hi” or “thanks for your help . ” OPs and workers were identiﬁed in Collabode by usernames , and participants sometimes used ﬁrst names when they could be inferred ( in one instance the OP explicitly asked a worker for their name ) . Asked how comfortable they felt working with the crowd programmers on a 7 - point Likert scale , OPs had a mixed but generally positive response ( Figure 6 - 11 ) . The OP who reported the 110 0 1 2 3 1 very uncomfortable 2 3 4 5 6 7 very comfortable N u m be r o f r e s po n s e s Figure 6 - 11 : OP post - session responses to : “How comfortable did you feel working with recruited programmers during this session ? ” lowest rating wrote : “spent a lot of time chatting without making progress , ” and that misunderstood tasks resulted in bad code or “arguing with the worker . ” Several OPs said that they did not want to have to engage in conversations with workers . Even OPs who were more comfortable still worried about the social interaction : • OP 1 was worried about how workers would feel if they were told to stop work - ing : “now I don’t want to stop him because he’s doing something , ” “feels so bad to stop him in the middle of something . ” • OP 3 was frustrated “when the collaborators ask questions that don’t make sense” because they couldn’t be ignored , but engaging in a conversation to reach full understanding would take too much attention . In general , interacting with workers was a cognitive load OPs were not used to bear - ing while they program , and the tradeoﬀ with the usual cognitive requirements of programming was diﬀerent for each participant . The most consistent management issue was around work status : what were crowd programmers working on , how far along were they , and how well were they doing : Tracking tasks : OPs appreciated the task sidebar where all current tasks were visi - ble . But several OPs , trying to check in on a particular task , would click several of the tasks before ﬁnding their target . OP 5 suggested that tasks should have 111 titles , to make them easier to identify , and OP 4 suggested a marker in the code to identify the location of a task , to allow searching in the code rather than in the sidebar . OP 6 spent time mentally reviewing tasks to remember whether whether certain work had been sent out or not . Tracking workers : OPs frequently needed to examine worker code to understand what was or was not being done . Sometimes the real - time collaborative editing was suﬃcient , simply as an indicator of whether and where a worker was adding code . OPs used the changes view to see , or estimated from memory , workers’ time - on - task in order to gauge productivity . And OPs would wonder aloud at what workers were doing , why they weren’t writing code or why they were writing that code , trying to model workers’ thought process and progress . 6 . 4 . 8 Task Results Many workers requested review of their work , and OPs also oﬀered advice , made corrections , or asked questions while work was in progress . In some cases , OPs never had to revisit the output of a task : “the method just worked , and I didn’t need to debug” ( OP 7 ) . But in most cases , either before or after a task was marked as complete , the OP had to review the work in some way . Easier to read than write : Outsourcing was beneﬁcial when code was easier to verify than to produce . OPs cited many classes of tasks that might fall into this category : ﬁguring out how to use or connect libraries , producing boilerplate code , or implementing a known sequence of steps . Several also suggested using test cases to verify work , by asking workers to produce test cases along with implementation , by asking other workers to write tests , or by writing tests themselves . Appearances may be deceiving : Low OP success ratings were often given to tasks where the OP was required to understand and ﬁx outsourced code—many OPs commented that if they had to go back and understand the code anyway , the 112 beneﬁts of outsourcing were lost . In some cases , OPs were given bad code that looked good . OP 1 hoped to avoid understanding an outsourced regular expres - sion , which looked correct and even matched an example from the OP’s own web searching , but was eventually forced to parse it in order to ﬁnd a problem with anchoring . But there were also cases where good code looked bad : two OPs who asked workers to integrate the same code from Stack Overﬂow for the big image task were confused by return null statements on the last line . They spent time reading and understanding the code only to realize there was a deeply - nested non - null return in the success condition . One potential downfall of micro - outsourcing is that tasks will be only weakly decoupled from one another , making it hard to work on one task while other parts of the system are in ﬂux . During the study OPs experienced many successful instances of parallel work on interdependent code , but this was not always the case . OP 2 experienced one failure mode : “because you’re giving each programmer a task that’s very limited in scope , they don’t have the ability to go back and refactor other code that aﬀects the way the task they’re working on is implemented . ” This is in contrast to the continuous ad hoc refactoring one might do when programming alone , and it both makes the tasks harder and reduces the quality of the results . The OP needs to be able to identify , step in , and ﬁx such situations quickly , but in many cases OPs were busy elsewhere or were reluctant to disrupt work in progress . Finally , OPs with industry experience were concerned not just with the quality of worker code , which was quite variable and troubled several OPs , but also with issues that would arise using micro - outsourcing in a team or company context . Identity and accountability : Workers in this study were identiﬁed only by a user - name and were assigned without any review by the OP , which in some cases meant that their skill level was too low , or that OPs felt workers were not taking responsibility for their code . Just as other micro - work marketplaces ( in - cluding oDesk ) rely on identity and reputation to hold workers accountable , micro - outsourcing requires the same . 113 Private libraries : Proprietary code and protecting company secrets might be ad - dressed by building closed groups of trusted workers bound by nondisclosure agreements . But even open - source projects often make use of team - or project - speciﬁc libraries , frameworks , and tools , which workers will have to learn . Style : Consistent style and use of certain patterns or idioms makes maintenance and debugging tasks more straightforward . Some style conformance can be checked and repaired automatically , but to date , programmers are still reduced to arguing over whether indentation should use tabs or spaces , and code from workers will have the same sorts of issues . All of these point to the opportunity to hire and train workers over the long term . Micro - outsourcing is an avenue for both workers and requesters to reduce their initial risk but then develop a relationship that leads to growth and expertise . 6 . 4 . 9 Prospects for µoutsourcing OPs who found micro - outsourcing interesting and potentially useful generally did so because they could work at the level of speciﬁcations and high - level design rather than code and low - level implementation : • OP 1 : “I like this model very much” because “I’m more interested in high - level design decisions . ” The model is “perfect for how I program , [ . . . ] how I approach a problem , and I guess that could be diﬀerent for other people , maybe people who enjoy programming more low - level stuﬀ . ” • OP 2 : “I feel like I’ve been writing speciﬁcations . ” • OP 5 appreciated “being able to focus on the ﬂow of the code and the more diﬃcult parts of the problem . ” These results support the hypothesis that micro - outsourcing would allow the OP to work at a high level of abstraction while crowd programmers sweat the details . By way of contrast , OP 4 was less enthusiastic about the model . This OP spent 114 much more time hacking on code without attempting to outsource , in some cases appearing to struggle with problems of the sort that workers solved successfully in other sessions . OP 4’s experience suggests that micro - outsourcing may not be a good ﬁt for all programming styles . It also suggests that there is a metacognitive learning curve : some OPs were more aware of their own strengths and weaknesses , and were better able to outsource work that ﬁt workers’ comparative advantages . Several OPs said that the speciﬁcations required for micro - outsourcing changed their programming approach . They were forced to “specify inputs and outputs more clearly” ( OP 5 ) , to make more “initial investment in ﬁguring out interfaces” ( OP 7 ) , and to think about how to make components more independent . OP 6 described how micro - outsourcing meant less thinking about code details , but more thinking “up - front , about how to distribute tasks and what parts of the project I can shoot oﬀ to diﬀerent people and what not , ” and said that this was an even greater diﬀer - ence , compared to programming alone , than the interaction with and management of crowd programmers . To the extent that better design yields better software , micro - outsourcing can provide both a forcing function to produce the design and rapid evaluation of how well the design holds up . The model also worked well for OPs who lacked skills the crowd programmers could ﬁll in : • OP 2 , who reported the lowest Java proﬁciency , wrote : “I was able to program in Java really eﬀectively without having to remember anything about the syntax or libraries . ” • OP 7 : “I loved seeing one of my workers complete a task that would have been more diﬃcult for me to complete , ” noting also the learning beneﬁt of being able to see the code unfold in real - time , revealing the approach as well as the results . And multiple OPs thought that the session had been a good introduction , but that they could use micro - outsourcing much more eﬀectively in the future . Overall we received a number of very positive comments that suggest micro - outsourcing is worth continued study : 115 • OP 3 : “I’d like this method to do this . . . and then it just shows up . . . that’s really cool . ” • OP 1 : “I’ve never done anything like this before , I couldn’t , because there was no system like it . ” • OP 7 : “I liked it , I was kind of surprised , I thought it would be more diﬃcult to ﬁgure out what things to outsource . ” • OP 5 : “I hope this is the future of programming . ” Crowd programmers also gave very positive feedback . Asked to rate on a 7 - point Likert scale whether they would want to work on a hypothetical oDesk micro - outsourcing platform , the response was encouraging ( Figure 6 - 12a ) . And asked on a per - task level whether they would want to work on similar tasks in the future , the response was overwhelmingly positive ( Figure 6 - 12b ) . • Worker E : “Doing a little tid bits of Java is always a fun [ sic ] . ” • Worker B : “I am not sure what is [ sic ] that I was contributing to . Not sure of the reason behind the event . All I know is it was fun working in here . It was completely diﬀerent from what I regularly do . Online editor is amazing . ” • Worker U : “I love this kind of work , when I’m required to implement something given a detailed speciﬁcation . It was also very interesting to watch code being written in real time by other programmers . ” • Worker N wrote to the experimenter , “I have been reading your paper on Col - labode . Found it interesting . ” Negative comments generally focused on two topics : Collabode bugs and missing IDE features ; and underspeciﬁed , confusing , or overly diﬃcult tasks . Comments from several workers ( such as E and U above ) support the hypothesis that there is a match between programmers who want to specify and build a system at a high level , and programmers who prefer to work on the individual components of such a system . 116 0 2 4 6 8 10 12 1 not at all 2 3 4 5 6 7 very much N u m be r o f r e s po n s e s ( a ) Worker post - session responses to : “Imagine a service on oDesk where all jobs were were like this ( 15 minutes , jump into a project in - progress ) . Would you want to work there ? ” 0 5 10 15 20 25 30 1 not interested 2 3 4 5 6 7 very interested N u m be r o f t a sks ( b ) Worker per - task responses to : “How much would you want to work on jobs like this in the future ? ” Figure 6 - 12 : Worker ratings for ( a ) how much they would want to work on a hypo - thetical oDesk micro - outsourcing platform , and ( b ) whether they would want to work in the future on tasks similar to the ones they received during the study . 117 6 . 4 . 10 Design Implications When creating tasks , requesters should be able to specify properties of the task that will help workers decide whether and how to work on it . This includes task - speciﬁc properties , such as expected time or diﬃculty and API knowledge required , as well as expected work practices : is this a task that should require no discussion or support , or does the requester want to discuss the problem and review the work ? At the same time , requesters should be able to create tasks according to predeﬁned templates ( in addition to one - oﬀ speciﬁcations ) for requests such as ‘implement this method’ or ‘write a test for this method . ’ And they should have the ability to queue tasks pending the completion of prerequisite tasks , in order to plan more than one step ahead . The task routing system , in addition to matching the skills required for a task , can also ﬁnd workers for whom the OP’s desired work practices are a good ﬁt . The system as a whole should allow both OPs and workers to build and maintain an identity and reputation that can enable trust and accountability . The worker interface needs to better focus workers , not necessarily by hiding code or making the assigned task more salient , but by : • giving clear indications of the speciﬁc places in the code to work on the task ; • removing feedback irrelevant to the task that may distract or confuse , e . g . failing test cases elsewhere in the code ; • and making it easier to test their individual contribution , e . g . by creating or running relevant tests or main methods easily . This interface should be supported by stronger links between task requests and code , with the ability to create persistent references both at task creation and when ques - tions arise . Finally , it is clear from this user study that workers and original programmers need an improved , structured status communication mechanism . Multiple OPs described wanting a ‘task - focused’ view that would allow them to manage tasks with more 118 information than the sidebar and real - time editing could provide . And while one OP raised and dismissed the idea of a task “progress bar” as impossible , the idea of a task lifecycle is worth exploring : how can the system automatically detect certain statuses , and based on common work patterns , make it easy for the worker and OP to share status along a task timeline : Reading might be an initial state : the worker is reading the request and the code . The system can detect and summarize for the OP where the worker is looking . Researching is a natural next state : the worker is looking up relevant information . If the system provides or is aware of documentation browsing [ 24 ] and code navigation , it can also try to detect or summarize research status . Working is the easiest state to observe from real - time edits , but OPs often wondered what part of the task a worker was working on , and this should be made easy for workers to communicate . In some cases workers would go outside the scope of a task to do other useful work , which an appropriate visualization may be able to show automatically . Done has diﬀerent meanings at diﬀerent times : has the worker already left for the next job somewhere else , or are they waiting to ﬁx bugs after a review ? Questions and feedback will be easier to understand when they come attached to the appropriate context : what code is the worker focused on , what parts of the project have they looked at , and so on . 6 . 5 Conclusion The overwhelming majority of participants in our study of micro - outsourcing , both original programmers and crowd programmers , gave positive feedback about the po - tential for this collaborative software development model . Supporting the work of programmers across 9 sessions with up to 5 concurrent editors clearly demonstrates how Collabode makes real - time code collaboration practical and useful . 119 Micro - outsourcing requires the construction of a new market for programming micro - work that does not quite already exist on platforms such as oDesk or Mechanical Turk , but the properties of that market do not immediately appear to be particularly exotic : a reputation system is required to identify programmers who can do useful work , and a task routing system is needed that has a low burden of speciﬁcation for requesters but also makes it easy for workers to receive tasks that match their skills . If and when highly - collaborative programming becomes more common , some developers are sure to ﬁnd that paying for small pieces of work makes economic sense , and micro - outsourcing will become one of the ‘futures of programming . ’ 120 Chapter 7 Future Work The Collabode system , error - mediated integration , and the highly - collaborative pro - gramming models developed in this work are intended as useful jumping - oﬀ points for future research . 7 . 1 Collaborative Real - Time Software Development While source code is the dominant artifact of software engineering , it is not the only point of potential collaboration between developers . They might , for example , collaborate on running the program and examining its output , and participants in the study of error - mediated integration presented in Chapter 3 did just that . But they would block on their parter before running the code , waiting for them to complete their current piece of work . Participants almost never ran their programs while they contained errors , presumably because it was too diﬃcult to understand what code was being run , and what the results meant for each member of the pair . This was not a failure of the system architecture , which was perfectly capable of running the code , but of the interface , which failed to support parallelism and limited participants’ collaboration options . Collabode has demonstrated success making editing and testing highly collabora - tive , but there is much future research needed on how to make other phases of the software development process collaborative to the same degree : 121 Design : Collaborative real - time editors for drawing and diagramming already exist and may be useful for collaborative design , as well as tabletop interfaces useful for co - located design collaboration . Debugging : Real - time collaboration in debugging tools , where multiple program - mers can independently navigate data or program state exposed by the debug - ger , will also raise questions around debugging process and practices . And since programmers so often turn to ‘ println debugging’ with console or log output because of its simplicity and universality , debugging is all the more ripe for exciting new ideas . 7 . 2 Error - Mediated Integration Throughout this work , the ‘errors’ in error - mediated integration have been compila - tion errors , but this was only a convenient choice that solved a ﬁrst - order problem . It may be that EMI with compilation errors will allow a diﬀerent problem to dominate : changes that compile but produce runtime errors for other programmers . One ap - proach to apply to this problem is test - mediated integration , taking a cue from tools such as JUnitMX [ 58 ] that validate incoming changes against tests , but new collabo - ration structures and user interfaces may mitigate the problem without requiring test suites . The technique of error - mediated integration can also be applied to programming languages other than Java and which do not share its characteristics . In some cases , such as other strongly - typed languages , compilation errors may still be a logical choice . In other cases , such as dynamically - typed languages , the compiler or parser may be be able to identify syntax errors but not other classes of problems . In such cases , static analysis tools may be useful . Error - mediated integration is not version control and was designed to solve the problem of close collaboration , not collaboration at project - scale in terms of time or programmers . EMI could be combined with version control by simply having the two operate independently , but a more powerful approach will be to use EMI to 122 inform the operation of version control . Developer - chosen and annotated revisions are valuable for individual and especially team developers to understand project history , but EMI can help identify and suggest potentially useful code states to record in version control , and can help developers cherry - pick completed changes to record while leaving in - progress work for a later revision . As seen in Chapter 5 with the force - commit option provided for test - driven pair programming , mixing manual and automatic integration is an open problem . In addressing this problem , as well as the question posed in Chapter 3 of how one programmer’s edits to a collaborator’s un - integrated code should be handled by the system , it will be important to reﬁne EMI in a way that still presents a simple and clear mental model for programmers . No craftsman wants to use tools that omit important functionality , but neither will they master a tool whose operation is unpredictable . Finally , there is clear algorithms research needed to make EMI far more eﬃcient . In Collabode , EMI uses the Java compiler as a black box . The algorithm chooses a subset of edits , applies them , asks the compiler for errors , looks at the errors , and repeats . Moving EMI inside the compiler would allow for powerful optimizations : for example , a region that introduces block - comment opener / * can only be valid when paired with * / , and edit subsets containing only one of those can be ignored . Other more powerful heuristics are waiting to be identiﬁed . 7 . 3 Models of Collaborative Programming The models presented in this thesis are an attempt to cover diﬀerent potential users ( student , amateur , and professional programmers ) exercising diﬀerent beneﬁts of col - laborative programming . There are many further collaborative models to explore : Sprints & Hackathons : In addition to structured collaborations with well - deﬁned roles , Collabode can enable a self - organizing group to work together with little setup and rapid feedback on their progress . 123 Global Classroom : Connecting remote students and instructors with a fully - featured IDE ( as opposed to screen sharing , for example ) will allow for more eﬀective teaching and a more rewarding experience . Global Enterprise : For collaborators coordinating across time zones , error - mediated integration is an alternative to version control that makes sharing works - in - progress natural . With the help of developers , the detailed editing history can be summarized into meaningful version control commits . The classroom programming model needs contributions from computer science education research to understand how to turn tools and capabilities into educational strategies and outcomes . And the micro - outsourcing model relies on a market for short - term programming . This market does not yet exist , but many research questions into how to build and scale it certainly do . 7 . 4 Changing the Game Real - time collaborative text editing , reinvented on successive platforms with ever - greater usability , certainly never replaced single - author editing , and never supplanted asynchronous forms of collaboration . Few , if any , novelists write in Google Docs with their editor looking on to oﬀer immediate corrections . Few playwrights demand an army of real - time dramaturges who ﬁll in historical details on the ﬂy . Few teachers are inviting classes of students to write essays they will evaluate in real - time . Instead , real - time collaborative editing ( RTCE ) is a mode authors turn on when they have a particular collaboration problem to solve : brainstorming , shared note - taking , reviewing , annotating , and so on . Even if most of an author’s time using an editor that supports RTCE is spent without using that feature , its availability when a collaboration problem arises may still be ( in ) valuable . RTCE for source code might have a similar future : in an occasional classroom activity , during a pair programming impasse , or when an easily - outsourced problem arises , developers will be happy to have real - time collaboration tools on hand . This 124 would certainly not be a failure of RTCE for source code , as it will still enable all the new , useful collaboration models discussed in previous chapters . There is , however , a chance for software development with real - time collaborative editing to be a qualitatively diﬀerent activity from development without it . Many participants in the studies of error - mediated integration and test - driven pair pro - gramming had limited prior experience with pair programming or test - driven pro - gramming and described how those models were unappealing , yet they often gave positive feedback about their experience with the RTCE incarnations of these models in Collabode . Interface novelty and participant politeness surely explains some of the diﬀerence , but the addition of real - time collaboration also changes the character of these existing models . Pair programming with RTCE doesn’t require one member of the pair to forego editing , reading , navigating , or searching the code . Test - driven programming with RTCE doesn’t require constant alternation between two diﬀerent mental modes of system building . Outsourcing with RTCE enables hyper - specialized programmers to work on problems in the same domain across many systems , in contrast to today’s generalist programmers who work on many problems in a single system . In each case , real - time collaboration changes the underlying character of an existing practice , pointing to a chance for collaboration of this kind to have a broader impact on software development . Finally , to return to the computer science education motivation described in Chap - ter 4 , real - time collaboration on code is a uniquely accessible collaboration mode for students who do not have the maturity to work in a balanced pair or the expertise to master version control . Even for students who are ready to collaborate using those state - of - the - practice methods , RTCE enables small - scale collaboration on in - class or online code - writing exercises . There are many questions to answer on collaborative software development in - terfaces , algorithms , and models—but there is also a larger question : can real - time collaboration on source code change the game of software development ? The present work is an incremental step towards the answer , “yes . ” Future work should be bold , 125 and demonstrate how highly - collaborative software development is fundamentally dif - ferent from current practices . 126 Chapter 8 Conclusion At the outset of this project , the author made a prediction : by the time I could build Collabode , I would no longer need to . That is , in the time one academic could build a collaborative IDE good enough to demonstrate the value of some new models of highly - collaborative software development , a dozen open source and industry teams would build a dozen collaborative IDEs . It is true that we are now well on our way to a dozen web - based collaborative IDEs in the wild , although development took a long detour through web - based single - user IDEs ﬁrst . Real - time collaborative editing is a signiﬁcant technical challenge , so this is perhaps no surprise , but zero - setup collaboration is one if the great beneﬁts of an online IDE , as this thesis hopefully demonstrates . Perhaps the highly - collaborative programming models presented here will help inspire the direction of these IDEs . As for other kinds of software development collaboration , question - and - answer site Stack Overﬂow ( stackoverflow . com ) and source code hosting service GitHub ( github . com ) have been two of the most exciting developments . Neither uses real - time collaborative editing , but both demonstrate how incremental improvements to existing technologies ( Q & A sites , wikis , version control ) can combine with excellent community - building to create resources that change the experience of programming and make it more collaborative . And so I hope the next community - builders will be inspired by the possibilities of real - time collaboration . As online education expands its reach—as companies hire 127 more developers to build more complex systems—as new markets enable greater par - ticipation and specialization—perhaps programmers will rely on highly - collaborative socio - technical systems to be successful . I look forward to using what they build . 128 Bibliography [ 1 ] F . T . Baker . Chief programmer team management of production programming . IBM Systems Journal , 11 ( 1 ) : 56 – 73 , 1972 . [ 2 ] Michael Bayne , Richard Cook , and Michael D . Ernst . Always - available static and dynamic feedback . In ICSE , page 521 , 2011 . [ 3 ] Kent Beck . Extreme Programming Explained : Embrace Change . Addison - Wesley , 1999 . [ 4 ] Kent Beck . Test - Driven Development : By Example . Addison - Wesley , 2003 . [ 5 ] Michael S . Bernstein , Greg Little , Robert C . Miller , Björn Hartmann , Mark S . Ackerman , David R . Karger , David Crowell , and Katrina Panovich . Soylent : A Word Processor with a Crowd Inside . In User Interface Software and Technology ( UIST ) , UIST ’10 , page 313 , New York , New York , USA , 2010 . ACM Press . [ 6 ] Sylvia Beyer , Kristina Rynes , and Susan Haller . Deterrents to women taking computer science courses . IEEE Technology and Society Magazine , 23 ( 1 ) : 21 – 28 , January 2004 . [ 7 ] Jiang Bo , Bu Jiajun , Chen Chun , and Wang Bo . Semantic consistency main - tenance in collaborative graphics design systems . In Proc . Computer Supported Cooperative Work in Design , pages 35 – 40 . IEEE , April 2008 . [ 8 ] Frederick P . Brooks . The Mythical Man - Month : Essays on Software Engineering . Addison - Wesley , 1975 . [ 9 ] Sallyann Bryant . Double Trouble : Mixing Qualitative and Quantitative Methods in the Study of eXtreme Programmers . In VL / HCC , 2004 . [ 10 ] Sallyann Bryant . Rating Expertise in Collaborative Software Development . In Proc . PPIG , pages 19 – 29 , 2005 . [ 11 ] Sallyann Bryant , Pablo Romero , and Benedict du Boulay . Pair programming and the mysterious role of the navigator . International Journal of Human - Computer Studies , 66 ( 7 ) : 10 , 2008 . [ 12 ] Lori Carter . Why students with an apparent aptitude for computer science don’t choose to major in computer science . In Proc . SIGCSE , volume 38 , page 27 , 2006 . 129 [ 13 ] Angela N . Chang . A Mobile Instructor Interface for Collaborative Software Devel - opment Education . Master of engineering , Massachusetts Institute of Technology , 2012 . [ 14 ] Li - Te Cheng , Susanne Hupfer , Steven Ross , and John Patterson . Jazzing up Eclipse with collaborative tools . In OOPSLA workshop on eclipse technology eXchange , 2003 . [ 15 ] Jan Chong and T Hurlbutt . The Social Dynamics of Pair Programming . In International Conference on Software Engineering , pages 354 – 363 . Ieee , May 2007 . [ 16 ] Alistair Cockburn . Crystal Clear : A Human - Powered Methodology for Small Teams . Addison - Wesley , 2004 . [ 17 ] M . Dawande , M . Johar , S . Kumar , and V . S . Mookerjee . A Comparison of Pair Versus Solo Programming Under Diﬀerent Objectives : An Analytical Approach . Information Systems Research , 19 ( 1 ) : 71 – 92 , March 2008 . [ 18 ] P . Dewan and J . Riedl . Toward Computer - Supported Concurrent Software En - gineering . IEEE Computer , 26 : 17 – 27 , 1993 . [ 19 ] Prasun Dewan , Puneet Agarwal , Gautam Shroﬀ , and Rajesh Hegde . Distributed side - by - side programming . In CHASE , page 7 , 2009 . [ 20 ] Douglas C . Engelbart and William K . English . A research center for augmenting human intellect . In Proc . Fall Joint Computer Conference , Part I - AFIPS , page 395 . ACM Press , December 1968 . [ 21 ] Neil Fraser . Diﬀerential synchronization . In Proc . ACM Symposium on Document Engineering - DocEng , page 13 . ACM Press , September 2009 . [ 22 ] Max Goldman , Greg Little , and Robert C . Miller . Collabode : Collaborative Coding in the Browser . In CHASE , page 65 , May 2011 . [ 23 ] Max Goldman , Greg Little , and Robert C . Miller . Real - Time Collaborative Coding in a Web IDE . In UIST , pages 155 – 164 , 2011 . [ 24 ] Max Goldman and Robert C . Miller . Codetrail : Connecting source code and web resources . In Symposium on Visual Languages and Human - Centric Computing , pages 65 – 72 . IEEE , September 2008 . [ 25 ] Max Goldman and Robert C . Miller . Test - Driven Roles for Pair Programmming . In CHASE , pages 515 – 516 , 2010 . [ 26 ] Lile Hattori and Michele Lanza . Syde : a tool for collaborative software develop - ment . In ICSE , pages 235 – 238 , 2010 . [ 27 ] Rajesh Hegde and Prasun Dewan . Connecting Programming Environments to Support Ad - Hoc Collaboration . In ASE , pages 178 – 187 . IEEE , September 2008 . 130 [ 28 ] Chih - Wei Ho , Somik Raha , Edward Gehringer , and Laurie Williams . Sangam : a distributed pair programming plug - in for Eclipse . In OOPSLA workshop on Eclipse Technology eXchange , page 73 , 2004 . [ 29 ] Andreas Höfer . Video analysis of pair programming . Proc . Scrutinizing agile practices or shoot - out at the agile corral ( APOS ) , pages 37 – 41 , 2008 . [ 30 ] Reid Holmes and Robert J . Walker . Customized awareness : recommending rel - evant external change events . In ICSE , pages 465 – 474 , 2010 . [ 31 ] Susanne Hupfer , Li - Te Cheng , Steven Ross , and John Patterson . Introducing col - laboration into an application development environment . In Computer Supported Cooperative Work , page 21 , 2004 . [ 32 ] Claudia - Lavinia Ignat and Moira C . Norrie . Handling Conﬂicts through Multi - level Editing in Peer - to - peer Environments . In Proc . CSCW Workshop on Col - laborative Editing Systems , 2006 . [ 33 ] Gregor Kiczales , Erik Hilsdale , Jim Hugunin , Mik Kersten , Jeﬀrey Palm , and William G . Griswold . An Overview of AspectJ . In Jø rgen Knudsen , editor , ECOOP 2001 - Object - Oriented Programming , volume 2072 of Lecture Notes in Computer Science , pages 327 – 354 . Springer Berlin / Heidelberg , 2001 . [ 34 ] Andrew J . Ko , Htet Htet Aung , and Brad A . Myers . Design requirements for more ﬂexible structured editors from a study of programmers’ text editing . In CHI Extended Abstracts , CHI EA ’05 , page 1557 , 2005 . [ 35 ] Janne Lautamäki , Antti Nieminen , Johannes Koskinen , Timo Aho , Tommi Mikkonen , and Marc Englund . CoRED : browser - based Collaborative Real - time Editor for Java web applications . In Proc . CSCW , page 1307 . ACM Press , Febru - ary 2012 . [ 36 ] Harlan D . Mills . Chief programmer teams : Principles and procedures . Technical report , 1971 . [ 37 ] Sten Minor . Interacting with structure - oriented editors . International Journal of Man - Machine Studies , 37 ( 4 ) : 399 – 418 , October 1992 . [ 38 ] Matthias M . Müller . Two controlled experiments concerning the comparison of pair programming to peer review . Journal of Systems and Software , 78 ( 2 ) : 166 – 179 , 2005 . [ 39 ] Kanyamas Navoraphan , Edward F . Gehringer , James Culp , Karl Gyllstrom , and David Stotts . Next - generation DPP with Sangam and Facetop . In OOPSLA workshop on Eclipse Technology eXchange , page 6 , 2006 . [ 40 ] Lutz Prechelt , Ulrich Stärk , and Stephan Salinger . Types of Cooperation Episodes in Side - by - Side Programming . In PPIG , 2009 . 131 [ 41 ] Xiaoxia Ren , Fenil Shah , Frank Tip , Barbara G . Ryder , and Ophelia Chesley . Chianti : a tool for change impact analysis of java programs . In Proc . OOPSLA , volume 39 , 2004 . [ 42 ] Barbara G . Ryder and Frank Tip . Change impact analysis for object - oriented programs . In Workshop on Program Analysis for Software Tools and Engineering , 2001 . [ 43 ] David Saﬀ and Michael D . Ernst . Reducing wasted development time via contin - uous testing . In International Symposium on Software Reliability Engineering , pages 281 – 292 . IEEE , 2003 . [ 44 ] Stephan Salinger , Christopher Oezbek , Karl Beecher , and Julia Schenk . Saros : an Eclipse plug - in for distributed party programming . In CHASE , pages 48 – 55 , 2010 . [ 45 ] Stephan Salinger and Lutz Prechelt . What happens during Pair Programming ? In PPIG , 2008 . [ 46 ] Gerard Salton and Christopher Buckley . Term - weighting approaches in auto - matic text retrieval . Information Processing and Management , 24 ( 5 ) : 513 – 523 , 1988 . [ 47 ] A . Sarma , Z . Noroozi , and A . van Der Hoek . Palantír : raising awareness among conﬁguration management workspaces . In ICSE , pages 444 – 454 , 2003 . [ 48 ] Francisco Servant , James A . Jones , and André Van Der Hoek . CASI : preventing indirect conﬂicts through a live visualization . In CHASE , pages 39 – 46 , 2010 . [ 49 ] Danhua Shao , Sarfraz Khurshid , and Dewayne E Perry . Evaluation of Semantic Interference Detection in Parallel Changes : an Exploratory Experiment . In In - ternational Conference on Software Maintenance , pages 74 – 83 . IEEE , October 2007 . [ 50 ] Chengzheng Sun and Clarence Ellis . Operational transformation in real - time group editors . In Proc . Computer Supported Cooperative Work , pages 59 – 68 , 1998 . [ 51 ] Christoph Treude and Margaret - Anne Storey . Awareness 2 . 0 : staying aware of projects , developers and tasks using dashboards and feeds . In ICSE , pages 365 – 374 , 2010 . [ 52 ] Arie van Deursen , Ali Mesbah , Bas Cornelissen , Andy Zaidman , Martin Pinzger , and Anja Guzzi . Adinda : a knowledgeable , browser - based IDE . In ICSE , pages 203 – 206 , 2010 . [ 53 ] Larry Wall , Tom Christiansen , and Jon Orwant . Programming Perl . O’Reilly Media , 3rd edition , 2000 . 132 [ 54 ] Richard C . Waters . Program editors should not abandon text oriented com - mands . ACM SIGPLAN Notices , 17 ( 7 ) : 39 , July 1982 . [ 55 ] Linda L Werner , Brian Hanks , and Charlie McDowell . Pair - programming helps female computer science students . J . Educ . Resour . Comput . , 4 : 4 , 2004 . [ 56 ] Laurie Williams , R . R . Kessler , W . Cunningham , and R . Jeﬀries . Strengthening the case for pair programming . IEEE Software , 17 ( 4 ) : 19 – 25 , 2000 . [ 57 ] Jan Wloka , Barbara Ryder , Frank Tip , and Xiaoxia Ren . Safe - commit analysis to facilitate team software development . In International Conference on Software Engineering , pages 507 – 517 , 2009 . [ 58 ] Jan Wloka , Barbara G . Ryder , and Frank Tip . JUnitMX - A change - aware unit testing tool . In International Conference on Software Engineering , pages 567 – 570 , 2009 . 133