Common Bugs in Scratch Programs Christoph Frädrich fraedric @ fim . uni - passau . de University of Passau Passau , Germany Florian Obermüller obermuel @ fim . uni - passau . de University of Passau Passau , Germany Nina Körber koerber @ fim . uni - passau . de University of Passau Passau , Germany Ute Heuer ute . heuer @ uni - passau . de University of Passau Passau , Germany Gordon Fraser gordon . fraser @ uni - passau . de University of Passau Passau , Germany ABSTRACT Bugs in Scratch programs can spoil the fun and inhibit learning success . Many common bugs are the result of recurring patterns of bad code . In this paper we present a collection of common code patterns that typically hint at bugs in Scratch programs , and the LitterBox tool which can automatically detect them . We empiri - cally evaluate how frequently these patterns occur , and how severe their consequences usually are . While fixing bugs inevitably is part of learning , the possibility to identify the bugs automatically provides the potential to support learners . CCS CONCEPTS • Social and professional topics → Software engineering ed - ucation ; K - 12 education ; • Software and its engineering → Visual languages . KEYWORDS Scratch , Block - based programming , Code quality ACM Reference Format : Christoph Frädrich , Florian Obermüller , Nina Körber , Ute Heuer , and Gor - don Fraser . 2020 . Common Bugs in Scratch Programs . In Proceedings of the 2020 ACM Conference on Innovation and Technology in Computer Science Education ( ITiCSE ’20 ) , June 15 – 19 , 2020 , Trondheim , Norway . ACM , New York , NY , USA , 7 pages . https : / / doi . org / 10 . 1145 / 3341525 . 3387389 1 INTRODUCTION Block - based programming languages like Scratch [ 13 ] are hugely successful at introducing and engaging young learners with the concepts of programming , and once children are hooked they use their imagination to produce complex and intricate games , stories , and other types of programs . Often these programs do not work immediately because of bugs , i . e . , mistakes in the assembled blocks . While finding and fixing such bugs ( i . e . , debugging programs ) is an essential skill and an important aspect of learning , bugs can never - theless be the source of endless frustration , discouraging learners and potentially inhibiting their learning success . Bugs can occur for different reasons , for example when program - ming concepts are not well understood , or simply because it is Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page . Copyrights for components of this work owned by others than ACM mustbehonored . Abstractingwithcreditispermitted . Tocopyotherwise , orrepublish , to post on servers or to redistribute to lists , requires prior specific permission and / or a fee . Request permissions from permissions @ acm . org . ITiCSE ’20 , June 15 – 19 , 2020 , Trondheim , Norway © 2020 Association for Computing Machinery . ACM ISBN 978 - 1 - 4503 - 6874 - 2 / 20 / 06 . . . $ 15 . 00 https : / / doi . org / 10 . 1145 / 3341525 . 3387389 Figure 1 : Common Scratch bug , taken from a publicly shared project : The comparison of the literals “Level” and “21” in the if - condition will never be true . Instead of “Level” , the user should have used the variable with the same name . challenging to produce correctly working programs , regardless of whether one writes code in Scratch or any other programming language . Often , code that works initially is written in a clumsy and confusing way ( commonly referred to as code that smells , such as long scripts or duplicated code [ 9 , 19 ] ) . This causes bugs to be intro - duced later , when changing and extending the existing code . While there is no end to the creativity with which learners produce bugs , many of these bugs are the result of similar misunderstandings , and manifest in similar , reoccurring patterns of bugs . For example , con - sider Figure 1 : The comparison of two literals frequently happens if variables are not fully comprehended or if code is incomplete . Identifying such patterns offers the potential to support learners . In this paper , we present a catalogue of 25 bug patterns based on common misunderstandings and programming errors in Scratch . We introduce LitterBox , an automated program analysis tool which can find occurrences of these bug patterns in Scratch pro - grams . Given a Scratch project ID , LitterBox retrieves and parses the source code of the project , and reports all instances of bug pat - terns identified . To investigate how common the bug patterns are in practice , we applied LitterBox to a random sample of 74 , 830 Scratch projects . Since the occurrence of a bug pattern does not guarantee that a program is broken , we further investigated the typical severity of each of the bug patterns by manually checking how they affect real Scratch programs . Our investigations show that a common misunderstanding lies in the usage of key - event handlers as the best way of reacting to user input ( resulting in Stuttering Movement ) , and that synchronising scripts with messages or backdrops ( e . g . , Missing Backdrop Switch ) can be error prone . Some bug patterns like Stuttering Movement al - most always break programs , while some bugs are more subtle , like the Position Equals Check , where positions are checked using exact equality instead of more permissive relations , resulting in fragile and misbehaving programs . In either case , however , an instance of a bug pattern is a sign of a problem . The possibility to identify bugs automatically can help learners with the inevitable debugging part of learning , and in producing working Scratch programs . Session : Computing in Schools I ITiCSE ’20 , June 15 – 19 , 2020 , Trondheim , Norway 89 Table 1 : Common code smells for Scratch . Code Smell Reference Broad variable scope [ 18 ] Complex animation [ 4 ] Dead code [ 4 , 8 , 18 ] Duplicate code [ 4 , 8 , 18 ] Duplicate string [ 18 ] Empty script [ 8 , 18 ] Empty sprite [ 8 ] Feature envy [ 8 , 18 ] Inappropriate intimacy [ 8 , 18 ] Long script [ 8 , 18 ] Many parameters [ 8 ] Middle man [ 8 , 18 ] Uncommunicative name [ 4 , 18 ] Unused variable [ 8 , 18 ] 2 BACKGROUND In this paper we investigate bug patterns in Scratch [ 13 ] pro - grams . Scratch is a widely used visual block - based programming language that aims at making programming more accessible for novices . It favours exploration over recall , implements visualisation of grammar rules and visually distinguishes different categories of statements and expressions [ 3 ] . The block - based nature of Scratch prevents syntactical errors in the program code , but it is neverthe - less possible to produce Scratch code that is problematic or plain wrong . Bad programming practices often lead to code that uses inefficient , confusing , or awkward constructions to achieve its re - sult . In programming , characteristics of source code that represent bad quality and are indicative of deeper problems are commonly referred to as code smells : Definition 1 ( Code Smell ) . A code smell is a code idiom that increases the likelihood of bugs in a program [ 7 ] . It has been established that certain code smells such as long meth - ods or duplicated code are prevalent in Scratch programs [ 9 , 19 ] . Categories of code smells in Scratch are mostly derived by map - ping smells from other programming languages [ 9 ] but also by defining new smells that exist only in block based languages [ 14 ] . There is also evidence that code smells can have a negative ef - fect on the learning progress of novice programmers [ 8 ] . Table 1 summarises the code smells that have been defined for Scratch . Smelly code is not wrong per se ; the program likely still works correctly . However , smells typically decrease understandability and increase the chances of programmers using and extending the code wrongly in the future , thus introducing bugs . The term bug is often ambiguously used ; when talking about bugs in this paper we refer to defects as defined in the IEEE Standard Classification of Software Anomalies [ 1 ] : Definition 2 ( Defect ) . A defect is a weakness in code that pre - vents software from meeting its specification and needs to be fixed [ 1 ] . Defects in programs can stem from misconceptions affecting the programmer’s problem solving process . This is a serious challenge for novices even in Scratch [ 17 ] . A defect represents functionally incorrect code , but the consequences of the defect are not necessar - ily visible to the user of the program . Only under certain conditions does a defect result in an observable deviation from the correct and expected behaviour . For example , the defect often has to be executed in a particular way in order to cause the program to misbehave , thus causing a failure : Definition 3 ( Failure ) . A failure represents the termination of the ability of a program to perform its required function . The execution of a defect may result in a failure . In practice , failures often result in program crashes , exploitable security holes , data - loss , or other severe consequences . In Scratch programs a failure represents a change in the output on the stage , such as erroneous movement of a sprite , wrong backdrops being shown , lack of reaction to a user input , and it might also result in the execution stopping unexpectedly or generally decrease the usability of the program ( e . g . , by slowing the program execution ) . On one hand , failures can be incredibly frustrating to learners . On the other hand , productive failure is seen as an emerging innovation in pedagogic practice and is considered a promising approach in computer science education as well [ 6 ] . Failures are typically found through testing , i . e . , running the program and checking the result against a specification ( potentially automatically [ 11 , 16 ] ) . Given a failure , debugging describes the activities of ( 1 ) identifying the underlying defect , and ( 2 ) producing an appropriate fix for the defect . When debugging programmers may gain insights on the programming task , into its pitfalls and proper solutions . Related pedagogic interventions should facilitate and strengthen these insights . Therefore meaningful teaching and training activities can encourage and guide reflection and com - munication about critical thinking involved in the debugging pro - cess . [ 5 , 12 ] . However , not all defects easily manifest in failures , potentially making them hard to spot . Failing to identify defects reduces chances for learners to practice fixing . Failing to fix defects , programs may never work . In order to support learners in identifying defects , we therefore aim to automatically identify defects in Scratch programs . For this , we define and identify bug patterns . A bug pattern is a code idiom that is likely to be a defect [ 10 ] . Definition 4 ( Bug Pattern ) . A bug pattern in Scratch is a composition of blocks typical of defective code , or a common erroneous deviation of a correct code idiom . The difference between a code smell and a bug pattern is that a code smell reports negative attributes of the code ( e . g . , long , confus - ing , duplicate , unused code ) , whereas bug patterns report specific combinations of blocks that are indicative of defects . Although previous work on code quality in Scratch focused on code smells , some of these are actually bug patterns , in particular the undefined block smell [ 18 ] as well as Hairball’s checks for ( 1 ) matching broad - cast and receive blocks , ( 2 ) synchronisation of say and sound blocks , and ( 3 ) proper initialisation of attributes and variables . Note that the occurrence of a bug pattern does not guarantee the existence of a defect ( i . e . , there may be false positives ) : Definition 5 ( False Positive ) . Non - defective code that matches a bug pattern constitutes a false positive . Session : Computing in Schools I ITiCSE ’20 , June 15 – 19 , 2020 , Trondheim , Norway 90 False positives are common for static program analysis tools [ 10 ] , and may occur for any approximate analysis . In particular , for bug patterns false positives may result if it is not possible to describe a combination of blocks that precisely distinguishes all defective from non - defective cases . Bug patterns are commonly used in pro - fessional programming , where tools like FindBugs [ 10 ] implement checks for catalogues of common bug patterns for the Java lan - guage . In this paper , we aim to define a catalogue of bug patterns for Scratch . 3 BUG PATTERNS IN SCRATCH In this section we describe bug patterns for Scratch programs . These patterns mostly originate from our experiences of teaching and building an analysis infrastructure for Scratch programs , and some are specialised versions of code smells [ 4 , 9 ] . We organise patterns in three categories : ( 1 ) Bugs that are effectively syntax errors , as a compiler would detect them in a text - based language ; ( 2 ) bugs that can occur in any programming language ; and ( 3 ) bug patterns that are specific to Scratch . 3 . 1 Syntax Errors Ambiguous Custom Block Signature : Scratch does not enforce unique names for custom blocks . Two custom blocks with the same name can only be distinguished if they have a different number or order of parameters . When two blocks have the same name and parameter order , no matter which call block is used , the program will always execute the custom block which was defined earlier . Ambiguous Parameter Name : The parameter names in custom blocks do not have to be unique . When two parameters have the same name , no matter the type or which one is used inside the custom block , it will always be evaluated as the last parameter . Call Without Definition : When a custom block is called without being defined nothing happens . This can occur in two different situations : 1 ) Earlier releases of Scratch 3 allowed removal of a custom block definition even when the custom block is still in use . 2 ) A script using a call to a custom block can be dragged and copied to another sprite , probably no custom block with the same signature as the call exists here and thus the call has no definition . Expression As Touchable Or Colour : This happens when inside a block that expects a colour or sprite as parameter ( e . g . , set pen color to or touching mouse - pointer ? ) a reporter block , or an expression with a string or number value is used . Missing Termination Condition : The repeat until blocks require a stopping condition . If the condition is missing , the result is an in - finite loop . This will then prevent the execution of blocks following the loop in the script . Orphaned Parameter : When custom blocks are created the user can define parameters , which can then be used in the body of the custom block . However , the block definition can be altered , includ - ing removal of parameters even if they are in use . Any instances of deleted parameters are retained , and then evaluated with the default value for the type of parameter in the underlying JavaScript execution of the Scratch virtual machine ( i . e . , 0 or empty string ) , since they are never initialised . Parameter Out Of Scope : The parameters of a custom block can be used anywhere inside the sprite that defines the custom block . However , they will never be initialised outside the custom block , and will always have the default value . 3 . 2 General Bugs Comparing Literals : Reporter blocks can be used to evaluate the truth value of certain expressions . Not only is it possible to compare literals to variables or the results of other reporter blocks , literals can also be compared to literals ( e . g . Fig . 1 ) . Since this will lead to the same result in each execution this construct is unnecessary and it can obscure that certain blocks will never or always be executed . Custom Block With Forever : If a custom block contains a forever loop and the custom block is used in the middle of another script , that other script will never be able to complete its execution . The forever loop in the custom block cannot be left , resulting in the calling script never being able to proceed . Custom Block With Termination : If a custom block contains a Stop all or Delete this clone and the custom block is called in the middle of another script , the script will never reach the blocks following the call . EndlessRecursion : Ifa customblock callsitself insideitsbodyand has no condition to stop the recursion , it will run for an indefinite amount of time . Forever Inside Loop : If two loops are nested and the inner loop is a forever loop , the inner loop will never terminate . Thus any statements preceeding the inner loop are only executed once ( e . g . Fig . 3 ) . Furthermore , any further statements following the outer loop can also never be reached . Message Never Received : This pattern is a specialised version of unmatched broadcast and receive blocks [ 4 ] . It occurs when there are blocks to send messages , but the When I receive message event handler is missing . Since no handler reacts to this event , the message stays unnoticed . Message Never Sent : This pattern is a specialised version of un - matched broadcast and receive blocks [ 4 ] . When there are blocks to receive messages but the corresponding broadcast message block is missing , that script will never be executed . Missing Clone Call : If the When I start as a clone event handler is used to start a script , but the sprite is never cloned , the event will never be triggered and the script is dead . Missing Clone Initialisation : When a sprite creates a clone of itself but has no scripts started by When I start as a clone or When this sprite clicked events , clones will not perform any actions . The clones remain frozen until they are deleted by delete this clone blocks or the program is restarted . Missing Loop Sensing : If a script is supposed to execute actions conditionally when an event occurs , this is often done by contin - uously checking for the event inside a forever or until loop . If the loop is missing , the occurrence of the event is only checked once and thus likely missed . No Working Scripts : The empty script smell ( cf . Lazy Class [ 9 ] ) occurs if an event handler has no other blocks attached to it . The dead code smell [ 9 ] occurs when a script has no event handler and can never be executed automatically . If both smells occur simulta - neously without any other scripts in a sprite we consider it a bug , since the script should likely consist of the event handler attached to the dead code . Session : Computing in Schools I ITiCSE ’20 , June 15 – 19 , 2020 , Trondheim , Norway 91 Position Equals Check : Scratch uses floating point values to store positions and calculate distances to other sprites or the mouse - pointer . Since two floating point values might never match exactly , using exact comparisons of these values as guards in conditional statements or loops such as until / wait until is prone to failure . Recursive Cloning : Scripts starting with a When I start as a clone event handler that contain a create clone of myself block may result in an infinite recursion . 3 . 3 Scratch - specific Bugs Missing Backdrop Switch : If the When backdrop switches to event handler is used to start a script and the backdrop never switches to the selected one , the script is never executed . This does not apply to programs including at least one of the switch options next , previous or random . Missing Erase All : If a sprite uses a pen down block but never an erase all block , then all drawings from a previous execution might remain , making it impossible to get a blank background without reloading the Scratch project . Missing Pen Down : Scripts of a sprite using a pen up block but never a pen down are likely wrong since either the sprite is supposed to draw something and does not , or the pen up may intefere with later additions of pen down blocks . Missing Pen Up : A sprite that uses pen down blocks but never a pen up may draw right away , when the project is restarted . This might not be intended . Stuttering Movement : A common way to move sprites in re - sponse to keyboard input is to use the specific event handler When key pressed followed by a move steps , change x by or change y by statement . Compared to the alternative to use a forever loop with a conditional containing a key pressed ? expression , the first approach results in noticeably slower reaction and stuttering movement of the sprite moved . 4 EVALUATION We aim to answer the following research questions : RQ1 : How common are the bug patterns ? RQ2 : How severe are the consequences of the defects ? RQ1 aims to give an overview on how many projects are affected by each bug pattern . By answering RQ2 our goal is to understand how often bug patterns cause failures . 4 . 1 Experimental Setup Analysis tool : We implemented the bug patterns listed in Sec - tion 3 in our own Java - based static analysis tool LitterBox . For the analysis LitterBox first constructs an abstract syntax tree ( AST ) . Each bug pattern finder is implemented as a visitor of the AST , and application to a Scratch program reports all instances of the bug pattern found in the AST . Dataset : Since LitterBox parses Scratch projects in the new data format introduced with Scratch version 3 , we could not use existing datasets ( e . g . , [ 2 ] ) . Therefore we created a new dataset of real Scratch programs by downloading the most recent programs from the Scratch platform over a period of 3 weeks . For this we first downloaded the project IDs of the most recent projects via the Scratch REST API 1 which LitterBox then used to directly download the JSON project file from the project host 2 . On average between 5 , 000 and 10 , 000 new programs were created each day , resulting in 135 , 164 projects for our dataset . A replication package containing all data and software needed to reproduce the results can be found at https : / / github . com / se2p / artifact - iticse2020 . RQ1 : To answer RQ1 we applied LitterBox on the data set . Since it is common to start a new Scratch project by remixing an exist - ing one it may also happen that bug patterns are inherited from the original projects . Counting the same bug patterns in remixed code multiple times would potentially skew our analysis of bug pattern frequency . Therefore we excluded all projects that were remixes . This led to the exclusion of 60 , 334 projects with 74 , 830 remaining for the analysis . We consider the cumulative number of bug patterns found as well as the number of projects that con - tain at least one instance of each pattern . We further consider the weighted method count ( WMC , i . e . , sum of cyclomatic complex - ity of all scripts ) to quantify the average complexity of projects containing bug patterns . RQ2 : To answer RQ2 we sampled 10 affected projects for each bug pattern from our data set , excluding remixes . We then manually classified whether the occurrence of the pattern results in a failure based on Definition 3 . Based on this definition we only counted occurrences of a pattern as a failure if it has a noticeable effect for the user . Thus , the classification required understanding each project and its intended behaviour , as well as executing and playing with the program in order to derive a verdict . In case a bug pattern did not yield a failure , we further classified whether this was a ) due to the bug pattern being contained in code that was not executed at all , b ) the occurrence of a false positive or c ) for other reasons . Each project was independently classified by two authors . In case of disagreements the bug pattern instances were discussed . If no consensus was reached , at least one more author was consulted . Threats To Validity : To avoid skewing the numbers , we exclude remixes in our analysis . Our dataset consists of only publicly shared projects ; it is conceivable that bug patterns might occur more fre - quently in unfinished projects not yet shared . To avoid bias we randomised the selection of projects . For the manual classification ( RQ2 ) , each project was independently classified by at least two authors of this paper . 4 . 2 RQ1 : How Common are the Bug Patterns ? In the evaluation of our data set without remixes we found instances of all the bug patterns defined in Section 3 . Table 2 shows how many projects are affected by each bug pattern , how often each pattern occurs in total and what the average weighted method count of affected projects is . Of the 74 , 830 projects 33 , 655 contained at least one bug pattern , resulting in 109 , 951 bug patterns in total . The most common bug patterns in terms of affected projects are Stuttering Movement ( 5 , 541 ) , Message Never Received ( 5 , 933 ) , and Message Never Sent ( 4 , 781 ) . The least common are Ambiguous Parameter Name ( 25 ) , Orphaned Parameter ( 88 ) and Ambiguous Custom Block Signature ( 92 ) . 1 https : / / github . com / LLK / scratch - rest - api / wiki , last accessed 17 . 1 . 2020 2 https : / / projects . scratch . mit . edu , last accessed 17 . 1 . 2020 Session : Computing in Schools I ITiCSE ’20 , June 15 – 19 , 2020 , Trondheim , Norway 92 Table 2 : Number of projects affected by each pattern and number of pattern instances found in total . Pattern # Projects # Patterns AVGWMC Ambiguous CB Signature 92 317 138 . 74 Ambiguous Parameter Name 25 402 39 . 28 Call Without Definition 164 569 288 . 2 Comparing Literals 1 , 999 4 , 939 242 . 95 Custom Block With Forever 176 574 313 . 58 Custom Block With Termination 263 985 243 . 6 Endless Recursion 109 386 141 . 54 Expression As Touchable Or Color 365 1 , 076 217 . 79 Forever Inside Loop 2 , 158 9 , 617 192 . 48 Message Never Received 5 , 933 12 , 479 163 . 95 Message Never Sent 4 , 781 24 , 933 193 . 99 Missing Backdrop Switch 903 4 , 282 154 . 47 Missing Clone Call 625 1 , 522 356 . 33 Missing Clone Initialization 1 , 691 5 , 862 185 . 71 Missing Erase All 164 245 73 . 12 Missing Loop Sensing 3 , 282 8 , 372 130 . 54 Missing Pen Down 164 199 203 . 17 Missing Pen Up 988 1 , 931 47 . 98 Missing Termination 709 1 , 564 257 . 43 No Working Scripts 549 730 86 . 61 Orphaned Parameter 88 175 308 . 19 Parameter Out Of Scope 461 1 , 493 400 . 15 Position Equals Check 1 , 472 4 , 725 206 . 81 Recursive Cloning 953 3 , 318 267 . 74 Stuttering Movement 5 , 541 19 , 256 34 . 02 Projects with Stuttering Movement arguably usually still provide the expected functionality , but the pattern causes the projects to be almost unusable , as is well known to the Scratch community and frequently discussed in forums and educational material 3 . The pattern is nevertheless often used as a means to introduce beginners as it allows controlling sprites without the need for conditional statements . The very low average WMC of 34 . 02 for projects with Stuttering Movement confirms that they are simple and small . Bug patterns related to the pen feature are also used in simple projects ( e . g . , average WMC of 47 . 98 for Missing Pen Up ) , which often have little functionality besides drawing basic patterns . How - ever , only 5 , 303 projects in our datasets use pen blocks at all , which is likely because pen blocks are an optional extension since Scratch 3 . 0 . Bug patterns related to custom blocks ( e . g . , Ambiguous Parameter Name or Ambiguous Custom Block Signature ) are less common . The main reason for this is that custom blocks are an advanced programming concept in Scratch , to which students are usually introduced later . As a result , out of all the projects only 10 , 576 used custom blocks . The average WMC confirms that these projects tend to be more complex ( e . g . , 313 . 58 for Custom Block With Forever ) . Besides bugs related to custom blocks , the Missing Clone Call bug pattern stands out because it is contained in more complex projects ( average WMC of 356 . 33 ) . This is most likely because it is easier to miss that a sprite is not cloned in big projects . A notable example was a project where the When Green Flag clicked event triggered the 3 https : / / en . wikibooks . org / wiki / Scratch / Lessons / Movement # Smooth _ Movement , last accessed 17 . 1 . 2020 same behaviour as the When I start as clone event , suggesting that cloning is a topic that is not easy to understand right away . Message - related bugs may result from missing refactoring support : When removing one part of a synchronised communication , Scratch does not warn the user that the other part remains . Summary ( RQ1 ) Bugs frequently appear in Scratch programs regardless of their complexity , and often follow a similar structure which we can use to automatically identify them . 4 . 3 RQ2 : How Severe are the Consequences of the Defects ? Figure 2 shows the results of the manual classification for each bug pattern . Out of the 250 projects we inspected , 70 instances of bugs manifested into failures . Of the remaining bug patterns , 96 were defects without visible impact , 52 did not result in failures because the defective code was never executed , and 32 bugs were identified as false positives . The most severe failures cause their project to stop working com - pletely ( i . e . , no reactions to user inputs and sprites not performing any actions ) , and sometimes even slow down the web browser to the point where it becomes unusable . For example , this happened in a project with an instance of Forever Inside Loop with multiple nested loops . Figure 3 shows an example of this bug pattern taken from one of the Scratch projects in our analysis : Since the inner forever - loop is never left , all clones are created at the same location and the same orientation , breaking the intended graphical effect . The defects most frequently causing failures are Stuttering Move - ment ( 10 of 10 executed ) and Missing Backdrop Switch ( 7 of 8 ex - ecuted ) . The frequent occurrence of Stuttering Movement is not surprising as this pattern is often even taught to students as a “cor - rect” or “first” approach to animating sprites . Notably , the latter can be created without modifying code : Most affected projects had scripts that waited for a backdrop that no longer existed . This leads us to believe that this bug often happens by accident or that students often do not clean up their projects . Some failures are subtle : For example , some projects have mul - tiple scripts triggered by different messages , resulting in similar behaviour ( e . g . , switching to different costumes of a sprite ) . In this scenario a Message Never Sent bug may be difficult to notice as it rarely manifests as a failure . Some defects do not cause a failure when the program is run for the first time , but only in later executions . For example , the Missing Pen Up pattern may only be noticed when the program is reset and the sprite clutters the screen . There are , however , also multiple reasons why a bug may exist in a project and not lead to a failure . The most common and simple reason is that the code containing the bug is never executed , as was the case in 52 projects . A reason why a bug is never executed can be as simple as it being located in unreachable code ( e . g . , inside an if with a condition that always evaluates to false ) . For example , the Comparing Literals pattern caused only one actual failure , whereas in the other 9 cases the defect was located in disconnected blocks that were not executed , suggesting that the authors of Scratch programs may be somewhat aware of this problem . Sometimes programs also simply ignore the wrong behaviour such as custom blocks with Ambiguous Parameter Names that do Session : Computing in Schools I ITiCSE ’20 , June 15 – 19 , 2020 , Trondheim , Norway 93 0 2 4 6 8 10 A m b i guou s C B S i g . A m b i guou s P a r a m . C a ll W i t hou t D e f . C o m p a r i ng L i t e r a l s C B W i t h Fo r eve r C B W i t h T e r m . E nd l ess R ec u r s i on E x p r A s T . o r C . Fo r eve r I n s i d e Loop M s g . N eve r R ec . M s g . N eve r S e n t M i ss i ng B ack d r op M i ss i ng C l on e C a ll M i ss i ng C l on e M i ss i ng E r ase A ll M i ss i ng Loop M i ss i ng P e n D o w n M i ss i ng P e n U p M i ss i ng T e r m . N o W o r k i ng S c r i p t s O r ph a n e d P a r a m . P a r a m . O u t O f P o s . E qu a l s C h eck R ec u r s i ve C l on i ng S t u tt e r i ng M o ve . False Positive Not Executed No Failure Failure Figure 2 : Results of the manual classification of Scratch projects . Figure 3 : Example of a Forever Inside Loop bug pattern , taken from a publicly shared project : The blocks in the outer forever - loop will only be executed once , since the execution will not leave the inner forever - loop . not use the parameters at all . Sometimes the sprites with the bug are affected in their behaviour ( e . g . , position , movement , or size ) , but do not result in a failure because they are hidden . An example are hidden sprites , with custom blocks that contain a forever loop that never stops . The Position Equals Check caused no failures because the sprites always arrived at the checked positions ; moving the sprite only one pixel away broke the program in most cases . In other cases the bug did not lead to failures because the author of the program worked around the bug ; for example , a Missing Pen Up may not lead to any noticeable problems if the program erases all drawings multiple times . As anticipated , we also found several cases ( 32 ) of false positives where the creator of the project deliberately used the mechanism we consider as a bug and also took measures to prevent a failure . For example , the Custom Block With Termination pattern may be correct if the termination statement is contained in conditional code . As our static analysis is an overapproximation it currently cannot correctly detect this case . Similarly , Recursive Cloning produces false positives when a clone takes care of deleting itself . Summary ( RQ2 ) When defective code is executed , it frequently results in failures , but dead code and redundant expressions often prevent visible impact . 5 CONCLUSIONS Bug patterns help to identify bugs and provide a common vocabu - lary to people talking about these bugs . To this end we introduced and empirically evaluated a new catalogue of 25 bug patterns in Scratch . Our evaluation found occurrences for each of the bug patterns , which shows that the concept of bug patterns can be successfully transferred to Scratch . In this paper we focused on the actual bug patterns , but an im - portant next step will be to study the effects of these bugs on the learning success of novice programmers , as well as guidelines for instructors on how to teach students about these patterns . Detec - tion of bug patterns might enable learners to engage in debugging processes more easily since the cognitive load of localising a po - tential bug can be reduced . This fosters discussion of successful and unsuccessful debugging activities and helps students reflect on underlying missing concepts or misconceptions . In the future it would be interesting to investigate whether bug patterns result from misconceptions in programming as some of these seem to be a symptom of those [ 15 , 17 ] . In this light , productive failure seems to be a promising approach that we will pursue and investigate further in the future . We also plan to further improve our LitterBox tool with ad - ditional bug patterns and lower false positive rates . LitterBox is available at : https : / / github . com / se2p / LitterBox ACKNOWLEDGEMENTS This work is supported by DFG project FR 2955 / 3 - 1 “Testing , De - bugging , and Repairing Blocks - based Programs” . We would like to thank Florian Sulzmaier and Andreas Stahlbauer for their contribu - tions to LitterBox . Session : Computing in Schools I ITiCSE ’20 , June 15 – 19 , 2020 , Trondheim , Norway 94 REFERENCES [ 1 ] 2010 . IEEE Standard Classification for Software Anomalies . IEEE Std 1044 - 2009 ( RevisionofIEEEStd1044 - 1993 ) ( Jan2010 ) , 1 – 23 . https : / / doi . org / 10 . 1109 / IEEESTD . 2010 . 5399061 [ 2 ] EfthimiaAivaloglou , FelienneHermans , JesúsMoreno - León , andGregorioRobles . 2017 . Adatasetofscratchprograms : scraped , shapedandscored . In Proceedingsof the 14th International Conference on Mining Software Repositories . IEEE , 511 – 514 . [ 3 ] David Bau , Jeff Gray , Caitlin Kelleher , Josh Sheldon , and Franklyn Turbak . 2017 . Learnable Programming : Blocks and Beyond . Commun . ACM 60 , 6 ( May 2017 ) , 72 – 80 . https : / / doi . org / 10 . 1145 / 3015455 [ 4 ] Bryce Boe , Charlotte Hill , Michelle Len , Greg Dreschler , Phillip Conrad , and Diana Franklin . 2013 . Hairball : Lint - inspired static analysis of scratch projects . SIGCSE 2013 - Proceedings of the 44th ACM Technical Symposium on Computer Science Education , 215 – 220 . https : / / doi . org / 10 . 1145 / 2445196 . 2445265 [ 5 ] David Deliema , Maggie Dahn , Virginia Flood , Ana Asuncion , Dor Abrahamson , Noel Enyedy , and Francis Steen . 2019 . Debugging as a Context for Fostering Reflection on Critical Thinking and Emotion . 209 – 228 . https : / / doi . org / 10 . 4324 / 9780429323058 - 13 [ 6 ] Katrina Falkner and Judy Sheard . 2019 . Pedagogic Approaches . Cambridge Uni - versity Press , 445 – 480 . https : / / doi . org / 10 . 1017 / 9781108654555 . 016 [ 7 ] Martin Fowler . 1999 . Refactoring : Improving the Design of Existing Code . Addison - Wesley , Boston , MA , USA . [ 8 ] Felienne Hermans and Efthimia Aivaloglou . 2016 . Do code smells hamper novice programming ? A controlled experiment on Scratch programs . In 2016 IEEE 24th International Conference on Program Comprehension ( ICPC ) . 1 – 10 . https : / / doi . org / 10 . 1109 / ICPC . 2016 . 7503706 [ 9 ] Felienne Hermans , Kathryn T . Stolee , and David Hoepelman . 2016 . Smells in Block - Based Programming Languages . In 2016 IEEE Symposium on Visual Languages and Human - Centric Computing ( VL / HCC ) ( 2016 - 09 ) . IEEE , 68 – 72 . https : / / doi . org / 10 . 1109 / VLHCC . 2016 . 7739666 [ 10 ] David Hovemeyer and William Pugh . 2004 . Finding Bugs is Easy . SIGPLAN Not . 39 , 12 ( Dec . 2004 ) , 92 – 106 . https : / / doi . org / 10 . 1145 / 1052883 . 1052895 [ 11 ] David E Johnson . 2016 . ITCH : Individual Testing of Computer Homework for Scratch Assignments . In Proceedings of the 47th ACM Technical Symposium on Computing Science Education . ACM , 223 – 227 . [ 12 ] Yasmin B . Kafai , David DeLiema , Deborah A . Fields , Gary Lewandowski , and Colleen Lewis . 2019 . Rethinking Debugging as Productive Failure for CS Educa - tion . In Proceedings of the 50th ACM Technical Symposium on Computer Science Education ( SIGCSE ’19 ) . Association for Computing Machinery , New York , NY , USA , 169 – 170 . https : / / doi . org / 10 . 1145 / 3287324 . 3287333 [ 13 ] John Maloney , Mitchel Resnick , Natalie Rusk , Brian Silverman , and Evelyn East - mond . 2010 . The Scratch Programming Language and Environment . ACM Transactions on Computing Education ( TOCE ) 10 ( 11 2010 ) , 16 . https : / / doi . org / 10 . 1145 / 1868358 . 1868363 [ 14 ] Jesús Moreno - León and Gregorio Robles . 2014 . Automatic detection of bad programming habits in scratch : A preliminary study . In 2014 IEEE Frontiers in Education Conference ( FIE ) Proceedings . 1 – 4 . https : / / doi . org / 10 . 1109 / FIE . 2014 . 7044055 [ 15 ] Juha Sorva . 2018 . Misconceptions and the Beginner Programmer . [ 16 ] Andreas Stahlbauer , Marvin Kreis , and Gordon Fraser . 2019 . Testing scratch programs automatically . In Proceedings of the 2019 27th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering . 165 – 175 . [ 17 ] Alaaeddin Swidan , Felienne Hermans , and Marileen Smit . 2018 . Programming MisconceptionsforSchoolStudents . In Proceedingsofthe2018ACMConferenceon International Computing Education Research ( ICER ’18 ) . Association for Comput - ing Machinery , New York , NY , USA , 151 – 159 . https : / / doi . org / 10 . 1145 / 3230977 . 3230995 [ 18 ] Peeratham Techapalokul and Eli Tilevich . 2017 . Quality Hound — An online code smell analyzer for scratch programs . In 2017 IEEE Symposium on Visual Languages and Human - Centric Computing ( VL / HCC ) . 337 – 338 . https : / / doi . org / 10 . 1109 / VLHCC . 2017 . 8103498 [ 19 ] PeerathamTechapalokulandEliTilevich . 2017 . UnderstandingRecurringQuality Problems and Their Impact on Code Sharing in Block - Based Software . In 2017 IEEE Symposium on Visual Languages and Human - Centric Computing ( VL / HCC ) ( 2017 - 10 ) . IEEE , 43 – 51 . https : / / doi . org / 10 . 1109 / VLHCC . 2017 . 8103449 Session : Computing in Schools I ITiCSE ’20 , June 15 – 19 , 2020 , Trondheim , Norway 95