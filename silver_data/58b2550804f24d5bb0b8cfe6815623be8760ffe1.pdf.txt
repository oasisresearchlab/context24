Version Space Algebra and its Application to Programming by Demonstration Tessa Lau tlau @ cs . washington . edu Pedro Domingos pedrod @ cs . washington . edu Daniel S . Weld weld @ cs . washington . edu Dept . of Computer Science & Engineering , University of Washington , Box 352350 , Seattle , WA 98195 - 2350 USA Abstract Machine learning research has been very successful at producing powerful , broadly - applicable classi(cid:12)cation learners . However , many practical learning problems do not (cid:12)t the classi(cid:12)cation framework well , and as a result the initial phase of suitably formulat - ing the problem and incorporating the rele - vant domain knowledge can be very di(cid:14)cult and typically consumes the majority of the project time . Here we propose a framework to systematize and speed this process , based on the notion of version space algebra . We extend the notion of version spaces beyond concept learning , and propose that carefully - tailored version spaces for complex applica - tions can be built by composing simpler , re - stricted version spaces . We illustrate our approach with SMARTedit , a programming by demonstration application for repetitive text - editing that uses version space algebra to guide a search over text - editing action se - quences . We demonstrate the system on a suite of repetitive text - editing problems and present experimental results showing its ef - fectiveness in learning from a small number of examples . 1 . Introduction More often than not , the most di(cid:14)cult and time - consuming part of developing a machine learning ap - plication is formulating the problem in terms amenable to currently - available learners ( Langley & Simon , 1995 ) . Machine - learning research has largely focused on classi(cid:12)cation , and although many sophisticated classi(cid:12)ers have been produced , many ( perhaps most ) problems are not easily cast in this framework . For ex - ample , in many domains ( e . g . , problem solving , vision , speech recognition , computational biology ) the desired output of the learned function is not a discrete scalar , but a structured object ( e . g . , a sequence of actions , a description of a scene , the text corresponding to a speech stream , the 3D shape of a protein ) . As a re - sult , applying machine learning is largely a \ black art , " with few formalized principles or domain - independent solutions available . In this paper we begin to address this problem by extending Mitchell’s ( 1982 ) version space framework to more complex learning problems . We propose the notion of a version space algebra in which simple , restricted version spaces are combined into more complex ones using operations like union and join . This approach lets the application designer combine multiple strong biases to achieve a weaker one that is carefully tailored to the application , and thus to reduce statistical bias for the least increase in vari - ance . We also begin to build a library of reusable ver - sion space components . We apply these components and the version space algebra in the construction of the SMARTedit system , a programming by demonstra - tion application for the text - editing domain . In many cases , SMARTedit learns generalized macros that au - tomate repetitive text transformations after just a sin - gle training example . Version space algorithms have not been widely ap - plied in practice , mainly because their extension to noisy data is non - trivial , and because the boundary - set representation they use is often not e(cid:14)cient enough ( although see the work of Norton and Hirsh ( 1992 ) , Hirsh et al . ( 1997 ) , and others ) . We expect that similar problems will be felt in the broader range of applications we extend the version space approach to here . However , the introduction of version spaces was of enormous value in clarifying the concept learning problem , and in moving from a phase of building ad hoc systems with limited uses to the current generation of powerful , widely - applicable classi(cid:12)ers . The goal of this paper is to provide a (cid:12)rst step in doing the same for a broader class of learning problems . Moreover , it may often be the case that some component version spaces in an application can be e(cid:14)ciently maintained while others require heuristic search . Combining the two should produce better results than approaching the whole problem in an ad hoc manner . 2 . Version Space Algebra In this section , we de(cid:12)ne our concept of a version space algebra : a method for composing together many sim - ple version spaces using algebraic operations such that the whole is also a version space . We (cid:12)rst extend ver - sion spaces to apply with any partial order ( not just generality , as in Mitchell ( 1982 ) ) . We then de(cid:12)ne the union , intersection , join , and transform operators over these extended version spaces , and describe the condi - tions under which the combined version space may be e(cid:14)ciently maintained . A hypothesis is a function that takes as input an ele - ment of its domain and produces as output an element of its range . A hypothesis space is a set of functions with the same domain and range . The bias deter - mines which subset of the universe of possible func - tions is part of the hypothesis space ; a stronger bias corresponds to a smaller hypothesis space . We say that a training example ( i ; o ) , for i 2 domain ( h ) and o 2 range ( h ) , is consistent with a hypothesis h if and only if h ( i ) = o . A version space , VS H ; D , consists of only those hypotheses in hypothesis space H that are consistent with the sequence D of examples . When a new example is observed , the version space must be updated to ensure that it remains consistent with the new example . We will omit the subscript and refer to the version space as VS when the hypothesis space and examples are clear from the context . In Mitchell’s ( 1982 ) original version space approach , the range of functions was required to be the Boolean set f 0 ; 1 g , and hypotheses in a version space were par - tially ordered by their generality . ( A hypothesis h 1 is more general than another h 2 i(cid:11) the set of examples for which h 1 ( i ) = 1 is a superset of the examples for which h 2 ( i ) = 1 . ) Mitchell showed that this partial or - der allows one to represent the version space solely in terms of its most - general and most - speci(cid:12)c boundaries G and S ( i . e . , the set G of most general hypotheses in the version space and the set S of most speci(cid:12)c hy - potheses ) . The consistent hypotheses are those that lie between the boundaries ( i . e . , every hypothesis in the version space is more speci(cid:12)c than some hypothesis in G and more general than some hypothesis in S ) . We say that a version space is boundary - set representable ( BSR ) if and only if it can be represented solely by the S and G boundaries . Hirsh ( 1991 ) showed that the properties of convexity and de(cid:12)niteness are neces - sary and su(cid:14)cient for a version space to be BSR . Mitchell’s approach is appropriate for concept learn - ing problems , where the goal is to predict whether an example is a member of a concept or not . We ex - tend the approach to any supervised learning problem ( i . e . , to learning functions with any range ) by allow - ing arbitrary partial orders . We base this proposal on the observation that the e(cid:14)cient representation of a version space by its boundaries only requires that some partial order be de(cid:12)ned on it , not necessarily one that corresponds to generality . The partial or - der to be used in a given version space is provided by the application designer , or by the designer of a ver - sion space library . The corresponding generalizations of the G and S boundaries are the least upper bound and greatest lower bound of the version space . As in Mitchell’s approach , the application designer provides an update function U ( VS ; d ) that shrinks VS to hold only the hypotheses consistent with example d . We now introduce a version space algebra using these extended version spaces . We de(cid:12)ne an atomic version space to be a version space as described above , i . e . , one that is de(cid:12)ned by a hypothesis space and a sequence of examples . We de(cid:12)ne a composite version space to be a composition of atomic or composite version spaces using one of the following operators . De(cid:12)nition 1 ( Version space union ) Let H 1 and H 2 be two hypothesis spaces such that the domain ( and range ) of functions in H 1 equals the domain ( and range ) of those in H 2 . Let D be a sequence of training examples . The version space union , VS H 1 ; D [ VS H 2 ; D , is equal to VS H 1 [ H 2 ; D . Hirsh proved that the union of two BSR version spaces is also BSR if and only if the union is convex and def - inite . In contrast , we allow unions of version spaces such that the unions are not necessarily boundary - set representable , by maintaining component version spaces separately ; thus , we can e(cid:14)ciently represent more complex hypothesis spaces . Proposition 1 ( E(cid:14)ciency of union ) The time ( space ) complexity of maintaining the union is a lin - ear sum of the time ( space ) complexity of maintaining each component version space . De(cid:12)nition 2 ( Version space intersection ) Let H 1 and H 2 be two hypothesis spaces such that the domain ( and range ) of functions in H 1 equals the do - main ( and range ) of those in H 2 . Let D be a sequence of training examples . The version space intersection , VS H 1 ; D \ VS H 2 ; D , is equal to VS H 1 \ H 2 ; D . The considerations made above for the version space union also apply to the version space intersection . In order to introduce the next operator , let C ( h ; D ) be a consistency predicate that is true when hypothesis h is consistent with the data D , and false otherwise . In other words , C ( h ; D ) (cid:17) V ( i ; o ) 2 D h ( i ) = o . De(cid:12)nition 3 ( Version space join ) Let D 1 = f d j 1 g n j = 1 be a sequence of n training exam - ples each of the form ( i ; o ) where i 2 domain ( H 1 ) and o 2 range ( H 1 ) , and similarly for D 2 = f d j 2 g n j = 1 . Let D be the sequence of n pairs of examples h d j 1 ; d j 2 i . The join of two version spaces , VS H 1 ; D 1 . / VS H 2 ; D 2 , is the set of ordered pairs of hypotheses fh h 1 ; h 2 ij h 1 2 VS H 1 ; D 1 ; h 2 2 VS H 2 ; D 2 ; C ( h h 1 ; h 2 i ; D ) g . Joins provide a powerful way to build complex version spaces , but a question is raised about whether they can be maintained e(cid:14)ciently . Let T ( VS ; d ) be the time required to update VS with example d . Let S ( VS ) be the space required to represent the version space VS ( perhaps with boundary sets ) . Proposition 2 ( E(cid:14)ciency of join ) Let D 1 = f d j 1 g n j = 1 be a sequence of n training examples each of the form ( i ; o ) where i 2 domain ( H 1 ) and o 2 range ( H 1 ) , and let d 1 be another training example of the same type . De(cid:12)ne D 2 = f d j 2 g n j = 1 and d 2 similarly . Let D be the sequence of n pairs of examples h d j 1 ; d j 2 i . If 8 D 1 ; D 2 [ C ( h 1 ; D 1 ) ^ C ( h 2 ; D 2 ) ) C ( h h 1 ; h 2 i ; D ) ] , then 8 D 1 ; d 1 ; D 2 ; d 2 S ( VS H 1 ; D 1 . / VS H 2 ; D 2 ) = S ( VS H 1 ; D 1 ) + S ( VS H 2 ; D 2 ) + O ( 1 ) T ( VS H 1 ; D 1 . / VS H 2 ; D 2 ; h d 1 ; d 2 i ) = T ( VS H 1 ; D 1 ; d 1 ) + T ( VS H 2 ; D 2 ; d 2 ) + O ( 1 ) In many domain representations , the consistency of a hypothesis in the join depends only on whether each individual hypothesis is consistent with its respective training examples , and not on a dependency between the two hypotheses in a pair . In this situation we say there is an independent join in which the consistency of a pair of hypotheses in the version space join follows from the consistency of each individual hypothesis rel - ative to its respective training examples . If the join is independent , then the hypotheses in the version space join are exactly the hypotheses in the Cartesian prod - uct of the two component version spaces , and the join may be updated by updating each of the two compo - nent version spaces individually . For instance , given VS 1 containing hypotheses f A ; B g , and VS 2 contain - ing f X ; Y g , even though A and X are consistent with their respective data , it is not always the case that h A ; X i is consistent with the joint data . Although we have not yet formalized the conditions under which joins may be treated as independent , Section 4 gives several examples of independent joins in the PBD do - main . Note that our union and intersection operations are both commutative and associative , which follows di - rectly from the properties of the underlying set oper - ations . The join operator is neither commutative nor associative . De(cid:12)nition 4 ( Version space transform ) Let (cid:28) i be a mapping from elements in the domain of VS 1 to el - ements in the domain of VS 2 , and (cid:28) o be a one - to - one mapping from elements in the range of VS 1 to elements in the range of VS 2 . Version space VS 1 is a transform of VS 2 i(cid:11) VS 1 = f g j9 f 2 VS 2 8 i g ( i ) = (cid:28) − 1 o ( f ( (cid:28) i ( i ) ) ) g . Transforms are useful for expressing domain - speci(cid:12)c version spaces in terms of general - purpose ones ; see section 4 . 3 for examples . 3 . Application Design In order to use the version space algebra to model an application , the application designer must specify a set of atomic and composite version spaces and designate a single target space , as shown in Table 1 . The role of atomic spaces , composite spaces and target space in version space algebra is analogous to the role of termi - nal symbols , nonterminal symbols and start symbol in a context - free grammar . The simplest update function would examine each hypothesis in the version space individually , and discard the inconsistent hypotheses . A more e(cid:14)cient update function represents only the boundaries of the consistent set , and updates only the boundaries given each training example . The partial order is a means to this end . Similarly , the simplest execution function would separately compute the out - put for each hypothesis in the version space and as - sign votes to outputs accordingly , but it may be pos - sible to (cid:12)nd the vote for each output more e(cid:14)ciently ; we show an example in the next section . When nei - ther approach is feasible , approximate votes may be computed by sampling from the version space ; such sampling is an area for future research . 4 . Programming by Demonstration Programming by demonstration ( PBD ) is one possible component of an adaptive user interface . In a PBD ap - Table 1 . Domain description to be provided by the appli - cation designer in order to use the version space algebra framework . For each atomic version space : 1 . De(cid:12)nition of the hypothesis space . 2 . A partial order on the hypothesis space . 3 . An update function that updates the version space to contain only those hypotheses consis - tent with a given example . 4 . An execution function that computes a vote for each possible output given an input . For each composite version space : 1 . Formula expressing it in terms of atomic version spaces , previously - de(cid:12)ned composite spaces , and version - space - algebraic operators . 2 . A transformation function that takes an exam - ple for the composite version space and gener - ates the corresponding examples for each com - ponent version space . 3 . An execution function that takes the outputs ( votes ) of the component spaces’ execution functions and produces a vote for each possi - ble output of the composite space . The target composite version space . ( One of the previously - de(cid:12)ned composite spaces . ) plication , a user demonstrates how to perform a task , and the system learns an appropriate representation of the task procedure . The learned task model can then be executed on the user’s behalf in order to automate repetitive tasks . In this section , we apply our ver - sion space algebra to the problem of learning procedu - ral actions in a text - editing domain , and describe our SMARTedit ( Simple MAcro Recognition Tool ) PBD system that learns programs based on demonstrations of repetitive text - editing tasks . We begin by sketching the SMARTedit user interface , then de(cid:12)ne SMARTedit’s search space in terms of our version space algebra . 4 . 1 The SMARTedit User Interface SMARTedit implements an editor that supports a sub - set of the Emacs command language . As the user is editing a (cid:12)le , when she notices that she is about to perform a repetitive task , she invokes the SMART recorder by clicking on a button in the user interface . SMARTedit then records the sequence of states that result from the user’s editing commands , and learns functions that map from one state to another . When the user has completed one instance of the repetitive task , she clicks another button to indicate that she has completed a single demonstration . At this point , SMARTedit initializes the version space using the recorded state sequence as the (cid:12)rst training exam - ple . SMARTedit updates the version space lazily as the user provides training examples , which allows it to consider in(cid:12)nite version spaces that are only instan - tiated on receipt of a positive training example . The learner is able to make useful predictions after just a single training example . When the user enters another state where the same repetitive task must be performed , she invokes the learned procedure step by step . The system chooses the most likely function in the version space , executes it , and presents the result - ing state to the user . If the system’s guess was incor - rect , the user may press a button to switch to the next most likely state , and so on . At any point , she may choose to undo SMARTedit’s last action , or override the system and perform edits manually . When the user chooses a state ( either by selecting one of SMART - edit’s choices or by performing the action manually ) , this state is interpreted as another example and used to update the version spaces appropriately . 4 . 2 Version Space Decomposition We represent procedural knowledge as a function from one application state to another . In the text editing domain , the state is an ordered triple ( T ; L ; P ) , where T is the contents of the text editing bu(cid:11)er , L = ( R ; C ) the row and column location of the insertion cursor , and P the contents of the clipboard . After an action is performed ( e . g . , inserting a string at the current cursor position ) , the resultant state incorporates the changes made by that action . At the highest level , our composite version space de - scribes a set of functions mapping one text - editing pro - gram state to another . The set of functions in the ver - sion space represents all text - editing transformations we are able to learn . The goal of the learner is to in - duce a function from one state to another by generaliz - ing from training examples ( in the form of a sequence of states demonstrating the desired state changes ) . We compose the target version space out of smaller , com - ponent version spaces . Figure 1 shows the hierarchy of version spaces corresponding to the target function in the text - editing domain . Although we have presented it here as a tree for clarity , the complete version space has an equivalent representation as a formula in our algebraic notation . The target space Program represents the class of all functions learnable in our domain . It is composed of an independent join of a (cid:12)xed number of Action version spaces . ( In practice , the number is determined lazily as the length of the (cid:12)rst training example . Variable - length action sequences are a topic for future research . ) Each Action function represents a simple command a user might perform in a text editor , such as moving the insertion cursor , inserting and deleting text at the cur - rent cursor location , and manipulating the clipboard ( selecting text and copying it to and from the clip - board ) . The leaf nodes in the version space hierarchy are the atomic version spaces . The ConstInt hypothesis space includes all functions of the form f ( int : x ) = C for some integer constant C . We choose the partial order by the value of C ; if f ( x ) = C 1 and g ( y ) = C 2 , then f (cid:30) g i(cid:11) C 1 < C 2 . The ConstInt version space is trivially maintained ; after two or more examples , the version space collapses to one or zero hypotheses . The LinearInt hypothesis space includes all functions of the form f ( int : x ) = x + C , for some integer constant C . Its partial order and update function are analogous to ConstInt . The AbsRow and AbsCol version spaces transform the ConstInt atomic version spaces from integer functions into functions on row or column values ( i . e . , into func - tions that change the cursor position to an absolute row or column ) . Similarly , the RelRow and RelCol ver - sion spaces transform LinearInt atomic version spaces into row and column functions ( by changing the cur - sor position relative to its previous location ) . The Row composite version space consists of the union of Abs - Row and RelRow version spaces , and likewise for the Column version space . The RowCol version space is the independent join of the Row and Column version spaces with a consistency predicate that is always true . Besides row and column positioning , our domain rep - resentation supports positioning the cursor relative to the next occurrence of a string . If the cursor is po - sitioned after ( before ) a string , we say that the user was (cid:12)nding the next pre(cid:12)x ( su(cid:14)x ) match . Suppose the user has moved the cursor to the end of the next occurrence of the string \ PBD " . From the system’s point of view , the user may have been searching for the pre(cid:12)x \ PBD " , the pre(cid:12)x \ BD " , or the pre(cid:12)x \ D " . The FindPre(cid:12)x and FindSu(cid:14)x version spaces represent these types of string - searching hypotheses . More formally , the PrefStr and Su(cid:11)Str hypothesis spaces include all functions of the form f ( ) = T for Action Action Action Program . . . Move Location Insert ConstStr ConstInt ConstInt LinearInt LinearInt AbsRow AbsCol RelCol RelRow RowCol Location FindSuffix FindPrefix Row Column SuffStr PrefStr Paste DeleteSel Copy SelectTo DeleteTo Location Figure 1 . Version space structure for the text - editing do - main . The upper tree shows the complete version space for a Program , expressed in terms of Action version spaces ( middle tree ) . Action version spaces are in turn expressed in terms of Location version spaces ( bottom tree ) . Itali - cized text denotes an atomic version space , while regular text denotes a composite version space . some constant string T . We choose the partial order of PrefStr according to a string pre(cid:12)x relationship in the string T ; if f ( ) = T 1 and g ( ) = T 2 , then f (cid:30) g i(cid:11) T 1 is a proper pre(cid:12)x of T 2 . ( Su(cid:11)Str is de(cid:12)ned similarly . ) For clarity , we omit the function symbol and simply refer to the function as the string it produces . The least upper bound ( LUB ) and greatest lower bound ( GLB ) boundaries of the PrefStr version space are ini - tialized to be S and C respectively , where S is a token representing the set of all strings of length K ( some constant greater than the maximum text bu(cid:11)er size ) and C is a token representing the set of all strings of unit length . When the (cid:12)rst example is seen , the LUB becomes the singleton set containing the contents of the text bu(cid:11)er following the cursor ( a string ) , and the GLB becomes the singleton set f \ c " g , where c is the character immediately following the cursor . After the (cid:12)rst example the LUB and GLB will always contain at most one string each . Given a new training exam - ple in which the string T follows the cursor , and the LUB contains the string S , the LUB is updated to contain the longest common pre(cid:12)x of S and T . The GLB remains unchanged if the character immediately following the cursor is again c ; otherwise the version space collapses to the null set . The FindPre(cid:12)x version space transforms each hypoth - esis in the Su(cid:11)Str version space into a function from a state to a cursor position . For each function in the Su(cid:11)Str version space , we create a corresponding function in FindPre(cid:12)x that locates the (cid:12)rst occurrence of this string , and returns the cursor position at the end of the matching occurrence . FindSu(cid:14)x trans - forms PrefStr analagously , (cid:12)nding the beginning of each matching occurrence . The various types of cursor - positioning functions are unioned together as the single Location version space , which is in turn transformed by many of the actions . For instance , the Move version space transforms Lo - cation to provide functions from one state to a new state with a di(cid:11)erent cursor location . The DeleteTo ( SelectTo ) version space transforms a Location version space to represent functions that delete ( select ) from the input cursor location to a new location , and out - put a new state in which the text between the two positions has been deleted ( selected ) . 4 . 3 Transformation and Execution The transformation functions for the composite ver - sion spaces are straightforward ; they convert between state - state functions and functions over more primi - tive data types such as integers and tuples of integers . Although a complete description of the transformation functions used in SMARTedit is beyond the scope of this paper , we highlight two of the transformations used in our system . The transformation function for the top - level Program space takes a sequence of states s 0 ; s 1 ; : : : ; s n and con - structs n examples of the form h s i − 1 ; s i i , such that the i th tuple is used to update the i th Action version space . The RowCol transformation function takes a pair of in - put / output cursor locations ( ( r i ; c i ) ; ( r o ; c o ) ) and con - structs the input / output examples ( r i ; r o ) and ( c i ; c o ) that are appropriate for its component version spaces . Other version space transformations are straightfor - wardly de(cid:12)ned . A version space may be executed on a new input state in order to produce one or more output states . In gen - eral , executing a version space on an input i means letting each hypothesis h in it cast a vote for its out - put h ( i ) , and then choosing the output with the most votes . If possible , it is desirable to collect the votes without explicitly enumerating the hypotheses . For the purposes of the PBD application , we are interested in the ranked list of output states , with a preference for output states that are supported by larger numbers of hypotheses . In order to compute the output states for a given input state , the input state is propagated down to the atomic version spaces at the leaves of the tree using the same transformation function used to up - date the version space . The outputs of the leaves are then propagated up through the version space , using the transformation functions to convert them to the proper type . The set of outputs for the target space are then ranked according to the number of hypothe - ses that voted for each output , and the highest - ranked state is presented to the user as previously described . The execution of the FindSu(cid:14)x version space bears mentioning . The underlying Pre(cid:12)x version space rep - resents a set of strings , the longest of which is the string in the LUB , the others being some pre(cid:12)x of the string in the LUB . The execution maps each string in Pre(cid:12)x to the cursor location corresponding to its (cid:12)rst occurrence in the text (cid:12)le following the location of the cursor . We can perform this search e(cid:14)ciently in time O ( st ) where s is the length of the string and t is the length of the text (cid:12)le , by comparing the string against the text starting at every position in the text (cid:12)le fol - lowing the cursor position . The algorithm is as follows : (cid:12)nd the (cid:12)rst location where the (cid:12)rst k 1 characters of the text and search string match . Cast k 1 votes for this location , one for each of the pre(cid:12)xes which matched . Continue searching from this occurrence for a match of at least length k 2 > k 1 , casting k 2 − k 1 votes for the next match . Repeat until all pre(cid:12)xes have been matched or the end of text is reached , and return the set of output locations and their votes as the result of the execution . FindPre(cid:12)x is handled in a similar fashion . 5 . Experimental Results We have applied the SMARTedit system to a repre - sentative collection of repetitive text - editing scenarios . Each scenario is a collection of training examples ; a training example is a sequence of ( T ; L ; P ) states . Fig - ure 2 lists the scenarios we used to evaluate SMART - edit , along with the total number of instances in each , and the number of instances the system needed to see before making the correct prediction on all remaining instances ( i . e . , applying the correct transformation to them ) . In some cases , the system succeeds after just a single example . The columns scenario operates on a text (cid:12)le containing data in whitespace - separated columns . The task in this scenario consists of moving the (cid:12)rst column to the end of the line . The typical sequence of actions involved in this task is to select the text in the (cid:12)rst Scenario Total # Exs . # Train Exs . U1 U2 U3 columns 8 2 2 2 boldface 4 1 1 1 addressbook 6 2 2 2 grades 7 1 1 1 commentstyle 5 1 2 2 HTML - to - L A TEX 7 2 2 2 Figure 2 . List of scenarios used to test the SMARTedit sys - tem , total number of examples in each , and number of training examples ( for each of three users ) required by the system to induce a procedure that makes the correct pre - dictions on the remaining examples . column , copy it to the clipboard , delete the selection , move the cursor to the end of the line , and paste the contents of the clipboard . The boldface scenario has the user take a paragraph of text containing the word \ SMARTedit " and boldface each occurrence of that word by surrounding it with the HTML tags < B > and < / B > . The addressbook scenario operates on a text (cid:12)le con - taining a list of addresses , one per line . The task is to convert each address into a multi - line format suitable for printing on a mailing label by inserting carriage returns at appropriate locations in the address . This scenario is a simpli(cid:12)ed version of an example used to illustrate the TELS system ( Mo , 1989 ) . The grades scenario operates on a text (cid:12)le containing a list of students and their grades in a class . The task in this scenario is to delete the student name that appears at the end of the line , leaving only the list of grades . The commentstyle scenario operates on a text (cid:12)le containing source code in the C programming language . The task in this scenario is to convert all C - style comments into C + + - style comments ( assuming all comments occur on a single line ) . The HTML - to - L A TEX scenario escapes the angle brackets in HTML formatting tags using L A TEX’s $ math mode notation . 6 . Related Work Hirsh ( 1991 ) studied the algebra of boundary - set rep - resentable version spaces . We have extended his work beyond concept learning by allowing any partial or - der , de(cid:12)ning the join operator , and allowing non - BSR unions and intersections . A di(cid:11)erent extension of version spaces has been pro - posed by VanLehn and Ball ( 1987 ) , for inducing context - free grammars from examples . Since general - ity is undecidable for context - free grammars , VanLehn and Ball approximate the generality relation using an alternative partial order . Several prior systems have addressed programming by demonstration ( Cypher , 1993 ) in the text - editing do - main . The TELS system ( Mo , 1989 ) learns programs given demonstrations of action sequences ; TELS uses a collection of domain - speci(cid:12)c heuristics to determine when two actions may be generalized . The Editing by Example system ( Nix , 1985 ) took a di(cid:11)erent approach and induced a text - editing program using only the ini - tial and (cid:12)nal state of the transformation sequence ; the system is able to learn a restricted subset of regular expressions . The Cima system ( Maulsby & Witten , 1997 ) employs a disjunctive rule learner to learn the arguments to an action . Although many knowledge representations su(cid:14)ce for classifying training data into positive and negative examples , they may be useless in acting on a novel example . Cima solved this problem by heuristi - cally preferring rules that more fully describe its be - havior on an unseen example . In contrast , SMART - edit’s version space algebra approach makes the search bias explicit . Work on automatic induction of wrappers for informa - tion resources ( Kushmerick , 1997 ; Ashish & Knoblock , 1997 ) also generates procedural knowledge . In partic - ular , the LR wrapper class described by Kushmerick ( 1997 ) de(cid:12)nes a family of procedures , each of which is equivalent to a sequence of text - editing commands that , for each of the k attributes to be extracted : moves to the next attribute , selects the attribute’s text , and copies it to the clipboard . Lesh and Etzioni ( 1995 ) used version spaces for goal recognition . In the BOCE system , each observed ac - tion caused the version space of goals to be updated to contain only goals consistent with the observed ac - tions . The primary di(cid:11)erence between BOCE and SMARTedit is that BOCE assumes that actions are modeled explicitly as having preconditions and e(cid:11)ects in a STRIPS style ; this representation allows BOCE to directly connect actions with their potential target goals . In contrast , SMARTedit learns action sequences themselves , rather than goals . Langley and Simon ( 1995 ) discuss the di(cid:14)culty of formulating a problem in a representation amenable to classi(cid:12)cation , identify several domains where non - classi(cid:12)cation learning may be applied , and describe a number of early attempts to do so . 7 . Conclusion We have described our version space algebra and ap - plied it to the domain of programming by demonstra - tion . We make the following contributions : (cid:15) We have generalized version spaces to learning input - output mappings of any kind , including out - puts that are structured objects , not just Boolean values . (cid:15) We have developed a framework for application design using a version space algebra that provides union , intersection , join , and transformation op - erators to construct complex version spaces out of simpler ones . (cid:15) We have begun construction of a library of reusable component version spaces that may be applied to a variety of domains . (cid:15) Using our framework and library , we have built a programming by demonstration ( PBD ) system for the text - editing domain and evaluated its perfor - mance on several di(cid:11)erent repetitive text - editing problems . Directions for future work include : extending the version space library ; empirically evaluating alterna - tive domain encodings ; extending the algebra with useful new operators and studying their properties ; combining boundary - represented version spaces with heuristically - searched ones ; searching automatically through the space of version spaces to (cid:12)nd the best structure for a domain ; extending our algorithms to cope with noisy data probabilistically , including speci - fying prior probabilities on hypotheses ; sampling from version spaces for e(cid:14)cient execution ; and investigating the problems ( including credit assignment ) that arise when the parsing of an example into sub - examples is not given a priori . We also plan to enrich our domain model in order to learn more complex text transfor - mation functions . Acknowledgements This research was funded in part by the O(cid:14)ce of Naval Research Grant N00014 - 98 - 1 - 0147 , by National Sci - ence Foundation Grants IRI - 9303461 and IIS - 9872128 , and by a Microsoft Fellowship . We thank Corin Ander - son , Pat Langley , Steve Wolfman , and the anonymous reviewers for their feedback . References Ashish , N . , & Knoblock , C . ( 1997 ) . Semi - automatic wrapper generation for Internet information sources . Proceedings of the Second IFCIS International Con - ference on Cooperative Information Systems ( pp . 160 { 169 ) . Los Alamitos , CA : IEEE - CS Press . Cypher , A . ( Ed . ) . ( 1993 ) . Watch What I Do : Pro - gramming by Demonstration . Cambridge , MA : MIT Press . Hirsh , H . ( 1991 ) . Theoretical underpinnings of ver - sion spaces . Proceedings of the Twelfth International Joint Conference on Arti(cid:12)cial Intelligence ( pp . 665 { 670 ) . San Francisco , CA : Morgan Kaufmann . Hirsh , H . , Mishra , N . , & Pitt , L . ( 1997 ) . Version spaces without boundary sets . Proceedings of the Four - teenth National Conference on Arti(cid:12)cial Intelligence ( pp . 491 { 496 ) . Menlo Park , CA : AAAI Press . Kushmerick , N . ( 1997 ) . Wrapper induction for infor - mation extraction . Doctoral dissertation , Depart - ment of Computer Science & Engineering , Univer - sity of Washington , Seattle , WA . Langley , P . , & Simon , H . A . ( 1995 ) . Applications of machine learning and rule induction . Communica - tions of the ACM , 38 , 54 { 64 . Lesh , N . , & Etzioni , O . ( 1995 ) . A sound and fast goal recognizer . Proceedings of the Fourteenth Inter - national Joint Conference on Arti(cid:12)cial Intelligence ( pp . 1704 { 1710 ) . San Francisco , CA : Morgan Kauf - mann . Maulsby , D . , & Witten , I . H . ( 1997 ) . Cima : An Inter - active Concept Learning System for End - User Ap - plications . Applied Arti(cid:12)cial Intelligence , 11 , 653 { 671 . Mitchell , T . ( 1982 ) . Generalization as search . Arti(cid:12)cial Intelligence , 18 , 203 { 226 . Mo , D . H . ( 1989 ) . Learning text editing procedures from examples . Master’s thesis , Department of Computer Science , University of Calgary , Calgary , AB . Nix , R . P . ( 1985 ) . Editing by example . ACM Trans - actions on Programming Languages and Systems , 7 , 600 { 621 . Norton , S . W . , & Hirsh , H . ( 1992 ) . Classi(cid:12)er learning from noisy data as probabilistic evidence combina - tion . Proceedings of the Tenth National Conference on Arti(cid:12)cial Intelligence ( pp . 141 { 146 ) . Menlo Park , CA : AAAI Press . VanLehn , K . , & Ball , W . ( 1987 ) . A version space ap - proach to learning context - free grammars . Machine Learning , 2 , 39 { 74 .