Knowledge and Control IaM ic Design Expert System David C . Brown , \ Afrcester Polytechnic Institute B . Chandrasekaran , Ohio State University M ost first - generation expert sys - tems have been rule - based with a separate inference engine . How - ever , a large unstructured collection of rules clearly lacks validity as a realistic model of design because reducing all knowledge to a single form does not recognize that there are many different types of knowledge used in any design problem - solving activity . Using such a collection of rules also does not recognize that design knowledge forms into clusters . Nor does it specify where or when this knowledge is to be ap - plied , since different clusters of knowledge may be applicable at different times . Similarly , using a single , central all - purpose inference engine ignores the richness of design problem - solving . Yet another problem is the potential for un - focused system behavior because all rules have equal status in the system and have equal potential for use . Many systems structure rules into sets . However , these sets are based on subtasks rather than on types of knowledge , 1 - 3 and the problem solving is still uniform , as the same inference engine acts on each rule set . Advocates of such structuring claim the subtasks can be solved linearly with no backtracking between tasks and with only minimal backtracking within tasks . Such subtask structure tells us more about the nature ofthe domain than about design , since it is clear that design deci - sions of any kind can often be wrong and , if so , will lead to attempts to recover from failure . The uniform rule representation and the lack of knowledge - dependent structure does not provide clear predic - tions about an expert ' s failure - recovery behavior . These problems stem mainly from a basic mismatch between the level of the tools available to build systems and the level of abstraction of the design task . 0018 - 9162 / 86 / 0700 - 009201 $ . O0 Â© 1986 IEEE 92 COMPUTER Consequently , for more complex forms of expert problem solving , there is a need for tools at the task level . Such tools mustpro - vide a rich set of design - related task - level constructs . They should be helpful in cap - turing more structured forms of knowl - edge , and should help organize both knowledge and problem - solving behavior for more focused problem - solving . Generic tasks in reasoning . The Laboratory for AI Research at Ohio State is developing a framework in which in - vestigation of generic tasks in knowledge - based reasoning plays a fundamental role . 4 Appropriate families of knowledge structures and control regimes are con - structed for each generic task . From this perspective , design as a generic task calls on and uses distinctly different types of knowledge and control from , say , diagnosis . This point of - view naturally leads to families of high - level languages for expert system construction . These languages let domain knowledge be captured much more lucidly by using primitives ap - propriate to the task . They also make ap - propriate classes of control behavior avail - able to the designer . For the design subclass we call routine design , we have developed DSPL , a task - level language . ( " DSPL " stands for Design Specialists and Plans Language . ) Design is a complex activity , one that ar - tificial intelligence has only relatively weak theories of , especially for more creative design activity . In routine design , the structure of the artifact is fixed and stan - dard methods of designing various parts are known . However , there is still a complex prob - lem - solving activity : integrating and satis - fying all the constraints of the particular design problem . Rough design and back - tracking occur in this design process , but much of the problem solving is piecing together the design rather than creating new methods . In our view , a substantial part of design activity in industry is of this type . Thus , our approach could be widely applied . We use the domain of mechanical com - ponents - air cylinders in particular - to motivate our research . 5 The AIR - CYL system described later shows how our routine design problem - solving approach can be applied . Other work in design . The nature of design has been discussed considerably among artificial intelligence researchers . The circuit design domain is one area where somewhat more sophisticated issues about the structure of knowledge and con - trol in design have been discussed , but even there relatively few systems consider design problems in ways that are not ad hoc . & 9 In the mechanical systems domain , the work of Simmons , Dixon , and Cohen10 and Mittal , Morjaria , and Dym " I share our interest in producing a theory of design . The former authors concentrate on a theory of redesign , while the latter in - clude plans and active design knowledge in their theory , much as we do . Stefik , 12 too , presents an important view of design but is concerned with less routine design activity . His Constraint Posting mechanism could be used in an explanation of how routine design knowledge is produced . However , this design research did not lead to generic languages and architectures to support design as a problem - solving ac - tivity ( which is at least partly our aim ) . We have deliberately sought a level of design where the complexity of knowledge and control can be limited , but where more powerful building blocks than those now available can be provided in return . Onthe other hand , the complexity of the design problems solvable by our framework is still higher than those solved with the rule - based paradigm . Design components . Design is a highly creative activity involving diverse prob - lem - solving techniques and many kinds of knowledge . Clearly , since we don ' t know many of the problem - solving components of general design and since we poorly understand the components we do know about , a comprehensive detailed model of design is out of reach . However , there is agreement about many components of design activity . There is an element of refinement : Descriptions get refined into less abstract forms . Plans are used in recognizable situations . Such plans result from repeated use of past planning and valida - tion . Design activity often has a rough design phase followed by design proper . Design organization reflects the struc - ture or functionality of what is being designed . Similarly , the design representa - tion is also structured . During the design , Jul 1986 various restrictions are checked at ap - propriate points . The initial conditions ( requirements ) form a starting set of restrictions . Routine design approach In routine design , the designer selects from previously known sets of well - understood design alternatives . The choices may be simple at each point in the design , but overall the task is still too com - plex to be done by merely looking in a design database because there are too many possible combinations of initial re - quirements . Simple choices do not imply simple designs or a simple design process . A significant portion of design activity is composed of these routine tasks . ( While we have concentrated on routine design , we recognize that some design problems belong to a different type . ) Architecture . We use the architecture of a hierarchically organized community of design agents called specialists . This hierarchy reflects the hierarchical struc - ture of the artifact being designed . We consider routine design to be largely a top - down activity . In our architecture , each specialist has a repertoire of design plans to accomplish certain design tasks at its level of abstraction . The specialists choose from plans , make some commitments , and direct specialists at lower abstraction levels to refine the design . Failures cause different kinds of actions , such as choos - ing alternative plans and transferring con - trol to a parent specialist . The upper levels of the hierarchy are specialists in the more general aspects of the component , while the lower levels deal with more specific subsystems or com - ponents . We use a hierarchy not because the design is intrinsically hierarchical but because people use hierarchies to manage complexity . The specialists chosen , their responsibilities , and their hierarchical organization will reflect the mechanical designer ' s underlying conceptual structure of the problem domain . Agents . Several types of agents ( active problem - solver modules ) exist in the hierarchy ' s decision - making structure . They include specialists , plans , steps , tasks , and constraints . 93 Specialists cooperate to refine the de - sign . Each specialist tries to design a major section of the component . To do this , a specialist uses a collection of plans . A plan is a sequence of calls to special - ists or tasks , possibly with interspersed constraints . A plan represents one method to design the section of the component represented by the specialist . A plan specifies the order of invocation of the various agents used by this design method . The most basic design agent is a step . Each step makes a design decision . It decides on a value for some attribute ofthe component . The value is stored in a design database . The decision depends on the current state of the design , taking into ac - count any constraints . For example , one step would decide the material for some subcomponent , while another would de - cide its length . A series of steps - possibly with inter - vening constraints - forms a task , which designs a logically , structurally , or func - tionally coherent section of the compo - nent ( for example , a seat for a seal , or a hole for a bolt ) . Constraints test for particular relation - ships between two or more attributes at particular design stages . Constraints can occur nearly anywhere in the hierarchy . For example , a constraint might check that a hole for a bolt is not too small to be machinable in the material used . 13 Problem approach . The top - most spe - cialist is responsible for the whole design . Specialists lower down in the hierarchy make detailed decisions . Each specialist can make design decisions about the parts and functions in its specialty . The deci - sions are made in the context of previous design decisions made by other specialists , as recorded in the database . Specialists can design their pieces themselves or use the services of other specialists below them in the hierarchy . Specialists in the hierarchy will refine the design independently , using their plans . Tasks attached to specialists pro - duce values using groups of steps , while constraints check the integrity of the deci - sions made . Every specialist has some local design knowledge , some of which is expressed as constraints . The constraints capture the major things that must be true of a specialist ' s design before it can be con - sidered successfully completed . Other constraints , embedded in the specialist ' s plans , check the correctness of inter - mediate design decisions and check the compatibility of subproblem solutions . Design phases . The design activity falls into four phases . Requirements phase . Initially , re - quirements are collected from the user and are verified both individually and collec - tively . Once the requirements are accept - able , the system attempts a rough design . Rough design phase . Rough design is poorly understood - but it serves at least two purposes . First , those values on which much of the rest ofthe design depends will be decided and checked . The actual at - tributes decided depend on the component and the domain , but it is likely that a value for higher level attributes , such as material , will be chosen in this phase . If these attributes can ' t be achieved , there is little point going on with the rest of the design . This also prunes the design search space because once the overall char - acteristics of the design are established , the number of choices about how to proceed with the rest of the design diminishes . Second , as any mutually dependent at - tributes can prevent a design from pro - gressing , rough design can , as human designers do , pick a value for one of the attributes and use that as if the dependen - cies didn ' t exist . Specialists have both design and rough - design plans to select from , depending on the current phase . Not all specialists will need both . Some phases could be mixed during problem - solving , but we have made the rough phase occur first , fol - lowed by the design phase . Design phase . Once rough design is complete , the design phase can proceed . Design starts with the topmost specialist and works down to the lowest levels of the hierarchy . A specialist begins by receiving a design request from its parent specialist . It refers to the specification database for relevant specifications and then selects a plan using these data and the current de - sign state . 14 The specialist can fill in some of the design and can call its successors in plan - determined order with requests to refine a substructure ' s design . The knowledge in the specialist assigns priorities to the plans and invokes alternative plans in case a later specialist fails . When all of a specialist ' s plans fail , the specialist tells its parent . Redesign phase . If any failures occur during design , a redesign phasebegins . If a redesign phase succeeds , the design phase continues where it left off . The system tries to handle all failures at the point of failure before admitting defeat and passing fail - ure information up the hierarchy . A step , for example , may be able to examine the failure and then produce another value to satisfy a failing constraint while still re - taining local integrity . This local attention to failure is an essential element ofthe sys - tem ' s failure - handling behavior . Communication . The main means of communication in the system is passing in - formation and control messages between specialists across the connections forming the hierarchy . This restrains the control flow , and the system exhibits clear , well - focused problem - solving activity . Messages can request actions , report failures , ask for assistance , and make sug - gestions . This variety of messages is the key to handling subsystem interactions . One part of the emerging theory of design problem - solving is the form and content of these design - oriented messages . The design trace in the sidebar shows some of the types of messages used . Other agents . In addition to the spe - cialists in the hierarchy , the system may need other specialists outside the hierar - chy . These are specialists in somewhat more general activities commonly needed by several specialists in the hierarchy . For example , they may be certain kinds of stress calculation modules or database functions . In a more general design system , re - quests could be made to other types of problem - solvers . 15 A human user could act as a problem - solver , since requests for help will occur at well - defined points in the design . The expert system can subsequent - ly check the acceptability of the results provided . Routine design example In the company that cooperated with us , an air cylinder ( intended for accurate COMPUTER 94 Figure 2 . Partial AIR - CYL structure . and reliable backward and forward move - ment of some component ) had to be redesigned for every new customer . This was done to account for the particular space it had to fit in or the intended operating temperatures and pressures . The air cylinder , shown in Figure 1 , has about 15 parts . The AIR - CYL design problem - solving system was developed with the task - level DSPL language , which was in turn devel - oped with the Rutgers ELisp language on a DECsystem - 20 . AIR - CYL demonstrated the viability of our routine design theory . We are now extending the theory and ex - amining the issues that arose while using the air cylinder as our test case . Conceptual structure . Before designing AIR - CYL , we interviewed an air cylinder designer , analyzed the design protocols , and obtained a trace of the design process to establish the underlying conceptual structure in making an air cylinder ( see Figure 2 ) . For example , the cylinder head was clearly treated as a separate conceptual en - tity . The spring was an essentially parallel activity , while the rest of the design was treated by the designer as the third major activity . Because specialists could be fairly easily identified and plans for each specialist were few and identifiable , de - signing an air cylinder appeared strongly to be a routine design activity . Deign agents . In the examples that follow , we use a simplified form of the DSPL language . The task - based language allows expression of design agents , in - cluding specialists , and plans to carry out design objectives . Aplan consists of a set of actions , some ofwhich may be run in parallel . For exam - ple , in Figure 3 , we show a plan with atask called Validate and Process Require - ments , a constraint called Head and Spring Compatible ? , and a specialist called Rest . Together , these form the design plan . Some specialists will also have rough design plans . A task consists of the sequential use of steps , each of which obtains required in - formation , makes calculations , and makes a decision about the value of a single attribute . Figure 4 shows a step that decides the seat width for the piston seal . In this step , " Piston Seal Seat Width " is the name ofa task , " Seal Seat Width " is the name ofthe attribute being decided , " Increase Piston Thickness " is what the step will suggest if it cannot make a decision ( redesign is not possible for this step ) , " Piston Thickness " is a previously designed attribute , and " Available > Seal Seat Width " is the name of a constraint . July 1986 Figure 1 . An air cylinder . 95 Handling failures One view of failure handling considers all relevant knowledge to be available at failure time . Our view is that data and con - trol knowledge in human problem - solving is structured and probably incomplete , thus restricting the kinds of information available for handling failures . The struc - ture of the design problem - solving system ( that is , specialists , plans , tasks , and steps ) provides the context in which to structure failure handling . In our theory , all design agents detect their own failure , try to determine what went wrong , try to fix it locally , do so if they can , and report failure only if all at - tempts fail . Agents that have some control over other agents can use those agents when trying to correct the detected prob - lem . By using these ideas , we hope to establish what is essential for failure handling in this kind of design activity . 16 This Is a trace ; ; highly edited for tra0 ' is of a sucO of alternative plaf design . " * AIR COMPUTER : ment 96 Each kind of agent can have different kinds of reasons for failing . For example , a step finds that a decision violates some constraint , a task discovers that a step ' s failure can ' t be handled locally , a plan can fail if it ' s not applicable to the situation , and a specialist can fail if all of its plans fail . For every kind of failure , a message giv - ing details is generated and passed back to the calling agent . The message includes , wherever possible , suggestions about what might be done to alleviate the problem . Because there are usually many kinds of problems that can occur , an agent will first look at the message to decide what went on below and what to do next . A Failure Handler attached to an agent contains the knowledge to make those decisions . For some conditions , immediate failure can be specified , while for others a re - design might be attempted . A redesigner is associated with an agent . It contains July 1986 97 knowledge of how to change a design ac - Research issues cording to suggestions . The sidebar presents an edited trace of the AIR - CYL system in operation . It We feel that while the idea of design shows recovery from constraint failures . It refinement captures the essence of design also shows a plan failing and a new - and problem - solving - at least in its relatively successful - plan being selected . routine aspects - there are several impor - tant aspects of problem - solving and the use of plans that need more research . DSPL is being studied and refined to make it more powerful , flexible , and easy to use . In addition , we hope to improve the inter - face with the system so others can use it . Eventually we expect to provide a graph - COMPUTER 98 ical interface to show the development of the design as it progresses . One possible way to deal with failures is to try to relax one or more of the re - quirements . Clearly some requirements can be softer than others - and asking the user for some relaxation may clear the way to a successful design . If much effort has been expended on a design by both ma - chine and human , this makes a lot of sense . It may be possible for the system itself to choose the requirements to relax , but a lot of special knowledge would be necessary to implement this . Even knowing when to ask for a relaxation will be difficult . This is a matter for future research . We are quite aware that there are bound to be other examples of routine design tasks that cannot naturally be brought under the plan refinement paradigm . Even July 1986 99 if it is true that design is a process of choosing plans and refining designs , our ability to construct expert systems for design is very much a function ofthe types of design knowledge we can capture and manipulate . We would like , as a result of our research , to be able to characterize the kinds of design problems for which our approach can create effective expert systems . M ^ uch work remains to be done in building expert systems for rou - M I tine design activity before we can understand what design is and how best to build systems to do it . We feel that there is great need for tools that express knowledge at the task level . DSPL is an ex - ample of such a tool . We feel that our ap - proach of using a hierarchically structured system with plan selection captures the essential qualities of routine design . [ E Acknowledgments This work was supported at Ohio State University by Air Force Office of Scien - tific Research Grant 82 - 0255 . We would also like to acknowledge the cooperation of the AccuRay Corp . , Dave Herman , and Pete Schmitz . References 1 . J . McDermott , " Ri - A Rule - Based Configurer of Computer Systems , " Artificial Intelligence , Vol . 19 , No . 1 , Sept . 1982 , pp . 39 - 88 . 2 . T . Kowalski and D . Thomas , " The VLSI Design Automation Assistant : Prototype System , " Proc . ACM / IEEE 20th De - sign Automation Conf . , June 1983 , pp . 479483 . 3 . W . Birmingham and D . Siewiorek , " Micon : A Knowledge - Based Single - Board Computer Designer , " Proc . ACM / IEEE 21st Design Automation Conf . , June 1984 , pp . 565 - 571 . 4 . B . Chandrasekaran , " Generic Tasks in Knowledge - Based Reasoning : Character - izing and Designing Expert Systems at the Right Level of Abstraction , " Proc . IEEE Int ' l Conf . on Al Applications , Dec . 1985 . 5 . D . C . Brown , " Expert Systems for Design Problem - Solving Using Design Refine - ment with Plan Selection and Redesign , " unpublished PhD dissertation , Computer and Information Science Dept . , Ohio State University , Columbus , Ohio , Aug . 1984 . 6 . G . Sussman , " Electrical Design - A Problem for AI Research , " Proc . Int ' l Joint Conf . Al , Aug . 1977 , pp . 894 - 900 . 7 . D . McDermott , " Circuit Design as Problem - Solving , " Al and Pattern Recognition in CAD , J . - C . Latombe , ed . , North - Holland , Amsterdam , 1978 , pp . 227 - 245 . 8 . T . Mitchell , L . Steinberg , and J . Shul - man , " A Knowledge - Based Approach to Design , " IEEE Trans . Pattern Analysis and Machine Intelligence , Vol . 7 , No . 5 , Sept . 1985 , pp . 502 - 510 . 9 . M . Grinberg , " A Knowledge - Based Design System for Digital Electronics , " Proc . AAAIRlrst Ann . Nat ' l Conf . Al , Aug . 1980 , p . 283 . 10 . J . Dixon , M . Simmons , and P . Cohen , " An Architecture for Application of Artificial Intelligence to Design , " Proc . ACM / IEEE 21st Design Automation Conf . , June 1984 , pp . 634 - 640 . 11 . S . Mittal , M . Morjaria , and C . Dym , " Pride : An Expert System for the Design of Paper - Handling Systems , " Appli - cations of Knowledge - Based Systems to Engineering Analysis and Design , C . Dym , ed . , ASME , New York , 1985 , pp . 99 - 116 . 12 . M . Stefik , " Planning with Constraints ( Molgen : Part I and Part 2 ) , " Artificial Intelligence , Vol . 16 , No . 2 , 1980 . 13 . D . C . Brown and R . Breau , " Types of Constraints in Routine Design Problem - Solving , " Proc . IEEE First Int ' l Conf . Applications of Al to Engineering Problems , Southampton , England , Apr . 1986 . 14 . D . C . Brown and B . Chandrasekaran , " Plan Selection in Design Problem - Solving , " Proc . AISB 85 , Conf . of the Society for the Study of Artificial Intelligence and the Simulation of Behavior , Warwick , England , Apr . 1985 . 15 . B . Chandrasekaran , " Towards a Taxon - omy of Problem - Solving Types , " Al Magazine , Vol . 4 , No . 1 , Winter - Spring 1983 , pp . 9 - 17 . 16 . D . C . Brown , " Failure Handling in a Design Expert System , " in Computer - Aided Design , J . Gero , ed . , Butterworth & Co . , London , 1985 . David C . Brown is an assistant professor of computer science at Worcester Polytechnic In - stitute in Massachusetts . His research interests are knowledge - based problem - solving for design , languages and systems for design , knowledge acquisition for design and diag - nosis , and intelligent database browsing for manufacturing applications . Brown received his BSc in computer science from North Staffordshire Polytechnic and an MSc degree in computing from the University of Kent at Canterbury . He has an MS degree in computer and information science and a PhD in artificial intelligence from Ohio State University . He is a member of the ACM , IEEE Com - puter Society , and AAAI . Readers may write to Brown at the AI Research Group , Computer Science Dept . , Worcester Polytechnic Institute , Worcester , MA 01609 . B . Chandrasekaran has been at Ohio State University since 1969 . He is currently professor of computer and information science . From 1967 to 1969 he was a research scientist with the Philco - Ford Corporation in Blue Bell , Pa . , working on speech - and character - recognition machines . His major research activities are cur - rently in knowledge - based reasoning ; hedirects the Al group at OSU . Chandrasekaran received his bachelor of en - gineering degreewith honors fromMadras Uni - versity in 1963 and his PhD from the University of Pennsylvania in 1967 . He is associate editor for AI of IEEE Transactions on Systems , Man and Cybernetics and chairs the society ' s Tech - nical Committee on Al . He was elected a Fellow of the IEEE in 1986 . 100 COMPUTER