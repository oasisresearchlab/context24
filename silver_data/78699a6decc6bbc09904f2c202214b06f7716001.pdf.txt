72 COMMUNICATIONS OF THE ACM | JUNE 2017 | VOL . 60 | NO . 6 review articles A GLOBAL PUSH to broaden participation in computer science has led to an explosion of interest in blocks - based programming . Visual blocks are used by numerous programming tools ( see the sidebar ) . Millions of students receive their first exposure to programming via these tools in courses and activities like Code . org’s Hour of Code . Blocks allow beginners to compose programs without struggling with the frustrations of syntax ( Figure 1 ) . There is increasing interest in developing and studying blocks languages . At VL / HCC 2015 , a small workshop session called Blocks and Beyond a ballooned to a large event , with 51 submissions and 36 presenters . Researchers shared work in new blocks languages , a http : / / cs . wellesley . edu / blocks - and - beyond interface innovations , domain - specific applications of blocks , and ways to make blocks languages more effective and accessible for diverse coders . This article explores how blocks im - pact the learnability of programming . We begin by reviewing studies on the effectiveness of blocks languages . Then we discuss the key features of blocks languages and how they relate to learning . Finally , we look at appli - cations of blocks in new domains and discuss tools for creating your own blocks language . Watching beginners create their first programs with blocks can be si - multaneously inspiring and unsettling . Empowered by blocks , novices will rap - idly build complex , often - delightful creations . But just as quickly , they fill their screen with clumsy and intricate code . 22 A seasoned programmer in - specting a beginner’s disordered as - sembly might worry that snapping to - gether colorful blocks has nothing to do with “real code . ” But what is “real code , ” and why learn it ? What is “real code ? ” The purpose of a blocks - based tool is to make pro - gramming easy to learn . But program - ming education can have two distinct endpoints : Development of expertise to support professional programming , and the ability to accomplish other goals by creating programs . key insights ˽ Blocks programming environments have emerged as a popular way to introduce coding and as a stepping stone to traditional text - based languages , but they can also be used to write “real code . ” ˽ Blocks environments improve learnability for novices by favoring recognition over recall ; reducing cognitive load by chunking computational patterns into blocks ; and using direct manipulation of blocks to prevent errors and enhance understanding of program structure . ˽ Learnability is also enhanced by key features beyond blocks , including online environments , high - level abstractions , visible state , and easy - to - find examples . ˽ Tookits are available to enable you to enhance your own block language . Learnable Programming : Blocks and Beyond DOI : 10 . 1145 / 3015455 New blocks frameworks open doors to greater experimentation for novices and professionals alike . BY DAVID BAU , JEFF GRAY , CAITLIN KELLEHER , JOSH SHELDON , AND FRANKLYN TURBAK JUNE 2017 | VOL . 60 | NO . 6 | COMMUNICATIONS OF THE ACM 73 I M A G E B Y A N D R I J B O R Y S A SS O C I A T E S / S H U TT E R S T O C K The two objectives are not nec - essarily the same . The designers of Scratch note that for users “who see programming as a medium for ex - pression , not a path toward a career , Scratch is sufficient for their needs . ” 28 The GP blocks environment is being designed to enable “casual program - mers” to create ever more sophisticated programs , while removing limits that would force them to switch away from blocks . 24 Before discussing the learn - ing effects of blocks - based program - ming , we begin with a caution that it would be shortsighted to assume that tomorrow’s programmers will pro - gram with the same languages and systems as today’s . Each generation of programmers shifts the culture of coding , and the definition of “real code” will continue to evolve . However , core learning questions remain . For students who continue with the study of traditional program - ming , we can ask if a blocks - based in - troduction to programming is helpful or not . This question has been directly tested in classrooms . Measuring learning transfer : Re - search indicates that learning a blocks language can improve later learning of a traditional textual lan - guage . In a study of 10 th graders learn - ing C # or Java , 1 those who had taken a Scratch course in 9 th grade learned more quickly , understood loops bet - ter , and were more engaged and con - fident than their peers who had not . However , in the final test , a signifi - cant difference was seen in only one of three cognitive dimensions . In a study at two colleges , 25 students with little or no previous programming experience and weak math prepara - tion completed a CS0 programing class using Alice before beginning a Java CS1 course . Starting with Alice improved student grades ( GPA of 3 . 0 vs . 1 . 2 for non - Alice students ) and the percentage of students taking further CS courses ( 88 % compared to 47 % ) . The question of whether such ef - fects are simply due to giving students more preparation in an extra class has been tested by creating courses that combine a blocks - based introduc - tion with a transition to a traditional language . Reports from courses using Scratch before Java or C indicate im - proved student engagement and under - standing of some concepts . 19 , 39 In one study focused on learning transfer , 8 introductory Java course at CMU was modified to begin with Alice . Students in this class that used both languages averaged 10 % or more better perfor - mance on every section of the same Java final exam , including expression evalu - ation , control structures , arrays , and working with class definitions . That result is remarkable because one might assume that spending more time programming with blocks meant less time to learn Java . The study used a version of Alice that generated Java code from Alice blocks , and a mediated transfer pedagogy that made explicit connections between programming concepts in Alice and Java . Other studies of CS1 courses that switch from blocks to text without these features have identified potential challenges to learning with blocks . 10 , 27 Switching from a blocks language to text can involve both a change in syntax and semantics , and Shapiro and Ahrens pro - pose teaching the transitions separate - ly , by introducing syntax before general - izing semantics . 32 Additional research is needed to identify the circumstances under which blocks are effective . 74 COMMUNICATIONS OF THE ACM | JUNE 2017 | VOL . 60 | NO . 6 review articles ( Figure 2b ) . Yet , the basic idiom is the same as Scratch : explorable palettes organized by function . Remembering the order , type , and valid values of operands is also daunting for newcomers . Many block languages address this by supplying blocks with default operand values , drop - down menus and specialized editors to specify operands , and extra words to indicate operand meanings ( Figure 3a ) . Chunking information with blocks . Programming languages present a high cognitive load to a student who is learn - ing a new syntax . For example , consider the for loop in JavaScript syntax : for ( var i = 0 ; i < 50 ; i + + ) { _ _ _ } This dense notation is a barrier to beginners . In the words of one student , JavaScript “is really confusing to un - derstand with all the parentheses and brackets and all of that . ” 38 To understand the difficulty , con - sider that this code contains five words ( for var i i i ) , 10 pieces of punctua - tion ( ( = ; < ; + + ) { } ) , and two num - bers ( 0 and 50 ) , a total of 17 units of in - formation . Studies of human cognitive capacity have established that people have a working memory of about seven chunks of information . 23 Trying to un - derstand this line of code as 17 sepa - rate items may overwhelm the working memory of a new programmer . Experienced JavaScript program - mers have no problem understanding the line of code noted here because they have learned to interpret the code in larger chunks . Because a for loop follows a very common pattern , it can be read in just two chunks : first , the typical for loop that uses the conven - tional looping pattern ( i starting at 0 and incrementing by 1 ) ; second , the particular choice of 50 as the upper limit . Figure 4 illustrates different ways of chunking the code . Blocks help reduce cognitive load by showing new programmers how to read larger chunks . In the Code . org Com - puter Science Principles course , blocks for JavaScript for loops are drawn just as an expert would see the code : as two chunks with a single block with a sin - gle socket for the loop upper bound . Complexity can also be reduced by nesting chunks within chunks . For ex - Today , many introductory computer science courses use a blocks - before - text approach . In Harvard’s CS50 , stu - dents move from Scratch to C ; Berke - ley’s CS10 progresses from Snap ! to Python ; Project Lead The Way’s Com - puter Science Principles ( CSP ) course uses both Scratch and App Inventor before moving on to Python ; and Code . org’s CSP App Lab course moves from Droplet blocks to JavaScript . Why Blocks Are Learnable In 2004 , Ko , Myers , and Aung 15 identi - fied six learning barriers encountered by non - programmers in programming tasks . Three of these— selection , use , and coordination —reflect the difficulty of simply assembling a program . We believe the learnability of blocks lan - guages arises from how they address the usability challenges underlying these three learning barriers : 1 . Learning a programming vocabu - lary is difficult . Blocks simplify this problem because picking a block from a palette is far easier than remember - ing a word : blocks rely on recognition instead of recall . 2 . Code is difficult to use because it presents a high cognitive load for new programmers . Blocks reduce the cogni - tive load by chunking code into a smaller number of meaningful elements . 3 . Assembling code is error - prone . Blocks help users assemble code without basic errors by providing con - strained direct manipulation of struc - ture ( for example , two incompatible concepts do not have connecting parts ) . Recognition versus recall . Program - ming with a simple language or li - brary typically involves a vocabulary of about 100 – 200 words . For exam - ple , HTML has 100 tags and 100 at - tributes , and SQL has about 200 key - words ; Scratch is similar , with 130 blocks . Recalling 100 – 200 concepts can overwhelm a newcomer . Unlike text languages , blocks lan - guages are intimately tied to their pro - gramming environments , and nearly all block environments have adopted a few interface conventions that address key usability problems . One such con - vention is tackling vocabulary by orga - nizing blocks in functionally related palettes on the screen . Palettes differ from autocomplete menus in professional code editors be - cause they persist instead of disappear - ing and they organize concepts by topic instead of by name . This design simpli - fies discovery and exploration . Figure 2a shows the Sound palette in Scratch . It is an instructive reference showing all 13 methods for audio in that envi - ronment . Similar organization is seen in larger blocks environments . To help manage the complexity of creating mobile apps , App Inventor provides a dynamic set of blocks , with additional blocks available in programs that have interactions with more components Figure 1 . Snap ! is an example of a blocks - based programming environment . Users drag blocks from a palette of programming elements ( left ) into workspace ( center ) , where blocks can be assembled into programs . Snap ! also provides an output window ( top - right ) and a sprite picker ( bottom - right ) . JUNE 2017 | VOL . 60 | NO . 6 | COMMUNICATIONS OF THE ACM 75 review articles ample , Code . org reveals finer - grained for structure in more advanced por - tions of the same course , as illustrated at the bottom of Figure 4 . The use of blocks to chunk code aids readability even for simple com - mands , because blocks can forgo the punctuation that text code uses to de - note structure and use explanatory words instead . For example , as illus - trated in Figure 3b , a simple call in Py - thon requires reading delimiters and knowing argument order , whereas the equivalent block in Scratch reads natu - rally , using appropriate abstractions ( for example , a piano keyboard ) . By organizing code as visible chunks , blocks help new programmers concentrate on what the code means rather than the notation that is used to write it . Direct manipulation of visible struc - ture . The visual form of blocks alleviates the burden of assembling syntactically correct units by typing one character at a time . But there are other advantages of directly manipulating program frag - ments that have visual constraints . One benefit is the blocks can help prevent errors by making the grammar of the program visible . Blocks can be seen as a form of syntax - directed editing with constrained direct manipulation . In 1981 , creators of an early structure - editing tool noted , “Programs are not text ; they are hierarchical compositions of computational structures and should be edited , executed , and debugged in an environment that consistently acknowl - edges and reinforces this viewpoint . ” 35 Block shapes help beginners un - derstand which grammatical phrases ( expressions vs . commands vs . dec - larations ) are legal in what contexts . In Scratch , commands connect verti - cally with nubs and notches , whereas expressions are smooth shapes that fit into smooth holes . Constraints on drag - and - drop prevent the two types from being confused ( Figure 5 ) . Stu - dents report that the puzzle shapes are helpful for assembling programs . 38 Visualization of types by shape can be applied to richer type systems : OpenBlocks provides 14 connector shapes to represent different types , 29 and researchers have created experi - mental block languages with dynami - cally generated shapes to represent compositional type systems . 18 , 36 Figure 2 . The sound palette in Scratch ( a ) and a voice synthesis palette in App Inventor ( b ) . Palettes simplify the selection of programming elements by exploiting the ease of recogni - tion over recall . Palettes organize concepts by topic , not name , and they remain open when used , allowing the user to discover and tinker with blocks based on their function . Figure 3 . Blocks show structure visually ( a . Scratch ) instead of using punctuation . They can aid learnability using plain language , default values , and value pickers . Figure 4 . Three ways of reading a for loop in chunks . A naive reading of code ( top ) interprets the code as 17 chunks , but an expert reading of code ( middle ) interprets the most common form of loop as a single chunk , with a second chunk for the loop limit 50 . An alternative ( bottom ) reading interprets three clauses as chunks . Code . org uses the middle rendering when introducing loops to high - school students for the first time , and switches to the bottom rendering when students are familiar with for loops . ( a ) Scratch ( b ) Python playNoteFor ( 60 , 0 . 5 ) 76 COMMUNICATIONS OF THE ACM | JUNE 2017 | VOL . 60 | NO . 6 review articles structs can have an impact on learn - ability . Empirical studies by Stefik and Seibert 34 have found that com - mon keywords like for or operators such as ! = serve as hard - to - learn jar - gon , and are not as easily learnable as familiar words such as repeat or unequal . They found the syntax of languages such as Java and Perl are no more learnable than a synthetic programming language with ran - domly selected punctuation used for keywords . Even more important for learnability are the abstractions cho - sen by language designers to allow users to build simple programs with compelling behavior . For example , the designers of Alice worked with users to develop intuitive abstrac - tions for controlling 3D animations . During their design process , the Al - ice team eliminated jargon such as transformation matrices and substi - tuted more intuitive concepts like object - relative motions . These new abstractions made it easier for users to specify 3D animations . 7 Designing languages and librar - ies focused on learnability based on empirical evidence is a major area for future work . Runtime understanding . The dynam - ic state of a program can be made more understandable by making its state vis - ible . For example , Code . org highlights the individual block actively running so the correspondence between code and action can be seen . Snap ! provides widgets for every variable to show the current state . Even with highly visible state , un - derstanding actions in the past or fu - ture can be difficult . Liveness 20 is one approach to addressing this problem . A live system aims to make actions con - crete by applying them immediately to the current state . For example , in App Inventor , Scratch , and Snap ! , many ed - its to a running block program take ef - fect immediately , without the need to restart the program . Another approach for making the evolution of state understandable is to allow the programmer to travel in time by inspecting , advancing or rewinding the timeline of a program . The concept of omniscient debugging was first de - scribed in the early 1970s as a capabil - ity to trace backward in time through execution history to identify the loca - Directly manipulable blocks also encourage bottom - up tinkering with program pieces in ways not directly sup - ported by raw text . Blocks programmers experiment with blocks by connecting them to build islands of code fragments on the programming surface that are isolated from the main program . 22 , 38 In blocks environments supporting live - ness , 20 these fragments can be executed by pointing and clicking , providing a key benefit of interpreted text - based lan - guages without a read - eval - print loop console separate from the editor . The program gradually grows as it is aug - mented by dropping in these fragments when they behave as desired . Learnability Beyond Blocks . Blocks aid in the construction of code , but blocks alone are not enough to make a programming language learnable . Us - ers new to a language face additional learning challenges : ˲ They must wrestle with practical aspects like installing language tools , saving / loading programs , and so on ; ˲ They must learn the vocabulary of the language and understand the con - cepts denoted by its words ; ˲ They need to understand runtime semantics such as flow of control and changes in state over time ; and , ˲ They eventually need to learn com - mon patterns of use , moving beyond isolated concepts . Each of these learning hurdles can be helped or hindered by the program - ming environment , and each of these problems is an area of active research and development . Programming online . To simplify installation , programming tools are moving online . When a programming environment is in a Web browser , a new programmer is just a few clicks away from creating a first program . A cloud - based programming tool can provide a complete and consistent programming environment with fewer potential problems . Although blocks programming en - vironments for beginners have long been offered online , text - based pro - gramming environments are also be - coming available online . With tools such as Cloud 9 , CodeAnywhere , and CodeEnvy , programmers of all levels can benefit from working online . Words , concepts , and abstractions . The names chosen for language con - By organizing code as visible chunks , blocks help new programmers concentrate on what the code means rather than the notation that is used to write it . JUNE 2017 | VOL . 60 | NO . 6 | COMMUNICATIONS OF THE ACM 77 review articles tion of the fault that caused a later ob - served failure . 40 TRAKLA2 , 26 UUhistle 33 and Online Python Tutor 12 provide this capability for Java and Python . Examples and reuse . The activity of programming has changed with the availability of large repositories con - taining examples of shared code . Programmers of all levels report find - ing and adapting examples as a core programming activity . 6 , 9 In response , professional programming and end - user programming environments are beginning to incorporate example sup - port . 5 , 31 Novices , too , want to learn via examples , but may struggle to do so . 30 Blocks - based languages like Scratch and Looking Glass use online sharing and remixing programs to provide ex - ample access . But there is a trade - off between the simplicity of reuse and the robustness of reused code . For ex - ample , Scratch simplifies sharing of code examples for novices by providing a “backpack” for collecting program snippets and assets that can be shared and dragged into a new project . How - ever , the backpack does not necessarily guarantee the code will run correctly in a new project . In contrast , Looking Glass uses a more complex process for reuse in which users select the beginning and end of behavior they want to use . Coupled with execution history infor - mation , this can ensure the selected code will function within the context of a new program . A Play & Explore fea - ture allows users to connect program output to the line or lines of code that caused it , helping users to understand and begin to modify reused code . Scaling Blocks Code Why don’t professionals program with block interfaces ? One reason is that direct manipulation has efficiency dis - advantages when making small edits . When creating an expression such as ( a / 2 + b / 2 ) in blocks , the programmer must find and drag blocks for each of the three arithmetic operators , and then fill in holes with variables and numbers . Similarly , when rearranging an expression from ( a / 2 + b / 2 ) to ( a + b ) / 2 , the expression tree must be pulled apart and put together again , requiring more gestures and more forethought than making the edits in text . HCI research - ers observed that visual programming languages can have a higher viscosity than text code because they make small changes more difficult . 11 Beyond viscosity , blocks environ - ments can have several other usabil - ity disadvantages compared to textual programming languages : ˲ Low density : Blocks take more space on the screen than equivalent text code . ˲ Search and navigation : It can be challenging to find and navigate to the relevant part of a blocks program in a 2D workspace , only part of which may be visible . ˲ Source control : collaboration and version control systems are difficult to use without a text representation . The newest generation of blocks programming tools includes features designed to resolve the tension be - tween usability advantages of text vs . blocks . There are two approaches : text - style entry and bidirectional mode switching . Text - style entry of blocks . Some new blocks environments , such as Green - foot’s frame - based Stride editor 16 and GP , 24 are designed to be used by pro - grammers to create large programs , so efficient editing is an important design goal . Both Stride and GP improve effi - ciency by providing text - based editing shortcuts within a blocks - oriented in - terface . To allow users to circumvent the step of finding a block on the pal - ette , these systems let programmers enter blocks through an in - line auto - complete mechanism . Blocks can still be chosen from a palette , but a knowl - edgeable programmer can insert them by typing . The Stride editor also intro - duces a hybrid approach to editing code , differentiating between low - level and high - level structure ( Figure 6 ) . For Figure 5 . Block shapes show and enforce rules composition . Scratch commands compose vertically , and expressions fit into holes . Here , a Boolean expression ( diamond shape ) is being dropped into a matching hole for a loop test condition . Figure 6 . Greenfoot’s Stride editor combines text - style editing for expression - level details with drag - and - drop blocks for higher - level program structure . 78 COMMUNICATIONS OF THE ACM | JUNE 2017 | VOL . 60 | NO . 6 review articles expression - level code , it hides syntac - tic structure and allows traditional text editing , providing high - density display and lower viscosity . Visible tree struc - ture and drag - and - drop manipulation are used for higher - level code such as control flow and class declarations . Bidirectional Mode Switching . Some blocks environments provide a bidi - rectional transformation between a traditional text language and a blocks representation of that language . These include Pencil Code ( CoffeeScript ) 2 ( Figure 7 ) , Code . org’s App Lab b ( Java - Script ) , BlockEditor ( Java ) , 21 and Tiled Grace ( Grace ) . 13 Alice and Blockly pro - vide non - editable views of text code . The hypothesis that motivates the de - sign of dual - mode tools is that users may benefit from the learnability of blocks in one mode , while they learn syntax and get the efficiency of text in the other mode . This goal requires the views be linked . For text to be safe for users who may want to return blocks , it must be possible to switch between modes . In dual - mode editors , the text code is the primary representation of the program , and blocks are a projected user interface view derived by pars - ing . This approach allows the editor to fully represent text information such as spacing , but it also means the edi - tor must allow syntax errors that would not have been possible in blocks . Error - recovery heuristics convert sim - ple text syntax errors to special error blocks , but complex errors can prevent mode switching . Comparing approaches . There is a trade - off between the two approaches to unifying blocks and text . While the dual - mode editors provide direct sup - port for learning traditional text syntax such as JavaScript or Java , they also im - pose the cognitive overhead of work - ing with syntax errors that can only be introduced in text mode . Visualiza - tion research on multiple coordinated views suggests the benefits of provid - ing more than one view need to be bal - anced against the cognitive overhead imposed by switching between views . 37 Single mode structure editors have the advantage of a conceptual model free of syntax errors , because the pri - mary object being edited is the ab - stract syntax tree . However , to main - b https : / / code . org / educate / applab Figure 7 . Pencil Code provides bidirectional switching between blocks and text . Mode switching allows users to learn with blocks and edit quickly with text . Figure 8 . Blocks programming in MadeUp . 3D printing is an area of rapid innovation , and blocks make it possible to use new 3D modeling languages without a steep learning curve . Figure 9 . The SPARQL playground is a blocks - based query execution tool that provides blocks for constructing queries of RDF data . Query results ( bottom ) are also provided as blocks , and they can be dragged to build into other queries . JUNE 2017 | VOL . 60 | NO . 6 | COMMUNICATIONS OF THE ACM 79 review articles tain consistency , many kinds of textual edits must be prevented , and other edits may require special tree - editing commands . These constraints raise editing viscosity , and they may pres - ent additional cognitive barriers . In - terfaces that effectively bridge the gap between blocks and text are an active area of research . Applying Blocks : Two Examples Let us take a look at experimental blocks languages in two specific do - mains that are unfamiliar to most pro - grammers . Programming 3D printers . Tradition - ally , 3D printing models are drawn interactively by direct manipulation using CAD software . Writing custom code to create a model is a powerful al - ternative approach , but coding for 3D fabrication has traditionally been the province of a few expert programmers . Now , the falling cost and rising avail - ability of 3D printers has made it pos - sible for non - specialists to write their own custom 3D modeling code . Two recently developed languages bring programming for 3D printing to novice users : BeetleBlocks 17 and Ma - deup . 14 Although the two systems have different languages , there are several commonalities : both are Web - based in - terfaces with a live 3D rendering of the shape being created , and both provide a blocks language to simplify learning . Beetle - Blocks follows the principles of turtle graphics : a beetle moves a “pen” that can be turned on and off , and 3D shapes can be created out of iterated strokes . MadeUp ( Figure 8 ) takes a more abstract approach , allowing users to trace out both paths and parametric surfaces . Special functions can rotate or extrude the paths to create solids . The two languages offer differ - ent levels of power and abstraction . Which language is the right one to use ? This domain is an excellent ex - ample of the advantage of the learn - ability of blocks . Both blocks languag - es have a very shallow learning curve , and it is easy to try both . Querying the Semantic Web . The fre - quent need to query large datasets is another domain where learnability is essential . Consider the problem of querying Resource Description Frame - work ( RDF ) data from the Semantic Web . SPARQL is the standard language for querying RDF ; it includes sev - eral constructs for working with RDF triples that distinguish it from other query languages such as SQL . How - ever , potential users of SPARQL face two hurdles : First , programmers must learn the vocabulary and syntax of SPARQL , with its specialized operators and constructs . Second , querying RDF requires not just knowledge of the lan - guage , but also knowledge of instance and schema data . To address both problems , Paolo Bottoni and Miguel Ceriani have cre - ated a blocks language they call the SPARQL Playground . 4 Rather than help - ing users learn about sequential pro - grams , their blocks language helps users select , filter , and join data using SPARQL primitives . The SPARQL Playground is interest - ing for a second reason : all query results in the playground are also returned as draggable blocks ( Figure 9 ) . This fea - ture allows users to save instance data on the programming workspace to be incorporated into new queries . With the SPARQL Playground , it is easy to begin with general queries to explore the types of data available , and then use these discoveries to make refinements . Making New Blocks Languages It is now possible to create your own domain - specific blocks environment using a blocks - based language tool - kit . Blocks language authors should be aware of at least three toolkits : Blockly , c Droplet , 3 and OpenBlocks . 29 The original blocks metalanguage is MIT OpenBlocks . Created in 2007 by Ricarose Roque as the basis of StarLo - go TNG , it allows a large degree of geo - metric customization . OpenBlocks has also been used in App Inventor Classic and BlockEditor . One draw - back of OpenBlocks is that it requires users to download and install the Java JDK . The challenge of installation is addressed by Blockly , an HTML - based block language toolkit by Neil Fraser of Google . Blockly is currently the most popular blocks language toolkit : it is the tool behind App Inventor , the SPARQL playground , and MadeUp , as well as the Code . org Hour of Code puzzles . Future versions of Scratch will also use Blockly . Droplet is the newest of the blocks lan - c https : developers . google . com / blockly On the Web : ˲ Scratch ( https : / / scratch . mit . edu ) : In - browser animation and game creation , with support for extensions ˲ Code . org ( http : / / code . org ) : A variety of tools including puzzle programming exercises with tutorial videos ˲ Snap ! ( http : / / snap . berkeley . edu ) : Enhanced language inspired by Scratch that includes first class functions ˲ App Inventor ( http : / / appinventor . mit . edu ) : Creation of Android apps using in - browser blocks IDE ˲ Pencil Code ( https : / / pencilcode . net ) : Creates Coffee - Script Web apps , transforming between text and blocks ˲ StarLogo Nova ( http : / / www . slnova . org ) : Multi - agent simulations and games in a 3D rendered world ˲ Blockly Games ( https : / / blockly - games . appspot . com / ) : A set of puzzles to solve with programming blocks ˲ GameBlox ( https : / / gameblox . org ) : Game creation that includes clonable agents , physics , and more Downloadable : ˲ AgentSheets / AgentCubes ( http : / / www . agentsheets . com ) : Pioneering blocks environments for creating rule - based games and simulations ˲ Alice ( http : / / www . alice . org ) : Pioneering blocks environment for creating 3D virtual worlds ; support for exporting to Java ˲ Looking Glass ( https : / / lookingglass . wustl . edu ) : 3D animated story creation ; supports independent learning ˲ Kodu ( http : / / www . kodugamelab . com ) : Rule - based programming of games for xBox and PC On mobile : ˲ Scratch Jr ( http : / / www . scratchjr . org ) : Programming of animated scenes aimed at preliterate children ˲ Pocket Code ( http : / / www . catrobat . org ) : Blocks programming for small form factor of mobile devices ˲ Tynker ( https : / / www . tynker . com ) : Polished commercial platform for game and animation creation ˲ Hopscotch ( https : / / www . gethopscotch . com ) : Creating games and animations on iPhone and iPad Blocks - Based Educational Tools 80 COMMUNICATIONS OF THE ACM | JUNE 2017 | VOL . 60 | NO . 6 review articles guage creation toolkits , developed by Anthony Bau for use in Pencil Code , and also used by Code . org in their App Lab . It is newer and less mature than Open - Blocks and Blockly , but takes a unique approach that allows seamless bidi - rectional transformation between all blocks and textual code . Summary When a programming language is pro - vided as a user interface that welcomes novice users , rather than as a technical tool only for experienced developers , we arrive at a new picture of what the pro - gramming environment should provide : ˲ Vocabulary should derive from rec - ognition , not recall ; ˲ Cognitive load should be lowered by chunking code ; ˲ Grammar rules and types should be made visible ; ˲ Program chunks should be directly manipulable ; ˲ Low - viscosity editing should also be possible ; ˲ Coding environments should be available without the need for tool instal - lation ; ˲ Simple concepts should be de - scribed with clear words and high - level abstractions ; ˲ Runtime state and behavior should be visible ; and , ˲ Examples should be easy to find and apply . In short , for a programming tool to be usable by new or casual program - mers , its design must focus on learn - ability . Blocks have proven to be effec - tive at solving many of these problems . Although programming is still not nearly as widely learned as it should be , the progress made by blocks language interfaces can inspire us all to see that programming can be made more learn - able . The art of programming is the original human - computer interaction , and it remains an unsolved usability challenge . We can still do more to make programming available to all . References 1 . Armoni , M . , Meerbaum - Salant , O . and Ben - Ari , M . From Scratch to ‘real’ programming . Trans . Computing Education 14 , 4 ( Feb . 2015 ) . 2 . Bau , D . , Bau , D . A . , Dawson , M . , and Pickens , C . S . Pencil Code : Block code for a text world . In 14 th International Conference on Interaction Design and Children , ( 2015 ) , 445 – 448 . 3 . Bau , D . A . Droplet , a blocks - based editor for text code . J . Computing Sciences in Colleges 30 , 6 ( June 2015 ) , 138 – 144 . 4 . Bottoni , P . and Ceriani , M . Using blocks to get more blocks : Exploring linked data through integration of queries and result sets in block programming . In IEEE Blocks and Beyond Workshop , Oct . 2015 , 99 – 102 . 5 . Brandt , J . , Dontcheva , M . , Weskamp , M . and Klemmer , S . R . Example - centric programming : Integrating Web search into the development environment . In Proceedings of ACM SIGCHI Conference on Human Factors in Computing Systems , 2010 , 513 – 522 . 6 . Brandt , J . , Guo , P . J . , Lewenstein , J . , Dontcheva , M . , and Klemmer , S . R . Two studies of opportunistic programming : Interleaving Web foraging , learning , and writing code . In Proceedings of ACM SIGCHI Conference on Human Factors in Computing Systems , 2009 , 1589 – 1598 . 7 . Conway , M . , Audia , S . , Burnette , T . , Cosgrove , D . and Christiansen , K . Alice : Lessons learned from building a 3D system for novices . In Proceedings of ACM SIGCHI Conference on Human Factors in Computing Systems , 2000 , 486 – 493 . 8 . Dann , W . , Cosgrove , D . , Slater , D . , Culyba , D . and Cooper , S . Mediated transfer : Alice 3 to Java . In 43 rd ACM Technical Symposium on Computer Science Education , 2012 , 141 – 146 . 9 . Dorn , B . and Guzdial , M . Graphic designers who program as informal computer science learners . In Proceedings of 2 nd International Workshop on Computing Education Research , 2006 , 127 – 134 . 10 . Garlick , R . and Cankaya , E . C . Using Alice in CS1 : A quantitative experiment . In 15 th Annual Conference on Innovation and Technology in Computer Science Education , 2010 , 165 – 168 . 11 . Green , T . R . G . Cognitive dimensions of notations . People and Computers V . A . Sutcliffe and L . Macaulay , Eds . Cambridge University Press , Cambridge , UK , 1989 , 443 – 460 . 12 . Guo , P . J . Online Python tutor : Embeddable Web - based program visualization for CS education . In Proceedings of the 44 th ACM Technical Symposium on Computer Science Education , 2013 , 579 – 584 . 13 . Homer , M . and Noble , J . Combining tiled and textual views of code . In Proceedings of the 2014 IEEE Working Conf . Software Visualization , Sept . 2014 , 1 – 10 . 14 . Johnson , C . and Bui , P . Blocks in , blocks out : A language for 3D models . IEEE Blocks and Beyond Workshop , Oct . 2015 , 77 – 82 . 15 . Ko , A . J . , Myers , B . A . and Aung , H . H . Six learning barriers in end - user programming systems . In Proceedings of the IEEE Symp . Visual Languages and Human Centric Computing , 2004 , 199 – 206 . 16 . Kölling , M . , Brown , N . C . C . , and Altadmri , A . Frame - based editing : Easing the transition from blocks to text - based programming . In Proceedings of the 10 th Workshop in Primary and Secondary Computing Education , Nov . 2015 . 17 . Koschitz , D . and Rosenbaum , E . Exploring algorithmic geometry with ‘Beetle Blocks : ’ A graphical programming language for generating 3D forms . In Proceedings of the 15 th International Conference on Geometry and Graphics , Aug . 2012 , 380 – 389 . 18 . Lerner , S . , Foster , S . R . , and Griswold W . G . Polymorphic blocks : Formalism - inspired UI for structured connectors . In Proceedings of the 33 rd Annual ACM Conference on Human Factors in Computing Systems , 2015 , 3063 – 3072 . 19 . Malan , D . J . and Leitner , H . H . Scratch for budding computer scientists . ACM SIGCSE Bulletin 39 , 1 ( Mar . 2007 ) , 223 – 227 . 20 . Maloney , J . H . and Smith , R . B . Directness and liveness in the morphic user interface construction environment . In Proceedings of the 8 th Annual ACM Symposium on User Interface and Software Technology , 1995 , 21 – 28 . 21 . Matsuzawa , Y . , Ohata , T . , Sugiura , M . and Sakai , S . Language migration in non - CS introductory programming through mutual language translation environment . In Proceedings of the 46 th ACM Technical Symposium on Computer Science Education , 2015 , 185 – 190 . 22 . Meerbaum - Salant , O . , Armoni , M . and Ben - Ari , M . Habits of programming in Scratch . In Proceedings of the 16 th Annual Joint Conference on Innovation and Technology in Computer Science Education , 2011 , 168 – 172 . 23 . Miller , G . A . The magical number seven , plus or minus two : some limits on our capacity for processing information . Psychological Review 63 , 2 ( 1956 ) , 81 . 24 . Mönig , J . , Ohshima , Y . and Maloney , J . Blocks at your fingertips : Blurring the line between blocks and text in GP . IEEE Blocks and Beyond Workshop , 2015 , 51 – 53 . 25 . Moskal , B . , Lurie , D . and Cooper , S . Evaluating the effectiveness of a new instructional approach . ACM SIGCSE Bulletin 36 , 1 ( 2004 ) , 75 – 79 . 26 . Nikander , J . , Korhonen , A . , Seppälä , O . , Karavirta , V . , Silvasti , P . and Malmi , L . Visual algorithm simulation exercise system with automatic assessment : Trakla2 . Info . Education—An International J . 32 ( 2004 ) , 267 – 288 . 27 . Powers , K . , Ecott , S . and Hirshfield , L . M . Through the looking glass : Teaching CS0 with Alice . ACM SIGCSE Bulletin 39 , 1 ( Mar . 2007 ) , 213 – 217 . 28 . Resnick , M . , Maloney , J . , Monroy - Hernández , A . , Rusk , N . , Eastmond , E . , Brennan , K . , Millner , A . , Rosenbaum , E . , Silver , J . , Silverman , B . , and Kafai , Y . Scratch : Programming for all . Commun . ACM 52 , 11 ( Nov . 2009 ) , 60 – 67 . 29 . Roque , R . Openblocks : An extendable framework for graphical block programming systems . Master’s thesis , MIT , May 2007 . 30 . Rosson , M . B . , Ballin , J . and Nash , H . Everyday programming : Challenges and opportunities for informal Web development . In Proceedings of the 2004 IEEE Symposium on Visual Languages and Human Centric Computing , Sept . 2004 , 123 – 130 . 31 . Sawadsky , N . and Murphy , G . C . Fishtail : From task context to source code examples . In Proceedings of the 1 st Workshop on Developing Tools As Plug - ins , 2011 , 48 – 51 . 32 . Shapiro , R . B . and Ahrens , M . Beyond blocks : Syntax and semantics . Communications of the ACM 59 , 5 ( May 2016 ) , 39 – 41 . 33 . Sorva , J . and Sirkiä , T . Context - sensitive guidance in the UUhistle program visualization system . In Proceedings of the 6 th Program Visualization Workshop , 2011 , 77 – 85 . 34 . Stefik , A . and Siebert , S . An empirical investigation into programming language syntax . Trans . Computing Education 13 , 4 ( Nov . 2013 ) , 19 : 1 – 19 : 40 . 35 . Teitelbaum , T . and Reps , T . The Cornell program synthesizer : A syntax - directed programming environment . Commun . ACM 24 , 9 ( Sept . 1981 ) , 563 – 573 . 36 . Vasek , M . Representing expressive types in blocks programming languages . Undergraduate thesis , Wellesley College , May 2012 . 37 . Wang Baldonado M . Q . , Woodruff , A . , and Kuchinsky , A . Guidelines for using multiple views in information visualization . In Proceedings of the Working Conference on Advanced Visual Interfaces , 2000 , 110 – 119 . 38 . Weintrop , D . and Wilensky , U . To block or not to block , that is the question : students’ perceptions of blocks - based programming . In Proceedings of the 14 th International Conference on Interaction Design and Children , 2015 , 199 – 208 . 39 . Wolz , U . , Leitner , H . H . , Malan , D . J . , and Maloney J . Starting with Scratch in CS1 . ACM SIGCSE Bulletin 41 , 1 ( Mar . 2009 ) , 2 – 3 . 40 . Zelkowitz , M . Reversible execution . Commun . ACM 16 , 9 ( Sept . 1973 ) , 566 . David Bau ( davidbau @ csail . mit . edu ) is a Ph . D . student at MIT’s Computer Science and Artificial Intelligence Lab , Cambridge , MA . Jeff Gray ( gray @ cs . ua . edu ) is a professor in the Department of Computer Science at the University of Alabama , Tuscaloosa . Caitlin Kelleher ( ckelleher @ cse . wustl . edu ) is an assistant professor in the Department of Computer Science at Washington University , St . Louis , MO . Josh Sheldon ( jsheldon @ csail . mit . edu ) is Director of Programs and MIT App inventor at MIT’s Computer Science and Artificial Intelligence Lab , Cambridge , MA . Franklyn Turbak ( fturbak @ cs . wellesley . edu ) is an associate professor in the Department of Computer Science at Wellesley College , Wellesley , MA . © 2017 ACM 0001 - 0782 / 17 / 05 $ 15 . 00 . Watch the authors discuss their work in this exclusive Communications video . https : / / cacm . acm . org / videos / learnable - programming